<?xml version="1.0" ?><namespace name="Vcl.Graphics" platform="Win32">
  <pointer name="PColor" alias="System.UITypes.PColor" type="TColor" indircnt="1" file="System.UITypes.pas" line="458"/>
  <type name="TColor" type="TColor" loBound="-2147483648" hiBound="2147483647" file="System.UITypes.pas" line="459"/>
  <const name="clSystemColor" type="Integer" file="Vcl.Graphics.pas" line="45">
    <value>
      $FF000000
    </value>
  </const>
  <const name="clScrollBar" type="TColor" file="Vcl.Graphics.pas" line="47">
    <value>
      $FF000000
    </value>
  </const>
  <const name="clBackground" type="TColor" file="Vcl.Graphics.pas" line="48">
    <value>
      $FF000001
    </value>
  </const>
  <const name="clActiveCaption" type="TColor" file="Vcl.Graphics.pas" line="49">
    <value>
      $FF000002
    </value>
  </const>
  <const name="clInactiveCaption" type="TColor" file="Vcl.Graphics.pas" line="50">
    <value>
      $FF000003
    </value>
  </const>
  <const name="clMenu" type="TColor" file="Vcl.Graphics.pas" line="51">
    <value>
      $FF000004
    </value>
  </const>
  <const name="clWindow" type="TColor" file="Vcl.Graphics.pas" line="52">
    <value>
      $FF000005
    </value>
  </const>
  <const name="clWindowFrame" type="TColor" file="Vcl.Graphics.pas" line="53">
    <value>
      $FF000006
    </value>
  </const>
  <const name="clMenuText" type="TColor" file="Vcl.Graphics.pas" line="54">
    <value>
      $FF000007
    </value>
  </const>
  <const name="clWindowText" type="TColor" file="Vcl.Graphics.pas" line="55">
    <value>
      $FF000008
    </value>
  </const>
  <const name="clCaptionText" type="TColor" file="Vcl.Graphics.pas" line="56">
    <value>
      $FF000009
    </value>
  </const>
  <const name="clActiveBorder" type="TColor" file="Vcl.Graphics.pas" line="57">
    <value>
      $FF00000A
    </value>
  </const>
  <const name="clInactiveBorder" type="TColor" file="Vcl.Graphics.pas" line="58">
    <value>
      $FF00000B
    </value>
  </const>
  <const name="clAppWorkSpace" type="TColor" file="Vcl.Graphics.pas" line="59">
    <value>
      $FF00000C
    </value>
  </const>
  <const name="clHighlight" type="TColor" file="Vcl.Graphics.pas" line="60">
    <value>
      $FF00000D
    </value>
  </const>
  <const name="clHighlightText" type="TColor" file="Vcl.Graphics.pas" line="61">
    <value>
      $FF00000E
    </value>
  </const>
  <const name="clBtnFace" type="TColor" file="Vcl.Graphics.pas" line="62">
    <value>
      $FF00000F
    </value>
  </const>
  <const name="clBtnShadow" type="TColor" file="Vcl.Graphics.pas" line="63">
    <value>
      $FF000010
    </value>
  </const>
  <const name="clGrayText" type="TColor" file="Vcl.Graphics.pas" line="64">
    <value>
      $FF000011
    </value>
  </const>
  <const name="clBtnText" type="TColor" file="Vcl.Graphics.pas" line="65">
    <value>
      $FF000012
    </value>
  </const>
  <const name="clInactiveCaptionText" type="TColor" file="Vcl.Graphics.pas" line="66">
    <value>
      $FF000013
    </value>
  </const>
  <const name="clBtnHighlight" type="TColor" file="Vcl.Graphics.pas" line="67">
    <value>
      $FF000014
    </value>
  </const>
  <const name="cl3DDkShadow" type="TColor" file="Vcl.Graphics.pas" line="68">
    <value>
      $FF000015
    </value>
  </const>
  <const name="cl3DLight" type="TColor" file="Vcl.Graphics.pas" line="69">
    <value>
      $FF000016
    </value>
  </const>
  <const name="clInfoText" type="TColor" file="Vcl.Graphics.pas" line="70">
    <value>
      $FF000017
    </value>
  </const>
  <const name="clInfoBk" type="TColor" file="Vcl.Graphics.pas" line="71">
    <value>
      $FF000018
    </value>
  </const>
  <const name="clHotLight" type="TColor" file="Vcl.Graphics.pas" line="72">
    <value>
      $FF00001A
    </value>
  </const>
  <const name="clGradientActiveCaption" type="TColor" file="Vcl.Graphics.pas" line="73">
    <value>
      $FF00001B
    </value>
  </const>
  <const name="clGradientInactiveCaption" type="TColor" file="Vcl.Graphics.pas" line="74">
    <value>
      $FF00001C
    </value>
  </const>
  <const name="clMenuHighlight" type="TColor" file="Vcl.Graphics.pas" line="75">
    <value>
      $FF00001D
    </value>
  </const>
  <const name="clMenuBar" type="TColor" file="Vcl.Graphics.pas" line="76">
    <value>
      $FF00001E
    </value>
  </const>
  <const name="clBlack" type="TColor" file="Vcl.Graphics.pas" line="78">
    <value>
      $0
    </value>
  </const>
  <const name="clMaroon" type="TColor" file="Vcl.Graphics.pas" line="79">
    <value>
      $80
    </value>
  </const>
  <const name="clGreen" type="TColor" file="Vcl.Graphics.pas" line="80">
    <value>
      $8000
    </value>
  </const>
  <const name="clOlive" type="TColor" file="Vcl.Graphics.pas" line="81">
    <value>
      $8080
    </value>
  </const>
  <const name="clNavy" type="TColor" file="Vcl.Graphics.pas" line="82">
    <value>
      $800000
    </value>
  </const>
  <const name="clPurple" type="TColor" file="Vcl.Graphics.pas" line="83">
    <value>
      $800080
    </value>
  </const>
  <const name="clTeal" type="TColor" file="Vcl.Graphics.pas" line="84">
    <value>
      $808000
    </value>
  </const>
  <const name="clGray" type="TColor" file="Vcl.Graphics.pas" line="85">
    <value>
      $808080
    </value>
  </const>
  <const name="clSilver" type="TColor" file="Vcl.Graphics.pas" line="86">
    <value>
      $C0C0C0
    </value>
  </const>
  <const name="clRed" type="TColor" file="Vcl.Graphics.pas" line="87">
    <value>
      $FF
    </value>
  </const>
  <const name="clLime" type="TColor" file="Vcl.Graphics.pas" line="88">
    <value>
      $FF00
    </value>
  </const>
  <const name="clYellow" type="TColor" file="Vcl.Graphics.pas" line="89">
    <value>
      $FFFF
    </value>
  </const>
  <const name="clBlue" type="TColor" file="Vcl.Graphics.pas" line="90">
    <value>
      $FF0000
    </value>
  </const>
  <const name="clFuchsia" type="TColor" file="Vcl.Graphics.pas" line="91">
    <value>
      $FF00FF
    </value>
  </const>
  <const name="clAqua" type="TColor" file="Vcl.Graphics.pas" line="92">
    <value>
      $FFFF00
    </value>
  </const>
  <const name="clLtGray" type="TColor" file="Vcl.Graphics.pas" line="93">
    <value>
      $C0C0C0
    </value>
  </const>
  <const name="clDkGray" type="TColor" file="Vcl.Graphics.pas" line="94">
    <value>
      $808080
    </value>
  </const>
  <const name="clWhite" type="TColor" file="Vcl.Graphics.pas" line="95">
    <value>
      $FFFFFF
    </value>
  </const>
  <const name="StandardColorsCount" type="Integer" file="Vcl.Graphics.pas" line="96">
    <value>
      $10
    </value>
  </const>
  <const name="clMoneyGreen" type="TColor" file="Vcl.Graphics.pas" line="98">
    <value>
      $C0DCC0
    </value>
  </const>
  <const name="clSkyBlue" type="TColor" file="Vcl.Graphics.pas" line="99">
    <value>
      $F0CAA6
    </value>
  </const>
  <const name="clCream" type="TColor" file="Vcl.Graphics.pas" line="100">
    <value>
      $F0FBFF
    </value>
  </const>
  <const name="clMedGray" type="TColor" file="Vcl.Graphics.pas" line="101">
    <value>
      $A4A0A0
    </value>
  </const>
  <const name="ExtendedColorsCount" type="Integer" file="Vcl.Graphics.pas" line="102">
    <value>
      $4
    </value>
  </const>
  <const name="clNone" type="TColor" file="Vcl.Graphics.pas" line="104">
    <value>
      $1FFFFFFF
    </value>
  </const>
  <const name="clDefault" type="TColor" file="Vcl.Graphics.pas" line="105">
    <value>
      $20000000
    </value>
  </const>
  <const name="clWebSnow" type="TColor" file="Vcl.Graphics.pas" line="109">
    <value>
      $FAFAFF
    </value>
  </const>
  <const name="clWebFloralWhite" type="TColor" file="Vcl.Graphics.pas" line="110">
    <value>
      $F0FAFF
    </value>
  </const>
  <const name="clWebLavenderBlush" type="TColor" file="Vcl.Graphics.pas" line="111">
    <value>
      $F5F0FF
    </value>
  </const>
  <const name="clWebOldLace" type="TColor" file="Vcl.Graphics.pas" line="112">
    <value>
      $E6F5FD
    </value>
  </const>
  <const name="clWebIvory" type="TColor" file="Vcl.Graphics.pas" line="113">
    <value>
      $F0FFFF
    </value>
  </const>
  <const name="clWebCornSilk" type="TColor" file="Vcl.Graphics.pas" line="114">
    <value>
      $DCF8FF
    </value>
  </const>
  <const name="clWebBeige" type="TColor" file="Vcl.Graphics.pas" line="115">
    <value>
      $DCF5F5
    </value>
  </const>
  <const name="clWebAntiqueWhite" type="TColor" file="Vcl.Graphics.pas" line="116">
    <value>
      $D7EBFA
    </value>
  </const>
  <const name="clWebWheat" type="TColor" file="Vcl.Graphics.pas" line="117">
    <value>
      $B3DEF5
    </value>
  </const>
  <const name="clWebAliceBlue" type="TColor" file="Vcl.Graphics.pas" line="118">
    <value>
      $FFF8F0
    </value>
  </const>
  <const name="clWebGhostWhite" type="TColor" file="Vcl.Graphics.pas" line="119">
    <value>
      $FFF8F8
    </value>
  </const>
  <const name="clWebLavender" type="TColor" file="Vcl.Graphics.pas" line="120">
    <value>
      $FAE6E6
    </value>
  </const>
  <const name="clWebSeashell" type="TColor" file="Vcl.Graphics.pas" line="121">
    <value>
      $EEF5FF
    </value>
  </const>
  <const name="clWebLightYellow" type="TColor" file="Vcl.Graphics.pas" line="122">
    <value>
      $E0FFFF
    </value>
  </const>
  <const name="clWebPapayaWhip" type="TColor" file="Vcl.Graphics.pas" line="123">
    <value>
      $D5EFFF
    </value>
  </const>
  <const name="clWebNavajoWhite" type="TColor" file="Vcl.Graphics.pas" line="124">
    <value>
      $ADDEFF
    </value>
  </const>
  <const name="clWebMoccasin" type="TColor" file="Vcl.Graphics.pas" line="125">
    <value>
      $B5E4FF
    </value>
  </const>
  <const name="clWebBurlywood" type="TColor" file="Vcl.Graphics.pas" line="126">
    <value>
      $87B8DE
    </value>
  </const>
  <const name="clWebAzure" type="TColor" file="Vcl.Graphics.pas" line="127">
    <value>
      $FFFFF0
    </value>
  </const>
  <const name="clWebMintcream" type="TColor" file="Vcl.Graphics.pas" line="128">
    <value>
      $FAFFF5
    </value>
  </const>
  <const name="clWebHoneydew" type="TColor" file="Vcl.Graphics.pas" line="129">
    <value>
      $F0FFF0
    </value>
  </const>
  <const name="clWebLinen" type="TColor" file="Vcl.Graphics.pas" line="130">
    <value>
      $E6F0FA
    </value>
  </const>
  <const name="clWebLemonChiffon" type="TColor" file="Vcl.Graphics.pas" line="131">
    <value>
      $CDFAFF
    </value>
  </const>
  <const name="clWebBlanchedAlmond" type="TColor" file="Vcl.Graphics.pas" line="132">
    <value>
      $CDEBFF
    </value>
  </const>
  <const name="clWebBisque" type="TColor" file="Vcl.Graphics.pas" line="133">
    <value>
      $C4E4FF
    </value>
  </const>
  <const name="clWebPeachPuff" type="TColor" file="Vcl.Graphics.pas" line="134">
    <value>
      $B9DAFF
    </value>
  </const>
  <const name="clWebTan" type="TColor" file="Vcl.Graphics.pas" line="135">
    <value>
      $8CB4D2
    </value>
  </const>
  <const name="clWebYellow" type="TColor" file="Vcl.Graphics.pas" line="137">
    <value>
      $FFFF
    </value>
  </const>
  <const name="clWebDarkOrange" type="TColor" file="Vcl.Graphics.pas" line="138">
    <value>
      $8CFF
    </value>
  </const>
  <const name="clWebRed" type="TColor" file="Vcl.Graphics.pas" line="139">
    <value>
      $FF
    </value>
  </const>
  <const name="clWebDarkRed" type="TColor" file="Vcl.Graphics.pas" line="140">
    <value>
      $8B
    </value>
  </const>
  <const name="clWebMaroon" type="TColor" file="Vcl.Graphics.pas" line="141">
    <value>
      $80
    </value>
  </const>
  <const name="clWebIndianRed" type="TColor" file="Vcl.Graphics.pas" line="142">
    <value>
      $5C5CCD
    </value>
  </const>
  <const name="clWebSalmon" type="TColor" file="Vcl.Graphics.pas" line="143">
    <value>
      $7280FA
    </value>
  </const>
  <const name="clWebCoral" type="TColor" file="Vcl.Graphics.pas" line="144">
    <value>
      $507FFF
    </value>
  </const>
  <const name="clWebGold" type="TColor" file="Vcl.Graphics.pas" line="145">
    <value>
      $D7FF
    </value>
  </const>
  <const name="clWebTomato" type="TColor" file="Vcl.Graphics.pas" line="146">
    <value>
      $4763FF
    </value>
  </const>
  <const name="clWebCrimson" type="TColor" file="Vcl.Graphics.pas" line="147">
    <value>
      $3C14DC
    </value>
  </const>
  <const name="clWebBrown" type="TColor" file="Vcl.Graphics.pas" line="148">
    <value>
      $2A2AA5
    </value>
  </const>
  <const name="clWebChocolate" type="TColor" file="Vcl.Graphics.pas" line="149">
    <value>
      $1E69D2
    </value>
  </const>
  <const name="clWebSandyBrown" type="TColor" file="Vcl.Graphics.pas" line="150">
    <value>
      $60A4F4
    </value>
  </const>
  <const name="clWebLightSalmon" type="TColor" file="Vcl.Graphics.pas" line="151">
    <value>
      $7AA0FF
    </value>
  </const>
  <const name="clWebLightCoral" type="TColor" file="Vcl.Graphics.pas" line="152">
    <value>
      $8080F0
    </value>
  </const>
  <const name="clWebOrange" type="TColor" file="Vcl.Graphics.pas" line="153">
    <value>
      $A5FF
    </value>
  </const>
  <const name="clWebOrangeRed" type="TColor" file="Vcl.Graphics.pas" line="154">
    <value>
      $45FF
    </value>
  </const>
  <const name="clWebFirebrick" type="TColor" file="Vcl.Graphics.pas" line="155">
    <value>
      $2222B2
    </value>
  </const>
  <const name="clWebSaddleBrown" type="TColor" file="Vcl.Graphics.pas" line="156">
    <value>
      $13458B
    </value>
  </const>
  <const name="clWebSienna" type="TColor" file="Vcl.Graphics.pas" line="157">
    <value>
      $2D52A0
    </value>
  </const>
  <const name="clWebPeru" type="TColor" file="Vcl.Graphics.pas" line="158">
    <value>
      $3F85CD
    </value>
  </const>
  <const name="clWebDarkSalmon" type="TColor" file="Vcl.Graphics.pas" line="159">
    <value>
      $7A96E9
    </value>
  </const>
  <const name="clWebRosyBrown" type="TColor" file="Vcl.Graphics.pas" line="160">
    <value>
      $8F8FBC
    </value>
  </const>
  <const name="clWebPaleGoldenrod" type="TColor" file="Vcl.Graphics.pas" line="162">
    <value>
      $AAE8EE
    </value>
  </const>
  <const name="clWebLightGoldenrodYellow" type="TColor" file="Vcl.Graphics.pas" line="163">
    <value>
      $D2FAFA
    </value>
  </const>
  <const name="clWebOlive" type="TColor" file="Vcl.Graphics.pas" line="164">
    <value>
      $8080
    </value>
  </const>
  <const name="clWebForestGreen" type="TColor" file="Vcl.Graphics.pas" line="165">
    <value>
      $228B22
    </value>
  </const>
  <const name="clWebGreenYellow" type="TColor" file="Vcl.Graphics.pas" line="166">
    <value>
      $2FFFAD
    </value>
  </const>
  <const name="clWebChartreuse" type="TColor" file="Vcl.Graphics.pas" line="167">
    <value>
      $FF7F
    </value>
  </const>
  <const name="clWebLightGreen" type="TColor" file="Vcl.Graphics.pas" line="168">
    <value>
      $90EE90
    </value>
  </const>
  <const name="clWebAquamarine" type="TColor" file="Vcl.Graphics.pas" line="169">
    <value>
      $D4FF7F
    </value>
  </const>
  <const name="clWebSeaGreen" type="TColor" file="Vcl.Graphics.pas" line="170">
    <value>
      $578B2E
    </value>
  </const>
  <const name="clWebGoldenRod" type="TColor" file="Vcl.Graphics.pas" line="171">
    <value>
      $20A5DA
    </value>
  </const>
  <const name="clWebKhaki" type="TColor" file="Vcl.Graphics.pas" line="172">
    <value>
      $8CE6F0
    </value>
  </const>
  <const name="clWebOliveDrab" type="TColor" file="Vcl.Graphics.pas" line="173">
    <value>
      $238E6B
    </value>
  </const>
  <const name="clWebGreen" type="TColor" file="Vcl.Graphics.pas" line="174">
    <value>
      $8000
    </value>
  </const>
  <const name="clWebYellowGreen" type="TColor" file="Vcl.Graphics.pas" line="175">
    <value>
      $32CD9A
    </value>
  </const>
  <const name="clWebLawnGreen" type="TColor" file="Vcl.Graphics.pas" line="176">
    <value>
      $FC7C
    </value>
  </const>
  <const name="clWebPaleGreen" type="TColor" file="Vcl.Graphics.pas" line="177">
    <value>
      $98FB98
    </value>
  </const>
  <const name="clWebMediumAquamarine" type="TColor" file="Vcl.Graphics.pas" line="178">
    <value>
      $AACD66
    </value>
  </const>
  <const name="clWebMediumSeaGreen" type="TColor" file="Vcl.Graphics.pas" line="179">
    <value>
      $71B33C
    </value>
  </const>
  <const name="clWebDarkGoldenRod" type="TColor" file="Vcl.Graphics.pas" line="180">
    <value>
      $B86B8
    </value>
  </const>
  <const name="clWebDarkKhaki" type="TColor" file="Vcl.Graphics.pas" line="181">
    <value>
      $6BB7BD
    </value>
  </const>
  <const name="clWebDarkOliveGreen" type="TColor" file="Vcl.Graphics.pas" line="182">
    <value>
      $2F6B55
    </value>
  </const>
  <const name="clWebDarkgreen" type="TColor" file="Vcl.Graphics.pas" line="183">
    <value>
      $6400
    </value>
  </const>
  <const name="clWebLimeGreen" type="TColor" file="Vcl.Graphics.pas" line="184">
    <value>
      $32CD32
    </value>
  </const>
  <const name="clWebLime" type="TColor" file="Vcl.Graphics.pas" line="185">
    <value>
      $FF00
    </value>
  </const>
  <const name="clWebSpringGreen" type="TColor" file="Vcl.Graphics.pas" line="186">
    <value>
      $7FFF00
    </value>
  </const>
  <const name="clWebMediumSpringGreen" type="TColor" file="Vcl.Graphics.pas" line="187">
    <value>
      $9AFA00
    </value>
  </const>
  <const name="clWebDarkSeaGreen" type="TColor" file="Vcl.Graphics.pas" line="188">
    <value>
      $8FBC8F
    </value>
  </const>
  <const name="clWebLightSeaGreen" type="TColor" file="Vcl.Graphics.pas" line="190">
    <value>
      $AAB220
    </value>
  </const>
  <const name="clWebPaleTurquoise" type="TColor" file="Vcl.Graphics.pas" line="191">
    <value>
      $EEEEAF
    </value>
  </const>
  <const name="clWebLightCyan" type="TColor" file="Vcl.Graphics.pas" line="192">
    <value>
      $FFFFE0
    </value>
  </const>
  <const name="clWebLightBlue" type="TColor" file="Vcl.Graphics.pas" line="193">
    <value>
      $E6D8AD
    </value>
  </const>
  <const name="clWebLightSkyBlue" type="TColor" file="Vcl.Graphics.pas" line="194">
    <value>
      $FACE87
    </value>
  </const>
  <const name="clWebCornFlowerBlue" type="TColor" file="Vcl.Graphics.pas" line="195">
    <value>
      $ED9564
    </value>
  </const>
  <const name="clWebDarkBlue" type="TColor" file="Vcl.Graphics.pas" line="196">
    <value>
      $8B0000
    </value>
  </const>
  <const name="clWebIndigo" type="TColor" file="Vcl.Graphics.pas" line="197">
    <value>
      $82004B
    </value>
  </const>
  <const name="clWebMediumTurquoise" type="TColor" file="Vcl.Graphics.pas" line="198">
    <value>
      $CCD148
    </value>
  </const>
  <const name="clWebTurquoise" type="TColor" file="Vcl.Graphics.pas" line="199">
    <value>
      $D0E040
    </value>
  </const>
  <const name="clWebCyan" type="TColor" file="Vcl.Graphics.pas" line="200">
    <value>
      $FFFF00
    </value>
  </const>
  <const name="clWebAqua" type="TColor" file="Vcl.Graphics.pas" line="201">
    <value>
      $FFFF00
    </value>
  </const>
  <const name="clWebPowderBlue" type="TColor" file="Vcl.Graphics.pas" line="202">
    <value>
      $E6E0B0
    </value>
  </const>
  <const name="clWebSkyBlue" type="TColor" file="Vcl.Graphics.pas" line="203">
    <value>
      $EBCE87
    </value>
  </const>
  <const name="clWebRoyalBlue" type="TColor" file="Vcl.Graphics.pas" line="204">
    <value>
      $E16941
    </value>
  </const>
  <const name="clWebMediumBlue" type="TColor" file="Vcl.Graphics.pas" line="205">
    <value>
      $CD0000
    </value>
  </const>
  <const name="clWebMidnightBlue" type="TColor" file="Vcl.Graphics.pas" line="206">
    <value>
      $701919
    </value>
  </const>
  <const name="clWebDarkTurquoise" type="TColor" file="Vcl.Graphics.pas" line="207">
    <value>
      $D1CE00
    </value>
  </const>
  <const name="clWebCadetBlue" type="TColor" file="Vcl.Graphics.pas" line="208">
    <value>
      $A09E5F
    </value>
  </const>
  <const name="clWebDarkCyan" type="TColor" file="Vcl.Graphics.pas" line="209">
    <value>
      $8B8B00
    </value>
  </const>
  <const name="clWebTeal" type="TColor" file="Vcl.Graphics.pas" line="210">
    <value>
      $808000
    </value>
  </const>
  <const name="clWebDeepskyBlue" type="TColor" file="Vcl.Graphics.pas" line="211">
    <value>
      $FFBF00
    </value>
  </const>
  <const name="clWebDodgerBlue" type="TColor" file="Vcl.Graphics.pas" line="212">
    <value>
      $FF901E
    </value>
  </const>
  <const name="clWebBlue" type="TColor" file="Vcl.Graphics.pas" line="213">
    <value>
      $FF0000
    </value>
  </const>
  <const name="clWebNavy" type="TColor" file="Vcl.Graphics.pas" line="214">
    <value>
      $800000
    </value>
  </const>
  <const name="clWebDarkViolet" type="TColor" file="Vcl.Graphics.pas" line="216">
    <value>
      $D30094
    </value>
  </const>
  <const name="clWebDarkOrchid" type="TColor" file="Vcl.Graphics.pas" line="217">
    <value>
      $CC3299
    </value>
  </const>
  <const name="clWebMagenta" type="TColor" file="Vcl.Graphics.pas" line="218">
    <value>
      $FF00FF
    </value>
  </const>
  <const name="clWebFuchsia" type="TColor" file="Vcl.Graphics.pas" line="219">
    <value>
      $FF00FF
    </value>
  </const>
  <const name="clWebDarkMagenta" type="TColor" file="Vcl.Graphics.pas" line="220">
    <value>
      $8B008B
    </value>
  </const>
  <const name="clWebMediumVioletRed" type="TColor" file="Vcl.Graphics.pas" line="221">
    <value>
      $8515C7
    </value>
  </const>
  <const name="clWebPaleVioletRed" type="TColor" file="Vcl.Graphics.pas" line="222">
    <value>
      $9370DB
    </value>
  </const>
  <const name="clWebBlueViolet" type="TColor" file="Vcl.Graphics.pas" line="223">
    <value>
      $E22B8A
    </value>
  </const>
  <const name="clWebMediumOrchid" type="TColor" file="Vcl.Graphics.pas" line="224">
    <value>
      $D355BA
    </value>
  </const>
  <const name="clWebMediumPurple" type="TColor" file="Vcl.Graphics.pas" line="225">
    <value>
      $DB7093
    </value>
  </const>
  <const name="clWebPurple" type="TColor" file="Vcl.Graphics.pas" line="226">
    <value>
      $800080
    </value>
  </const>
  <const name="clWebDeepPink" type="TColor" file="Vcl.Graphics.pas" line="227">
    <value>
      $9314FF
    </value>
  </const>
  <const name="clWebLightPink" type="TColor" file="Vcl.Graphics.pas" line="228">
    <value>
      $C1B6FF
    </value>
  </const>
  <const name="clWebViolet" type="TColor" file="Vcl.Graphics.pas" line="229">
    <value>
      $EE82EE
    </value>
  </const>
  <const name="clWebOrchid" type="TColor" file="Vcl.Graphics.pas" line="230">
    <value>
      $D670DA
    </value>
  </const>
  <const name="clWebPlum" type="TColor" file="Vcl.Graphics.pas" line="231">
    <value>
      $DDA0DD
    </value>
  </const>
  <const name="clWebThistle" type="TColor" file="Vcl.Graphics.pas" line="232">
    <value>
      $D8BFD8
    </value>
  </const>
  <const name="clWebHotPink" type="TColor" file="Vcl.Graphics.pas" line="233">
    <value>
      $B469FF
    </value>
  </const>
  <const name="clWebPink" type="TColor" file="Vcl.Graphics.pas" line="234">
    <value>
      $CBC0FF
    </value>
  </const>
  <const name="clWebLightSteelBlue" type="TColor" file="Vcl.Graphics.pas" line="236">
    <value>
      $DEC4B0
    </value>
  </const>
  <const name="clWebMediumSlateBlue" type="TColor" file="Vcl.Graphics.pas" line="237">
    <value>
      $EE687B
    </value>
  </const>
  <const name="clWebLightSlateGray" type="TColor" file="Vcl.Graphics.pas" line="238">
    <value>
      $998877
    </value>
  </const>
  <const name="clWebWhite" type="TColor" file="Vcl.Graphics.pas" line="239">
    <value>
      $FFFFFF
    </value>
  </const>
  <const name="clWebLightgrey" type="TColor" file="Vcl.Graphics.pas" line="240">
    <value>
      $D3D3D3
    </value>
  </const>
  <const name="clWebGray" type="TColor" file="Vcl.Graphics.pas" line="241">
    <value>
      $808080
    </value>
  </const>
  <const name="clWebSteelBlue" type="TColor" file="Vcl.Graphics.pas" line="242">
    <value>
      $B48246
    </value>
  </const>
  <const name="clWebSlateBlue" type="TColor" file="Vcl.Graphics.pas" line="243">
    <value>
      $CD5A6A
    </value>
  </const>
  <const name="clWebSlateGray" type="TColor" file="Vcl.Graphics.pas" line="244">
    <value>
      $908070
    </value>
  </const>
  <const name="clWebWhiteSmoke" type="TColor" file="Vcl.Graphics.pas" line="245">
    <value>
      $F5F5F5
    </value>
  </const>
  <const name="clWebSilver" type="TColor" file="Vcl.Graphics.pas" line="246">
    <value>
      $C0C0C0
    </value>
  </const>
  <const name="clWebDimGray" type="TColor" file="Vcl.Graphics.pas" line="247">
    <value>
      $696969
    </value>
  </const>
  <const name="clWebMistyRose" type="TColor" file="Vcl.Graphics.pas" line="248">
    <value>
      $E1E4FF
    </value>
  </const>
  <const name="clWebDarkSlateBlue" type="TColor" file="Vcl.Graphics.pas" line="249">
    <value>
      $8B3D48
    </value>
  </const>
  <const name="clWebDarkSlategray" type="TColor" file="Vcl.Graphics.pas" line="250">
    <value>
      $4F4F2F
    </value>
  </const>
  <const name="clWebGainsboro" type="TColor" file="Vcl.Graphics.pas" line="251">
    <value>
      $DCDCDC
    </value>
  </const>
  <const name="clWebDarkGray" type="TColor" file="Vcl.Graphics.pas" line="252">
    <value>
      $A9A9A9
    </value>
  </const>
  <const name="clWebBlack" type="TColor" file="Vcl.Graphics.pas" line="253">
    <value>
      $0
    </value>
  </const>
  <const name="WebColorsCount" type="Integer" file="Vcl.Graphics.pas" line="254">
    <value>
      $8C
    </value>
  </const>
  <const name="cmBlackness" type="Integer" file="Vcl.Graphics.pas" line="257">
    <value>
      $42
    </value>
  </const>
  <const name="cmDstInvert" type="Integer" file="Vcl.Graphics.pas" line="258">
    <value>
      $550009
    </value>
  </const>
  <const name="cmMergeCopy" type="Integer" file="Vcl.Graphics.pas" line="259">
    <value>
      $C000CA
    </value>
  </const>
  <const name="cmMergePaint" type="Integer" file="Vcl.Graphics.pas" line="260">
    <value>
      $BB0226
    </value>
  </const>
  <const name="cmNotSrcCopy" type="Integer" file="Vcl.Graphics.pas" line="261">
    <value>
      $330008
    </value>
  </const>
  <const name="cmNotSrcErase" type="Integer" file="Vcl.Graphics.pas" line="262">
    <value>
      $1100A6
    </value>
  </const>
  <const name="cmPatCopy" type="Integer" file="Vcl.Graphics.pas" line="263">
    <value>
      $F00021
    </value>
  </const>
  <const name="cmPatInvert" type="Integer" file="Vcl.Graphics.pas" line="264">
    <value>
      $5A0049
    </value>
  </const>
  <const name="cmPatPaint" type="Integer" file="Vcl.Graphics.pas" line="265">
    <value>
      $FB0A09
    </value>
  </const>
  <const name="cmSrcAnd" type="Integer" file="Vcl.Graphics.pas" line="266">
    <value>
      $8800C6
    </value>
  </const>
  <const name="cmSrcCopy" type="Integer" file="Vcl.Graphics.pas" line="267">
    <value>
      $CC0020
    </value>
  </const>
  <const name="cmSrcErase" type="Integer" file="Vcl.Graphics.pas" line="268">
    <value>
      $440328
    </value>
  </const>
  <const name="cmSrcInvert" type="Integer" file="Vcl.Graphics.pas" line="269">
    <value>
      $660046
    </value>
  </const>
  <const name="cmSrcPaint" type="Integer" file="Vcl.Graphics.pas" line="270">
    <value>
      $EE0086
    </value>
  </const>
  <const name="cmWhiteness" type="Integer" file="Vcl.Graphics.pas" line="271">
    <value>
      $FF0062
    </value>
  </const>
  <const name="rc3_StockIcon" type="Integer" file="Vcl.Graphics.pas" line="274">
    <value>
      $0
    </value>
  </const>
  <const name="rc3_Icon" type="Integer" file="Vcl.Graphics.pas" line="275">
    <value>
      $1
    </value>
  </const>
  <const name="rc3_Cursor" type="Integer" file="Vcl.Graphics.pas" line="276">
    <value>
      $2
    </value>
  </const>
  <const name="fsBold" type="TFontStyle" file="Vcl.Graphics.pas" line="280">
    <value>
      fsBold
    </value>
  </const>
  <const name="fsItalic" type="TFontStyle" file="Vcl.Graphics.pas" line="282">
    <value>
      fsItalic
    </value>
  </const>
  <const name="fsUnderline" type="TFontStyle" file="Vcl.Graphics.pas" line="284">
    <value>
      fsUnderline
    </value>
  </const>
  <const name="fsStrikeOut" type="TFontStyle" file="Vcl.Graphics.pas" line="286">
    <value>
      fsStrikeOut
    </value>
  </const>
  <const name="fpDefault" type="TFontPitch" file="Vcl.Graphics.pas" line="290">
    <value>
      fpDefault
    </value>
  </const>
  <const name="fpVariable" type="TFontPitch" file="Vcl.Graphics.pas" line="292">
    <value>
      fpVariable
    </value>
  </const>
  <const name="fpFixed" type="TFontPitch" file="Vcl.Graphics.pas" line="294">
    <value>
      fpFixed
    </value>
  </const>
  <const name="fqDefault" type="TFontQuality" file="Vcl.Graphics.pas" line="298">
    <value>
      fqDefault
    </value>
  </const>
  <const name="fqDraft" type="TFontQuality" file="Vcl.Graphics.pas" line="300">
    <value>
      fqDraft
    </value>
  </const>
  <const name="fqProof" type="TFontQuality" file="Vcl.Graphics.pas" line="302">
    <value>
      fqProof
    </value>
  </const>
  <const name="fqNonAntialiased" type="TFontQuality" file="Vcl.Graphics.pas" line="304">
    <value>
      fqNonAntialiased
    </value>
  </const>
  <const name="fqAntialiased" type="TFontQuality" file="Vcl.Graphics.pas" line="306">
    <value>
      fqAntialiased
    </value>
  </const>
  <const name="fqClearType" type="TFontQuality" file="Vcl.Graphics.pas" line="308">
    <value>
      fqClearType
    </value>
  </const>
  <const name="fqClearTypeNatural" type="TFontQuality" file="Vcl.Graphics.pas" line="310">
    <value>
      fqClearTypeNatural
    </value>
  </const>
  <const name="MASK_TF_COMPOSITED" type="Integer" file="Vcl.Graphics.pas" line="314">
    <value>
      $800000
    </value>
  </const>
  <const name="psSolid" type="TPenStyle" file="Vcl.Graphics.pas" line="446">
    <value>
      psSolid
    </value>
  </const>
  <const name="psDash" type="TPenStyle" file="Vcl.Graphics.pas" line="446">
    <value>
      psDash
    </value>
  </const>
  <const name="psDot" type="TPenStyle" file="Vcl.Graphics.pas" line="446">
    <value>
      psDot
    </value>
  </const>
  <const name="psDashDot" type="TPenStyle" file="Vcl.Graphics.pas" line="446">
    <value>
      psDashDot
    </value>
  </const>
  <const name="psDashDotDot" type="TPenStyle" file="Vcl.Graphics.pas" line="446">
    <value>
      psDashDotDot
    </value>
  </const>
  <const name="psClear" type="TPenStyle" file="Vcl.Graphics.pas" line="446">
    <value>
      psClear
    </value>
  </const>
  <const name="psInsideFrame" type="TPenStyle" file="Vcl.Graphics.pas" line="447">
    <value>
      psInsideFrame
    </value>
  </const>
  <const name="psUserStyle" type="TPenStyle" file="Vcl.Graphics.pas" line="447">
    <value>
      psUserStyle
    </value>
  </const>
  <const name="psAlternate" type="TPenStyle" file="Vcl.Graphics.pas" line="447">
    <value>
      psAlternate
    </value>
  </const>
  <const name="pmBlack" type="TPenMode" file="Vcl.Graphics.pas" line="448">
    <value>
      pmBlack
    </value>
  </const>
  <const name="pmWhite" type="TPenMode" file="Vcl.Graphics.pas" line="448">
    <value>
      pmWhite
    </value>
  </const>
  <const name="pmNop" type="TPenMode" file="Vcl.Graphics.pas" line="448">
    <value>
      pmNop
    </value>
  </const>
  <const name="pmNot" type="TPenMode" file="Vcl.Graphics.pas" line="448">
    <value>
      pmNot
    </value>
  </const>
  <const name="pmCopy" type="TPenMode" file="Vcl.Graphics.pas" line="448">
    <value>
      pmCopy
    </value>
  </const>
  <const name="pmNotCopy" type="TPenMode" file="Vcl.Graphics.pas" line="448">
    <value>
      pmNotCopy
    </value>
  </const>
  <const name="pmMergePenNot" type="TPenMode" file="Vcl.Graphics.pas" line="449">
    <value>
      pmMergePenNot
    </value>
  </const>
  <const name="pmMaskPenNot" type="TPenMode" file="Vcl.Graphics.pas" line="449">
    <value>
      pmMaskPenNot
    </value>
  </const>
  <const name="pmMergeNotPen" type="TPenMode" file="Vcl.Graphics.pas" line="449">
    <value>
      pmMergeNotPen
    </value>
  </const>
  <const name="pmMaskNotPen" type="TPenMode" file="Vcl.Graphics.pas" line="449">
    <value>
      pmMaskNotPen
    </value>
  </const>
  <const name="pmMerge" type="TPenMode" file="Vcl.Graphics.pas" line="449">
    <value>
      pmMerge
    </value>
  </const>
  <const name="pmNotMerge" type="TPenMode" file="Vcl.Graphics.pas" line="450">
    <value>
      pmNotMerge
    </value>
  </const>
  <const name="pmMask" type="TPenMode" file="Vcl.Graphics.pas" line="450">
    <value>
      pmMask
    </value>
  </const>
  <const name="pmNotMask" type="TPenMode" file="Vcl.Graphics.pas" line="450">
    <value>
      pmNotMask
    </value>
  </const>
  <const name="pmXor" type="TPenMode" file="Vcl.Graphics.pas" line="450">
    <value>
      pmXor
    </value>
  </const>
  <const name="pmNotXor" type="TPenMode" file="Vcl.Graphics.pas" line="450">
    <value>
      pmNotXor
    </value>
  </const>
  <const name="bsSolid" type="TBrushStyle" file="Vcl.Graphics.pas" line="476">
    <value>
      bsSolid
    </value>
  </const>
  <const name="bsClear" type="TBrushStyle" file="Vcl.Graphics.pas" line="476">
    <value>
      bsClear
    </value>
  </const>
  <const name="bsHorizontal" type="TBrushStyle" file="Vcl.Graphics.pas" line="476">
    <value>
      bsHorizontal
    </value>
  </const>
  <const name="bsVertical" type="TBrushStyle" file="Vcl.Graphics.pas" line="476">
    <value>
      bsVertical
    </value>
  </const>
  <const name="bsFDiagonal" type="TBrushStyle" file="Vcl.Graphics.pas" line="477">
    <value>
      bsFDiagonal
    </value>
  </const>
  <const name="bsBDiagonal" type="TBrushStyle" file="Vcl.Graphics.pas" line="477">
    <value>
      bsBDiagonal
    </value>
  </const>
  <const name="bsCross" type="TBrushStyle" file="Vcl.Graphics.pas" line="477">
    <value>
      bsCross
    </value>
  </const>
  <const name="bsDiagCross" type="TBrushStyle" file="Vcl.Graphics.pas" line="477">
    <value>
      bsDiagCross
    </value>
  </const>
  <const name="fsSurface" type="TFillStyle" file="Vcl.Graphics.pas" line="690">
    <value>
      fsSurface
    </value>
  </const>
  <const name="fsBorder" type="TFillStyle" file="Vcl.Graphics.pas" line="690">
    <value>
      fsBorder
    </value>
  </const>
  <const name="fmAlternate" type="TFillMode" file="Vcl.Graphics.pas" line="691">
    <value>
      fmAlternate
    </value>
  </const>
  <const name="fmWinding" type="TFillMode" file="Vcl.Graphics.pas" line="691">
    <value>
      fmWinding
    </value>
  </const>
  <const name="csHandleValid" type="TCanvasStates" file="Vcl.Graphics.pas" line="695">
    <value>
      csHandleValid
    </value>
  </const>
  <const name="csFontValid" type="TCanvasStates" file="Vcl.Graphics.pas" line="695">
    <value>
      csFontValid
    </value>
  </const>
  <const name="csPenValid" type="TCanvasStates" file="Vcl.Graphics.pas" line="695">
    <value>
      csPenValid
    </value>
  </const>
  <const name="csBrushValid" type="TCanvasStates" file="Vcl.Graphics.pas" line="695">
    <value>
      csBrushValid
    </value>
  </const>
  <const name="coLeftToRight" type="TCanvasOrientation" file="Vcl.Graphics.pas" line="697">
    <value>
      coLeftToRight
    </value>
  </const>
  <const name="coRightToLeft" type="TCanvasOrientation" file="Vcl.Graphics.pas" line="697">
    <value>
      coRightToLeft
    </value>
  </const>
  <const name="tfBottom" type="TTextFormats" file="Vcl.Graphics.pas" line="699">
    <value>
      tfBottom
    </value>
  </const>
  <const name="tfCalcRect" type="TTextFormats" file="Vcl.Graphics.pas" line="699">
    <value>
      tfCalcRect
    </value>
  </const>
  <const name="tfCenter" type="TTextFormats" file="Vcl.Graphics.pas" line="699">
    <value>
      tfCenter
    </value>
  </const>
  <const name="tfEditControl" type="TTextFormats" file="Vcl.Graphics.pas" line="699">
    <value>
      tfEditControl
    </value>
  </const>
  <const name="tfEndEllipsis" type="TTextFormats" file="Vcl.Graphics.pas" line="699">
    <value>
      tfEndEllipsis
    </value>
  </const>
  <const name="tfPathEllipsis" type="TTextFormats" file="Vcl.Graphics.pas" line="700">
    <value>
      tfPathEllipsis
    </value>
  </const>
  <const name="tfExpandTabs" type="TTextFormats" file="Vcl.Graphics.pas" line="700">
    <value>
      tfExpandTabs
    </value>
  </const>
  <const name="tfExternalLeading" type="TTextFormats" file="Vcl.Graphics.pas" line="700">
    <value>
      tfExternalLeading
    </value>
  </const>
  <const name="tfLeft" type="TTextFormats" file="Vcl.Graphics.pas" line="700">
    <value>
      tfLeft
    </value>
  </const>
  <const name="tfModifyString" type="TTextFormats" file="Vcl.Graphics.pas" line="700">
    <value>
      tfModifyString
    </value>
  </const>
  <const name="tfNoClip" type="TTextFormats" file="Vcl.Graphics.pas" line="701">
    <value>
      tfNoClip
    </value>
  </const>
  <const name="tfNoPrefix" type="TTextFormats" file="Vcl.Graphics.pas" line="701">
    <value>
      tfNoPrefix
    </value>
  </const>
  <const name="tfRight" type="TTextFormats" file="Vcl.Graphics.pas" line="701">
    <value>
      tfRight
    </value>
  </const>
  <const name="tfRtlReading" type="TTextFormats" file="Vcl.Graphics.pas" line="701">
    <value>
      tfRtlReading
    </value>
  </const>
  <const name="tfSingleLine" type="TTextFormats" file="Vcl.Graphics.pas" line="701">
    <value>
      tfSingleLine
    </value>
  </const>
  <const name="tfTop" type="TTextFormats" file="Vcl.Graphics.pas" line="701">
    <value>
      tfTop
    </value>
  </const>
  <const name="tfVerticalCenter" type="TTextFormats" file="Vcl.Graphics.pas" line="702">
    <value>
      tfVerticalCenter
    </value>
  </const>
  <const name="tfWordBreak" type="TTextFormats" file="Vcl.Graphics.pas" line="702">
    <value>
      tfWordBreak
    </value>
  </const>
  <const name="tfHidePrefix" type="TTextFormats" file="Vcl.Graphics.pas" line="702">
    <value>
      tfHidePrefix
    </value>
  </const>
  <const name="tfNoFullWidthCharBreak" type="TTextFormats" file="Vcl.Graphics.pas" line="702">
    <value>
      tfNoFullWidthCharBreak
    </value>
  </const>
  <const name="tfPrefixOnly" type="TTextFormats" file="Vcl.Graphics.pas" line="703">
    <value>
      tfPrefixOnly
    </value>
  </const>
  <const name="tfTabStop" type="TTextFormats" file="Vcl.Graphics.pas" line="703">
    <value>
      tfTabStop
    </value>
  </const>
  <const name="tfWordEllipsis" type="TTextFormats" file="Vcl.Graphics.pas" line="703">
    <value>
      tfWordEllipsis
    </value>
  </const>
  <const name="tfComposited" type="TTextFormats" file="Vcl.Graphics.pas" line="703">
    <value>
      tfComposited
    </value>
  </const>
  <const name="psStarting" type="TProgressStage" file="Vcl.Graphics.pas" line="906">
    <value>
      psStarting
    </value>
  </const>
  <const name="psRunning" type="TProgressStage" file="Vcl.Graphics.pas" line="906">
    <value>
      psRunning
    </value>
  </const>
  <const name="psEnding" type="TProgressStage" file="Vcl.Graphics.pas" line="906">
    <value>
      psEnding
    </value>
  </const>
  <const name="gsStream" type="TFindGraphicClassSource" file="Vcl.Graphics.pas" line="999">
    <value>
      gsStream
    </value>
  </const>
  <const name="gsFileName" type="TFindGraphicClassSource" file="Vcl.Graphics.pas" line="999">
    <value>
      gsFileName
    </value>
  </const>
  <const name="gsClipboard" type="TFindGraphicClassSource" file="Vcl.Graphics.pas" line="999">
    <value>
      gsClipboard
    </value>
  </const>
  <const name="bmDIB" type="TBitmapHandleType" file="Vcl.Graphics.pas" line="1334">
    <value>
      bmDIB
    </value>
  </const>
  <const name="bmDDB" type="TBitmapHandleType" file="Vcl.Graphics.pas" line="1334">
    <value>
      bmDDB
    </value>
  </const>
  <const name="pfDevice" type="TPixelFormat" file="Vcl.Graphics.pas" line="1335">
    <value>
      pfDevice
    </value>
  </const>
  <const name="pf1bit" type="TPixelFormat" file="Vcl.Graphics.pas" line="1335">
    <value>
      pf1bit
    </value>
  </const>
  <const name="pf4bit" type="TPixelFormat" file="Vcl.Graphics.pas" line="1335">
    <value>
      pf4bit
    </value>
  </const>
  <const name="pf8bit" type="TPixelFormat" file="Vcl.Graphics.pas" line="1335">
    <value>
      pf8bit
    </value>
  </const>
  <const name="pf15bit" type="TPixelFormat" file="Vcl.Graphics.pas" line="1335">
    <value>
      pf15bit
    </value>
  </const>
  <const name="pf16bit" type="TPixelFormat" file="Vcl.Graphics.pas" line="1335">
    <value>
      pf16bit
    </value>
  </const>
  <const name="pf24bit" type="TPixelFormat" file="Vcl.Graphics.pas" line="1335">
    <value>
      pf24bit
    </value>
  </const>
  <const name="pf32bit" type="TPixelFormat" file="Vcl.Graphics.pas" line="1335">
    <value>
      pf32bit
    </value>
  </const>
  <const name="pfCustom" type="TPixelFormat" file="Vcl.Graphics.pas" line="1335">
    <value>
      pfCustom
    </value>
  </const>
  <const name="afIgnored" type="TAlphaFormat" file="Vcl.Graphics.pas" line="1336">
    <value>
      afIgnored
    </value>
  </const>
  <const name="afDefined" type="TAlphaFormat" file="Vcl.Graphics.pas" line="1336">
    <value>
      afDefined
    </value>
  </const>
  <const name="afPremultiplied" type="TAlphaFormat" file="Vcl.Graphics.pas" line="1336">
    <value>
      afPremultiplied
    </value>
  </const>
  <const name="tmAuto" type="TTransparentMode" file="Vcl.Graphics.pas" line="1337">
    <value>
      tmAuto
    </value>
  </const>
  <const name="tmFixed" type="TTransparentMode" file="Vcl.Graphics.pas" line="1337">
    <value>
      tmFixed
    </value>
  </const>
  <const name="wifBmp" type="TWICImageFormat" file="Vcl.Graphics.pas" line="1548">
    <value>
      wifBmp
    </value>
  </const>
  <const name="wifPng" type="TWICImageFormat" file="Vcl.Graphics.pas" line="1548">
    <value>
      wifPng
    </value>
  </const>
  <const name="wifJpeg" type="TWICImageFormat" file="Vcl.Graphics.pas" line="1548">
    <value>
      wifJpeg
    </value>
  </const>
  <const name="wifGif" type="TWICImageFormat" file="Vcl.Graphics.pas" line="1548">
    <value>
      wifGif
    </value>
  </const>
  <const name="wifTiff" type="TWICImageFormat" file="Vcl.Graphics.pas" line="1548">
    <value>
      wifTiff
    </value>
  </const>
  <const name="wifWMPhoto" type="TWICImageFormat" file="Vcl.Graphics.pas" line="1548">
    <value>
      wifWMPhoto
    </value>
  </const>
  <const name="wifOther" type="TWICImageFormat" file="Vcl.Graphics.pas" line="1548">
    <value>
      wifOther
    </value>
  </const>
  <const name="wipmNone" type="TWICImageInterpolationMode" file="Vcl.Graphics.pas" line="1549">
    <value>
      wipmNone
    </value>
  </const>
  <const name="wipmHighQualityCubic" type="TWICImageInterpolationMode" file="Vcl.Graphics.pas" line="1549">
    <value>
      wipmHighQualityCubic
    </value>
  </const>
  <const name="wipmFant" type="TWICImageInterpolationMode" file="Vcl.Graphics.pas" line="1549">
    <value>
      wipmFant
    </value>
  </const>
  <const name="wipmCubic" type="TWICImageInterpolationMode" file="Vcl.Graphics.pas" line="1549">
    <value>
      wipmCubic
    </value>
  </const>
  <const name="wipmLinear" type="TWICImageInterpolationMode" file="Vcl.Graphics.pas" line="1549">
    <value>
      wipmLinear
    </value>
  </const>
  <const name="wipmNearestNeighbor" type="TWICImageInterpolationMode" file="Vcl.Graphics.pas" line="1549">
    <value>
      wipmNearestNeighbor
    </value>
  </const>
  <pointer name="PCursorOrIcon" type="TCursorOrIcon" indircnt="1" file="Vcl.Graphics.pas" line="319"/>
  <struct name="TCursorOrIcon" size="6" file="Vcl.Graphics.pas" line="321">
    <field name="Reserved" type="Word" visibility="public" size="2" offset="0" file="Vcl.Graphics.pas" line="322"/>
    <field name="wType" type="Word" visibility="public" size="2" offset="2" file="Vcl.Graphics.pas" line="323"/>
    <field name="Count" type="Word" visibility="public" size="2" offset="4" file="Vcl.Graphics.pas" line="324"/>
  </struct>
  <pointer name="PIconRec" type="TIconRec" indircnt="1" file="Vcl.Graphics.pas" line="328"/>
  <struct name="TIconRec" size="16" file="Vcl.Graphics.pas" line="330">
    <field name="Width" type="Byte" visibility="public" size="1" offset="0" file="Vcl.Graphics.pas" line="331"/>
    <field name="Height" type="Byte" visibility="public" size="1" offset="1" file="Vcl.Graphics.pas" line="332"/>
    <field name="Colors" type="Word" visibility="public" size="2" offset="2" file="Vcl.Graphics.pas" line="333"/>
    <field name="Reserved1" type="Word" visibility="public" size="2" offset="4" file="Vcl.Graphics.pas" line="334"/>
    <field name="Reserved2" type="Word" visibility="public" size="2" offset="6" file="Vcl.Graphics.pas" line="335"/>
    <field name="DIBSize" type="Integer" visibility="public" size="4" offset="8" file="Vcl.Graphics.pas" line="336"/>
    <field name="DIBOffset" type="Integer" visibility="public" size="4" offset="12" file="Vcl.Graphics.pas" line="337"/>
  </struct>
  <type name="HMETAFILE" type="cardinal" loBound="0" hiBound="-1" file="System.pas" line="12"/>
  <type name="HENHMETAFILE" type="cardinal" loBound="0" hiBound="-1" file="System.pas" line="12"/>
  <class name="EInvalidGraphic" file="Vcl.Graphics.pas" line="349">
    <ancestor name="Exception" namespace="System.SysUtils">
      <methodref name="Create@" visibility="class private" procflags="class constructor noself">
      </methodref>
      <methodref name="Destroy@" visibility="class private" procflags="class destructor noself">
      </methodref>
      <methodref name="SetInnerException" visibility="protected">
      </methodref>
      <methodref name="SetStackInfo" visibility="protected">
      </methodref>
      <methodref name="GetStackTrace" visibility="protected">
      </methodref>
      <methodref name="RaisingException" visibility="protected" procflags="virtual">
      </methodref>
      <methodref name="Create" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateFmt" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateRes" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateRes" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmt" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmt" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateHelp" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateFmtHelp" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateResHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmtHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmtHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="Destroy" visibility="public" procflags="destructor override">
      </methodref>
      <methodref name="GetBaseException" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="ToString" visibility="public" procflags="override">
      </methodref>
      <propertyref name="BaseException" visibility="public">
      </propertyref>
      <propertyref name="HelpContext" visibility="public">
      </propertyref>
      <propertyref name="InnerException" visibility="public">
      </propertyref>
      <propertyref name="Message" visibility="public">
      </propertyref>
      <propertyref name="StackTrace" visibility="public">
      </propertyref>
      <propertyref name="StackInfo" visibility="public">
      </propertyref>
      <methodref name="RaiseOuterException" visibility="public" procflags="static">
      </methodref>
      <methodref name="ThrowOuterException" visibility="public" procflags="static">
      </methodref>
      <ancestor name="TObject" namespace="System">
        <methodref name="Create" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="Free" visibility="public">
        </methodref>
        <methodref name="DisposeOf" visibility="public" procflags="inline">
        </methodref>
        <methodref name="InitInstance" visibility="public" procflags="class">
        </methodref>
        <methodref name="CleanupInstance" visibility="public">
        </methodref>
        <methodref name="ClassType" visibility="public" procflags="inline">
        </methodref>
        <methodref name="ClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassNameIs" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassParent" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="ClassInfo" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InstanceSize" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InheritsFrom" visibility="public" procflags="class">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodName" visibility="public" procflags="class">
        </methodref>
        <methodref name="QualifiedClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="GetInterface" visibility="public">
        </methodref>
        <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
        </methodref>
        <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="UnitName" visibility="public" procflags="class">
        </methodref>
        <methodref name="UnitScope" visibility="public" procflags="class">
        </methodref>
        <methodref name="Equals" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetHashCode" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="ToString" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="SafeCallException" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="AfterConstruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Dispatch" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="DefaultHandler" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="NewInstance" visibility="public" procflags="class virtual">
        </methodref>
        <methodref name="FreeInstance" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor virtual">
        </methodref>
        <methodref name="GetDisposed" visibility="protected" procflags="inline">
        </methodref>
        <methodref name="CheckDisposed" visibility="protected" procflags="inline">
        </methodref>
        <propertyref name="Disposed" visibility="protected">
        </propertyref>
      </ancestor>
    </ancestor>
  </class>
  <class name="EInvalidGraphicOperation" file="Vcl.Graphics.pas" line="350">
    <ancestor name="Exception" namespace="System.SysUtils">
      <methodref name="Create@" visibility="class private" procflags="class constructor noself">
      </methodref>
      <methodref name="Destroy@" visibility="class private" procflags="class destructor noself">
      </methodref>
      <methodref name="SetInnerException" visibility="protected">
      </methodref>
      <methodref name="SetStackInfo" visibility="protected">
      </methodref>
      <methodref name="GetStackTrace" visibility="protected">
      </methodref>
      <methodref name="RaisingException" visibility="protected" procflags="virtual">
      </methodref>
      <methodref name="Create" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateFmt" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateRes" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateRes" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmt" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmt" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateHelp" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateFmtHelp" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="CreateResHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmtHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="CreateResFmtHelp" visibility="public" procflags="constructor overload">
      </methodref>
      <methodref name="Destroy" visibility="public" procflags="destructor override">
      </methodref>
      <methodref name="GetBaseException" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="ToString" visibility="public" procflags="override">
      </methodref>
      <propertyref name="BaseException" visibility="public">
      </propertyref>
      <propertyref name="HelpContext" visibility="public">
      </propertyref>
      <propertyref name="InnerException" visibility="public">
      </propertyref>
      <propertyref name="Message" visibility="public">
      </propertyref>
      <propertyref name="StackTrace" visibility="public">
      </propertyref>
      <propertyref name="StackInfo" visibility="public">
      </propertyref>
      <methodref name="RaiseOuterException" visibility="public" procflags="static">
      </methodref>
      <methodref name="ThrowOuterException" visibility="public" procflags="static">
      </methodref>
      <ancestor name="TObject" namespace="System">
        <methodref name="Create" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="Free" visibility="public">
        </methodref>
        <methodref name="DisposeOf" visibility="public" procflags="inline">
        </methodref>
        <methodref name="InitInstance" visibility="public" procflags="class">
        </methodref>
        <methodref name="CleanupInstance" visibility="public">
        </methodref>
        <methodref name="ClassType" visibility="public" procflags="inline">
        </methodref>
        <methodref name="ClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassNameIs" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassParent" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="ClassInfo" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InstanceSize" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InheritsFrom" visibility="public" procflags="class">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodName" visibility="public" procflags="class">
        </methodref>
        <methodref name="QualifiedClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="GetInterface" visibility="public">
        </methodref>
        <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
        </methodref>
        <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="UnitName" visibility="public" procflags="class">
        </methodref>
        <methodref name="UnitScope" visibility="public" procflags="class">
        </methodref>
        <methodref name="Equals" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetHashCode" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="ToString" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="SafeCallException" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="AfterConstruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Dispatch" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="DefaultHandler" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="NewInstance" visibility="public" procflags="class virtual">
        </methodref>
        <methodref name="FreeInstance" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor virtual">
        </methodref>
        <methodref name="GetDisposed" visibility="protected" procflags="inline">
        </methodref>
        <methodref name="CheckDisposed" visibility="protected" procflags="inline">
        </methodref>
        <propertyref name="Disposed" visibility="protected">
        </propertyref>
      </ancestor>
    </ancestor>
  </class>
  <classref name="TGraphicClass" ref="TGraphic" file="Vcl.Graphics.pas" line="357"/>
  <classref name="TScaledGraphicDrawerClass" ref="TScaledGraphicDrawer" file="Vcl.Graphics.pas" line="359"/>
  <struct name="TResData" size="4" file="Vcl.Graphics.pas" line="376">
    <field name="Handle" type="NativeUInt" visibility="public" size="4" offset="0" file="Vcl.Graphics.pas" line="377"/>
  </struct>
  <enum name="TFontStyle" alias="System.UITypes.TFontStyle" file="Vcl.Graphics.pas" line="382">
    <element value="0" name="fsBold"/>
    <element value="1" name="fsItalic"/>
    <element value="2" name="fsUnderline"/>
    <element value="3" name="fsStrikeOut"/>
  </enum>
  <set name="TFontStyles" alias="System.UITypes.TFontStyles" type="TFontStyle" file="Vcl.Graphics.pas" line="384">
    <element name="fsBold"/>
    <element name="fsItalic"/>
    <element name="fsUnderline"/>
    <element name="fsStrikeOut"/>
  </set>
  <type name="TFontName" type="UnicodeString" file="System.UITypes.pas" line="83"/>
  <type name="TFontCharset" type="byte" loBound="0" hiBound="255" file="System.UITypes.pas" line="72"/>
  <enum name="TFontPitch" alias="System.UITypes.TFontPitch" file="Vcl.Graphics.pas" line="390">
    <element value="0" name="fpDefault"/>
    <element value="1" name="fpVariable"/>
    <element value="2" name="fpFixed"/>
  </enum>
  <enum name="TFontQuality" alias="System.UITypes.TFontQuality" file="Vcl.Graphics.pas" line="392">
    <element value="0" name="fqDefault"/>
    <element value="1" name="fqDraft"/>
    <element value="2" name="fqProof"/>
    <element value="3" name="fqNonAntialiased"/>
    <element value="4" name="fqAntialiased"/>
    <element value="5" name="fqClearType"/>
    <element value="6" name="fqClearTypeNatural"/>
  </enum>
  <struct name="TFontData" size="144" file="Vcl.Graphics.pas" line="425">
    <field name="Handle" type="HFONT" visibility="public" size="4" offset="0" file="Vcl.Graphics.pas" line="426"/>
    <field name="Height" type="Integer" visibility="public" size="4" offset="4" file="Vcl.Graphics.pas" line="427"/>
    <field name="Orientation" type="Integer" visibility="public" size="4" offset="8" file="Vcl.Graphics.pas" line="428"/>
    <field name="Pitch" type="TFontPitch" visibility="public" size="1" offset="12" file="Vcl.Graphics.pas" line="429"/>
    <field name="Style" type="TFontStylesBase" visibility="public" size="1" offset="13" file="Vcl.Graphics.pas" line="430"/>
    <field name="Charset" type="TFontCharset" visibility="public" size="1" offset="14" file="Vcl.Graphics.pas" line="431"/>
    <field name="Name" type="TFontDataName" visibility="public" size="125" offset="15" file="Vcl.Graphics.pas" line="432"/>
    <field name="Quality" type="TFontQuality" visibility="public" size="1" offset="140" file="Vcl.Graphics.pas" line="433"/>
  </struct>
  <enum name="TPenStyle" file="Vcl.Graphics.pas" line="446">
    <element value="0" name="psSolid" file="Vcl.Graphics.pas" line="446"/>
    <element value="1" name="psDash" file="Vcl.Graphics.pas" line="446"/>
    <element value="2" name="psDot" file="Vcl.Graphics.pas" line="446"/>
    <element value="3" name="psDashDot" file="Vcl.Graphics.pas" line="446"/>
    <element value="4" name="psDashDotDot" file="Vcl.Graphics.pas" line="446"/>
    <element value="5" name="psClear" file="Vcl.Graphics.pas" line="446"/>
    <element value="6" name="psInsideFrame" file="Vcl.Graphics.pas" line="447"/>
    <element value="7" name="psUserStyle" file="Vcl.Graphics.pas" line="447"/>
    <element value="8" name="psAlternate" file="Vcl.Graphics.pas" line="447"/>
  </enum>
  <enum name="TPenMode" file="Vcl.Graphics.pas" line="448">
    <element value="0" name="pmBlack" file="Vcl.Graphics.pas" line="448"/>
    <element value="1" name="pmWhite" file="Vcl.Graphics.pas" line="448"/>
    <element value="2" name="pmNop" file="Vcl.Graphics.pas" line="448"/>
    <element value="3" name="pmNot" file="Vcl.Graphics.pas" line="448"/>
    <element value="4" name="pmCopy" file="Vcl.Graphics.pas" line="448"/>
    <element value="5" name="pmNotCopy" file="Vcl.Graphics.pas" line="448"/>
    <element value="6" name="pmMergePenNot" file="Vcl.Graphics.pas" line="449"/>
    <element value="7" name="pmMaskPenNot" file="Vcl.Graphics.pas" line="449"/>
    <element value="8" name="pmMergeNotPen" file="Vcl.Graphics.pas" line="449"/>
    <element value="9" name="pmMaskNotPen" file="Vcl.Graphics.pas" line="449"/>
    <element value="10" name="pmMerge" file="Vcl.Graphics.pas" line="449"/>
    <element value="11" name="pmNotMerge" file="Vcl.Graphics.pas" line="450"/>
    <element value="12" name="pmMask" file="Vcl.Graphics.pas" line="450"/>
    <element value="13" name="pmNotMask" file="Vcl.Graphics.pas" line="450"/>
    <element value="14" name="pmXor" file="Vcl.Graphics.pas" line="450"/>
    <element value="15" name="pmNotXor" file="Vcl.Graphics.pas" line="450"/>
  </enum>
  <struct name="TPenData" size="16" file="Vcl.Graphics.pas" line="468">
    <field name="Handle" type="HPEN" visibility="public" size="4" offset="0" file="Vcl.Graphics.pas" line="469"/>
    <field name="Color" type="TColor" visibility="public" size="4" offset="4" file="Vcl.Graphics.pas" line="470"/>
    <field name="Width" type="Integer" visibility="public" size="4" offset="8" file="Vcl.Graphics.pas" line="471"/>
    <field name="Style" type="TPenStyle" visibility="public" size="1" offset="12" file="Vcl.Graphics.pas" line="472"/>
  </struct>
  <enum name="TBrushStyle" file="Vcl.Graphics.pas" line="476">
    <element value="0" name="bsSolid" file="Vcl.Graphics.pas" line="476"/>
    <element value="1" name="bsClear" file="Vcl.Graphics.pas" line="476"/>
    <element value="2" name="bsHorizontal" file="Vcl.Graphics.pas" line="476"/>
    <element value="3" name="bsVertical" file="Vcl.Graphics.pas" line="476"/>
    <element value="4" name="bsFDiagonal" file="Vcl.Graphics.pas" line="477"/>
    <element value="5" name="bsBDiagonal" file="Vcl.Graphics.pas" line="477"/>
    <element value="6" name="bsCross" file="Vcl.Graphics.pas" line="477"/>
    <element value="7" name="bsDiagCross" file="Vcl.Graphics.pas" line="477"/>
  </enum>
  <struct name="TBrushData" size="16" file="Vcl.Graphics.pas" line="495">
    <field name="Handle" type="HBRUSH" visibility="public" size="4" offset="0" file="Vcl.Graphics.pas" line="496"/>
    <field name="Color" type="TColor" visibility="public" size="4" offset="4" file="Vcl.Graphics.pas" line="497"/>
    <field name="Bitmap" type="TBitmap" visibility="public" size="4" offset="8" file="Vcl.Graphics.pas" line="498"/>
    <field name="Style" type="TBrushStyle" visibility="public" size="1" offset="12" file="Vcl.Graphics.pas" line="499"/>
    <field name="OwnsBitmap" type="Boolean" visibility="public" size="1" offset="13" file="Vcl.Graphics.pas" line="500"/>
  </struct>
  <pointer name="PResource" type="TResource" indircnt="1" file="Vcl.Graphics.pas" line="505"/>
  <struct name="TResource" size="164" file="Vcl.Graphics.pas" line="506">
    <field name="Next" type="PResource" visibility="public" size="4" offset="0" file="Vcl.Graphics.pas" line="507"/>
    <field name="RefCount" type="Integer" visibility="public" size="4" offset="4" file="Vcl.Graphics.pas" line="508"/>
    <field name="Handle" type="NativeUInt" visibility="public" size="4" offset="8" file="Vcl.Graphics.pas" line="509"/>
    <field name="HashCode" type="Word" visibility="public" size="2" offset="12" file="Vcl.Graphics.pas" line="510"/>
    <field name="Owner" type="Cardinal" visibility="public" size="4" offset="16" file="Vcl.Graphics.pas" line="511"/>
    <field name="Data" type="TResData" visibility="public" variant="true" size="4" offset="20" file="Vcl.Graphics.pas" line="513"/>
    <field name="Font" type="TFontData" visibility="public" variant="true" size="144" offset="20" file="Vcl.Graphics.pas" line="514"/>
    <field name="Pen" type="TPenData" visibility="public" variant="true" size="16" offset="20" file="Vcl.Graphics.pas" line="515"/>
    <field name="Brush" type="TBrushData" visibility="public" variant="true" size="16" offset="20" file="Vcl.Graphics.pas" line="516"/>
  </struct>
  <class name="TGraphicsObject" file="Vcl.Graphics.pas" line="520">
    <ancestor name="TPersistent" namespace="System.Classes">
      <methodref name="AssignError" visibility="private">
      </methodref>
      <methodref name="AssignTo" visibility="protected" procflags="virtual">
      </methodref>
      <methodref name="DefineProperties" visibility="protected" procflags="virtual">
      </methodref>
      <methodref name="GetOwner" visibility="protected" procflags="dynamic">
      </methodref>
      <methodref name="Destroy" visibility="public" procflags="destructor override">
      </methodref>
      <methodref name="Assign" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="GetNamePath" visibility="public" procflags="dynamic">
      </methodref>
      <ancestor name="TObject" namespace="System">
        <methodref name="Create" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="Free" visibility="public">
        </methodref>
        <methodref name="DisposeOf" visibility="public" procflags="inline">
        </methodref>
        <methodref name="InitInstance" visibility="public" procflags="class">
        </methodref>
        <methodref name="CleanupInstance" visibility="public">
        </methodref>
        <methodref name="ClassType" visibility="public" procflags="inline">
        </methodref>
        <methodref name="ClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassNameIs" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassParent" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="ClassInfo" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InstanceSize" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InheritsFrom" visibility="public" procflags="class">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodName" visibility="public" procflags="class">
        </methodref>
        <methodref name="QualifiedClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="GetInterface" visibility="public">
        </methodref>
        <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
        </methodref>
        <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="UnitName" visibility="public" procflags="class">
        </methodref>
        <methodref name="UnitScope" visibility="public" procflags="class">
        </methodref>
        <methodref name="Equals" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetHashCode" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="ToString" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="SafeCallException" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="AfterConstruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Dispatch" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="DefaultHandler" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="NewInstance" visibility="public" procflags="class virtual">
        </methodref>
        <methodref name="FreeInstance" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor virtual">
        </methodref>
        <methodref name="GetDisposed" visibility="protected" procflags="inline">
        </methodref>
        <methodref name="CheckDisposed" visibility="protected" procflags="inline">
        </methodref>
        <propertyref name="Disposed" visibility="protected">
        </propertyref>
      </ancestor>
    </ancestor>
    <members>
      <field name="FOnChange" type="TNotifyEvent" visibility="private" size="8" offset="8" file="Vcl.Graphics.pas" line="522"/>
      <field name="FResource" type="PResource" visibility="private" size="4" offset="16" file="Vcl.Graphics.pas" line="527"/>
      <field name="FOwnerLock" type="PRTLCriticalSection" visibility="private" size="4" offset="20" file="Vcl.Graphics.pas" line="528"/>
      <procedure name="Changed" visibility="protected" procflags="virtual" file="Vcl.Graphics.pas" line="531">
      </procedure>
      <procedure name="Lock" visibility="protected" file="Vcl.Graphics.pas" line="532">
      </procedure>
      <procedure name="Unlock" visibility="protected" file="Vcl.Graphics.pas" line="533">
      </procedure>
      <function name="HandleAllocated" visibility="public" file="Vcl.Graphics.pas" line="535">
        <parameters>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <property name="OwnerCriticalSection" visibility="public" read="FOwnerLock" write="FOwnerLock" type="PRTLCriticalSection" file="Vcl.Graphics.pas" line="540"/>
      <event name="OnChange" visibility="public" read="FOnChange" write="FOnChange" type="TNotifyEvent" file="Vcl.Graphics.pas" line="542"/>
    </members>
  </class>
  <interface name="IChangeNotifier" GUID="{1FB62321-44A7-11D0-9E93-0020AF3D82DA}" ancestor="IInterface" file="Vcl.Graphics.pas" line="545">
    <procedure name="Changed" visibility="public" procflags="abstract virtual" file="Vcl.Graphics.pas" line="547">
    </procedure>
  </interface>
  <class name="TFont" file="Vcl.Graphics.pas" line="550">
    <ancestor name="TGraphicsObject" namespace="Vcl.Graphics">
      <methodref name="Changed" visibility="protected" procflags="virtual"/>
      <methodref name="Lock" visibility="protected"/>
      <methodref name="Unlock" visibility="protected"/>
      <methodref name="HandleAllocated" visibility="public"/>
      <propertyref name="OwnerCriticalSection" visibility="public"/>
      <eventref name="OnChange" visibility="public"/>
      <ancestor name="TPersistent" namespace="System.Classes">
        <methodref name="AssignError" visibility="private">
        </methodref>
        <methodref name="AssignTo" visibility="protected" procflags="virtual">
        </methodref>
        <methodref name="DefineProperties" visibility="protected" procflags="virtual">
        </methodref>
        <methodref name="GetOwner" visibility="protected" procflags="dynamic">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor override">
        </methodref>
        <methodref name="Assign" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetNamePath" visibility="public" procflags="dynamic">
        </methodref>
        <ancestor name="TObject" namespace="System">
          <methodref name="Create" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="Free" visibility="public">
          </methodref>
          <methodref name="DisposeOf" visibility="public" procflags="inline">
          </methodref>
          <methodref name="InitInstance" visibility="public" procflags="class">
          </methodref>
          <methodref name="CleanupInstance" visibility="public">
          </methodref>
          <methodref name="ClassType" visibility="public" procflags="inline">
          </methodref>
          <methodref name="ClassName" visibility="public" procflags="class">
          </methodref>
          <methodref name="ClassNameIs" visibility="public" procflags="class">
          </methodref>
          <methodref name="ClassParent" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="ClassInfo" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="InstanceSize" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="InheritsFrom" visibility="public" procflags="class">
          </methodref>
          <methodref name="MethodAddress" visibility="public" procflags="class overload">
          </methodref>
          <methodref name="MethodAddress" visibility="public" procflags="class overload">
          </methodref>
          <methodref name="MethodName" visibility="public" procflags="class">
          </methodref>
          <methodref name="QualifiedClassName" visibility="public" procflags="class">
          </methodref>
          <methodref name="FieldAddress" visibility="public" procflags="overload">
          </methodref>
          <methodref name="FieldAddress" visibility="public" procflags="overload">
          </methodref>
          <methodref name="GetInterface" visibility="public">
          </methodref>
          <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
          </methodref>
          <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="UnitName" visibility="public" procflags="class">
          </methodref>
          <methodref name="UnitScope" visibility="public" procflags="class">
          </methodref>
          <methodref name="Equals" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="GetHashCode" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="ToString" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="SafeCallException" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="AfterConstruction" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="Dispatch" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="DefaultHandler" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="NewInstance" visibility="public" procflags="class virtual">
          </methodref>
          <methodref name="FreeInstance" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="Destroy" visibility="public" procflags="destructor virtual">
          </methodref>
          <methodref name="GetDisposed" visibility="protected" procflags="inline">
          </methodref>
          <methodref name="CheckDisposed" visibility="protected" procflags="inline">
          </methodref>
          <propertyref name="Disposed" visibility="protected">
          </propertyref>
        </ancestor>
      </ancestor>
    </ancestor>
    <members>
      <field name="FColor" type="TColor" visibility="private" size="4" offset="24" file="Vcl.Graphics.pas" line="552"/>
      <field name="FPixelsPerInch" type="Integer" visibility="private" size="4" offset="28" file="Vcl.Graphics.pas" line="553"/>
      <field name="FNotify" type="IChangeNotifier" visibility="private" size="4" offset="32" file="Vcl.Graphics.pas" line="554"/>
      <procedure name="GetData" visibility="private" file="Vcl.Graphics.pas" line="559">
        <parameters>
          <parameter name="FontData" type="TFontData" paramflags="var"/>
        </parameters>
      </procedure>
      <procedure name="SetData" visibility="private" file="Vcl.Graphics.pas" line="560">
        <parameters>
          <parameter name="FontData" type="TFontData" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="Changed" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="563">
      </procedure>
      <function name="GetHandle" visibility="protected" file="Vcl.Graphics.pas" line="564">
        <parameters>
          <retval type="HFONT"/>
        </parameters>
      </function>
      <function name="GetHeight" visibility="protected" procflags="inline" file="Vcl.Graphics.pas" line="565">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="GetName" visibility="protected" file="Vcl.Graphics.pas" line="566">
        <parameters>
          <retval type="TFontName"/>
        </parameters>
      </function>
      <function name="GetOrientation" visibility="protected" file="Vcl.Graphics.pas" line="567">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="GetPitch" visibility="protected" file="Vcl.Graphics.pas" line="568">
        <parameters>
          <retval type="TFontPitch"/>
        </parameters>
      </function>
      <function name="GetSize" visibility="protected" file="Vcl.Graphics.pas" line="569">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="GetStyle" visibility="protected" procflags="inline" file="Vcl.Graphics.pas" line="570">
        <parameters>
          <retval type="TFontStyles"/>
        </parameters>
      </function>
      <function name="GetCharset" visibility="protected" file="Vcl.Graphics.pas" line="571">
        <parameters>
          <retval type="TFontCharset"/>
        </parameters>
      </function>
      <function name="GetQuality" visibility="protected" file="Vcl.Graphics.pas" line="572">
        <parameters>
          <retval type="TFontQuality"/>
        </parameters>
      </function>
      <procedure name="SetColor" visibility="protected" file="Vcl.Graphics.pas" line="573">
        <parameters>
          <parameter name="Value" type="TColor" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="SetHandle" visibility="protected" file="Vcl.Graphics.pas" line="574">
        <parameters>
          <parameter name="Value" type="HFONT" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="SetHeight" visibility="protected" file="Vcl.Graphics.pas" line="575">
        <parameters>
          <parameter name="Value" type="Integer" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="SetOrientation" visibility="protected" file="Vcl.Graphics.pas" line="576">
        <parameters>
          <parameter name="Value" type="Integer" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="SetName" visibility="protected" file="Vcl.Graphics.pas" line="577">
        <parameters>
          <parameter name="Value" type="TFontName" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="SetPitch" visibility="protected" file="Vcl.Graphics.pas" line="578">
        <parameters>
          <parameter name="Value" type="TFontPitch" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="SetSize" visibility="protected" file="Vcl.Graphics.pas" line="579">
        <parameters>
          <parameter name="Value" type="Integer" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="SetStyle" visibility="protected" file="Vcl.Graphics.pas" line="580">
        <parameters>
          <parameter name="Value" type="TFontStyles" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="SetCharset" visibility="protected" file="Vcl.Graphics.pas" line="581">
        <parameters>
          <parameter name="Value" type="TFontCharset" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="SetQuality" visibility="protected" file="Vcl.Graphics.pas" line="582">
        <parameters>
          <parameter name="Value" type="TFontQuality" paramflags="const"/>
        </parameters>
      </procedure>
      <constructor name="Create" visibility="public" file="Vcl.Graphics.pas" line="584">
        <parameters>
        </parameters>
      </constructor>
      <destructor name="Destroy" visibility="public" file="Vcl.Graphics.pas" line="585">
        <parameters>
        </parameters>
      </destructor>
      <procedure name="Assign" visibility="public" procflags="override" file="Vcl.Graphics.pas" line="586">
        <parameters>
          <parameter name="Source" type="TPersistent"/>
        </parameters>
      </procedure>
      <property name="FontAdapter" visibility="public" read="FNotify" write="FNotify" type="IChangeNotifier" file="Vcl.Graphics.pas" line="587"/>
      <property name="Handle" visibility="public" read="GetHandle" write="SetHandle" type="HFONT" file="Vcl.Graphics.pas" line="588"/>
      <property name="PixelsPerInch" visibility="public" read="FPixelsPerInch" write="FPixelsPerInch" type="Integer" file="Vcl.Graphics.pas" line="589"/>
      <property name="Charset" visibility="published" read="GetCharset" write="SetCharset" type="TFontCharset" file="Vcl.Graphics.pas" line="591"/>
      <property name="Color" visibility="published" read="FColor" write="SetColor" type="TColor" file="Vcl.Graphics.pas" line="592"/>
      <property name="Height" visibility="published" read="GetHeight" write="SetHeight" type="Integer" file="Vcl.Graphics.pas" line="593"/>
      <property name="Name" visibility="published" read="GetName" write="SetName" type="TFontName" default="0" file="Vcl.Graphics.pas" line="594"/>
      <property name="Orientation" visibility="published" read="GetOrientation" write="SetOrientation" type="Integer" default="0" file="Vcl.Graphics.pas" line="595"/>
      <property name="Pitch" visibility="published" read="GetPitch" write="SetPitch" type="TFontPitch" default="0" file="Vcl.Graphics.pas" line="596"/>
      <property name="Size" visibility="published" read="GetSize" write="SetSize" stored="False" type="Integer" file="Vcl.Graphics.pas" line="597"/>
      <property name="Style" visibility="published" read="GetStyle" write="SetStyle" type="TFontStyles" file="Vcl.Graphics.pas" line="598"/>
      <property name="Quality" visibility="published" read="GetQuality" write="SetQuality" type="TFontQuality" default="0" file="Vcl.Graphics.pas" line="599"/>
    </members>
  </class>
  <class name="TPen" file="Vcl.Graphics.pas" line="602">
    <ancestor name="TGraphicsObject" namespace="Vcl.Graphics">
      <methodref name="Changed" visibility="protected" procflags="virtual"/>
      <methodref name="Lock" visibility="protected"/>
      <methodref name="Unlock" visibility="protected"/>
      <methodref name="HandleAllocated" visibility="public"/>
      <propertyref name="OwnerCriticalSection" visibility="public"/>
      <eventref name="OnChange" visibility="public"/>
      <ancestor name="TPersistent" namespace="System.Classes">
        <methodref name="AssignError" visibility="private">
        </methodref>
        <methodref name="AssignTo" visibility="protected" procflags="virtual">
        </methodref>
        <methodref name="DefineProperties" visibility="protected" procflags="virtual">
        </methodref>
        <methodref name="GetOwner" visibility="protected" procflags="dynamic">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor override">
        </methodref>
        <methodref name="Assign" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetNamePath" visibility="public" procflags="dynamic">
        </methodref>
        <ancestor name="TObject" namespace="System">
          <methodref name="Create" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="Free" visibility="public">
          </methodref>
          <methodref name="DisposeOf" visibility="public" procflags="inline">
          </methodref>
          <methodref name="InitInstance" visibility="public" procflags="class">
          </methodref>
          <methodref name="CleanupInstance" visibility="public">
          </methodref>
          <methodref name="ClassType" visibility="public" procflags="inline">
          </methodref>
          <methodref name="ClassName" visibility="public" procflags="class">
          </methodref>
          <methodref name="ClassNameIs" visibility="public" procflags="class">
          </methodref>
          <methodref name="ClassParent" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="ClassInfo" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="InstanceSize" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="InheritsFrom" visibility="public" procflags="class">
          </methodref>
          <methodref name="MethodAddress" visibility="public" procflags="class overload">
          </methodref>
          <methodref name="MethodAddress" visibility="public" procflags="class overload">
          </methodref>
          <methodref name="MethodName" visibility="public" procflags="class">
          </methodref>
          <methodref name="QualifiedClassName" visibility="public" procflags="class">
          </methodref>
          <methodref name="FieldAddress" visibility="public" procflags="overload">
          </methodref>
          <methodref name="FieldAddress" visibility="public" procflags="overload">
          </methodref>
          <methodref name="GetInterface" visibility="public">
          </methodref>
          <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
          </methodref>
          <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="UnitName" visibility="public" procflags="class">
          </methodref>
          <methodref name="UnitScope" visibility="public" procflags="class">
          </methodref>
          <methodref name="Equals" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="GetHashCode" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="ToString" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="SafeCallException" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="AfterConstruction" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="Dispatch" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="DefaultHandler" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="NewInstance" visibility="public" procflags="class virtual">
          </methodref>
          <methodref name="FreeInstance" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="Destroy" visibility="public" procflags="destructor virtual">
          </methodref>
          <methodref name="GetDisposed" visibility="protected" procflags="inline">
          </methodref>
          <methodref name="CheckDisposed" visibility="protected" procflags="inline">
          </methodref>
          <propertyref name="Disposed" visibility="protected">
          </propertyref>
        </ancestor>
      </ancestor>
    </ancestor>
    <members>
      <field name="FMode" type="TPenMode" visibility="private" size="1" offset="24" file="Vcl.Graphics.pas" line="604"/>
      <procedure name="GetData" visibility="private" file="Vcl.Graphics.pas" line="609">
        <parameters>
          <parameter name="PenData" type="TPenData" paramflags="var"/>
        </parameters>
      </procedure>
      <procedure name="SetData" visibility="private" file="Vcl.Graphics.pas" line="610">
        <parameters>
          <parameter name="PenData" type="TPenData" paramflags="const"/>
        </parameters>
      </procedure>
      <function name="GetColor" visibility="protected" procflags="inline" file="Vcl.Graphics.pas" line="613">
        <parameters>
          <retval type="TColor"/>
        </parameters>
      </function>
      <procedure name="SetColor" visibility="protected" file="Vcl.Graphics.pas" line="614">
        <parameters>
          <parameter name="Value" type="TColor"/>
        </parameters>
      </procedure>
      <function name="GetHandle" visibility="protected" file="Vcl.Graphics.pas" line="615">
        <parameters>
          <retval type="HPEN"/>
        </parameters>
      </function>
      <procedure name="SetHandle" visibility="protected" file="Vcl.Graphics.pas" line="616">
        <parameters>
          <parameter name="Value" type="HPEN"/>
        </parameters>
      </procedure>
      <procedure name="SetMode" visibility="protected" file="Vcl.Graphics.pas" line="617">
        <parameters>
          <parameter name="Value" type="TPenMode"/>
        </parameters>
      </procedure>
      <function name="GetStyle" visibility="protected" file="Vcl.Graphics.pas" line="618">
        <parameters>
          <retval type="TPenStyle"/>
        </parameters>
      </function>
      <procedure name="SetStyle" visibility="protected" file="Vcl.Graphics.pas" line="619">
        <parameters>
          <parameter name="Value" type="TPenStyle"/>
        </parameters>
      </procedure>
      <function name="GetWidth" visibility="protected" procflags="inline" file="Vcl.Graphics.pas" line="620">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      </function>
      <procedure name="SetWidth" visibility="protected" file="Vcl.Graphics.pas" line="621">
        <parameters>
          <parameter name="Value" type="Integer"/>
        </parameters>
      </procedure>
      <constructor name="Create" visibility="public" file="Vcl.Graphics.pas" line="623">
        <parameters>
        </parameters>
      </constructor>
      <destructor name="Destroy" visibility="public" file="Vcl.Graphics.pas" line="624">
        <parameters>
        </parameters>
      </destructor>
      <procedure name="Assign" visibility="public" procflags="override" file="Vcl.Graphics.pas" line="625">
        <parameters>
          <parameter name="Source" type="TPersistent"/>
        </parameters>
      </procedure>
      <property name="Handle" visibility="public" read="GetHandle" write="SetHandle" type="HPEN" file="Vcl.Graphics.pas" line="626"/>
      <property name="Color" visibility="published" read="GetColor" write="SetColor" type="TColor" default="0" file="Vcl.Graphics.pas" line="628"/>
      <property name="Mode" visibility="published" read="FMode" write="SetMode" type="TPenMode" default="4" file="Vcl.Graphics.pas" line="629"/>
      <property name="Style" visibility="published" read="GetStyle" write="SetStyle" type="TPenStyle" default="0" file="Vcl.Graphics.pas" line="630"/>
      <property name="Width" visibility="published" read="GetWidth" write="SetWidth" type="Integer" default="1" file="Vcl.Graphics.pas" line="631"/>
    </members>
  </class>
  <class name="TBrush" file="Vcl.Graphics.pas" line="634">
    <ancestor name="TGraphicsObject" namespace="Vcl.Graphics">
      <methodref name="Changed" visibility="protected" procflags="virtual"/>
      <methodref name="Lock" visibility="protected"/>
      <methodref name="Unlock" visibility="protected"/>
      <methodref name="HandleAllocated" visibility="public"/>
      <propertyref name="OwnerCriticalSection" visibility="public"/>
      <eventref name="OnChange" visibility="public"/>
      <ancestor name="TPersistent" namespace="System.Classes">
        <methodref name="AssignError" visibility="private">
        </methodref>
        <methodref name="AssignTo" visibility="protected" procflags="virtual">
        </methodref>
        <methodref name="DefineProperties" visibility="protected" procflags="virtual">
        </methodref>
        <methodref name="GetOwner" visibility="protected" procflags="dynamic">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor override">
        </methodref>
        <methodref name="Assign" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetNamePath" visibility="public" procflags="dynamic">
        </methodref>
        <ancestor name="TObject" namespace="System">
          <methodref name="Create" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="Free" visibility="public">
          </methodref>
          <methodref name="DisposeOf" visibility="public" procflags="inline">
          </methodref>
          <methodref name="InitInstance" visibility="public" procflags="class">
          </methodref>
          <methodref name="CleanupInstance" visibility="public">
          </methodref>
          <methodref name="ClassType" visibility="public" procflags="inline">
          </methodref>
          <methodref name="ClassName" visibility="public" procflags="class">
          </methodref>
          <methodref name="ClassNameIs" visibility="public" procflags="class">
          </methodref>
          <methodref name="ClassParent" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="ClassInfo" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="InstanceSize" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="InheritsFrom" visibility="public" procflags="class">
          </methodref>
          <methodref name="MethodAddress" visibility="public" procflags="class overload">
          </methodref>
          <methodref name="MethodAddress" visibility="public" procflags="class overload">
          </methodref>
          <methodref name="MethodName" visibility="public" procflags="class">
          </methodref>
          <methodref name="QualifiedClassName" visibility="public" procflags="class">
          </methodref>
          <methodref name="FieldAddress" visibility="public" procflags="overload">
          </methodref>
          <methodref name="FieldAddress" visibility="public" procflags="overload">
          </methodref>
          <methodref name="GetInterface" visibility="public">
          </methodref>
          <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
          </methodref>
          <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="UnitName" visibility="public" procflags="class">
          </methodref>
          <methodref name="UnitScope" visibility="public" procflags="class">
          </methodref>
          <methodref name="Equals" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="GetHashCode" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="ToString" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="SafeCallException" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="AfterConstruction" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="Dispatch" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="DefaultHandler" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="NewInstance" visibility="public" procflags="class virtual">
          </methodref>
          <methodref name="FreeInstance" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="Destroy" visibility="public" procflags="destructor virtual">
          </methodref>
          <methodref name="GetDisposed" visibility="protected" procflags="inline">
          </methodref>
          <methodref name="CheckDisposed" visibility="protected" procflags="inline">
          </methodref>
          <propertyref name="Disposed" visibility="protected">
          </propertyref>
        </ancestor>
      </ancestor>
    </ancestor>
    <members>
      <procedure name="GetData" visibility="private" file="Vcl.Graphics.pas" line="640">
        <parameters>
          <parameter name="BrushData" type="TBrushData" paramflags="var"/>
        </parameters>
      </procedure>
      <procedure name="SetData" visibility="private" file="Vcl.Graphics.pas" line="641">
        <parameters>
          <parameter name="BrushData" type="TBrushData" paramflags="const"/>
        </parameters>
      </procedure>
      <function name="GetBitmap" visibility="protected" file="Vcl.Graphics.pas" line="644">
        <parameters>
          <retval type="TBitmap"/>
        </parameters>
      </function>
      <procedure name="SetBitmap" visibility="protected" file="Vcl.Graphics.pas" line="645">
        <parameters>
          <parameter name="Value" type="TBitmap"/>
        </parameters>
      </procedure>
      <function name="GetColor" visibility="protected" procflags="inline" file="Vcl.Graphics.pas" line="646">
        <parameters>
          <retval type="TColor"/>
        </parameters>
      </function>
      <procedure name="SetColor" visibility="protected" file="Vcl.Graphics.pas" line="647">
        <parameters>
          <parameter name="Value" type="TColor"/>
        </parameters>
      </procedure>
      <function name="GetHandle" visibility="protected" file="Vcl.Graphics.pas" line="648">
        <parameters>
          <retval type="HBRUSH"/>
        </parameters>
      </function>
      <procedure name="SetHandle" visibility="protected" file="Vcl.Graphics.pas" line="649">
        <parameters>
          <parameter name="Value" type="HBRUSH"/>
        </parameters>
      </procedure>
      <function name="GetStyle" visibility="protected" procflags="inline" file="Vcl.Graphics.pas" line="650">
        <parameters>
          <retval type="TBrushStyle"/>
        </parameters>
      </function>
      <procedure name="SetStyle" visibility="protected" file="Vcl.Graphics.pas" line="651">
        <parameters>
          <parameter name="Value" type="TBrushStyle"/>
        </parameters>
      </procedure>
      <constructor name="Create" visibility="public" file="Vcl.Graphics.pas" line="653">
        <parameters>
        </parameters>
      </constructor>
      <destructor name="Destroy" visibility="public" file="Vcl.Graphics.pas" line="654">
        <parameters>
        </parameters>
      </destructor>
      <procedure name="Assign" visibility="public" procflags="override" file="Vcl.Graphics.pas" line="655">
        <parameters>
          <parameter name="Source" type="TPersistent"/>
        </parameters>
      </procedure>
      <property name="Bitmap" visibility="public" read="GetBitmap" write="SetBitmap" type="TBitmap" file="Vcl.Graphics.pas" line="656"/>
      <property name="Handle" visibility="public" read="GetHandle" write="SetHandle" type="HBRUSH" file="Vcl.Graphics.pas" line="657"/>
      <property name="Color" visibility="published" read="GetColor" write="SetColor" type="TColor" default="16777215" file="Vcl.Graphics.pas" line="659"/>
      <property name="Style" visibility="published" read="GetStyle" write="SetStyle" type="TBrushStyle" default="0" file="Vcl.Graphics.pas" line="660"/>
    </members>
  </class>
  <class name="TFontRecall" file="Vcl.Graphics.pas" line="663">
    <ancestor name="TRecall" namespace="System.Classes">
      <methodref name="Create" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="Destroy" visibility="public" procflags="destructor override">
      </methodref>
      <methodref name="Store" visibility="public">
      </methodref>
      <methodref name="Forget" visibility="public">
      </methodref>
      <propertyref name="Reference" visibility="public">
      </propertyref>
      <ancestor name="TObject" namespace="System">
        <methodref name="Create" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="Free" visibility="public">
        </methodref>
        <methodref name="DisposeOf" visibility="public" procflags="inline">
        </methodref>
        <methodref name="InitInstance" visibility="public" procflags="class">
        </methodref>
        <methodref name="CleanupInstance" visibility="public">
        </methodref>
        <methodref name="ClassType" visibility="public" procflags="inline">
        </methodref>
        <methodref name="ClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassNameIs" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassParent" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="ClassInfo" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InstanceSize" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InheritsFrom" visibility="public" procflags="class">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodName" visibility="public" procflags="class">
        </methodref>
        <methodref name="QualifiedClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="GetInterface" visibility="public">
        </methodref>
        <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
        </methodref>
        <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="UnitName" visibility="public" procflags="class">
        </methodref>
        <methodref name="UnitScope" visibility="public" procflags="class">
        </methodref>
        <methodref name="Equals" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetHashCode" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="ToString" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="SafeCallException" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="AfterConstruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Dispatch" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="DefaultHandler" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="NewInstance" visibility="public" procflags="class virtual">
        </methodref>
        <methodref name="FreeInstance" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor virtual">
        </methodref>
        <methodref name="GetDisposed" visibility="protected" procflags="inline">
        </methodref>
        <methodref name="CheckDisposed" visibility="protected" procflags="inline">
        </methodref>
        <propertyref name="Disposed" visibility="protected">
        </propertyref>
      </ancestor>
    </ancestor>
    <members>
      <constructor name="Create" visibility="public" file="Vcl.Graphics.pas" line="665">
        <parameters>
          <parameter name="AFont" type="TFont"/>
        </parameters>
      </constructor>
    </members>
  </class>
  <class name="TPenRecall" file="Vcl.Graphics.pas" line="668">
    <ancestor name="TRecall" namespace="System.Classes">
      <methodref name="Create" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="Destroy" visibility="public" procflags="destructor override">
      </methodref>
      <methodref name="Store" visibility="public">
      </methodref>
      <methodref name="Forget" visibility="public">
      </methodref>
      <propertyref name="Reference" visibility="public">
      </propertyref>
      <ancestor name="TObject" namespace="System">
        <methodref name="Create" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="Free" visibility="public">
        </methodref>
        <methodref name="DisposeOf" visibility="public" procflags="inline">
        </methodref>
        <methodref name="InitInstance" visibility="public" procflags="class">
        </methodref>
        <methodref name="CleanupInstance" visibility="public">
        </methodref>
        <methodref name="ClassType" visibility="public" procflags="inline">
        </methodref>
        <methodref name="ClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassNameIs" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassParent" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="ClassInfo" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InstanceSize" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InheritsFrom" visibility="public" procflags="class">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodName" visibility="public" procflags="class">
        </methodref>
        <methodref name="QualifiedClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="GetInterface" visibility="public">
        </methodref>
        <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
        </methodref>
        <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="UnitName" visibility="public" procflags="class">
        </methodref>
        <methodref name="UnitScope" visibility="public" procflags="class">
        </methodref>
        <methodref name="Equals" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetHashCode" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="ToString" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="SafeCallException" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="AfterConstruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Dispatch" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="DefaultHandler" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="NewInstance" visibility="public" procflags="class virtual">
        </methodref>
        <methodref name="FreeInstance" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor virtual">
        </methodref>
        <methodref name="GetDisposed" visibility="protected" procflags="inline">
        </methodref>
        <methodref name="CheckDisposed" visibility="protected" procflags="inline">
        </methodref>
        <propertyref name="Disposed" visibility="protected">
        </propertyref>
      </ancestor>
    </ancestor>
    <members>
      <constructor name="Create" visibility="public" file="Vcl.Graphics.pas" line="670">
        <parameters>
          <parameter name="APen" type="TPen"/>
        </parameters>
      </constructor>
    </members>
  </class>
  <class name="TBrushRecall" file="Vcl.Graphics.pas" line="673">
    <ancestor name="TRecall" namespace="System.Classes">
      <methodref name="Create" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="Destroy" visibility="public" procflags="destructor override">
      </methodref>
      <methodref name="Store" visibility="public">
      </methodref>
      <methodref name="Forget" visibility="public">
      </methodref>
      <propertyref name="Reference" visibility="public">
      </propertyref>
      <ancestor name="TObject" namespace="System">
        <methodref name="Create" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="Free" visibility="public">
        </methodref>
        <methodref name="DisposeOf" visibility="public" procflags="inline">
        </methodref>
        <methodref name="InitInstance" visibility="public" procflags="class">
        </methodref>
        <methodref name="CleanupInstance" visibility="public">
        </methodref>
        <methodref name="ClassType" visibility="public" procflags="inline">
        </methodref>
        <methodref name="ClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassNameIs" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassParent" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="ClassInfo" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InstanceSize" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InheritsFrom" visibility="public" procflags="class">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodName" visibility="public" procflags="class">
        </methodref>
        <methodref name="QualifiedClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="GetInterface" visibility="public">
        </methodref>
        <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
        </methodref>
        <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="UnitName" visibility="public" procflags="class">
        </methodref>
        <methodref name="UnitScope" visibility="public" procflags="class">
        </methodref>
        <methodref name="Equals" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetHashCode" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="ToString" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="SafeCallException" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="AfterConstruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Dispatch" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="DefaultHandler" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="NewInstance" visibility="public" procflags="class virtual">
        </methodref>
        <methodref name="FreeInstance" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor virtual">
        </methodref>
        <methodref name="GetDisposed" visibility="protected" procflags="inline">
        </methodref>
        <methodref name="CheckDisposed" visibility="protected" procflags="inline">
        </methodref>
        <propertyref name="Disposed" visibility="protected">
        </propertyref>
      </ancestor>
    </ancestor>
    <members>
      <constructor name="Create" visibility="public" file="Vcl.Graphics.pas" line="675">
        <parameters>
          <parameter name="ABrush" type="TBrush"/>
        </parameters>
      </constructor>
    </members>
  </class>
  <enum name="TFillStyle" file="Vcl.Graphics.pas" line="690">
    <element value="0" name="fsSurface" file="Vcl.Graphics.pas" line="690"/>
    <element value="1" name="fsBorder" file="Vcl.Graphics.pas" line="690"/>
  </enum>
  <enum name="TFillMode" file="Vcl.Graphics.pas" line="691">
    <element value="0" name="fmAlternate" file="Vcl.Graphics.pas" line="691"/>
    <element value="1" name="fmWinding" file="Vcl.Graphics.pas" line="691"/>
  </enum>
  <type name="TCopyMode" type="integer" loBound="-2147483648" hiBound="2147483647" file="System.pas" line="12"/>
  <enum name="TCanvasStates" file="Vcl.Graphics.pas" line="695">
    <element value="0" name="csHandleValid" file="Vcl.Graphics.pas" line="695"/>
    <element value="1" name="csFontValid" file="Vcl.Graphics.pas" line="695"/>
    <element value="2" name="csPenValid" file="Vcl.Graphics.pas" line="695"/>
    <element value="3" name="csBrushValid" file="Vcl.Graphics.pas" line="695"/>
  </enum>
  <set name="TCanvasState" type="TCanvasStates" file="Vcl.Graphics.pas" line="696">
    <element name="csHandleValid"/>
    <element name="csFontValid"/>
    <element name="csPenValid"/>
    <element name="csBrushValid"/>
  </set>
  <enum name="TCanvasOrientation" file="Vcl.Graphics.pas" line="697">
    <element value="0" name="coLeftToRight" file="Vcl.Graphics.pas" line="697"/>
    <element value="1" name="coRightToLeft" file="Vcl.Graphics.pas" line="697"/>
  </enum>
  <enum name="TTextFormats" file="Vcl.Graphics.pas" line="699">
    <element value="0" name="tfBottom" file="Vcl.Graphics.pas" line="699"/>
    <element value="1" name="tfCalcRect" file="Vcl.Graphics.pas" line="699"/>
    <element value="2" name="tfCenter" file="Vcl.Graphics.pas" line="699"/>
    <element value="3" name="tfEditControl" file="Vcl.Graphics.pas" line="699"/>
    <element value="4" name="tfEndEllipsis" file="Vcl.Graphics.pas" line="699"/>
    <element value="5" name="tfPathEllipsis" file="Vcl.Graphics.pas" line="700"/>
    <element value="6" name="tfExpandTabs" file="Vcl.Graphics.pas" line="700"/>
    <element value="7" name="tfExternalLeading" file="Vcl.Graphics.pas" line="700"/>
    <element value="8" name="tfLeft" file="Vcl.Graphics.pas" line="700"/>
    <element value="9" name="tfModifyString" file="Vcl.Graphics.pas" line="700"/>
    <element value="10" name="tfNoClip" file="Vcl.Graphics.pas" line="701"/>
    <element value="11" name="tfNoPrefix" file="Vcl.Graphics.pas" line="701"/>
    <element value="12" name="tfRight" file="Vcl.Graphics.pas" line="701"/>
    <element value="13" name="tfRtlReading" file="Vcl.Graphics.pas" line="701"/>
    <element value="14" name="tfSingleLine" file="Vcl.Graphics.pas" line="701"/>
    <element value="15" name="tfTop" file="Vcl.Graphics.pas" line="701"/>
    <element value="16" name="tfVerticalCenter" file="Vcl.Graphics.pas" line="702"/>
    <element value="17" name="tfWordBreak" file="Vcl.Graphics.pas" line="702"/>
    <element value="18" name="tfHidePrefix" file="Vcl.Graphics.pas" line="702"/>
    <element value="19" name="tfNoFullWidthCharBreak" file="Vcl.Graphics.pas" line="702"/>
    <element value="20" name="tfPrefixOnly" file="Vcl.Graphics.pas" line="703"/>
    <element value="21" name="tfTabStop" file="Vcl.Graphics.pas" line="703"/>
    <element value="22" name="tfWordEllipsis" file="Vcl.Graphics.pas" line="703"/>
    <element value="23" name="tfComposited" file="Vcl.Graphics.pas" line="703"/>
  </enum>
  <set name="TTextFormat" type="TTextFormats" file="Vcl.Graphics.pas" line="704">
    <element name="tfBottom"/>
    <element name="tfCalcRect"/>
    <element name="tfCenter"/>
    <element name="tfEditControl"/>
    <element name="tfEndEllipsis"/>
    <element name="tfPathEllipsis"/>
    <element name="tfExpandTabs"/>
    <element name="tfExternalLeading"/>
    <element name="tfLeft"/>
    <element name="tfModifyString"/>
    <element name="tfNoClip"/>
    <element name="tfNoPrefix"/>
    <element name="tfRight"/>
    <element name="tfRtlReading"/>
    <element name="tfSingleLine"/>
    <element name="tfTop"/>
    <element name="tfVerticalCenter"/>
    <element name="tfWordBreak"/>
    <element name="tfHidePrefix"/>
    <element name="tfNoFullWidthCharBreak"/>
    <element name="tfPrefixOnly"/>
    <element name="tfTabStop"/>
    <element name="tfWordEllipsis"/>
    <element name="tfComposited"/>
  </set>
  <type name="TDrawTextFlags" type="cardinal" loBound="0" hiBound="-1" file="System.pas" line="12"/>
  <struct name="TTextFormatFlags" size="4" file="Vcl.Graphics.pas" line="707">
    <field name="FValue" type="TTextFormat" visibility="private" size="4" offset="0" file="Vcl.Graphics.pas" line="709"/>
    <function name="operator Implicit" visibility="public" procflags="class noself operator overload" file="Vcl.Graphics.pas" line="711" generated="true">
      <parameters>
        <parameter name="Value" type="TTextFormat"/>
        <retval type="TTextFormatFlags"/>
      </parameters>
    </function>
    <function name="operator Implicit" visibility="public" procflags="class noself operator overload" file="Vcl.Graphics.pas" line="712" generated="true">
      <parameters>
        <parameter name="Value" type="TTextFormatFlags"/>
        <retval type="TTextFormat"/>
      </parameters>
    </function>
    <function name="operator Implicit" visibility="public" procflags="class noself operator overload" file="Vcl.Graphics.pas" line="713" generated="true">
      <parameters>
        <parameter name="Value" type="Cardinal"/>
        <retval type="TTextFormatFlags"/>
      </parameters>
    </function>
    <function name="operator Implicit" visibility="public" procflags="class noself operator overload" file="Vcl.Graphics.pas" line="714" generated="true">
      <parameters>
        <parameter name="Value" type="TTextFormatFlags"/>
        <retval type="Cardinal"/>
      </parameters>
    </function>
  </struct>
  <class name="TCustomCanvas" file="Vcl.Graphics.pas" line="717">
    <ancestor name="TPersistent" namespace="System.Classes">
      <methodref name="AssignError" visibility="private">
      </methodref>
      <methodref name="AssignTo" visibility="protected" procflags="virtual">
      </methodref>
      <methodref name="DefineProperties" visibility="protected" procflags="virtual">
      </methodref>
      <methodref name="GetOwner" visibility="protected" procflags="dynamic">
      </methodref>
      <methodref name="Destroy" visibility="public" procflags="destructor override">
      </methodref>
      <methodref name="Assign" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="GetNamePath" visibility="public" procflags="dynamic">
      </methodref>
      <ancestor name="TObject" namespace="System">
        <methodref name="Create" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="Free" visibility="public">
        </methodref>
        <methodref name="DisposeOf" visibility="public" procflags="inline">
        </methodref>
        <methodref name="InitInstance" visibility="public" procflags="class">
        </methodref>
        <methodref name="CleanupInstance" visibility="public">
        </methodref>
        <methodref name="ClassType" visibility="public" procflags="inline">
        </methodref>
        <methodref name="ClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassNameIs" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassParent" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="ClassInfo" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InstanceSize" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InheritsFrom" visibility="public" procflags="class">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodName" visibility="public" procflags="class">
        </methodref>
        <methodref name="QualifiedClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="GetInterface" visibility="public">
        </methodref>
        <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
        </methodref>
        <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="UnitName" visibility="public" procflags="class">
        </methodref>
        <methodref name="UnitScope" visibility="public" procflags="class">
        </methodref>
        <methodref name="Equals" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetHashCode" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="ToString" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="SafeCallException" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="AfterConstruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Dispatch" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="DefaultHandler" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="NewInstance" visibility="public" procflags="class virtual">
        </methodref>
        <methodref name="FreeInstance" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor virtual">
        </methodref>
        <methodref name="GetDisposed" visibility="protected" procflags="inline">
        </methodref>
        <methodref name="CheckDisposed" visibility="protected" procflags="inline">
        </methodref>
        <propertyref name="Disposed" visibility="protected">
        </propertyref>
      </ancestor>
    </ancestor>
    <members>
      <field name="FOnChange" type="TNotifyEvent" visibility="private" size="8" offset="8" file="Vcl.Graphics.pas" line="719"/>
      <field name="FOnChanging" type="TNotifyEvent" visibility="private" size="8" offset="16" file="Vcl.Graphics.pas" line="720"/>
      <field name="FTextFlags" type="Integer" visibility="private" size="4" offset="24" file="Vcl.Graphics.pas" line="721"/>
      <field name="FLock" type="_RTL_CRITICAL_SECTION" visibility="private" size="24" offset="28" file="Vcl.Graphics.pas" line="723"/>
      <field name="FLockCount" type="Integer" visibility="private" size="4" offset="52" file="Vcl.Graphics.pas" line="724"/>
      <function name="GetCanvasOrientation" visibility="protected" procflags="abstract virtual" file="Vcl.Graphics.pas" line="727">
        <parameters>
          <retval type="TCanvasOrientation"/>
        </parameters>
      </function>
      <function name="GetClipRect" visibility="protected" procflags="abstract virtual" file="Vcl.Graphics.pas" line="728">
        <parameters>
          <retval type="TRect"/>
        </parameters>
      </function>
      <function name="GetPenPos" visibility="protected" procflags="abstract virtual" file="Vcl.Graphics.pas" line="729">
        <parameters>
          <retval type="TPoint"/>
        </parameters>
      </function>
      <function name="GetPixel" visibility="protected" procflags="abstract virtual" file="Vcl.Graphics.pas" line="730">
        <parameters>
          <parameter name="X" type="Integer"/>
          <parameter name="Y" type="Integer"/>
          <retval type="TColor"/>
        </parameters>
      </function>
      <procedure name="SetPenPos" visibility="protected" procflags="abstract virtual" file="Vcl.Graphics.pas" line="731">
        <parameters>
          <parameter name="Value" type="TPoint"/>
        </parameters>
      </procedure>
      <procedure name="SetPixel" visibility="protected" procflags="abstract virtual" file="Vcl.Graphics.pas" line="732">
        <parameters>
          <parameter name="X" type="Integer"/>
          <parameter name="Y" type="Integer"/>
          <parameter name="Value" type="TColor"/>
        </parameters>
      </procedure>
      <procedure name="Changed" visibility="protected" procflags="virtual" file="Vcl.Graphics.pas" line="733">
      </procedure>
      <procedure name="Changing" visibility="protected" procflags="virtual" file="Vcl.Graphics.pas" line="734">
      </procedure>
      <procedure name="RequiredState" visibility="protected" procflags="abstract virtual" file="Vcl.Graphics.pas" line="735">
        <parameters>
          <parameter name="ReqState" type="TCanvasState"/>
        </parameters>
      </procedure>
      <procedure name="Arc" visibility="public" procflags="abstract virtual" file="Vcl.Graphics.pas" line="737">
        <parameters>
          <parameter name="X1" type="Integer"/>
          <parameter name="Y1" type="Integer"/>
          <parameter name="X2" type="Integer"/>
          <parameter name="Y2" type="Integer"/>
          <parameter name="X3" type="Integer"/>
          <parameter name="Y3" type="Integer"/>
          <parameter name="X4" type="Integer"/>
          <parameter name="Y4" type="Integer"/>
        </parameters>
      </procedure>
      <procedure name="ArcTo" visibility="public" procflags="abstract virtual" file="Vcl.Graphics.pas" line="738">
        <parameters>
          <parameter name="X1" type="Integer"/>
          <parameter name="Y1" type="Integer"/>
          <parameter name="X2" type="Integer"/>
          <parameter name="Y2" type="Integer"/>
          <parameter name="X3" type="Integer"/>
          <parameter name="Y3" type="Integer"/>
          <parameter name="X4" type="Integer"/>
          <parameter name="Y4" type="Integer"/>
        </parameters>
      </procedure>
      <procedure name="AngleArc" visibility="public" procflags="abstract virtual" file="Vcl.Graphics.pas" line="739">
        <parameters>
          <parameter name="X" type="Integer"/>
          <parameter name="Y" type="Integer"/>
          <parameter name="Radius" type="Cardinal"/>
          <parameter name="StartAngle" type="Single"/>
          <parameter name="SweepAngle" type="Single"/>
        </parameters>
      </procedure>
      <procedure name="BrushCopy" visibility="public" procflags="abstract virtual" file="Vcl.Graphics.pas" line="740">
        <parameters>
          <parameter name="Dest" type="TRect" paramflags="const"/>
          <parameter name="Bitmap" type="TBitmap"/>
          <parameter name="Source" type="TRect" paramflags="const"/>
          <parameter name="Color" type="TColor"/>
        </parameters>
      </procedure>
      <procedure name="Chord" visibility="public" procflags="abstract virtual" file="Vcl.Graphics.pas" line="742">
        <parameters>
          <parameter name="X1" type="Integer"/>
          <parameter name="Y1" type="Integer"/>
          <parameter name="X2" type="Integer"/>
          <parameter name="Y2" type="Integer"/>
          <parameter name="X3" type="Integer"/>
          <parameter name="Y3" type="Integer"/>
          <parameter name="X4" type="Integer"/>
          <parameter name="Y4" type="Integer"/>
        </parameters>
      </procedure>
      <procedure name="Draw" visibility="public" procflags="abstract overload virtual" file="Vcl.Graphics.pas" line="743">
        <parameters>
          <parameter name="X" type="Integer"/>
          <parameter name="Y" type="Integer"/>
          <parameter name="Graphic" type="TGraphic"/>
        </parameters>
      </procedure>
      <procedure name="Draw" visibility="public" procflags="abstract overload virtual" file="Vcl.Graphics.pas" line="744">
        <parameters>
          <parameter name="X" type="Integer"/>
          <parameter name="Y" type="Integer"/>
          <parameter name="Graphic" type="TGraphic"/>
          <parameter name="Opacity" type="Byte"/>
        </parameters>
      </procedure>
      <procedure name="DrawFocusRect" visibility="public" procflags="abstract virtual" file="Vcl.Graphics.pas" line="745">
        <parameters>
          <parameter name="Rect" type="TRect" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="Ellipse" visibility="public" procflags="abstract overload virtual" file="Vcl.Graphics.pas" line="746">
        <parameters>
          <parameter name="X1" type="Integer"/>
          <parameter name="Y1" type="Integer"/>
          <parameter name="X2" type="Integer"/>
          <parameter name="Y2" type="Integer"/>
        </parameters>
      </procedure>
      <procedure name="Ellipse" visibility="public" procflags="overload" file="Vcl.Graphics.pas" line="747">
        <parameters>
          <parameter name="Rect" type="TRect" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="FillRect" visibility="public" procflags="abstract virtual" file="Vcl.Graphics.pas" line="748">
        <parameters>
          <parameter name="Rect" type="TRect" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="FloodFill" visibility="public" procflags="abstract virtual" file="Vcl.Graphics.pas" line="749">
        <parameters>
          <parameter name="X" type="Integer"/>
          <parameter name="Y" type="Integer"/>
          <parameter name="Color" type="TColor"/>
          <parameter name="FillStyle" type="TFillStyle"/>
        </parameters>
      </procedure>
      <procedure name="FrameRect" visibility="public" procflags="abstract virtual" file="Vcl.Graphics.pas" line="750">
        <parameters>
          <parameter name="Rect" type="TRect" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="LineTo" visibility="public" procflags="abstract virtual" file="Vcl.Graphics.pas" line="751">
        <parameters>
          <parameter name="X" type="Integer"/>
          <parameter name="Y" type="Integer"/>
        </parameters>
      </procedure>
      <procedure name="Lock" visibility="public" file="Vcl.Graphics.pas" line="752">
      </procedure>
      <procedure name="MoveTo" visibility="public" procflags="abstract virtual" file="Vcl.Graphics.pas" line="753">
        <parameters>
          <parameter name="X" type="Integer"/>
          <parameter name="Y" type="Integer"/>
        </parameters>
      </procedure>
      <procedure name="Pie" visibility="public" procflags="abstract virtual" file="Vcl.Graphics.pas" line="754">
        <parameters>
          <parameter name="X1" type="Integer"/>
          <parameter name="Y1" type="Integer"/>
          <parameter name="X2" type="Integer"/>
          <parameter name="Y2" type="Integer"/>
          <parameter name="X3" type="Integer"/>
          <parameter name="Y3" type="Integer"/>
          <parameter name="X4" type="Integer"/>
          <parameter name="Y4" type="Integer"/>
        </parameters>
      </procedure>
      <procedure name="Polygon" visibility="public" procflags="abstract virtual" file="Vcl.Graphics.pas" line="755">
        <parameters>
          <parameter name="Points" paramflags="const">
            <array name="Points">
              <element type="TPoint"/>
            </array>
          </parameter>
        </parameters>
      </procedure>
      <procedure name="Polyline" visibility="public" procflags="abstract virtual" file="Vcl.Graphics.pas" line="756">
        <parameters>
          <parameter name="Points" paramflags="const">
            <array name="Points">
              <element type="TPoint"/>
            </array>
          </parameter>
        </parameters>
      </procedure>
      <procedure name="PolyBezier" visibility="public" procflags="abstract virtual" file="Vcl.Graphics.pas" line="757">
        <parameters>
          <parameter name="Points" paramflags="const">
            <array name="Points">
              <element type="TPoint"/>
            </array>
          </parameter>
        </parameters>
      </procedure>
      <procedure name="PolyBezierTo" visibility="public" procflags="abstract virtual" file="Vcl.Graphics.pas" line="758">
        <parameters>
          <parameter name="Points" paramflags="const">
            <array name="Points">
              <element type="TPoint"/>
            </array>
          </parameter>
        </parameters>
      </procedure>
      <procedure name="Rectangle" visibility="public" procflags="abstract overload virtual" file="Vcl.Graphics.pas" line="759">
        <parameters>
          <parameter name="X1" type="Integer"/>
          <parameter name="Y1" type="Integer"/>
          <parameter name="X2" type="Integer"/>
          <parameter name="Y2" type="Integer"/>
        </parameters>
      </procedure>
      <procedure name="Rectangle" visibility="public" procflags="overload" file="Vcl.Graphics.pas" line="760">
        <parameters>
          <parameter name="Rect" type="TRect" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="Refresh" visibility="public" procflags="abstract virtual" file="Vcl.Graphics.pas" line="761">
      </procedure>
      <procedure name="RoundRect" visibility="public" procflags="abstract overload virtual" file="Vcl.Graphics.pas" line="762">
        <parameters>
          <parameter name="X1" type="Integer"/>
          <parameter name="Y1" type="Integer"/>
          <parameter name="X2" type="Integer"/>
          <parameter name="Y2" type="Integer"/>
          <parameter name="X3" type="Integer"/>
          <parameter name="Y3" type="Integer"/>
        </parameters>
      </procedure>
      <procedure name="RoundRect" visibility="public" procflags="overload" file="Vcl.Graphics.pas" line="763">
        <parameters>
          <parameter name="Rect" type="TRect" paramflags="const"/>
          <parameter name="CX" type="Integer"/>
          <parameter name="CY" type="Integer"/>
        </parameters>
      </procedure>
      <procedure name="StretchDraw" visibility="public" procflags="abstract virtual" file="Vcl.Graphics.pas" line="764">
        <parameters>
          <parameter name="Rect" type="TRect" paramflags="const"/>
          <parameter name="Graphic" type="TGraphic"/>
        </parameters>
      </procedure>
      <function name="TextExtent" visibility="public" procflags="abstract virtual" file="Vcl.Graphics.pas" line="765">
        <parameters>
          <parameter name="Text" type="string" paramflags="const"/>
          <retval type="TSize"/>
        </parameters>
      </function>
      <function name="TextHeight" visibility="public" file="Vcl.Graphics.pas" line="766">
        <parameters>
          <parameter name="Text" type="string" paramflags="const"/>
          <retval type="Integer"/>
        </parameters>
      </function>
      <procedure name="TextOut" visibility="public" procflags="abstract virtual" file="Vcl.Graphics.pas" line="767">
        <parameters>
          <parameter name="X" type="Integer"/>
          <parameter name="Y" type="Integer"/>
          <parameter name="Text" type="string" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="TextRect" visibility="public" procflags="abstract overload virtual" file="Vcl.Graphics.pas" line="768">
        <parameters>
          <parameter name="Rect" type="TRect" paramflags="var"/>
          <parameter name="Text" type="string" paramflags="var"/>
          <parameter name="TextFormat" type="TTextFormat">
            <value>
              []
            </value>
          </parameter>
        </parameters>
      </procedure>
      <procedure name="TextRect" visibility="public" procflags="abstract overload virtual" file="Vcl.Graphics.pas" line="769">
        <parameters>
          <parameter name="Rect" type="TRect"/>
          <parameter name="X" type="Integer"/>
          <parameter name="Y" type="Integer"/>
          <parameter name="Text" type="string" paramflags="const"/>
        </parameters>
      </procedure>
      <function name="TextWidth" visibility="public" file="Vcl.Graphics.pas" line="770">
        <parameters>
          <parameter name="Text" type="string" paramflags="const"/>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="TryLock" visibility="public" file="Vcl.Graphics.pas" line="771">
        <parameters>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <procedure name="Unlock" visibility="public" file="Vcl.Graphics.pas" line="772">
      </procedure>
      <property name="ClipRect" visibility="public" read="GetClipRect" type="TRect" file="Vcl.Graphics.pas" line="773"/>
      <property name="LockCount" visibility="public" read="FLockCount" type="Integer" file="Vcl.Graphics.pas" line="775"/>
      <property name="CanvasOrientation" visibility="public" read="GetCanvasOrientation" type="TCanvasOrientation" file="Vcl.Graphics.pas" line="777"/>
      <property name="PenPos" visibility="public" read="GetPenPos" write="SetPenPos" type="TPoint" file="Vcl.Graphics.pas" line="778"/>
      <property name="Pixels[X][Y]" visibility="public" read="GetPixel" write="SetPixel" type="TColor" file="Vcl.Graphics.pas" line="779"/>
      <property name="TextFlags" visibility="public" read="FTextFlags" write="FTextFlags" type="Integer" file="Vcl.Graphics.pas" line="780"/>
      <event name="OnChange" visibility="public" read="FOnChange" write="FOnChange" type="TNotifyEvent" file="Vcl.Graphics.pas" line="781"/>
      <event name="OnChanging" visibility="public" read="FOnChanging" write="FOnChanging" type="TNotifyEvent" file="Vcl.Graphics.pas" line="782"/>
    </members>
  </class>
  <class name="TCanvas" file="Vcl.Graphics.pas" line="785">
    <ancestor name="TCustomCanvas" namespace="Vcl.Graphics">
      <methodref name="GetCanvasOrientation" visibility="protected" procflags="abstract virtual"/>
      <methodref name="GetClipRect" visibility="protected" procflags="abstract virtual"/>
      <methodref name="GetPenPos" visibility="protected" procflags="abstract virtual"/>
      <methodref name="GetPixel" visibility="protected" procflags="abstract virtual"/>
      <methodref name="SetPenPos" visibility="protected" procflags="abstract virtual"/>
      <methodref name="SetPixel" visibility="protected" procflags="abstract virtual"/>
      <methodref name="Changed" visibility="protected" procflags="virtual"/>
      <methodref name="Changing" visibility="protected" procflags="virtual"/>
      <methodref name="RequiredState" visibility="protected" procflags="abstract virtual"/>
      <methodref name="Arc" visibility="public" procflags="abstract virtual"/>
      <methodref name="ArcTo" visibility="public" procflags="abstract virtual"/>
      <methodref name="AngleArc" visibility="public" procflags="abstract virtual"/>
      <methodref name="BrushCopy" visibility="public" procflags="abstract virtual"/>
      <methodref name="Chord" visibility="public" procflags="abstract virtual"/>
      <methodref name="Draw" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="Draw" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="DrawFocusRect" visibility="public" procflags="abstract virtual"/>
      <methodref name="Ellipse" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="Ellipse" visibility="public" procflags="overload"/>
      <methodref name="FillRect" visibility="public" procflags="abstract virtual"/>
      <methodref name="FloodFill" visibility="public" procflags="abstract virtual"/>
      <methodref name="FrameRect" visibility="public" procflags="abstract virtual"/>
      <methodref name="LineTo" visibility="public" procflags="abstract virtual"/>
      <methodref name="Lock" visibility="public"/>
      <methodref name="MoveTo" visibility="public" procflags="abstract virtual"/>
      <methodref name="Pie" visibility="public" procflags="abstract virtual"/>
      <methodref name="Polygon" visibility="public" procflags="abstract virtual"/>
      <methodref name="Polyline" visibility="public" procflags="abstract virtual"/>
      <methodref name="PolyBezier" visibility="public" procflags="abstract virtual"/>
      <methodref name="PolyBezierTo" visibility="public" procflags="abstract virtual"/>
      <methodref name="Rectangle" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="Rectangle" visibility="public" procflags="overload"/>
      <methodref name="Refresh" visibility="public" procflags="abstract virtual"/>
      <methodref name="RoundRect" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="RoundRect" visibility="public" procflags="overload"/>
      <methodref name="StretchDraw" visibility="public" procflags="abstract virtual"/>
      <methodref name="TextExtent" visibility="public" procflags="abstract virtual"/>
      <methodref name="TextHeight" visibility="public"/>
      <methodref name="TextOut" visibility="public" procflags="abstract virtual"/>
      <methodref name="TextRect" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="TextRect" visibility="public" procflags="abstract overload virtual"/>
      <methodref name="TextWidth" visibility="public"/>
      <methodref name="TryLock" visibility="public"/>
      <methodref name="Unlock" visibility="public"/>
      <propertyref name="ClipRect" visibility="public"/>
      <propertyref name="LockCount" visibility="public"/>
      <propertyref name="CanvasOrientation" visibility="public"/>
      <propertyref name="PenPos" visibility="public"/>
      <propertyref name="Pixels" visibility="public"/>
      <propertyref name="TextFlags" visibility="public"/>
      <eventref name="OnChange" visibility="public"/>
      <eventref name="OnChanging" visibility="public"/>
      <ancestor name="TPersistent" namespace="System.Classes">
        <methodref name="AssignError" visibility="private">
        </methodref>
        <methodref name="AssignTo" visibility="protected" procflags="virtual">
        </methodref>
        <methodref name="DefineProperties" visibility="protected" procflags="virtual">
        </methodref>
        <methodref name="GetOwner" visibility="protected" procflags="dynamic">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor override">
        </methodref>
        <methodref name="Assign" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetNamePath" visibility="public" procflags="dynamic">
        </methodref>
        <ancestor name="TObject" namespace="System">
          <methodref name="Create" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="Free" visibility="public">
          </methodref>
          <methodref name="DisposeOf" visibility="public" procflags="inline">
          </methodref>
          <methodref name="InitInstance" visibility="public" procflags="class">
          </methodref>
          <methodref name="CleanupInstance" visibility="public">
          </methodref>
          <methodref name="ClassType" visibility="public" procflags="inline">
          </methodref>
          <methodref name="ClassName" visibility="public" procflags="class">
          </methodref>
          <methodref name="ClassNameIs" visibility="public" procflags="class">
          </methodref>
          <methodref name="ClassParent" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="ClassInfo" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="InstanceSize" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="InheritsFrom" visibility="public" procflags="class">
          </methodref>
          <methodref name="MethodAddress" visibility="public" procflags="class overload">
          </methodref>
          <methodref name="MethodAddress" visibility="public" procflags="class overload">
          </methodref>
          <methodref name="MethodName" visibility="public" procflags="class">
          </methodref>
          <methodref name="QualifiedClassName" visibility="public" procflags="class">
          </methodref>
          <methodref name="FieldAddress" visibility="public" procflags="overload">
          </methodref>
          <methodref name="FieldAddress" visibility="public" procflags="overload">
          </methodref>
          <methodref name="GetInterface" visibility="public">
          </methodref>
          <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
          </methodref>
          <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="UnitName" visibility="public" procflags="class">
          </methodref>
          <methodref name="UnitScope" visibility="public" procflags="class">
          </methodref>
          <methodref name="Equals" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="GetHashCode" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="ToString" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="SafeCallException" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="AfterConstruction" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="Dispatch" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="DefaultHandler" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="NewInstance" visibility="public" procflags="class virtual">
          </methodref>
          <methodref name="FreeInstance" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="Destroy" visibility="public" procflags="destructor virtual">
          </methodref>
          <methodref name="GetDisposed" visibility="protected" procflags="inline">
          </methodref>
          <methodref name="CheckDisposed" visibility="protected" procflags="inline">
          </methodref>
          <propertyref name="Disposed" visibility="protected">
          </propertyref>
        </ancestor>
      </ancestor>
    </ancestor>
    <members>
      <field name="FHandle" type="HDC" visibility="private" size="4" offset="56" file="Vcl.Graphics.pas" line="787"/>
      <field name="State" type="TCanvasState" visibility="private" size="1" offset="60" file="Vcl.Graphics.pas" line="788"/>
      <field name="FFont" type="TFont" visibility="private" size="4" offset="64" file="Vcl.Graphics.pas" line="789"/>
      <field name="FPen" type="TPen" visibility="private" size="4" offset="68" file="Vcl.Graphics.pas" line="790"/>
      <field name="FBrush" type="TBrush" visibility="private" size="4" offset="72" file="Vcl.Graphics.pas" line="791"/>
      <field name="FPenPos" type="TPoint" visibility="private" size="8" offset="76" file="Vcl.Graphics.pas" line="792"/>
      <field name="FCopyMode" type="Integer" visibility="private" size="4" offset="84" file="Vcl.Graphics.pas" line="793"/>
      <procedure name="CreateBrush" visibility="private" file="Vcl.Graphics.pas" line="794">
      </procedure>
      <procedure name="CreateFont" visibility="private" file="Vcl.Graphics.pas" line="795">
      </procedure>
      <procedure name="CreatePen" visibility="private" file="Vcl.Graphics.pas" line="796">
      </procedure>
      <procedure name="BrushChanged" visibility="private" file="Vcl.Graphics.pas" line="797">
        <parameters>
          <parameter name="ABrush" type="TObject"/>
        </parameters>
      </procedure>
      <procedure name="DeselectHandles" visibility="private" file="Vcl.Graphics.pas" line="798">
      </procedure>
      <procedure name="FontChanged" visibility="private" file="Vcl.Graphics.pas" line="799">
        <parameters>
          <parameter name="AFont" type="TObject"/>
        </parameters>
      </procedure>
      <procedure name="PenChanged" visibility="private" file="Vcl.Graphics.pas" line="800">
        <parameters>
          <parameter name="APen" type="TObject"/>
        </parameters>
      </procedure>
      <function name="GetCanvasOrientation" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="802">
        <parameters>
          <retval type="TCanvasOrientation"/>
        </parameters>
      <devnotes><summary>
Represents the getter method for the CanvasOrientation property.
GetCanvasOrientation is called each time the value of the CanvasOrientation is read. 
</summary></devnotes></function>
      <function name="GetClipRect" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="803">
        <parameters>
          <retval type="TRect"/>
        </parameters>
      <devnotes><summary>
Represents the getter method for the ClipRect property.
GetClipRect is called each time the value of ClipRect is read. 
</summary></devnotes></function>
      <function name="GetPenPos" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="804">
        <parameters>
          <retval type="TPoint"/>
        </parameters>
      <devnotes><summary>
Represents the getter method for the PenPos property.
GetPenPos is called each time the value of PenPos is read. 
</summary></devnotes></function>
      <function name="GetPixel" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="805">
        <parameters>
          <parameter name="X" type="Integer"/>
          <parameter name="Y" type="Integer"/>
          <retval type="TColor"/>
        </parameters>
      <devnotes><summary>
Represents the getter method for the Pixels property.
GetPixel is called each time the color of a pixel in the Pixels property is read. 
</summary></devnotes></function>
      <function name="GetHandle" visibility="protected" file="Vcl.Graphics.pas" line="806">
        <parameters>
          <retval type="HDC"/>
        </parameters>
      <devnotes><summary>
Represents the getter method for the Handle property.
GetHandle is called each time the value of the Handle property is read. GetHandle uses the RequiredState method to make sure that the canvas has a valid handle allocated. 
</summary></devnotes></function>
      <procedure name="SetBrush" visibility="protected" file="Vcl.Graphics.pas" line="807">
        <parameters>
          <parameter name="Value" type="TBrush"/>
        </parameters>
      <devnotes><summary>
Represents the setter method for the Brush property.
SetBrush is called each time the value of the Brush property is changed. 
</summary></devnotes></procedure>
      <procedure name="SetFont" visibility="protected" file="Vcl.Graphics.pas" line="808">
        <parameters>
          <parameter name="Value" type="TFont"/>
        </parameters>
      <devnotes><summary>
Represents the setter method for the Font property.
SetFont is called each time the value of the Font property is changed. 
</summary></devnotes></procedure>
      <procedure name="SetHandle" visibility="protected" file="Vcl.Graphics.pas" line="809">
        <parameters>
          <parameter name="Value" type="HDC"/>
        </parameters>
      <devnotes><summary>
Represents the setter method for the Handle property.
SetHandle is called each time the value of the Handle property is changed. SetHandle makes sure to deallocate all associated graphical objects before changing the handle. 
</summary></devnotes></procedure>
      <procedure name="SetPen" visibility="protected" file="Vcl.Graphics.pas" line="810">
        <parameters>
          <parameter name="Value" type="TPen"/>
        </parameters>
      <devnotes><summary>
Represents the setter method for the Pen property.
SetPen is called each time the value of the Pen property is changed. 
</summary></devnotes></procedure>
      <procedure name="SetPenPos" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="811">
        <parameters>
          <parameter name="Value" type="TPoint"/>
        </parameters>
      <devnotes><summary>
Represents the setter method for the PenPos property.
SetPenPos is called each time the value of the PenPos property is changed. 
</summary></devnotes></procedure>
      <procedure name="SetPixel" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="812">
        <parameters>
          <parameter name="X" type="Integer"/>
          <parameter name="Y" type="Integer"/>
          <parameter name="Value" type="TColor"/>
        </parameters>
      <devnotes><summary>
Represents the setter method for the Pixels property.
SetPixel is called each time the color of a pixel in the Pixels property is changed. 
</summary></devnotes></procedure>
      <procedure name="CreateHandle" visibility="protected" procflags="virtual" file="Vcl.Graphics.pas" line="813">
      <devnotes><summary>
Allocates a new handle for the canvas.
CreateHandle is called automatically by the canvas when a handle is required. In TCanvas, CreateHandle simply returns without allocating a handle. CreateHandle is supposed to be overridden in descending classes, which, in certain conditions, allocate handles. 
For example, TControlCanvas returns the HDC (Windows Device Context handle) for the control the canvas is associated to. 
</summary></devnotes></procedure>
      <procedure name="RequiredState" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="814">
        <parameters>
          <parameter name="ReqState" type="TCanvasState"/>
        </parameters>
      <devnotes><summary>
Changes the current state of the canvas to meet the given requirements.
RequiredState ensures that a canvas meets a set of given requirements. If the requirements are not met, the canvas initializes its internal structures so that the requirements are met after the call to RequiredState is completed. 
RequiredState verifies that the Pen, Brush and Font objects are created and initialized. RequiredState also makes sure that the canvas has a handle allocated. 
</summary></devnotes></procedure>
      <constructor name="Create" visibility="public" file="Vcl.Graphics.pas" line="816">
        <parameters>
        </parameters>
      <devnotes><summary>
Creates an instance of TCanvas.
Call Create to instantiate a TCanvas object at runtime. Create allocates memory for the instance of TCanvas and creates the TFont, TBrush and TPen objects for the Font, Brush, and Pen properties. Create also initializes the CopyMode to cmSrcCopy.
</summary></devnotes></constructor>
      <destructor name="Destroy" visibility="public" file="Vcl.Graphics.pas" line="817">
        <parameters>
        </parameters>
      <devnotes><summary>
Destroys an instance of TCanvas.
Do not call Destroy directly in an application. Instead, call Free. Free verifies that the TCanvas object is not nil and only then calls Destroy.
</summary></devnotes></destructor>
      <procedure name="Arc" visibility="public" procflags="override" file="Vcl.Graphics.pas" line="818">
        <parameters>
          <parameter name="X1" type="Integer"/>
          <parameter name="Y1" type="Integer"/>
          <parameter name="X2" type="Integer"/>
          <parameter name="Y2" type="Integer"/>
          <parameter name="X3" type="Integer"/>
          <parameter name="Y3" type="Integer"/>
          <parameter name="X4" type="Integer"/>
          <parameter name="Y4" type="Integer"/>
        </parameters>
      <devnotes><summary>
Draws an arc on the image along the perimeter of the ellipse bounded by the specified rectangle. 
Use Arc to draw an elliptically curved line with the current Pen. The arc traverses the perimeter of an ellipse that is bounded by the points (X1,Y1) and (X2,Y2). The arc is drawn following the perimeter of the ellipse, counterclockwise, from the starting point to the ending point. The starting point is defined by the intersection of the ellipse and a line defined by the center of the ellipse and (X3,Y3). The ending point is defined by the intersection of the ellipse and a line defined by the center of the ellipse and (X4, Y4).

Note: On Windows 9x or Windows ME, the sums X1 + X2 and Y1 + Y2 cannot exceed 32768. Also, the sum X1 + X2 + Y1 + Y2 cannot exceed 32768.
On NT or Windows 2000, the drawing direction can be changed to clockwise using the Windows API call SetArcDirection.
</summary></devnotes></procedure>
      <procedure name="ArcTo" visibility="public" procflags="override" file="Vcl.Graphics.pas" line="819">
        <parameters>
          <parameter name="X1" type="Integer"/>
          <parameter name="Y1" type="Integer"/>
          <parameter name="X2" type="Integer"/>
          <parameter name="Y2" type="Integer"/>
          <parameter name="X3" type="Integer"/>
          <parameter name="Y3" type="Integer"/>
          <parameter name="X4" type="Integer"/>
          <parameter name="Y4" type="Integer"/>
        </parameters>
      <devnotes><summary>
Draws an arc on the image along the perimeter of the ellipse bounded by the specified rectangle.
Vcl.Graphics.TCanvas.ArcTo inherits from Vcl.Graphics.TCustomCanvas.ArcTo. All content below this line refers to Vcl.Graphics.TCustomCanvas.ArcTo.
Draws an arc on the image along the perimeter of the ellipse bounded by the specified rectangle.
Override the ArcTo method (or just use Arcto from descendant classes) to implement drawing of an elliptically curved line with the current Pen. The arc traverses the perimeter of an ellipse that is bounded by the points (X1,Y1) and (X2,Y2). The arc is drawn following the perimeter of the ellipse, counterclockwise, from the starting point to the ending point. The starting point is defined by the intersection of the ellipse and a line defined by the center of the ellipse and (X3,Y3). The ending point is defined by the intersection of the ellipse and a line defined by the center of the ellipse and (X4, Y4).
This procedure draws lines by using the current pen and updates the value of PenPos to the value of the last endpoint. 
</summary></devnotes></procedure>
      <procedure name="AngleArc" visibility="public" procflags="override" file="Vcl.Graphics.pas" line="820">
        <parameters>
          <parameter name="X" type="Integer"/>
          <parameter name="Y" type="Integer"/>
          <parameter name="Radius" type="Cardinal"/>
          <parameter name="StartAngle" type="Single"/>
          <parameter name="SweepAngle" type="Single"/>
        </parameters>
      <devnotes><summary>
Draws an arc on the image along the perimeter of the circle defined by the parameters.
The AngleArc method draws a line from the current position to the starting point of the arc and then a counterclockwise circular arc to the arc endpoint.  The arc traverses the perimeter of a circle whose center lies at (X,Y) and whose radius is Radius. The arc is drawn following the perimeter of the circle, counterclockwise, from the StartAngle with a sweep angle of SweepAngle.
If the sweep angle is greater than 360 degrees, the entire circle is drawn and part of the arc is drawn multiple times.
The current position is updated to the arc endpoint.
</summary></devnotes></procedure>
      <procedure name="BrushCopy" visibility="public" procflags="override" file="Vcl.Graphics.pas" line="821">
        <parameters>
          <parameter name="Dest" type="TRect" paramflags="const"/>
          <parameter name="Bitmap" type="TBitmap"/>
          <parameter name="Source" type="TRect" paramflags="const"/>
          <parameter name="Color" type="TColor"/>
        </parameters>
      <devnotes><summary>
Copies a portion of a bitmap onto a rectangle on the canvas, replacing one of the colors of the bitmap with the brush of the canvas.
Use BrushCopy to achieve special effects such as making the copied image partially transparent. BrushCopy is provided mainly for backward compatibility. Use a TImageList instead of BrushCopy.
Dest specifies the rectangular portion of the canvas that will receive the copy of the bitmap. Bitmap specifies the graphic to copy from. Source specifies the rectangular area of Bitmap to copy. Color specifies the color in Bitmap to replace with the Brush of the canvas.
To use BrushCopy to make the copied image partially transparent, specify the color of the surface of the canvas (clBackground for example) as the Color of the Brush property, then call BrushCopy.
</summary></devnotes></procedure>
      <procedure name="Chord" visibility="public" procflags="override" file="Vcl.Graphics.pas" line="823">
        <parameters>
          <parameter name="X1" type="Integer"/>
          <parameter name="Y1" type="Integer"/>
          <parameter name="X2" type="Integer"/>
          <parameter name="Y2" type="Integer"/>
          <parameter name="X3" type="Integer"/>
          <parameter name="Y3" type="Integer"/>
          <parameter name="X4" type="Integer"/>
          <parameter name="Y4" type="Integer"/>
        </parameters>
      <devnotes><summary>
Draws a closed figure represented by the intersection of a line and an ellipse.
Use Chord to create a shape that is defined by an arc and a line that joins the endpoints of the arc. The chord consists of a portion of an ellipse that is bounded by the points (X1,Y1) and (X2,Y2). The ellipse is bisected by a line that runs between the points (X3,Y3) and (X4,Y4). 
The perimeter of the chord runs counter clockwise from (X3, Y3), counterclockwise along the ellipse to (X4,Y4), and straight back to (X3,Y3). If (X3,Y3) and (X4,Y4) are not on the surface of the ellipse, the corresponding corners on the chord are the closest points on the perimeter that intersect the line. The outline of the chord is drawn using the value of Pen, and the shape is filled using the value of Brush.

Note:  On Windows 9x or Windows ME, the sums X1 + X2 and Y1 + Y2 cannot exceed 32768. Also, the sum X1 + X2 + Y1 + Y2 cannot exceed 32768.
On NT, the drawing direction can be changed to clockwise using the Windows API call SetArcDirection.
</summary></devnotes></procedure>
      <procedure name="CopyRect" visibility="public" file="Vcl.Graphics.pas" line="824">
        <parameters>
          <parameter name="Dest" type="TRect" paramflags="const"/>
          <parameter name="Canvas" type="TCanvas"/>
          <parameter name="Source" type="TRect" paramflags="const"/>
        </parameters>
      <devnotes><summary>
Copies part of an image from another canvas into the canvas.
Use CopyRect to transfer part of the image on another canvas to the image of the TCanvas object. Dest specifies the rectangle on the canvas where the source image will be copied. The Canvas parameter specifies the canvas with the source image. Source specifies a rectangle bounding the portion of the source canvas that will be copied.
The portion of the source canvas is copied using the mode specified by CopyMode.
</summary></devnotes></procedure>
      <procedure name="Draw" visibility="public" procflags="overload override" file="Vcl.Graphics.pas" line="826">
        <parameters>
          <parameter name="X" type="Integer"/>
          <parameter name="Y" type="Integer"/>
          <parameter name="Graphic" type="TGraphic"/>
        </parameters>
      <devnotes><summary>
Renders the graphic specified by the Graphic parameter on the canvas at the location given by the coordinates (X, Y).
Call Draw to draw a graphic on the canvas. Draw calls the Draw method of the graphic. The image is rendered into a rectangle determined by the size of the graphic, with the upper left corner at the point (X, Y). 
Graphics can be bitmaps, icons, or metafiles. If the graphic is a TBitmap object, the bitmap is rendered using the value of CopyMode.
</summary></devnotes></procedure>
      <procedure name="Draw" visibility="public" procflags="overload override" file="Vcl.Graphics.pas" line="827">
        <parameters>
          <parameter name="X" type="Integer"/>
          <parameter name="Y" type="Integer"/>
          <parameter name="Graphic" type="TGraphic"/>
          <parameter name="Opacity" type="Byte"/>
        </parameters>
      <devnotes><summary>
Renders the graphic specified by the Graphic parameter on the canvas at the location given by the coordinates (X, Y).
Call Draw to draw a graphic on the canvas. Draw calls the Draw method of the graphic. The image is rendered into a rectangle determined by the size of the graphic, with the upper left corner at the point (X, Y). 
Graphics can be bitmaps, icons, or metafiles. If the graphic is a TBitmap object, the bitmap is rendered using the value of CopyMode.
</summary></devnotes></procedure>
      <procedure name="DrawFocusRect" visibility="public" procflags="override" file="Vcl.Graphics.pas" line="828">
        <parameters>
          <parameter name="Rect" type="TRect" paramflags="const"/>
        </parameters>
      <devnotes><summary>
Draws a rectangle in the style used to indicate that the object inside the rectangle has focus.
Call DrawFocusRect for the perimeter of the image of a control when the control gets or loses input focus. Because DrawFocusRect uses an XOR function, calling it a second time while specifying the same rectangle removes the rectangle from the screen.
The rectangle this function draws cannot be scrolled. To scroll an area containing a rectangle drawn by DrawFocusRect, call DrawFocusRect to remove the rectangle from the screen, scroll the area, and then call DrawFocusRect to draw the rectangle in the new position. 
</summary></devnotes></procedure>
      <procedure name="Ellipse" visibility="public" procflags="overload override" file="Vcl.Graphics.pas" line="829">
        <parameters>
          <parameter name="X1" type="Integer"/>
          <parameter name="Y1" type="Integer"/>
          <parameter name="X2" type="Integer"/>
          <parameter name="Y2" type="Integer"/>
        </parameters>
      <devnotes><summary>
Draws the ellipse defined by a bounding rectangle on the canvas.
Call Ellipse to draw a circle or ellipse on the canvas. Specify the bounding rectangle either by giving:

The top left point at pixel coordinates (X1, Y1) and the bottom right point at (X2, Y2).
A TRect value.If the bounding rectangle is a square, a circle is drawn.The ellipse is outlined using the value of Pen, and filled using the value of Brush.Note:  On Windows 9x or Windows ME, the sums X1 + X2 and Y1 + Y2 cannot exceed 32768. Also, the sum X1 + X2 + Y1 + Y2 cannot exceed 32768.</summary></devnotes></procedure>
      <procedure name="FillRect" visibility="public" procflags="override" file="Vcl.Graphics.pas" line="830">
        <parameters>
          <parameter name="Rect" type="TRect" paramflags="const"/>
        </parameters>
      <devnotes><summary>
Fills the specified rectangle on the canvas using the current brush.
Use FillRect to fill a rectangular region using the current brush. The region is filled including the top and left sides of the rectangle, but excluding the bottom and right edges.
</summary></devnotes></procedure>
      <procedure name="FloodFill" visibility="public" procflags="override" file="Vcl.Graphics.pas" line="831">
        <parameters>
          <parameter name="X" type="Integer"/>
          <parameter name="Y" type="Integer"/>
          <parameter name="Color" type="TColor"/>
          <parameter name="FillStyle" type="TFillStyle"/>
        </parameters>
      <devnotes><summary>
Fills an area of the canvas using the current brush.
Use FloodFill to fill a possibly non-rectangular region of the image with the value of Brush. The boundaries of the region to be filled are determined by moving outward from the point (X,Y) until a color boundary involving the Color parameter is encountered.
X and X are the coordinates on the canvas where filling starts.
Color is the color that defines the boundary of the region to fill. Its interpretation depends on the value of FillStyle.
FillStyle specifies whether the region is defined by all pixels with the same value as Color, or all points with a different value.

Tip:  Use the Pixels property to get the exact value of the color at the point (X,Y) when using a FillStyle of fsSurface. Similarly, when FillStyle is fsBorder, use Pixels to get the exact value of the boundary color if a point on the boundary is known.</summary></devnotes></procedure>
      <procedure name="FrameRect" visibility="public" procflags="override" file="Vcl.Graphics.pas" line="832">
        <parameters>
          <parameter name="Rect" type="TRect" paramflags="const"/>
        </parameters>
      <devnotes><summary>
Draws a rectangle using the Brush of the canvas to draw the border.
Use FrameRect to draw a 1 pixel wide border around a rectangular region. FrameRect does not fill the interior of the rectangle with the Brush pattern.
To draw a boundary using the Pen instead, use the Polygon method.
</summary></devnotes></procedure>
      <function name="HandleAllocated" visibility="public" file="Vcl.Graphics.pas" line="833">
        <parameters>
          <retval type="Boolean"/>
        </parameters>
      <devnotes><summary>
Indicates whether the TCanvas object has acquired a handle to a device context.
Use HandleAllocated to determine whether the Handle property is set to an HDC value. HandleAllocated indicates whether the canvas has acquired a device context. Use HandleAllocated rather than reading the Handle property. When an application reads the Handle property, TCanvas automatically allocates a new device context and returns its handle if the property had not been previously set.
</summary></devnotes></function>
      <procedure name="LineTo" visibility="public" procflags="override" file="Vcl.Graphics.pas" line="834">
        <parameters>
          <parameter name="X" type="Integer"/>
          <parameter name="Y" type="Integer"/>
        </parameters>
      <devnotes><summary>
Draws a line on the canvas from PenPos to the point specified by X and Y, and sets the pen position to (X, Y).
Use LineTo to draw a line from PenPos up to, but not including the point (X,Y). LineTo changes the value of PenPos to (X,Y). 
The line is drawn using Pen.

Note:  If the current Pen does not have a style of psSolid, the line is drawn with a background specified by the current brush. </summary></devnotes></procedure>
      <procedure name="MoveTo" visibility="public" procflags="override" file="Vcl.Graphics.pas" line="835">
        <parameters>
          <parameter name="X" type="Integer"/>
          <parameter name="Y" type="Integer"/>
        </parameters>
      <devnotes><summary>
Changes the current drawing position to the point (X,Y).
Use MoveTo to set the value of PenPos before calling LineTo. Calling MoveTo is equivalent to setting the PenPos property.
</summary></devnotes></procedure>
      <procedure name="Pie" visibility="public" procflags="override" file="Vcl.Graphics.pas" line="836">
        <parameters>
          <parameter name="X1" type="Integer"/>
          <parameter name="Y1" type="Integer"/>
          <parameter name="X2" type="Integer"/>
          <parameter name="Y2" type="Integer"/>
          <parameter name="X3" type="Integer"/>
          <parameter name="Y3" type="Integer"/>
          <parameter name="X4" type="Integer"/>
          <parameter name="Y4" type="Integer"/>
        </parameters>
      <devnotes><summary>
Draws a pie-shaped section of the ellipse bounded by the rectangle (X1, Y1) and (X2, Y2) on the canvas.
Use Pie to draw a pie-shaped wedge on the image. The wedge is defined by the ellipse bounded by the rectangle determined by the points (X1, Y1) and (X2, Y2). The section drawn is determined by two lines radiating from the center of the ellipse through the points (X3, Y3) and (X4, Y4). 
The wedge is outlined using Pen, and filled using Brush.

Note:  On Windows 9x or Windows ME, the sums X1 + X2 and Y1 + Y2 cannot exceed 32768. Also, the sum X1 + X2 + Y1 + Y2 cannot exceed 32768. </summary></devnotes></procedure>
      <procedure name="Polygon" visibility="public" procflags="override" file="Vcl.Graphics.pas" line="837">
        <parameters>
          <parameter name="Points" paramflags="const">
            <array name="Points" file="Vcl.Graphics.pas" line="4028">
              <element type="TPoint"/>
            </array>
          </parameter>
        </parameters>
      <devnotes><summary>
Draws a series of lines on the canvas connecting the points passed in and closing the shape by drawing a line from the last point to the first point.
Use Polygon to draw a closed, many-sided shape on the canvas, using the value of Pen. After drawing the complete shape, Polygon fills the shape using the value of Brush.
The Points parameter is an array of points that give the vertices of the polygon.

Note:  The Points_Size parameter is the index of the last point in the array (one less than the total number of points).
The first point is always connected to the last point.

Note:  In Delphi, you can use the Slice function to pass a portion of an array of points to the Polygon method. For example, to form a polygon using the first ten points from an array of 100 points, use the Slice function as follows:
Canvas.Polygon(Slice(PointArray, 10));

To draw a polygon on the canvas, without filling it, use the Polyline method, specifying the first point a second time at the end.
</summary></devnotes></procedure>
      <procedure name="Polyline" visibility="public" procflags="override" file="Vcl.Graphics.pas" line="838">
        <parameters>
          <parameter name="Points" paramflags="const">
            <array name="Points" file="Vcl.Graphics.pas" line="4040">
              <element type="TPoint"/>
            </array>
          </parameter>
        </parameters>
      <devnotes><summary>
Draws a series of lines on the canvas with the current pen, connecting each of the points passed to it in Points.
Use Polyline to connect a set of points on the canvas. If you specify only two points, Polyline draws a single line. 
The Points parameter is an array of points to be connected.

Note:  The Points_Size parameter is the index of the last point in the array (one less than the total number of points).
Note:  In Delphi, you can use the Slice function to pass a portion of an array of points to the Polyline method. For example, to form a line connecting the first ten points from an array of 100 points, use the Slice function as follows:
Canvas.Polyline(Slice(PointArray, 10));

Calling the MoveTo function with the value of the first point, and then repeatedly calling LineTo with all subsequent points will draw the same image on the canvas. However, unlike LineTo, Polyline does not change the value of PenPos.
</summary></devnotes></procedure>
      <procedure name="PolyBezier" visibility="public" procflags="override" file="Vcl.Graphics.pas" line="839">
        <parameters>
          <parameter name="Points" paramflags="const">
            <array name="Points" file="Vcl.Graphics.pas" line="4052">
              <element type="TPoint"/>
            </array>
          </parameter>
        </parameters>
      <devnotes><summary>
Draws a set of Bezier curves.
Use PolyBezier to draw cubic Bezier curves using the endpoints and control points specified by the Points parameter. The first curve is drawn from the first point to the fourth point, using the second and third points as control points. Each subsequent curve in the sequence needs exactly three more points: the ending point of the previous curve is used as the starting point, the next two points in the sequence are control points, and the third is the ending point.
The Points parameter gives the endpoints to use when generating the Bezier curves.

Note:  The Points_Size parameter is the index of the last point in the array (one less than the total number of points).
This procedure draws lines by using the current pen.

Note:  In Delphi, you can use the Slice function to pass a portion of an array of points to the PolyBezier method. For example, to form a Bezier curve using the first ten points from an array of 100 points, use the Slice function as follows:
Canvas.PolyBezier(Slice(PointArray, 10));

Control points after a[Index+3] are ignored. Nothing happens if there aren't enough control points.
</summary></devnotes></procedure>
      <procedure name="PolyBezierTo" visibility="public" procflags="override" file="Vcl.Graphics.pas" line="840">
        <parameters>
          <parameter name="Points" paramflags="const">
            <array name="Points" file="Vcl.Graphics.pas" line="4064">
              <element type="TPoint"/>
            </array>
          </parameter>
        </parameters>
      <devnotes><summary>
Draws a set of Bezier curves and updates the value of PenPos.
Use PolyBezierTo to draw cubic Bezier curves using the endpoints and control points specified by the Points parameter. The first curve is drawn from the first point to the fourth point, using the second and third points as control points. Each subsequent curve in the sequence needs exactly three more points: the ending point of the previous curve is used as the starting point, the next two points in the sequence are control points, and the third is the ending point.
The Points parameter gives the endpoints to use when generating the Bezier curves.

Note:  The Points_Size parameter is the index of the last point in the array (one less than the total number of points).
This procedure draws lines by using the current pen and updates the value of PenPos to the value of the last endpoint.

Note:  In Delphi, you can use the Slice function to pass a portion of an array of points to the PolyBezierTo method. For example, to form a Bezier curve using the first ten points from an array of 100 points, use the Slice function as follows:
Canvas.PolyBezierTo(Slice(PointArray, 10));
</summary></devnotes></procedure>
      <procedure name="Rectangle" visibility="public" procflags="overload override" file="Vcl.Graphics.pas" line="841">
        <parameters>
          <parameter name="X1" type="Integer"/>
          <parameter name="Y1" type="Integer"/>
          <parameter name="X2" type="Integer"/>
          <parameter name="Y2" type="Integer"/>
        </parameters>
      <devnotes><summary>
Draws a rectangle on the canvas.
Use Rectangle to draw a rectangle using Pen and fill it with Brush. Specify the rectangle's coordinates in one of two ways:
Giving four coordinates that define the upper left corner at the point (X1, Y1) and the lower right corner at the point (X2, Y2).
Using a TRect type.
To fill a rectangular region without drawing the boundary in the current pen, use FillRect. To outline a rectangular region without filling it, use FrameRect or Polygon. To draw a rectangle with rounded corners, use RoundRect.
</summary></devnotes></procedure>
      <procedure name="Refresh" visibility="public" procflags="override" file="Vcl.Graphics.pas" line="842">
      <devnotes><summary>
Deselects the Pen, Brush, and Font from the device context.
Call Refresh to return the HDC used by the canvas to a default state. Refresh does not change the values of the Font, Brush, or Pen properties. Calling any of the drawing methods of the canvas after calling Refresh will reselect the Font, Brush, or Pen into the HDC if it is used by the drawing method.
</summary></devnotes></procedure>
      <procedure name="RoundRect" visibility="public" procflags="overload override" file="Vcl.Graphics.pas" line="843">
        <parameters>
          <parameter name="X1" type="Integer"/>
          <parameter name="Y1" type="Integer"/>
          <parameter name="X2" type="Integer"/>
          <parameter name="Y2" type="Integer"/>
          <parameter name="X3" type="Integer"/>
          <parameter name="Y3" type="Integer"/>
        </parameters>
      <devnotes><summary>
Draws a rectangle with rounded corners on the canvas.
Use RoundRect to draw a rounded rectangle using Pen and fill it with Brush. The rectangle will have edges defined by the points (X1,Y1), (X2,Y1), (X2,Y2), (X1,Y2), but the corners will be shaved to create a rounded appearance. The curve of the rounded corners matches the curvature of an ellipse with width X3 and height Y3. 
To draw an ellipse instead, use Ellipse. To draw a true rectangle, use Rectangle.
</summary></devnotes></procedure>
      <procedure name="StretchDraw" visibility="public" procflags="override" file="Vcl.Graphics.pas" line="844">
        <parameters>
          <parameter name="Rect" type="TRect" paramflags="const"/>
          <parameter name="Graphic" type="TGraphic"/>
        </parameters>
      <devnotes><summary>
Draws the graphic specified by the Graphic parameter in the rectangle specified by the Rect parameter.
Call StretchDraw to draw a graphic on the canvas so that the image fits in the specified rectangle. StretchDraw calls the Draw method of the graphic. The graphic object determines how to fit into the rectangle. This may involve changing magnification and/or aspect ratio.
To render the graphic in its natural size, use the Draw method, instead.
If the graphic is a TBitmap object, the bitmap is rendered using the value of CopyMode.

Note:  If the graphic is an icon, it is not stretched.</summary></devnotes></procedure>
      <function name="TextExtent" visibility="public" procflags="override" file="Vcl.Graphics.pas" line="845">
        <parameters>
          <parameter name="Text" type="string" paramflags="const"/>
          <retval type="TSize"/>
        </parameters>
      <devnotes><summary>
Returns the width and height, in pixels, of a string rendered in the current font.
Use TextExtent to determine the space a string will occupy in the image. Other elements in the image such as lines, boxes, or additional lines of text can be positioned to accommodate the size of the text. TextExtent returns the width and height of the rectangle that bounds the text on the canvas. 
To check only the height, call TextHeight. To check only the width, call TextWidth.
</summary></devnotes></function>
      <procedure name="TextOut" visibility="public" procflags="override" file="Vcl.Graphics.pas" line="846">
        <parameters>
          <parameter name="X" type="Integer"/>
          <parameter name="Y" type="Integer"/>
          <parameter name="Text" type="string" paramflags="const"/>
        </parameters>
      <devnotes><summary>
Writes a string on the canvas, starting at the point (X,Y), and then updates the PenPos to the end of the string.
Use TextOut to write a string onto the canvas. The string will be written using the current value of Font. Use the TextExtent method to determine the space occupied by the text in the image. To write only the text that fits within a clipping rectangle, use TextRect instead.
After a call to TextOut, the PenPos property indicates the point at the top right of the text on the canvas. 
</summary></devnotes></procedure>
      <procedure name="TextRect" visibility="public" procflags="overload override" file="Vcl.Graphics.pas" line="847">
        <parameters>
          <parameter name="Rect" type="TRect" paramflags="var"/>
          <parameter name="Text" type="string" paramflags="var"/>
          <parameter name="TextFormat" type="TTextFormat">
            <value>
              []
            </value>
          </parameter>
        </parameters>
      <devnotes><summary>
Writes a string inside a clipping rectangle.
Use TextRect to write a string within a limited rectangular region. Any portions of the string that fall outside the rectangle passed in the Rect parameter are clipped and don't appear. The upper left corner of the text is placed at the point (X, Y).
</summary></devnotes></procedure>
      <procedure name="TextRect" visibility="public" procflags="overload override" file="Vcl.Graphics.pas" line="848">
        <parameters>
          <parameter name="Rect" type="TRect"/>
          <parameter name="X" type="Integer"/>
          <parameter name="Y" type="Integer"/>
          <parameter name="Text" type="string" paramflags="const"/>
        </parameters>
      <devnotes><summary>
Writes a string inside a clipping rectangle.
Use TextRect to write a string within a limited rectangular region. Any portions of the string that fall outside the rectangle passed in the Rect parameter are clipped and don't appear. The upper left corner of the text is placed at the point (X, Y).
</summary></devnotes></procedure>
      <property name="Handle" visibility="public" read="GetHandle" write="SetHandle" type="HDC" file="Vcl.Graphics.pas" line="849"><devnotes><summary>
Specifies the handle for this canvas.
The Handle property specifies the Windows GDI handle to the device context for this canvas.
Set Handle to the HDC for the device context the canvas must draw into. When a windowed control responds to a Windows paint message, the HDC for drawing is passed in to the PaintWindow method. In other cases, an HDC can be obtained for a window by calling the GetDeviceContext method of a control. Additionally, Windows provides API calls to obtain an HDC for a printer or for a memory image.
Read the Handle property to supplement the drawing services provided by the TCanvas object with API calls that require a handle to a device context. Most of the Windows GDI calls require an HDC.
TCanvas does not own the HDC. Applications must create an HDC and set the Handle property. Applications must release the HDC when the canvas no longer needs it. Setting the Handle property of a canvas that already has a valid HDC will not automatically release the initial HDC. 

Note:  Some descendants of TCanvas, such as TControlCanvas, do own the HDC. Do not set the Handle property for these objects. They fetch and free their own Handle.</summary></devnotes></property>
      <property name="Brush" visibility="published" read="FBrush" write="SetBrush" type="TBrush" file="Vcl.Graphics.pas" line="851"><devnotes><summary>
Determines the color and pattern for filling graphical shapes and backgrounds.
Set the Brush property to specify the color and pattern to use when drawing the background or filling in graphical shapes. The value of Brush is a TBrush object. Set the properties of the TBrush object to specify the color and pattern or bitmap to use when filling in spaces on the canvas.

Note:  Setting the Brush property assigns the specified TBrush object, rather than replacing the current TBrush object.</summary></devnotes></property>
      <property name="CopyMode" visibility="published" read="FCopyMode" write="FCopyMode" type="Integer" default="13369376" file="Vcl.Graphics.pas" line="852"><devnotes><summary>
Specifies how a graphical image is copied onto the canvas.
Set CopyMode to affect the way graphical images are drawn onto the canvas. The CopyMode is used when copying an image from another canvas using the CopyRect method. CopyMode is also used by TBitmap objects when they draw themselves to a canvas.
Use CopyMode to achieve a variety of affects when rendering an image. Achieve special effects like merged images and making parts of a bitmap transparent by combining multiple images with different CopyModes.
</summary></devnotes></property>
      <property name="Font" visibility="published" read="FFont" write="SetFont" type="TFont" file="Vcl.Graphics.pas" line="853"><devnotes><summary>
Specifies the font to use when writing text on the image.
Set Font to specify the font to use for writing text on the image. The value of Font is a T Font object. Set the properties of the T Font object to specify the font face, color, size, style, and any other aspects of the font.
The Canvas.Font property is only guaranteed to equal the Font property if you have an owner-drawn listbox (where you are expected to use the canvas). Even in that case, it is only guaranteed to equal the Font property once the first paint message is underway. If you use a canvas inside an ownerdraw event, everything should work as expected. Using the canvas for a reason outside the scope of its intended usage may give unpredictable results.

Note:  Setting the Font property assigns the specified T Font object, rather than replacing the current T Font object.</summary></devnotes></property>
      <property name="Pen" visibility="published" read="FPen" write="SetPen" type="TPen" file="Vcl.Graphics.pas" line="854"><devnotes><summary>
Specifies the kind of pen the canvas uses for drawing lines and outlining shapes.
Set Pen to specify the pen to use for drawing lines and outlining shapes in the image. The value of Pen is a TPen object. Set the properties of the TPen object to specify the color, style, width, and mode of the pen.

Note:  Setting the Pen property assigns the specified TPen object, rather than replacing the current TPen object.</summary></devnotes></property>
    </members>
  <devnotes><summary>
TCanvas provides an abstract drawing space for objects that must render their own images.
Use TCanvas as a drawing surface for objects that draw an image of themselves. Standard window controls such as edit controls or list boxes do not require a canvas, as they are drawn by the system. 
TCanvas provides properties, events, and methods that assist in creating an image by:

Specifying the type of brush, pen, and font to use.
Drawing and filling a variety of shapes and lines.
Writing text.
Rendering graphic images.
Enabling a response to changes in the current image.
TCanvas has two descendants, TControlCanvas and TMetafileCanvas, which assist in drawing images of controls and in creating metafile images for objects. 
</summary></devnotes></class>
  <class name="TScaledGraphicDrawer" file="Vcl.Graphics.pas" line="857">
    <ancestor name="TPersistent" namespace="System.Classes">
      <methodref name="AssignError" visibility="private">
      </methodref>
      <methodref name="AssignTo" visibility="protected" procflags="virtual">
      </methodref>
      <methodref name="DefineProperties" visibility="protected" procflags="virtual">
      </methodref>
      <methodref name="GetOwner" visibility="protected" procflags="dynamic">
      </methodref>
      <methodref name="Destroy" visibility="public" procflags="destructor override">
      </methodref>
      <methodref name="Assign" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="GetNamePath" visibility="public" procflags="dynamic">
      </methodref>
      <ancestor name="TObject" namespace="System">
        <methodref name="Create" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="Free" visibility="public">
        </methodref>
        <methodref name="DisposeOf" visibility="public" procflags="inline">
        </methodref>
        <methodref name="InitInstance" visibility="public" procflags="class">
        </methodref>
        <methodref name="CleanupInstance" visibility="public">
        </methodref>
        <methodref name="ClassType" visibility="public" procflags="inline">
        </methodref>
        <methodref name="ClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassNameIs" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassParent" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="ClassInfo" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InstanceSize" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InheritsFrom" visibility="public" procflags="class">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodName" visibility="public" procflags="class">
        </methodref>
        <methodref name="QualifiedClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="GetInterface" visibility="public">
        </methodref>
        <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
        </methodref>
        <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="UnitName" visibility="public" procflags="class">
        </methodref>
        <methodref name="UnitScope" visibility="public" procflags="class">
        </methodref>
        <methodref name="Equals" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetHashCode" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="ToString" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="SafeCallException" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="AfterConstruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Dispatch" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="DefaultHandler" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="NewInstance" visibility="public" procflags="class virtual">
        </methodref>
        <methodref name="FreeInstance" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor virtual">
        </methodref>
        <methodref name="GetDisposed" visibility="protected" procflags="inline">
        </methodref>
        <methodref name="CheckDisposed" visibility="protected" procflags="inline">
        </methodref>
        <propertyref name="Disposed" visibility="protected">
        </propertyref>
      </ancestor>
    </ancestor>
    <members>
      <field name="FGraphic" type="TGraphic" visibility="private" size="4" offset="4" file="Vcl.Graphics.pas" line="859"/>
      <function name="GetInitialized" visibility="protected" procflags="virtual" file="Vcl.Graphics.pas" line="861">
        <parameters>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <property name="Graphic" visibility="protected" read="FGraphic" type="TGraphic" file="Vcl.Graphics.pas" line="862"/>
      <constructor name="Create" visibility="public" file="Vcl.Graphics.pas" line="864">
        <parameters>
          <parameter name="AGraphic" type="TGraphic"/>
          <parameter name="AInitialize" type="Boolean"/>
        </parameters>
      </constructor>
      <procedure name="Initialize" visibility="public" procflags="abstract virtual" file="Vcl.Graphics.pas" line="865">
      </procedure>
      <procedure name="Draw" visibility="public" procflags="abstract overload virtual" file="Vcl.Graphics.pas" line="866">
        <parameters>
          <parameter name="ACanvas" type="TCanvas"/>
          <parameter name="ARect" type="TRect" paramflags="const"/>
        </parameters>
      </procedure>
      <property name="Initialized" visibility="public" read="GetInitialized" type="Boolean" file="Vcl.Graphics.pas" line="867"/>
    </members>
  </class>
  <enum name="TProgressStage" file="Vcl.Graphics.pas" line="906">
    <element value="0" name="psStarting" file="Vcl.Graphics.pas" line="906"/>
    <element value="1" name="psRunning" file="Vcl.Graphics.pas" line="906"/>
    <element value="2" name="psEnding" file="Vcl.Graphics.pas" line="906"/>
  </enum>
  <type name="TProgressEvent" file="Vcl.Graphics.pas" line="907" procflags="closure">
  </type>
  <class name="TGraphic" file="Vcl.Graphics.pas" line="936">
    <ancestor name="TInterfacedPersistent" namespace="System.Classes">
      <interfaces>
        <implements name="IInterface"/>
      </interfaces>
      <methodref name="_AddRef" visibility="protected">
      </methodref>
      <methodref name="_Release" visibility="protected">
      </methodref>
      <methodref name="QueryInterface" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="AfterConstruction" visibility="public" procflags="override">
      </methodref>
      <ancestor name="TPersistent" namespace="System.Classes">
        <methodref name="AssignError" visibility="private">
        </methodref>
        <methodref name="AssignTo" visibility="protected" procflags="virtual">
        </methodref>
        <methodref name="DefineProperties" visibility="protected" procflags="virtual">
        </methodref>
        <methodref name="GetOwner" visibility="protected" procflags="dynamic">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor override">
        </methodref>
        <methodref name="Assign" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetNamePath" visibility="public" procflags="dynamic">
        </methodref>
        <ancestor name="TObject" namespace="System">
          <methodref name="Create" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="Free" visibility="public">
          </methodref>
          <methodref name="DisposeOf" visibility="public" procflags="inline">
          </methodref>
          <methodref name="InitInstance" visibility="public" procflags="class">
          </methodref>
          <methodref name="CleanupInstance" visibility="public">
          </methodref>
          <methodref name="ClassType" visibility="public" procflags="inline">
          </methodref>
          <methodref name="ClassName" visibility="public" procflags="class">
          </methodref>
          <methodref name="ClassNameIs" visibility="public" procflags="class">
          </methodref>
          <methodref name="ClassParent" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="ClassInfo" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="InstanceSize" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="InheritsFrom" visibility="public" procflags="class">
          </methodref>
          <methodref name="MethodAddress" visibility="public" procflags="class overload">
          </methodref>
          <methodref name="MethodAddress" visibility="public" procflags="class overload">
          </methodref>
          <methodref name="MethodName" visibility="public" procflags="class">
          </methodref>
          <methodref name="QualifiedClassName" visibility="public" procflags="class">
          </methodref>
          <methodref name="FieldAddress" visibility="public" procflags="overload">
          </methodref>
          <methodref name="FieldAddress" visibility="public" procflags="overload">
          </methodref>
          <methodref name="GetInterface" visibility="public">
          </methodref>
          <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
          </methodref>
          <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="UnitName" visibility="public" procflags="class">
          </methodref>
          <methodref name="UnitScope" visibility="public" procflags="class">
          </methodref>
          <methodref name="Equals" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="GetHashCode" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="ToString" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="SafeCallException" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="AfterConstruction" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="Dispatch" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="DefaultHandler" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="NewInstance" visibility="public" procflags="class virtual">
          </methodref>
          <methodref name="FreeInstance" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="Destroy" visibility="public" procflags="destructor virtual">
          </methodref>
          <methodref name="GetDisposed" visibility="protected" procflags="inline">
          </methodref>
          <methodref name="CheckDisposed" visibility="protected" procflags="inline">
          </methodref>
          <propertyref name="Disposed" visibility="protected">
          </propertyref>
        </ancestor>
      </ancestor>
    </ancestor>
    <interfaces>
      <implements name="IStreamPersist"/>
    </interfaces>
    <members>
      <field name="FOnChange" type="TNotifyEvent" visibility="private" size="8" offset="16" file="Vcl.Graphics.pas" line="938"/>
      <field name="FOnProgress" type="TProgressEvent" visibility="private" size="8" offset="24" file="Vcl.Graphics.pas" line="939"/>
      <field name="FModified" type="Boolean" visibility="private" size="1" offset="32" file="Vcl.Graphics.pas" line="940"/>
      <field name="FTransparent" type="Boolean" visibility="private" size="1" offset="33" file="Vcl.Graphics.pas" line="941"/>
      <field name="FPaletteModified" type="Boolean" visibility="private" size="1" offset="34" file="Vcl.Graphics.pas" line="942"/>
      <field name="FScaledDrawer" type="TScaledGraphicDrawer" visibility="private" size="4" offset="36" file="Vcl.Graphics.pas" line="943"/>
      <procedure name="SetModified" visibility="private" file="Vcl.Graphics.pas" line="944">
        <parameters>
          <parameter name="Value" type="Boolean"/>
        </parameters>
      </procedure>
      <procedure name="Changed" visibility="protected" procflags="virtual" file="Vcl.Graphics.pas" line="946">
        <parameters>
          <parameter name="Sender" type="TObject"/>
        </parameters>
      <devnotes><summary>
Called when graphic has changed.
Changed is called automatically whenever the TGraphic object is modified. It sets the Modified property to True and triggers the OnChange event.
</summary></devnotes></procedure>
      <procedure name="DefineProperties" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="947">
        <parameters>
          <parameter name="Filer" type="TFiler"/>
        </parameters>
      <devnotes><summary>
Set virtual property for reading and writing graphic data stream.
DefineProperties overrides TPersistent.DefineProperties for the ReadData and WriteData methods for reading and writing graphic data from and to a TStream object. It creates a virtual property Data that can be treated as a property to read or write graphic data to the TGraphic object.
</summary></devnotes></procedure>
      <procedure name="Draw" visibility="protected" procflags="abstract virtual" file="Vcl.Graphics.pas" line="948">
        <parameters>
          <parameter name="ACanvas" type="TCanvas"/>
          <parameter name="Rect" type="TRect" paramflags="const"/>
        </parameters>
      <devnotes><summary>
Render graphic onto canvas at rectangle.
TCanvas.Draw calls this function to render the graphic onto its canvas at the coordinates specified by the Rect parameter. Descendants of TGraphic should override this function with a specific rendering implementation.
</summary></devnotes></procedure>
      <procedure name="DrawTransparent" visibility="protected" procflags="virtual" file="Vcl.Graphics.pas" line="949">
        <parameters>
          <parameter name="ACanvas" type="TCanvas"/>
          <parameter name="Rect" type="TRect" paramflags="const"/>
          <parameter name="Opacity" type="Byte"/>
        </parameters>
      <devnotes><summary>
Render graphic onto canvas at rectangle, blending with canvas's background.
DrawTransparent renders the graphic onto a canvas at the coordinates specified by the Rect parameter, blending it with the canvas's background.
</summary></devnotes></procedure>
      <function name="Equals" visibility="protected" procflags="overload virtual" file="Vcl.Graphics.pas" line="950">
        <parameters>
          <parameter name="Graphic" type="TGraphic"/>
          <retval type="Boolean"/>
        </parameters>
      <devnotes><summary>
Compare graphic to another TGraphic object and return true if objects contain same graphic.
Equals compares the contents of two TGraphic objects. Equals returns false if the TGraphic are different classes or if they contain different graphical data.

Code Examples
TGraphic (Delphi)
TGraphic (C++)



</summary></devnotes></function>
      <function name="GetEmpty" visibility="protected" procflags="abstract virtual" file="Vcl.Graphics.pas" line="951">
        <parameters>
          <retval type="Boolean"/>
        </parameters>
      <devnotes><summary>
Indicates whether graphics object contains graphic.
GetEmpty indicates whether the TGraphic object contains a graphic.
Each descendant of the TGraphic class should override the GetEmpty method to indicate whether a given TGraphic object is bound to an image.
</summary></devnotes></function>
      <function name="GetHeight" visibility="protected" procflags="abstract virtual" file="Vcl.Graphics.pas" line="952">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      <devnotes><summary>
Get vertical size of graphic in pixels.
GetHeight gets the vertical size of the TGraphic object in pixels.
Each descendant of TGraphic defines its own GetHeight and SetHeight methods to access the Height property.
</summary></devnotes></function>
      <function name="GetPalette" visibility="protected" procflags="virtual" file="Vcl.Graphics.pas" line="953">
        <parameters>
          <retval type="HPALETTE"/>
        </parameters>
      <devnotes><summary>
Get color palette of graphical image.
GetPalette gets the color palette of the graphical image. You can also use the Palette property to get the color palette of a graphical image. If the graphic does not need or use a palette, the Palette property is zero.
</summary></devnotes></function>
      <function name="GetTransparent" visibility="protected" procflags="virtual" file="Vcl.Graphics.pas" line="954">
        <parameters>
          <retval type="Boolean"/>
        </parameters>
      <devnotes><summary>
Specifies if graphic is drawn transparently.
GetTransparent specifies whether a graphic should be drawn transparently.
Use the Transparent property to specify that the graphic be drawn transparently. 
</summary></devnotes></function>
      <function name="GetWidth" visibility="protected" procflags="abstract virtual" file="Vcl.Graphics.pas" line="955">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      <devnotes><summary>
Get horizontal size of graphic in pixels.
GetWidth gets the horizontal size of the graphic in pixels.
Each descendant of the TGraphic class defines its own GetWidth and SetWidth methods to access the Width property. 
</summary></devnotes></function>
      <procedure name="Progress" visibility="protected" procflags="dynamic" file="Vcl.Graphics.pas" line="956">
        <parameters>
          <parameter name="Sender" type="TObject"/>
          <parameter name="Stage" type="TProgressStage"/>
          <parameter name="PercentDone" type="Byte"/>
          <parameter name="RedrawNow" type="Boolean"/>
          <parameter name="R" type="TRect" paramflags="const"/>
          <parameter name="Msg" type="string" paramflags="const"/>
        </parameters>
      <devnotes><summary>
Generate OnProgress event when graphic is changing.
Progress generates an OnProgress event when the graphic is in the process of changing.
For certain descendants of TGraphic, OnProgress occurs during slow processes such as loading, storing, or transforming image data. OnProgress allows applications to provide feedback to the user about the progress of the process. 
Component writers can generate OnProgress events for new descendants of TGraphic by calling the protected Progress method. These events are propagated to the TPicture and TImage objects. 
</summary></devnotes></procedure>
      <procedure name="ReadData" visibility="protected" procflags="virtual" file="Vcl.Graphics.pas" line="958">
        <parameters>
          <parameter name="Stream" type="TStream"/>
        </parameters>
      <devnotes><summary>
Read graphic data from TStream.
ReadData is used to read the binary graphic from the virtual property Data (created by DefineProperties) when streaming in a TGraphic from the TStream Stream.
</summary></devnotes></procedure>
      <procedure name="SetHeight" visibility="protected" procflags="abstract virtual" file="Vcl.Graphics.pas" line="959">
        <parameters>
          <parameter name="Value" type="Integer"/>
        </parameters>
      <devnotes><summary>
Set vertical size of graphic in pixels.
SetHeight sets the vertical size of the graphic in pixels.
Each descendant of the TGraphic class defines its own GetHeight and SetHeight methods to access the Height property. 
</summary></devnotes></procedure>
      <procedure name="SetPalette" visibility="protected" procflags="virtual" file="Vcl.Graphics.pas" line="960">
        <parameters>
          <parameter name="Value" type="HPALETTE"/>
        </parameters>
      <devnotes><summary>
Set color palette of graphical image.
SetPalette sets the color palette of the graphical image.
Use the Palette property to get the color palette of a graphical image. If the graphic does not need or does not use a palette, the Palette property is zero.
</summary></devnotes></procedure>
      <procedure name="SetTransparent" visibility="protected" procflags="virtual" file="Vcl.Graphics.pas" line="961">
        <parameters>
          <parameter name="Value" type="Boolean"/>
        </parameters>
      <devnotes><summary>
Specify if graphic should be drawn transparently.
SetTransparent specifies if a graphic should be drawn transparently.
</summary></devnotes></procedure>
      <procedure name="SetWidth" visibility="protected" procflags="abstract virtual" file="Vcl.Graphics.pas" line="962">
        <parameters>
          <parameter name="Value" type="Integer"/>
        </parameters>
      <devnotes><summary>
Set horizontal size of graphic in pixels.
SetWidth sets the horizontal size of the graphic in pixels.
Each descendant of the TGraphic class defines its own GetWidth and SetWidth methods to access the Width property. 
</summary></devnotes></procedure>
      <procedure name="WriteData" visibility="protected" procflags="virtual" file="Vcl.Graphics.pas" line="963">
        <parameters>
          <parameter name="Stream" type="TStream"/>
        </parameters>
      <devnotes><summary>
Write graphic data to TStream.
WriteData is used to write the binary graphic to the virtual property Data (created by DefineProperties) when streaming a TGraphic out to the TStream Stream.
</summary></devnotes></procedure>
      <function name="GetSupportsPartialTransparency" visibility="protected" procflags="virtual" file="Vcl.Graphics.pas" line="964">
        <parameters>
          <retval type="Boolean"/>
        </parameters>
      <devnotes><summary>
Indicate whether graphic supports partial transparency.
GetSupportsPartialTransparency indicates whether the graphic supports partial transparency.
TGraphic descendants should override GetSupportsPartialTransparency if they are capable of having partially transparent pixels.
</summary></devnotes></function>
      <constructor name="Create" visibility="public" file="Vcl.Graphics.pas" line="966">
        <parameters>
        </parameters>
      <devnotes><summary>
Create TGraphic object.
This method creates and intializes a TGraphic object.


</summary></devnotes></constructor>
      <destructor name="Destroy" visibility="public" file="Vcl.Graphics.pas" line="967">
        <parameters>
        </parameters>
      <devnotes><summary>
Destroys the TPersistent instance and frees its memory.
Vcl.Graphics.TGraphic.Destroy inherits from System.Classes.TPersistent.Destroy. All content below this line refers to System.Classes.TPersistent.Destroy.
Destroys the TPersistent instance and frees its memory.
Do not call Destroy directly. Call Free instead. Free checks that the object reference is not nil before calling Destroy.
</summary></devnotes></destructor>
      <function name="Equals" visibility="public" procflags="overload override" file="Vcl.Graphics.pas" line="968">
        <parameters>
          <parameter name="Obj" type="TObject"/>
          <retval type="Boolean"/>
        </parameters>
      <devnotes><summary>
Compare graphic to another TGraphic object and return true if objects contain same graphic.
Equals compares the contents of two TGraphic objects. Equals returns false if the TGraphic are different classes or if they contain different graphical data.

Code Examples
TGraphic (Delphi)
TGraphic (C++)



</summary></devnotes></function>
      <procedure name="LoadFromFile" visibility="public" procflags="virtual" file="Vcl.Graphics.pas" line="969">
        <parameters>
          <parameter name="Filename" type="string" paramflags="const"/>
        </parameters>
      <devnotes><summary>
Loads a graphic image stored in a file.
LoadFromFile reads the file specified in FileName and loads the data into the graphics object.
</summary></devnotes></procedure>
      <procedure name="SaveToFile" visibility="public" procflags="virtual" file="Vcl.Graphics.pas" line="970">
        <parameters>
          <parameter name="Filename" type="string" paramflags="const"/>
        </parameters>
      <devnotes><summary>
Saves a graphics image to a file.
SaveToFile writes the graphic to a file, specified by Filename.

Code Examples
TJPEGImageAssign (Delphi)
TJPEGImageAssign (C++)
ImageProc Sample



</summary></devnotes></procedure>
      <function name="CanLoadFromStream" visibility="public" procflags="class virtual" file="Vcl.Graphics.pas" line="971">
        <parameters>
          <parameter name="Stream" type="TStream"/>
          <retval type="Boolean"/>
        </parameters>
      <devnotes><summary>
CanLoadFromStream returns True when a specified stream contains a streamed image of a specific TGraphic subclass. 
The method uses current stream position, it does not change current stream position.


</summary></devnotes></function>
      <procedure name="LoadFromStream" visibility="public" procflags="abstract virtual" file="Vcl.Graphics.pas" line="972">
        <parameters>
          <parameter name="Stream" type="TStream"/>
        </parameters>
      <devnotes><summary>
Introduces an abstract method that loads the image from a stream.
Each descendant graphic object defines a LoadFromStream method that loads a graphics object from Stream.
</summary></devnotes></procedure>
      <procedure name="SaveToStream" visibility="public" procflags="abstract virtual" file="Vcl.Graphics.pas" line="973">
        <parameters>
          <parameter name="Stream" type="TStream"/>
        </parameters>
      <devnotes><summary>
Introduces an abstract method that saves the graphic image to a stream.
Each descendant graphic object defines a SaveToStream method that saves the object to a Stream.


</summary></devnotes></procedure>
      <procedure name="LoadFromClipboardFormat" visibility="public" procflags="abstract virtual" file="Vcl.Graphics.pas" line="974">
        <parameters>
          <parameter name="AFormat" type="Word"/>
          <parameter name="AData" type="NativeUInt"/>
          <parameter name="APalette" type="HPALETTE"/>
        </parameters>
      <devnotes><summary>
Introduces an abstract method that loads the image from a variable in Clipboard format.
Each descendant graphic object defines a LoadFromClipboardFormat method that replaces the current graphic image with the graphic indicated by AData, which it loads from the Clipboard.
The format for the new graphic object must be registered with the Clipboard in the RegisterClipboardFormat method, or an exception is raised.
</summary></devnotes></procedure>
      <procedure name="SaveToClipboardFormat" visibility="public" procflags="abstract virtual" file="Vcl.Graphics.pas" line="976">
        <parameters>
          <parameter name="AFormat" type="Word" paramflags="var"/>
          <parameter name="AData" type="NativeUInt" paramflags="var"/>
          <parameter name="APalette" type="HPALETTE" paramflags="var"/>
        </parameters>
      <devnotes><summary>
Introduces an abstract method that assigns the graphic to a variable in clipboard format.
Each descendant graphic object defines a SaveToClipboardFormat method that saves that particular graphic image type to a Clipboard format. An application must have registered the format with the TGraphic object using the RegisterClipboardFormat method.
</summary></devnotes></procedure>
      <procedure name="SetSize" visibility="public" procflags="virtual" file="Vcl.Graphics.pas" line="978">
        <parameters>
          <parameter name="AWidth" type="Integer"/>
          <parameter name="AHeight" type="Integer"/>
        </parameters>
      <devnotes><summary>
Specifies the size of the graphic.
Use the SetSize method to set both the height and width of the graphic. This results in better performance than setting the height and width separately.


</summary></devnotes></procedure>
      <procedure name="EnableScaledDrawer" visibility="public" procflags="virtual" file="Vcl.Graphics.pas" line="980">
        <parameters>
          <parameter name="AGraphicScalerClass" type="TScaledGraphicDrawerClass"/>
          <parameter name="AInitialize" type="Boolean">
            <value>
              True
            </value>
          </parameter>
        </parameters>
      <devnotes><summary>
EnableScaledDrawer Enables scaled drawer for a graphic, which is used to scale the graphic.
AGraphicScalerClass specifies the scaled drawer class, for example TWICScaledGraphicDrawer. 

See also
ScaledDrawer
DisableScaledDrawer

</summary></devnotes></procedure>
      <procedure name="DisableScaledDrawer" visibility="public" procflags="virtual" file="Vcl.Graphics.pas" line="981">
      <devnotes><summary>
DisableScaledDrawer Disables scaled drawer for a graphic.

See also
ScaledDrawer
EnableScaledDrawer

</summary></devnotes></procedure>
      <procedure name="UpdateScaledDrawer" visibility="public" procflags="virtual" file="Vcl.Graphics.pas" line="982">
      <devnotes><summary>
Embarcadero Technologies does not currently have any additional information.


</summary></devnotes></procedure>
      <property name="Empty" visibility="public" read="GetEmpty" type="Boolean" file="Vcl.Graphics.pas" line="984"><devnotes><summary>
Indicates whether the graphics object contains a graphic.
Use Empty to determine whether the graphic is bound to an image. Each descendant graphic object defines its own Get method to access the Empty property.


</summary></devnotes></property>
      <property name="Height" visibility="public" read="GetHeight" write="SetHeight" type="Integer" file="Vcl.Graphics.pas" line="985"><devnotes><summary>
Specifies the vertical size of the graphic in pixels.
Use Height to determine the height of the graphic image. Each descendant graphic object defines its own Get and Set methods to access the Height property.

Code Examples
SaveToFile (Delphi)
ScanLine (Delphi)
SaveToFile (C++)
ScanLine (C++)



</summary></devnotes></property>
      <property name="Modified" visibility="public" read="FModified" write="SetModified" type="Boolean" file="Vcl.Graphics.pas" line="986"><devnotes><summary>
Indicates whether the graphics object has been changed or edited.
If Modified is true, the graphic object has changed. If Modified is false, the graphics object is in the same state as when the object was loaded.
The Modified property indicates only if bitmap objects have been modified. Modified is not true if the graphics object contains an icon or metafile graphic, even if they have been modified.
If the graphics object was modified, save the changes to a file with the SaveToFile method. The next time the application runs, it can load the graphic from the file with the LoadFromFile method.


</summary></devnotes></property>
      <property name="Palette" visibility="public" read="GetPalette" write="SetPalette" type="HPALETTE" file="Vcl.Graphics.pas" line="987"><devnotes><summary>
Indicates the color palette of the graphical image.
Use Palette to get the color palette of a graphical image. If the graphic does not need or does not use a palette, the Palette property is zero.

Code Examples
GetDeviceContext (Delphi)
GetDeviceContext (C++)



</summary></devnotes></property>
      <property name="PaletteModified" visibility="public" read="FPaletteModified" write="FPaletteModified" type="Boolean" file="Vcl.Graphics.pas" line="988"><devnotes><summary>
Indicates whether the palette has changed.
Use PaletteModified to determine if the palette used for a graphical image has changed. PaletteModified is used in the OnChange event. PaletteModified remains true until whoever is responsible for realizing this new palette (for example, TImage) sets it to false.


</summary></devnotes></property>
      <property name="Transparent" visibility="public" read="GetTransparent" write="SetTransparent" type="Boolean" file="Vcl.Graphics.pas" line="989"><devnotes><summary>
Indicates whether the image covers its rectangular area.
Use Transparent to specify that the graphic be drawn transparently. Some descendants of TGraphic such as TIcon and TMetafile are always transparent, so setting the property for those objects does not change their behavior. However, the TBitmap graphic's drawing is affected by this property. The TImage component sets this property to be the same as its Transparent property to achieve transparent painting.
When the Transparent property is set to True, you can either specify a color as the transparent color or you can use the default color, which is the pixel in the lower left. The specified color is not displayed in the graphic, which lets the background show through. This can be useful in layering and for non-rectangular graphics.

Code Examples
FileSelectBtnEdit (Delphi)
TransparentColor (Delphi)
FileSelectBtnEdit (C++)
TransparentColor (C++)



</summary></devnotes></property>
      <property name="Width" visibility="public" read="GetWidth" write="SetWidth" type="Integer" file="Vcl.Graphics.pas" line="990"><devnotes><summary>
Determines the maximum width of the graphics object in pixels.
Each descendant graphic object defines its own Get and Set methods to access the Width property.

Code Examples
SaveToFile (Delphi)
ScanLine (Delphi)
SaveToFile (C++)
ScanLine (C++)



</summary></devnotes></property>
      <property name="ScaledDrawer" visibility="public" read="FScaledDrawer" type="TScaledGraphicDrawer" file="Vcl.Graphics.pas" line="991"><devnotes><summary>
Returns the reference to the scaled drawer.
When the scaled drawer is enabled for graphic, then the ScaledDrawer property returns the reference to it. 

See also
EnableScaledDrawer

</summary></devnotes></property>
      <event name="OnChange" visibility="public" read="FOnChange" write="FOnChange" type="TNotifyEvent" file="Vcl.Graphics.pas" line="992"><devnotes><summary>
Occurs whenever a graphical image changes.
Use OnChange to write a handler to perform an action then the graphical image changes.


</summary></devnotes></event>
      <event name="OnProgress" visibility="public" read="FOnProgress" write="FOnProgress" type="TProgressEvent" file="Vcl.Graphics.pas" line="993"><devnotes><summary>
Occurs when a graphical image is in the process of changing.
For certain descendants of TGraphic, OnProgress occurs during slow processes such as loading, storing, or transforming image data. OnProgress allows applications to provide feedback to the user about the progress of the slow process. 
Component writers can generate OnProgress events for new descendants of TGraphic by calling the protected Progress method. These events are propagated to the TPicture and TImage objects.
OnProgress is an event handler of type Vcl.Graphics.TProgressEvent.
</summary></devnotes></event>
      <property name="SupportsPartialTransparency" visibility="public" read="GetSupportsPartialTransparency" type="Boolean" file="Vcl.Graphics.pas" line="994"><devnotes><summary>
Indicate whether graphic supports partial transparency or an alpha channel.
SupportsPartialTransparency indicates whether the graphic supports partial transparency or an alpha channel.
Some TGraphic descendants, such as TBitmap and TPngImage, can support partial transparency or an alpha channel. When a graphic that supports partial transparency is drawn on a canvas using DrawTransparent, it should be blended with the pixels on the canvas based on the value of the alpha channel.
</summary></devnotes></property>
    </members>
  <devnotes><summary>
TGraphic is the abstract base class type for objects such as icons, bitmaps, and metafiles that can store and display visual images.
TGraphic is an abstract class that cannot be instantiated. Descendant graphics objects override many of the methods of TGraphic to address the needs of their particular file format and graphical characteristics. TGraphic also introduces methods that work with TPicture objects and the Clipboard. Properties of TGraphic provide information about the state and size of the graphic image.
When the type of graphic is known, store the graphic in its specific type object. Otherwise, use a TPicture object that can hold any type of TGraphic.
</summary></devnotes></class>
  <array name="TGraphicArray" file="Vcl.Graphics.pas" line="997">
    <element type="TGraphic"/>
  </array>
  <enum name="TFindGraphicClassSource" file="Vcl.Graphics.pas" line="999">
    <element value="0" name="gsStream" file="Vcl.Graphics.pas" line="999"/>
    <element value="1" name="gsFileName" file="Vcl.Graphics.pas" line="999"/>
    <element value="2" name="gsClipboard" file="Vcl.Graphics.pas" line="999"/>
  </enum>
  <struct name="TFindGraphicClassContext" size="16" file="Vcl.Graphics.pas" line="1000">
    <field name="FSource" type="TFindGraphicClassSource" visibility="public" size="1" offset="0" file="Vcl.Graphics.pas" line="1002"/>
    <field name="FFileName" type="string" visibility="public" size="4" offset="4" file="Vcl.Graphics.pas" line="1003"/>
    <field name="FClipboardFormat" type="Word" visibility="public" size="2" offset="8" file="Vcl.Graphics.pas" line="1004"/>
    <field name="FStream" type="TStream" visibility="public" size="4" offset="12" file="Vcl.Graphics.pas" line="1005"/>
  </struct>
  <type name="TFindGraphicClassEvent" file="Vcl.Graphics.pas" line="1007" procflags="closure">
  </type>
  <class name="TPicture" file="Vcl.Graphics.pas" line="1050">
    <ancestor name="TInterfacedPersistent" namespace="System.Classes">
      <interfaces>
        <implements name="IInterface"/>
      </interfaces>
      <methodref name="_AddRef" visibility="protected">
      </methodref>
      <methodref name="_Release" visibility="protected">
      </methodref>
      <methodref name="QueryInterface" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="AfterConstruction" visibility="public" procflags="override">
      </methodref>
      <ancestor name="TPersistent" namespace="System.Classes">
        <methodref name="AssignError" visibility="private">
        </methodref>
        <methodref name="AssignTo" visibility="protected" procflags="virtual">
        </methodref>
        <methodref name="DefineProperties" visibility="protected" procflags="virtual">
        </methodref>
        <methodref name="GetOwner" visibility="protected" procflags="dynamic">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor override">
        </methodref>
        <methodref name="Assign" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetNamePath" visibility="public" procflags="dynamic">
        </methodref>
        <ancestor name="TObject" namespace="System">
          <methodref name="Create" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="Free" visibility="public">
          </methodref>
          <methodref name="DisposeOf" visibility="public" procflags="inline">
          </methodref>
          <methodref name="InitInstance" visibility="public" procflags="class">
          </methodref>
          <methodref name="CleanupInstance" visibility="public">
          </methodref>
          <methodref name="ClassType" visibility="public" procflags="inline">
          </methodref>
          <methodref name="ClassName" visibility="public" procflags="class">
          </methodref>
          <methodref name="ClassNameIs" visibility="public" procflags="class">
          </methodref>
          <methodref name="ClassParent" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="ClassInfo" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="InstanceSize" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="InheritsFrom" visibility="public" procflags="class">
          </methodref>
          <methodref name="MethodAddress" visibility="public" procflags="class overload">
          </methodref>
          <methodref name="MethodAddress" visibility="public" procflags="class overload">
          </methodref>
          <methodref name="MethodName" visibility="public" procflags="class">
          </methodref>
          <methodref name="QualifiedClassName" visibility="public" procflags="class">
          </methodref>
          <methodref name="FieldAddress" visibility="public" procflags="overload">
          </methodref>
          <methodref name="FieldAddress" visibility="public" procflags="overload">
          </methodref>
          <methodref name="GetInterface" visibility="public">
          </methodref>
          <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
          </methodref>
          <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="UnitName" visibility="public" procflags="class">
          </methodref>
          <methodref name="UnitScope" visibility="public" procflags="class">
          </methodref>
          <methodref name="Equals" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="GetHashCode" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="ToString" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="SafeCallException" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="AfterConstruction" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="Dispatch" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="DefaultHandler" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="NewInstance" visibility="public" procflags="class virtual">
          </methodref>
          <methodref name="FreeInstance" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="Destroy" visibility="public" procflags="destructor virtual">
          </methodref>
          <methodref name="GetDisposed" visibility="protected" procflags="inline">
          </methodref>
          <methodref name="CheckDisposed" visibility="protected" procflags="inline">
          </methodref>
          <propertyref name="Disposed" visibility="protected">
          </propertyref>
        </ancestor>
      </ancestor>
    </ancestor>
    <interfaces>
      <implements name="IStreamPersist"/>
    </interfaces>
    <members>
      <anonMethod name="TLoadProc" visibility="private" alias="Vcl.Graphics.TLoadProc" file="Vcl.Graphics.pas" line="1052">
        <procedure name="Invoke" visibility="public" procflags="abstract virtual" file="Vcl.Graphics.pas" line="1052">
          <parameters>
            <parameter name="Graphic" type="TGraphic"/>
          </parameters>
        </procedure>
      </anonMethod>
      <field name="FGraphic" type="TGraphic" visibility="private" size="4" offset="12" file="Vcl.Graphics.pas" line="1054"/>
      <field name="FOnChange" type="TNotifyEvent" visibility="private" size="8" offset="16" file="Vcl.Graphics.pas" line="1055"/>
      <field name="FNotify" type="IChangeNotifier" visibility="private" size="4" offset="24" file="Vcl.Graphics.pas" line="1056"/>
      <field name="FOnProgress" type="TProgressEvent" visibility="private" size="8" offset="32" file="Vcl.Graphics.pas" line="1057"/>
      <field name="FOnFindGraphicClass" type="TFindGraphicClassEvent" visibility="private" size="8" offset="40" file="Vcl.Graphics.pas" line="1058"/>
      <procedure name="ForceType" visibility="private" file="Vcl.Graphics.pas" line="1059">
        <parameters>
          <parameter name="GraphicType" type="TGraphicClass"/>
        </parameters>
      </procedure>
      <procedure name="Load" visibility="private" file="Vcl.Graphics.pas" line="1060">
        <parameters>
          <parameter name="GraphicClass" type="TGraphicClass"/>
          <parameter name="LoadProc" type="TPicture.TLoadProc"/>
        </parameters>
      </procedure>
      <function name="GetBitmap" visibility="private" file="Vcl.Graphics.pas" line="1061">
        <parameters>
          <retval type="TBitmap"/>
        </parameters>
      </function>
      <function name="GetHeight" visibility="private" file="Vcl.Graphics.pas" line="1062">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="GetIcon" visibility="private" file="Vcl.Graphics.pas" line="1063">
        <parameters>
          <retval type="TIcon"/>
        </parameters>
      </function>
      <function name="GetMetafile" visibility="private" file="Vcl.Graphics.pas" line="1064">
        <parameters>
          <retval type="TMetafile"/>
        </parameters>
      </function>
      <function name="GetWidth" visibility="private" file="Vcl.Graphics.pas" line="1065">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="GetWICImage" visibility="private" file="Vcl.Graphics.pas" line="1066">
        <parameters>
          <retval type="TWICImage"/>
        </parameters>
      </function>
      <procedure name="ReadData" visibility="private" file="Vcl.Graphics.pas" line="1067">
        <parameters>
          <parameter name="Stream" type="TStream"/>
        </parameters>
      </procedure>
      <procedure name="SetBitmap" visibility="private" file="Vcl.Graphics.pas" line="1068">
        <parameters>
          <parameter name="Value" type="TBitmap"/>
        </parameters>
      </procedure>
      <procedure name="SetGraphic" visibility="private" file="Vcl.Graphics.pas" line="1069">
        <parameters>
          <parameter name="Value" type="TGraphic"/>
        </parameters>
      </procedure>
      <procedure name="SetIcon" visibility="private" file="Vcl.Graphics.pas" line="1070">
        <parameters>
          <parameter name="Value" type="TIcon"/>
        </parameters>
      </procedure>
      <procedure name="SetMetafile" visibility="private" file="Vcl.Graphics.pas" line="1071">
        <parameters>
          <parameter name="Value" type="TMetafile"/>
        </parameters>
      </procedure>
      <procedure name="SetWICImage" visibility="private" file="Vcl.Graphics.pas" line="1072">
        <parameters>
          <parameter name="Value" type="TWICImage"/>
        </parameters>
      </procedure>
      <procedure name="WriteData" visibility="private" file="Vcl.Graphics.pas" line="1073">
        <parameters>
          <parameter name="Stream" type="TStream"/>
        </parameters>
      </procedure>
      <procedure name="AssignTo" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="1075">
        <parameters>
          <parameter name="Dest" type="TPersistent"/>
        </parameters>
      <devnotes><summary>
Copies the properties of an object to a destination object.
Vcl.Graphics.TPicture.AssignTo inherits from System.Classes.TPersistent.AssignTo. All content below this line refers to System.Classes.TPersistent.AssignTo.
Copies the properties of an object to a destination object.
Override the AssignTo method to extend the functionality of the Assign method of destination objects so that they handle newly created object classes. When defining a new object class, override the Assign method for every existing object class that should be able to copy its properties to the new class. Override the AssignTo method for every existing class to which the new class can copy.
The Assign method of TPersistent calls AssignTo if the descendant object does not succeed in copying the properties of a source object. The AssignTo method defined by TPersistent raises an EConvertError exception. 
For example, given the following code in which A and B are instance variables:

A.Assign(B); {Delphi}

A-&gt;Assign(B); // C++

if A knows how to handle B, then it does so and returns. If A doesn't know how to handle B's type, execution will trickle to the TPersistent version of Assign, which calls:

B.AssignTo(A); {Delphi}

B-&gt;AssignTo(A); // C++

If B knows how to copy to A, the assignment succeeds. Otherwise, TPersistent raises an exception.
</summary></devnotes></procedure>
      <procedure name="Changed" visibility="protected" procflags="dynamic" file="Vcl.Graphics.pas" line="1076">
        <parameters>
          <parameter name="Sender" type="TObject"/>
        </parameters>
      <devnotes><summary>
Embarcadero Technologies does not currently have any additional information.


</summary></devnotes></procedure>
      <procedure name="DefineProperties" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="1077">
        <parameters>
          <parameter name="Filer" type="TFiler"/>
        </parameters>
      <devnotes><summary>
Provides an interface for a method that reads and writes otherwise unpublished data.
Vcl.Graphics.TPicture.DefineProperties inherits from System.Classes.TPersistent.DefineProperties. All content below this line refers to System.Classes.TPersistent.DefineProperties.
Provides an interface for a method that reads and writes otherwise unpublished data.
Descendants of TPersistent override DefineProperties to designate a method for storing the object's unpublished data to a stream such as a form file. By default, writing an object to a stream writes the values of all its published properties, and reading the object in reads those values and assigns them to the properties. Objects can also specify methods that read and write data other than published properties by overriding the DefineProperties method.
When overriding DefineProperties, consider including some or all of the following:

A call to the inherited method
Calls to the filer object's DefineProperty method
Calls to the filer object's DefineBinaryProperty method
DefineProperties is virtual, so descendant classes can override it as necessary but are not required to do so.
</summary></devnotes></procedure>
      <procedure name="Progress" visibility="protected" procflags="dynamic" file="Vcl.Graphics.pas" line="1078">
        <parameters>
          <parameter name="Sender" type="TObject"/>
          <parameter name="Stage" type="TProgressStage"/>
          <parameter name="PercentDone" type="Byte"/>
          <parameter name="RedrawNow" type="Boolean"/>
          <parameter name="R" type="TRect" paramflags="const"/>
          <parameter name="Msg" type="string" paramflags="const"/>
        </parameters>
      <devnotes><summary>
Embarcadero Technologies does not currently have any additional information.


</summary></devnotes></procedure>
      <procedure name="FindGraphicClass" visibility="protected" procflags="dynamic" file="Vcl.Graphics.pas" line="1080">
        <parameters>
          <parameter name="Context" type="TFindGraphicClassContext" paramflags="const"/>
          <parameter name="GraphicClass" type="TGraphicClass" paramflags="var"/>
        </parameters>
      <devnotes><summary>
Embarcadero Technologies does not currently have any additional information.


</summary></devnotes></procedure>
      <constructor name="Create" visibility="public" file="Vcl.Graphics.pas" line="1083">
        <parameters>
        </parameters>
      <devnotes><summary>
Creates a TPicture object.
Call Create to create an instance of TPicture at runtime. Create allocates the memory for the picture object and initializes its internal formats. After creating the TPicture object, use the LoadFromClipboardFormat or LoadFromFile method to assign a graphical image to the picture, so that it is available to the application.
</summary></devnotes></constructor>
      <destructor name="Destroy" visibility="public" file="Vcl.Graphics.pas" line="1084">
        <parameters>
        </parameters>
      <devnotes><summary>
Destroys an instance of a picture object.
Do not call Destroy directly in an application. Instead, call Free. Free verifies that the TPicture reference is not nil before it calls Destroy.
Destroy frees the graphic image it contains before calling the inherited Destroy.
</summary></devnotes></destructor>
      <procedure name="LoadFromFile" visibility="public" file="Vcl.Graphics.pas" line="1085">
        <parameters>
          <parameter name="Filename" type="string" paramflags="const"/>
        </parameters>
      <devnotes><summary>
Reads the file specified in Filename and loads the data into the TPicture object.
Use LoadFromFile to read a picture from disk. The TGraphic class created is determined by the file extension of the file. If the file extension is not recognized an EInvalidGraphic exception is raised.
</summary></devnotes></procedure>
      <procedure name="SaveToFile" visibility="public" file="Vcl.Graphics.pas" line="1086">
        <parameters>
          <parameter name="Filename" type="string" paramflags="const"/>
        </parameters>
      <devnotes><summary>
Writes the picture to disk.
Use SaveToFile to save a TPicture object to the file specified in Filename.
The saved picture can be loaded to another TPicture or to an appropriate TGraphic descendant by calling its LoadFromFile method.
</summary></devnotes></procedure>
      <procedure name="LoadFromStream" visibility="public" file="Vcl.Graphics.pas" line="1087">
        <parameters>
          <parameter name="Stream" type="TStream"/>
        </parameters>
      <devnotes><summary>
Reads the picture from a Stream.
Use LoadFromStream to read a picture from a TStream object. The TGraphic class created is determined by the type of data contained in the stream.
The data in the stream should be previously written by a call to the SaveToStream method of another TPicture or of a TGraphic descendant.
</summary></devnotes></procedure>
      <procedure name="SaveToStream" visibility="public" file="Vcl.Graphics.pas" line="1088">
        <parameters>
          <parameter name="Stream" type="TStream"/>
        </parameters>
      <devnotes><summary>
Saves the picture to a stream.
Use SaveToStream to save a picture to the TStream object specified by the Stream parameter. 
The saved picture can be loaded to another TPicture or to an appropriate TGraphic descendant by calling its LoadFromStream method.
</summary></devnotes></procedure>
      <procedure name="LoadFromClipboardFormat" visibility="public" file="Vcl.Graphics.pas" line="1089">
        <parameters>
          <parameter name="AFormat" type="Word"/>
          <parameter name="AData" type="NativeUInt"/>
          <parameter name="APalette" type="HPALETTE"/>
        </parameters>
      <devnotes><summary>
Reads the picture from the handle provided in the given Clipboard format.
Use LoadFromClipboardFormat to read in a graphic from the Clipboard. If the format is not supported, an EInvalidGraphic exception is raised.
The following code snippet shows how to load a picture from the clipboard into a TImage control.

Note: To load a picture into the clipboard, you can use the code snippet for the SaveToClipboardFormat method.

Delphi:

uses
  Vcl.Clipbrd;

procedure TForm1.Button1Click(Sender: TObject);
var
  Picture: TPicture;
begin
 Picture := TPicture.Create;
 try
   Picture.LoadFromClipboardFormat(cf_BitMap, ClipBoard.GetAsHandle(cf_Bitmap), 0);
   Image1.Picture := Picture;
 finally
   Picture.Free;
   Clipboard.Clear;
 end;
end;



C++:

#include &lt;Vcl.Clipbrd.hpp&gt;

void __fastcall TForm1::Button1Click(TObject *Sender){
	TPicture* Picture;
	TClipboard* cb = Clipboard();

	Picture = new TPicture();
	try{
		Picture-&gt;LoadFromClipboardFormat(CF_BITMAP, cb-&gt;GetAsHandle(CF_BITMAP), 0);
		Image1-&gt;Picture = Picture;
	}
	__finally{
		delete Picture;
		cb-&gt;Clear();
	}
}

</summary></devnotes></procedure>
      <procedure name="SaveToClipboardFormat" visibility="public" file="Vcl.Graphics.pas" line="1091">
        <parameters>
          <parameter name="AFormat" type="Word" paramflags="var"/>
          <parameter name="AData" type="NativeUInt" paramflags="var"/>
          <parameter name="APalette" type="HPALETTE" paramflags="var"/>
        </parameters>
      <devnotes><summary>
Allocates a global handle and writes the picture in its native Clipboard format (CF_BITMAP for bitmaps, CF_METAFILE for metafiles, and so on).
Use SaveToClipboardFormat to copy the picture to a Clipboard format. The resulting values can then be copied to the Windows clipboard using the clipboard's SetAsHandle method.
The palette of the picture is returned in the APalette parameter, the format in the AFormat parameter, and a handle to the data in the AData parameter. Before the picture can be saved, an application must have registered the format using the RegisterClipboardFormat method.
The following code snippet shows how to save a bitmap to the clipboard.

Note: To load a bitmap from the clipboard, you can use the code snippet for the LoadFromClipboardFormat method.

Delphi:

uses
  Vcl.Clipbrd;

procedure TForm1.Button1Click(Sender: TObject);
var
  MyFormat : Word;
  Picture : TPicture;
  AData : THandle;
  APalette : HPALETTE;
begin
  Picture := TPicture.Create;
  try
    Picture.LoadFromFile('C:\Users\Public\Pictures\Sample Pictures\desert.bmp');
    Picture.SaveToClipBoardFormat(MyFormat, AData, APalette);
    ClipBoard.SetAsHandle(MyFormat,AData);
  finally
    Picture.Free;
  end;
end;



C++:

#include &lt;Vcl.Clipbrd.hpp&gt;

void __fastcall TForm1::Button1Click(TObject *Sender){
	TClipboard* cb = Clipboard();
	unsigned short MyFormat;
	TPicture* Picture;
	unsigned int AData;
	HPALETTE APalette;

	Picture = new TPicture();
	try{
		Picture-&gt;LoadFromFile(&quot;C:\\Users\\Public\\Pictures\\Sample Pictures\\desert.bmp&quot;);
		Picture-&gt;SaveToClipboardFormat(MyFormat, AData, APalette);
		cb-&gt;SetAsHandle(MyFormat, AData);
	}
	__finally{
		delete Picture;
	}
}

</summary></devnotes></procedure>
      <function name="SupportsClipboardFormat" visibility="public" procflags="class" file="Vcl.Graphics.pas" line="1093">
        <parameters>
          <parameter name="AFormat" type="Word"/>
          <retval type="Boolean"/>
        </parameters>
      <devnotes><summary>
Indicates if the given Clipboard format is supported by the LoadFromClipboardFormat method.
If the LoadFromClipboardFormat method supports the Clipboard format specified as the value of AFormat, SupportsClipboardFormat returns true. If the format is not supported, the method returns false.
</summary></devnotes></function>
      <procedure name="Assign" visibility="public" procflags="override" file="Vcl.Graphics.pas" line="1094">
        <parameters>
          <parameter name="Source" type="TPersistent"/>
        </parameters>
      <devnotes><summary>
Copies one object to another by copying the contents of that object to the other.
When Source is a object type that is valid for the Graphic property, Assign makes that graphic the value of the Graphic property.
The actions performed by Assign depend on the actual types of the TPicture Graphic property and Source. For example, if the Graphic property and Source are bitmaps (TBitmap), the bitmap contained in Source is copied into the Graphic property. Similar conversions are valid, for example, for TIcon or TMetafile.
If the Source parameter is not a valid object for the Graphic property, Assign calls the inherited method so that the picture can be copied from any object with which it is compatible.
</summary></devnotes></procedure>
      <procedure name="RegisterFileFormat" visibility="public" procflags="class" file="Vcl.Graphics.pas" line="1095">
        <parameters>
          <parameter name="AExtension" type="string" paramflags="const"/>
          <parameter name="ADescription" type="string" paramflags="const"/>
          <parameter name="AGraphicClass" type="TGraphicClass"/>
        </parameters>
      <devnotes><summary>
Registers a new TGraphic class for use in LoadFromFile.
Use RegisterFileFormat to register a graphic file format with TPicture so that it can be used with a Open or Save dialog box.
The AExtension parameter specifies the three-character system file extension to associate with the graphic class (for example, &quot;bmp&quot; is associated with TBitmap). The ADescription parameter specifies the description of the graphic to appear in the drop down list of the dialog box (for example, &quot;Bitmaps&quot; is the description of TBitmap). The AGraphicClass parameter registers the new graphic class to associate with the file format.
</summary></devnotes></procedure>
      <procedure name="RegisterClipboardFormat" visibility="public" procflags="class" file="Vcl.Graphics.pas" line="1097">
        <parameters>
          <parameter name="AFormat" type="Word"/>
          <parameter name="AGraphicClass" type="TGraphicClass"/>
        </parameters>
      <devnotes><summary>
Registers a new TGraphic class for use in the LoadFromClipboardFormat method.
Use RegisterClipboardFormat register a new graphic format with TPicture so that it can be used with the LoadFromClipboardFormat method.
</summary></devnotes></procedure>
      <procedure name="UnregisterGraphicClass" visibility="public" procflags="class" file="Vcl.Graphics.pas" line="1099">
        <parameters>
          <parameter name="AClass" type="TGraphicClass"/>
        </parameters>
      <devnotes><summary>
Removes all references to the specified TGraphic class and all its descendants from the internal lists of file formats and clipboard formats.
Call UnregisterGraphicClass to make a graphic class unavailable to all picture objects. UnregisterGraphicClass reverses the registration accomplished by the RegisterFileFormat, or RegisterFileFormatRes, or RegisterClipboardFormat method. When a graphic class is registered, the global GraphicFilter, GraphicExtension, and GraphicFileMask functions can return dialog filter strings, default file extensions or file filters for the graphic class. Call UnregisterGraphicClass when these values should not be available. For example, component writers who implement custom graphic classes unregister those classes according to the language used. In Delphi, the classes are unregistered in the finalization block of the unit that implements them and, in C++, the classes are unregistered using the #pragma exit directive (C++). 
File formats and clipboard formats for the custom class are registered in the initialization block (Delphi) or using #pragma startup (C++).
</summary></devnotes></procedure>
      <procedure name="RegisterFileFormatRes" visibility="public" procflags="class" file="Vcl.Graphics.pas" line="1104">
        <parameters>
          <parameter name="AExtension" type="string" paramflags="const"/>
          <parameter name="ADescriptionResID" type="Integer"/>
          <parameter name="AGraphicClass" type="TGraphicClass"/>
        </parameters>
      <devnotes><summary>
Registers a new TGraphic class for use in the LoadFromFile method.
Use RegisterFileFormatRes by specifying a string resource.
The AExtension parameter specifies the three-character system file extension to associate with the graphic class (for example, &quot;bmp&quot; is associated with TBitmap).
The ADescriptionResID parameter specifies the resource ID for a description of the graphic, which then appears in the drop down list of the dialog box (for example, &quot;Bitmaps&quot; is the description of TBitmap).
The AGraphicClass parameter registers the new graphic class to associate with the file format.
</summary></devnotes></procedure>
      <property name="Bitmap" visibility="public" read="GetBitmap" write="SetBitmap" type="TBitmap" file="Vcl.Graphics.pas" line="1107"><devnotes><summary>
Specifies the contents of the picture object as a bitmap graphic (.BMP file format).
Use Bitmap to reference the picture object when it contains a bitmap. If Bitmap is referenced when the picture contains a Metafile or Icon graphic, the graphic won't be converted (Types of Graphic Objects). Instead, the original contents of the picture are discarded and Bitmap returns a new, blank bitmap.

Note:  When assigning the Bitmap property, TPicture assigns the properties of a another TBitmap object. It does not take ownership of the specified value.</summary></devnotes></property>
      <property name="Graphic" visibility="public" read="FGraphic" write="SetGraphic" type="TGraphic" file="Vcl.Graphics.pas" line="1108"><devnotes><summary>
Specifies the graphic that the picture contains.
Use Graphic to specify what graphic the TPicture object contains. The graphic can be a bitmap, icon, metafile, or user-defined graphic class (Types of Graphic Objects).

Note:  When assigning the Graphic property, TPicture assigns the properties of a another TGraphic object. It does not take ownership of the specified object.</summary></devnotes></property>
      <property name="PictureAdapter" visibility="public" read="FNotify" write="FNotify" type="IChangeNotifier" file="Vcl.Graphics.pas" line="1109"><devnotes><summary>
Represents an OLE interface for the picture.
PictureAdapter is for internal use only.
</summary></devnotes></property>
      <property name="Height" visibility="public" read="GetHeight" type="Integer" file="Vcl.Graphics.pas" line="1110"><devnotes><summary>
Specifies the vertical size (in pixels) of the graphic.
Use Height to find the height of the graphic image contained in the picture object. Height is the native, unstretched, height of the picture.
</summary></devnotes></property>
      <property name="Icon" visibility="public" read="GetIcon" write="SetIcon" type="TIcon" file="Vcl.Graphics.pas" line="1111"><devnotes><summary>
Specifies the contents of the TPicture object as an icon graphic (.ICO file format).
If Icon is referenced when the TPicture contains a Bitmap or Metafile graphic, the graphic won't be converted. Instead, the original contents of the TPicture are discarded and Icon returns a new, blank icon.

Note:  When assigning the Icon property, TPicture assigns the properties of a another Icon object. It does not take ownership of the specified value.</summary></devnotes></property>
      <property name="Metafile" visibility="public" read="GetMetafile" write="SetMetafile" type="TMetafile" file="Vcl.Graphics.pas" line="1112"><devnotes><summary>
Specifies the contents of the picture object as an Enhanced Windows metafile graphic (.EMF file format).
If Metafile is referenced when the TPicture contains a Bitmap or Icon graphic, the graphic won't be converted. Instead, the original contents of the TPicture are discarded and Metafile returns a new, blank metafile (Types of Graphic Objects
).

Note:  When assigning the Metafile property, TPicture assigns the properties of a another TMetafile object. It does not take ownership of the specified value.</summary></devnotes></property>
      <property name="WICImage" visibility="public" read="GetWICImage" write="SetWICImage" type="TWICImage" file="Vcl.Graphics.pas" line="1113"><devnotes><summary>
Embarcadero Technologies does not currently have any additional information.


</summary></devnotes></property>
      <property name="Width" visibility="public" read="GetWidth" type="Integer" file="Vcl.Graphics.pas" line="1114"><devnotes><summary>
Specifies the horizontal size (in pixels) of the picture.
Use Width to find the width of a graphic image. Width contains the native, unstretched, width of the picture.
</summary></devnotes></property>
      <event name="OnChange" visibility="public" read="FOnChange" write="FOnChange" type="TNotifyEvent" file="Vcl.Graphics.pas" line="1115"><devnotes><summary>
Occurs when the specific graphics item encapsulated by the picture object changes.
Use OnChange to write an event handler to process an action when the graphic is modified.


</summary></devnotes></event>
      <event name="OnProgress" visibility="public" read="FOnProgress" write="FOnProgress" type="TProgressEvent" file="Vcl.Graphics.pas" line="1116"><devnotes><summary>
Occurs periodically during slow operations that affect the graphic.
OnProgress is generated by the particular graphic that the picture object contains. Whether OnProgress occurs depends upon the type of graphic in the Graphic property. Some graphics generate this event, others do not. Jpeg images, for example, generate an OnProgress event.
Write an OnProgress event handler to provide the user with feedback during slow operations such as loading large compressed images. TImage, for example, hooks the OnProgress event of TPicture.

Note:  The PercentDone parameter on the event handler is only an approximation. With some image formats, the value of PercentDone may actually decrease from the value in previous events, as the graphic object discovers there is more work to do.
OnProgress is an event handler of type Vcl.Graphics.TProgressEvent.
</summary></devnotes></event>
      <event name="OnFindGraphicClass" visibility="public" read="FOnFindGraphicClass" write="FOnFindGraphicClass" type="TFindGraphicClassEvent" file="Vcl.Graphics.pas" line="1117"><devnotes><summary>
Embarcadero Technologies does not currently have any additional information.


</summary></devnotes></event>
    </members>
  <devnotes><summary>
TPicture contains a bitmap, icon, metafile graphic, or user-defined graphic.
TPicture is a TGraphic container, used to hold a graphic, the type of which is specified in the Graphic property. It is used in place of a TGraphic if the graphic can be of any TGraphic class. LoadFromFile and SaveToFile are polymorphic. For example, if the TPicture is holding an Icon, it is valid to LoadFromFile a bitmap file, where the class TIcon can only read .ICO files.
If the TPicture contains a bitmap graphic, the Bitmap property specifies the graphic. If the TPicture contains an icon graphic, the Icon property specifies the graphic. If the TPicture contains a metafile graphic, the Metafile property specifies the graphic.
The properties of TPicture indicate the type of graphic that the picture object contains, and its size. The methods of TPicture are used to load, save, and manipulate graphics.
To load or save a picture to the Clipboard, use the Assign method of a TClipboard object.
To draw a picture on a canvas, call the Draw or StretchDraw methods of a TCanvas object, passing the Graphic property of a TPicture as a parameter.
</summary></devnotes></class>
  <class name="TMetafileCanvas" file="Vcl.Graphics.pas" line="1190">
    <ancestor name="TCanvas" namespace="Vcl.Graphics">
      <methodref name="CreateBrush" visibility="private"/>
      <methodref name="CreateFont" visibility="private"/>
      <methodref name="CreatePen" visibility="private"/>
      <methodref name="BrushChanged" visibility="private"/>
      <methodref name="DeselectHandles" visibility="private"/>
      <methodref name="FontChanged" visibility="private"/>
      <methodref name="PenChanged" visibility="private"/>
      <methodref name="GetCanvasOrientation" visibility="protected" procflags="override"/>
      <methodref name="GetClipRect" visibility="protected" procflags="override"/>
      <methodref name="GetPenPos" visibility="protected" procflags="override"/>
      <methodref name="GetPixel" visibility="protected" procflags="override"/>
      <methodref name="GetHandle" visibility="protected"/>
      <methodref name="SetBrush" visibility="protected"/>
      <methodref name="SetFont" visibility="protected"/>
      <methodref name="SetHandle" visibility="protected"/>
      <methodref name="SetPen" visibility="protected"/>
      <methodref name="SetPenPos" visibility="protected" procflags="override"/>
      <methodref name="SetPixel" visibility="protected" procflags="override"/>
      <methodref name="CreateHandle" visibility="protected" procflags="virtual"/>
      <methodref name="RequiredState" visibility="protected" procflags="override"/>
      <methodref name="Create" visibility="public" procflags="constructor"/>
      <methodref name="Destroy" visibility="public" procflags="destructor override"/>
      <methodref name="Arc" visibility="public" procflags="override"/>
      <methodref name="ArcTo" visibility="public" procflags="override"/>
      <methodref name="AngleArc" visibility="public" procflags="override"/>
      <methodref name="BrushCopy" visibility="public" procflags="override"/>
      <methodref name="Chord" visibility="public" procflags="override"/>
      <methodref name="CopyRect" visibility="public"/>
      <methodref name="Draw" visibility="public" procflags="overload override"/>
      <methodref name="Draw" visibility="public" procflags="overload override"/>
      <methodref name="DrawFocusRect" visibility="public" procflags="override"/>
      <methodref name="Ellipse" visibility="public" procflags="overload override"/>
      <methodref name="FillRect" visibility="public" procflags="override"/>
      <methodref name="FloodFill" visibility="public" procflags="override"/>
      <methodref name="FrameRect" visibility="public" procflags="override"/>
      <methodref name="HandleAllocated" visibility="public"/>
      <methodref name="LineTo" visibility="public" procflags="override"/>
      <methodref name="MoveTo" visibility="public" procflags="override"/>
      <methodref name="Pie" visibility="public" procflags="override"/>
      <methodref name="Polygon" visibility="public" procflags="override"/>
      <methodref name="Polyline" visibility="public" procflags="override"/>
      <methodref name="PolyBezier" visibility="public" procflags="override"/>
      <methodref name="PolyBezierTo" visibility="public" procflags="override"/>
      <methodref name="Rectangle" visibility="public" procflags="overload override"/>
      <methodref name="Refresh" visibility="public" procflags="override"/>
      <methodref name="RoundRect" visibility="public" procflags="overload override"/>
      <methodref name="StretchDraw" visibility="public" procflags="override"/>
      <methodref name="TextExtent" visibility="public" procflags="override"/>
      <methodref name="TextOut" visibility="public" procflags="override"/>
      <methodref name="TextRect" visibility="public" procflags="overload override"/>
      <methodref name="TextRect" visibility="public" procflags="overload override"/>
      <propertyref name="Handle" visibility="public"/>
      <propertyref name="Brush" visibility="published"/>
      <propertyref name="CopyMode" visibility="published"/>
      <propertyref name="Font" visibility="published"/>
      <propertyref name="Pen" visibility="published"/>
      <ancestor name="TCustomCanvas" namespace="Vcl.Graphics">
        <methodref name="GetCanvasOrientation" visibility="protected" procflags="abstract virtual"/>
        <methodref name="GetClipRect" visibility="protected" procflags="abstract virtual"/>
        <methodref name="GetPenPos" visibility="protected" procflags="abstract virtual"/>
        <methodref name="GetPixel" visibility="protected" procflags="abstract virtual"/>
        <methodref name="SetPenPos" visibility="protected" procflags="abstract virtual"/>
        <methodref name="SetPixel" visibility="protected" procflags="abstract virtual"/>
        <methodref name="Changed" visibility="protected" procflags="virtual"/>
        <methodref name="Changing" visibility="protected" procflags="virtual"/>
        <methodref name="RequiredState" visibility="protected" procflags="abstract virtual"/>
        <methodref name="Arc" visibility="public" procflags="abstract virtual"/>
        <methodref name="ArcTo" visibility="public" procflags="abstract virtual"/>
        <methodref name="AngleArc" visibility="public" procflags="abstract virtual"/>
        <methodref name="BrushCopy" visibility="public" procflags="abstract virtual"/>
        <methodref name="Chord" visibility="public" procflags="abstract virtual"/>
        <methodref name="Draw" visibility="public" procflags="abstract overload virtual"/>
        <methodref name="Draw" visibility="public" procflags="abstract overload virtual"/>
        <methodref name="DrawFocusRect" visibility="public" procflags="abstract virtual"/>
        <methodref name="Ellipse" visibility="public" procflags="abstract overload virtual"/>
        <methodref name="Ellipse" visibility="public" procflags="overload"/>
        <methodref name="FillRect" visibility="public" procflags="abstract virtual"/>
        <methodref name="FloodFill" visibility="public" procflags="abstract virtual"/>
        <methodref name="FrameRect" visibility="public" procflags="abstract virtual"/>
        <methodref name="LineTo" visibility="public" procflags="abstract virtual"/>
        <methodref name="Lock" visibility="public"/>
        <methodref name="MoveTo" visibility="public" procflags="abstract virtual"/>
        <methodref name="Pie" visibility="public" procflags="abstract virtual"/>
        <methodref name="Polygon" visibility="public" procflags="abstract virtual"/>
        <methodref name="Polyline" visibility="public" procflags="abstract virtual"/>
        <methodref name="PolyBezier" visibility="public" procflags="abstract virtual"/>
        <methodref name="PolyBezierTo" visibility="public" procflags="abstract virtual"/>
        <methodref name="Rectangle" visibility="public" procflags="abstract overload virtual"/>
        <methodref name="Rectangle" visibility="public" procflags="overload"/>
        <methodref name="Refresh" visibility="public" procflags="abstract virtual"/>
        <methodref name="RoundRect" visibility="public" procflags="abstract overload virtual"/>
        <methodref name="RoundRect" visibility="public" procflags="overload"/>
        <methodref name="StretchDraw" visibility="public" procflags="abstract virtual"/>
        <methodref name="TextExtent" visibility="public" procflags="abstract virtual"/>
        <methodref name="TextHeight" visibility="public"/>
        <methodref name="TextOut" visibility="public" procflags="abstract virtual"/>
        <methodref name="TextRect" visibility="public" procflags="abstract overload virtual"/>
        <methodref name="TextRect" visibility="public" procflags="abstract overload virtual"/>
        <methodref name="TextWidth" visibility="public"/>
        <methodref name="TryLock" visibility="public"/>
        <methodref name="Unlock" visibility="public"/>
        <propertyref name="ClipRect" visibility="public"/>
        <propertyref name="LockCount" visibility="public"/>
        <propertyref name="CanvasOrientation" visibility="public"/>
        <propertyref name="PenPos" visibility="public"/>
        <propertyref name="Pixels" visibility="public"/>
        <propertyref name="TextFlags" visibility="public"/>
        <eventref name="OnChange" visibility="public"/>
        <eventref name="OnChanging" visibility="public"/>
        <ancestor name="TPersistent" namespace="System.Classes">
          <methodref name="AssignError" visibility="private">
          </methodref>
          <methodref name="AssignTo" visibility="protected" procflags="virtual">
          </methodref>
          <methodref name="DefineProperties" visibility="protected" procflags="virtual">
          </methodref>
          <methodref name="GetOwner" visibility="protected" procflags="dynamic">
          </methodref>
          <methodref name="Destroy" visibility="public" procflags="destructor override">
          </methodref>
          <methodref name="Assign" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="GetNamePath" visibility="public" procflags="dynamic">
          </methodref>
          <ancestor name="TObject" namespace="System">
            <methodref name="Create" visibility="public" procflags="constructor">
            </methodref>
            <methodref name="Free" visibility="public">
            </methodref>
            <methodref name="DisposeOf" visibility="public" procflags="inline">
            </methodref>
            <methodref name="InitInstance" visibility="public" procflags="class">
            </methodref>
            <methodref name="CleanupInstance" visibility="public">
            </methodref>
            <methodref name="ClassType" visibility="public" procflags="inline">
            </methodref>
            <methodref name="ClassName" visibility="public" procflags="class">
            </methodref>
            <methodref name="ClassNameIs" visibility="public" procflags="class">
            </methodref>
            <methodref name="ClassParent" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="ClassInfo" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="InstanceSize" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="InheritsFrom" visibility="public" procflags="class">
            </methodref>
            <methodref name="MethodAddress" visibility="public" procflags="class overload">
            </methodref>
            <methodref name="MethodAddress" visibility="public" procflags="class overload">
            </methodref>
            <methodref name="MethodName" visibility="public" procflags="class">
            </methodref>
            <methodref name="QualifiedClassName" visibility="public" procflags="class">
            </methodref>
            <methodref name="FieldAddress" visibility="public" procflags="overload">
            </methodref>
            <methodref name="FieldAddress" visibility="public" procflags="overload">
            </methodref>
            <methodref name="GetInterface" visibility="public">
            </methodref>
            <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
            </methodref>
            <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="UnitName" visibility="public" procflags="class">
            </methodref>
            <methodref name="UnitScope" visibility="public" procflags="class">
            </methodref>
            <methodref name="Equals" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="GetHashCode" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="ToString" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="SafeCallException" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="AfterConstruction" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="Dispatch" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="DefaultHandler" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="NewInstance" visibility="public" procflags="class virtual">
            </methodref>
            <methodref name="FreeInstance" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="Destroy" visibility="public" procflags="destructor virtual">
            </methodref>
            <methodref name="GetDisposed" visibility="protected" procflags="inline">
            </methodref>
            <methodref name="CheckDisposed" visibility="protected" procflags="inline">
            </methodref>
            <propertyref name="Disposed" visibility="protected">
            </propertyref>
          </ancestor>
        </ancestor>
      </ancestor>
    </ancestor>
    <members>
      <field name="FMetafile" type="TMetafile" visibility="private" size="4" offset="88" file="Vcl.Graphics.pas" line="1192"/>
      <constructor name="Create" visibility="public" file="Vcl.Graphics.pas" line="1197">
        <parameters>
          <parameter name="AMetafile" type="TMetafile"/>
          <parameter name="ReferenceDevice" type="HDC"/>
        </parameters>
      </constructor>
      <constructor name="CreateWithComment" visibility="public" file="Vcl.Graphics.pas" line="1198">
        <parameters>
          <parameter name="AMetafile" type="TMetafile"/>
          <parameter name="ReferenceDevice" type="HDC"/>
          <parameter name="CreatedBy" type="string" paramflags="const"/>
          <parameter name="Description" type="string" paramflags="const"/>
        </parameters>
      </constructor>
      <destructor name="Destroy" visibility="public" file="Vcl.Graphics.pas" line="1200">
        <parameters>
        </parameters>
      </destructor>
    </members>
  </class>
  <class name="TSharedImage" file="Vcl.Graphics.pas" line="1203">
    <ancestor name="TObject" namespace="System">
      <methodref name="Create" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="Free" visibility="public">
      </methodref>
      <methodref name="DisposeOf" visibility="public" procflags="inline">
      </methodref>
      <methodref name="InitInstance" visibility="public" procflags="class">
      </methodref>
      <methodref name="CleanupInstance" visibility="public">
      </methodref>
      <methodref name="ClassType" visibility="public" procflags="inline">
      </methodref>
      <methodref name="ClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassNameIs" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassParent" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="ClassInfo" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InstanceSize" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InheritsFrom" visibility="public" procflags="class">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodName" visibility="public" procflags="class">
      </methodref>
      <methodref name="QualifiedClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="GetInterface" visibility="public">
      </methodref>
      <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
      </methodref>
      <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="UnitName" visibility="public" procflags="class">
      </methodref>
      <methodref name="UnitScope" visibility="public" procflags="class">
      </methodref>
      <methodref name="Equals" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="GetHashCode" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="ToString" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="SafeCallException" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="AfterConstruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Dispatch" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="DefaultHandler" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="NewInstance" visibility="public" procflags="class virtual">
      </methodref>
      <methodref name="FreeInstance" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Destroy" visibility="public" procflags="destructor virtual">
      </methodref>
      <methodref name="GetDisposed" visibility="protected" procflags="inline">
      </methodref>
      <methodref name="CheckDisposed" visibility="protected" procflags="inline">
      </methodref>
      <propertyref name="Disposed" visibility="protected">
      </propertyref>
    </ancestor>
    <members>
      <field name="FRefCount" type="Integer" visibility="private" size="4" offset="4" file="Vcl.Graphics.pas" line="1205"/>
      <procedure name="Reference" visibility="protected" procflags="inline" file="Vcl.Graphics.pas" line="1211">
      </procedure>
      <procedure name="Release" visibility="protected" file="Vcl.Graphics.pas" line="1212">
      </procedure>
      <procedure name="FreeHandle" visibility="protected" procflags="abstract virtual" file="Vcl.Graphics.pas" line="1213">
      </procedure>
      <property name="RefCount" visibility="protected" read="FRefCount" type="Integer" file="Vcl.Graphics.pas" line="1214"/>
      <destructor name="Destroy" visibility="public" file="Vcl.Graphics.pas" line="1216">
        <parameters>
        </parameters>
      </destructor>
    </members>
  </class>
  <class name="TMetafileImage" file="Vcl.Graphics.pas" line="1219">
    <ancestor name="TSharedImage" namespace="Vcl.Graphics">
      <methodref name="Reference" visibility="protected" procflags="inline"/>
      <methodref name="Release" visibility="protected"/>
      <methodref name="FreeHandle" visibility="protected" procflags="abstract virtual"/>
      <propertyref name="RefCount" visibility="protected"/>
      <methodref name="Destroy" visibility="public" procflags="destructor override"/>
      <ancestor name="TObject" namespace="System">
        <methodref name="Create" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="Free" visibility="public">
        </methodref>
        <methodref name="DisposeOf" visibility="public" procflags="inline">
        </methodref>
        <methodref name="InitInstance" visibility="public" procflags="class">
        </methodref>
        <methodref name="CleanupInstance" visibility="public">
        </methodref>
        <methodref name="ClassType" visibility="public" procflags="inline">
        </methodref>
        <methodref name="ClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassNameIs" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassParent" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="ClassInfo" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InstanceSize" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InheritsFrom" visibility="public" procflags="class">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodName" visibility="public" procflags="class">
        </methodref>
        <methodref name="QualifiedClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="GetInterface" visibility="public">
        </methodref>
        <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
        </methodref>
        <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="UnitName" visibility="public" procflags="class">
        </methodref>
        <methodref name="UnitScope" visibility="public" procflags="class">
        </methodref>
        <methodref name="Equals" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetHashCode" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="ToString" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="SafeCallException" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="AfterConstruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Dispatch" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="DefaultHandler" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="NewInstance" visibility="public" procflags="class virtual">
        </methodref>
        <methodref name="FreeInstance" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor virtual">
        </methodref>
        <methodref name="GetDisposed" visibility="protected" procflags="inline">
        </methodref>
        <methodref name="CheckDisposed" visibility="protected" procflags="inline">
        </methodref>
        <propertyref name="Disposed" visibility="protected">
        </propertyref>
      </ancestor>
    </ancestor>
    <members>
      <field name="FHandle" type="NativeUInt" visibility="private" size="4" offset="8" file="Vcl.Graphics.pas" line="1221"/>
      <field name="FWidth" type="Integer" visibility="private" size="4" offset="12" file="Vcl.Graphics.pas" line="1222"/>
      <field name="FHeight" type="Integer" visibility="private" size="4" offset="16" file="Vcl.Graphics.pas" line="1223"/>
      <field name="FPalette" type="HPALETTE" visibility="private" size="4" offset="20" file="Vcl.Graphics.pas" line="1224"/>
      <field name="FInch" type="Word" visibility="private" size="2" offset="24" file="Vcl.Graphics.pas" line="1225"/>
      <field name="FTempWidth" type="Integer" visibility="private" size="4" offset="28" file="Vcl.Graphics.pas" line="1226"/>
      <field name="FTempHeight" type="Integer" visibility="private" size="4" offset="32" file="Vcl.Graphics.pas" line="1227"/>
      <procedure name="FreeHandle" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="1229">
      </procedure>
      <destructor name="Destroy" visibility="public" file="Vcl.Graphics.pas" line="1231">
        <parameters>
        </parameters>
      </destructor>
    </members>
  </class>
  <class name="TMetafile" file="Vcl.Graphics.pas" line="1234">
    <ancestor name="TGraphic" namespace="Vcl.Graphics">
      <interfaces>
        <implements name="IStreamPersist"/>
      </interfaces>
      <methodref name="SetModified" visibility="private"/>
      <methodref name="Changed" visibility="protected" procflags="virtual"/>
      <methodref name="DefineProperties" visibility="protected" procflags="override"/>
      <methodref name="Draw" visibility="protected" procflags="abstract virtual"/>
      <methodref name="DrawTransparent" visibility="protected" procflags="virtual"/>
      <methodref name="Equals" visibility="protected" procflags="overload virtual"/>
      <methodref name="GetEmpty" visibility="protected" procflags="abstract virtual"/>
      <methodref name="GetHeight" visibility="protected" procflags="abstract virtual"/>
      <methodref name="GetPalette" visibility="protected" procflags="virtual"/>
      <methodref name="GetTransparent" visibility="protected" procflags="virtual"/>
      <methodref name="GetWidth" visibility="protected" procflags="abstract virtual"/>
      <methodref name="Progress" visibility="protected" procflags="dynamic"/>
      <methodref name="ReadData" visibility="protected" procflags="virtual"/>
      <methodref name="SetHeight" visibility="protected" procflags="abstract virtual"/>
      <methodref name="SetPalette" visibility="protected" procflags="virtual"/>
      <methodref name="SetTransparent" visibility="protected" procflags="virtual"/>
      <methodref name="SetWidth" visibility="protected" procflags="abstract virtual"/>
      <methodref name="WriteData" visibility="protected" procflags="virtual"/>
      <methodref name="GetSupportsPartialTransparency" visibility="protected" procflags="virtual"/>
      <methodref name="Create" visibility="public" procflags="constructor overload virtual"/>
      <methodref name="Destroy" visibility="public" procflags="destructor override"/>
      <methodref name="Equals" visibility="public" procflags="overload override"/>
      <methodref name="LoadFromFile" visibility="public" procflags="virtual"/>
      <methodref name="SaveToFile" visibility="public" procflags="virtual"/>
      <methodref name="CanLoadFromStream" visibility="public" procflags="class virtual"/>
      <methodref name="LoadFromStream" visibility="public" procflags="abstract virtual"/>
      <methodref name="SaveToStream" visibility="public" procflags="abstract virtual"/>
      <methodref name="LoadFromClipboardFormat" visibility="public" procflags="abstract virtual"/>
      <methodref name="SaveToClipboardFormat" visibility="public" procflags="abstract virtual"/>
      <methodref name="SetSize" visibility="public" procflags="virtual"/>
      <methodref name="EnableScaledDrawer" visibility="public" procflags="virtual"/>
      <methodref name="DisableScaledDrawer" visibility="public" procflags="virtual"/>
      <methodref name="UpdateScaledDrawer" visibility="public" procflags="virtual"/>
      <propertyref name="Empty" visibility="public"/>
      <propertyref name="Height" visibility="public"/>
      <propertyref name="Modified" visibility="public"/>
      <propertyref name="Palette" visibility="public"/>
      <propertyref name="PaletteModified" visibility="public"/>
      <propertyref name="Transparent" visibility="public"/>
      <propertyref name="Width" visibility="public"/>
      <propertyref name="ScaledDrawer" visibility="public"/>
      <eventref name="OnChange" visibility="public"/>
      <eventref name="OnProgress" visibility="public"/>
      <propertyref name="SupportsPartialTransparency" visibility="public"/>
      <ancestor name="TInterfacedPersistent" namespace="System.Classes">
        <interfaces>
          <implements name="IInterface"/>
        </interfaces>
        <methodref name="_AddRef" visibility="protected">
        </methodref>
        <methodref name="_Release" visibility="protected">
        </methodref>
        <methodref name="QueryInterface" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="AfterConstruction" visibility="public" procflags="override">
        </methodref>
        <ancestor name="TPersistent" namespace="System.Classes">
          <methodref name="AssignError" visibility="private">
          </methodref>
          <methodref name="AssignTo" visibility="protected" procflags="virtual">
          </methodref>
          <methodref name="DefineProperties" visibility="protected" procflags="virtual">
          </methodref>
          <methodref name="GetOwner" visibility="protected" procflags="dynamic">
          </methodref>
          <methodref name="Destroy" visibility="public" procflags="destructor override">
          </methodref>
          <methodref name="Assign" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="GetNamePath" visibility="public" procflags="dynamic">
          </methodref>
          <ancestor name="TObject" namespace="System">
            <methodref name="Create" visibility="public" procflags="constructor">
            </methodref>
            <methodref name="Free" visibility="public">
            </methodref>
            <methodref name="DisposeOf" visibility="public" procflags="inline">
            </methodref>
            <methodref name="InitInstance" visibility="public" procflags="class">
            </methodref>
            <methodref name="CleanupInstance" visibility="public">
            </methodref>
            <methodref name="ClassType" visibility="public" procflags="inline">
            </methodref>
            <methodref name="ClassName" visibility="public" procflags="class">
            </methodref>
            <methodref name="ClassNameIs" visibility="public" procflags="class">
            </methodref>
            <methodref name="ClassParent" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="ClassInfo" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="InstanceSize" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="InheritsFrom" visibility="public" procflags="class">
            </methodref>
            <methodref name="MethodAddress" visibility="public" procflags="class overload">
            </methodref>
            <methodref name="MethodAddress" visibility="public" procflags="class overload">
            </methodref>
            <methodref name="MethodName" visibility="public" procflags="class">
            </methodref>
            <methodref name="QualifiedClassName" visibility="public" procflags="class">
            </methodref>
            <methodref name="FieldAddress" visibility="public" procflags="overload">
            </methodref>
            <methodref name="FieldAddress" visibility="public" procflags="overload">
            </methodref>
            <methodref name="GetInterface" visibility="public">
            </methodref>
            <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
            </methodref>
            <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="UnitName" visibility="public" procflags="class">
            </methodref>
            <methodref name="UnitScope" visibility="public" procflags="class">
            </methodref>
            <methodref name="Equals" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="GetHashCode" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="ToString" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="SafeCallException" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="AfterConstruction" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="Dispatch" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="DefaultHandler" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="NewInstance" visibility="public" procflags="class virtual">
            </methodref>
            <methodref name="FreeInstance" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="Destroy" visibility="public" procflags="destructor virtual">
            </methodref>
            <methodref name="GetDisposed" visibility="protected" procflags="inline">
            </methodref>
            <methodref name="CheckDisposed" visibility="protected" procflags="inline">
            </methodref>
            <propertyref name="Disposed" visibility="protected">
            </propertyref>
          </ancestor>
        </ancestor>
      </ancestor>
    </ancestor>
    <members>
      <field name="FImage" type="TMetafileImage" visibility="private" size="4" offset="48" file="Vcl.Graphics.pas" line="1236"/>
      <field name="FEnhanced" type="Boolean" visibility="private" size="1" offset="52" file="Vcl.Graphics.pas" line="1237"/>
      <function name="GetAuthor" visibility="private" file="Vcl.Graphics.pas" line="1238">
        <parameters>
          <retval type="string"/>
        </parameters>
      </function>
      <function name="GetDesc" visibility="private" file="Vcl.Graphics.pas" line="1239">
        <parameters>
          <retval type="string"/>
        </parameters>
      </function>
      <function name="GetHandle" visibility="private" file="Vcl.Graphics.pas" line="1240">
        <parameters>
          <retval type="NativeUInt"/>
        </parameters>
      </function>
      <function name="GetInch" visibility="private" file="Vcl.Graphics.pas" line="1241">
        <parameters>
          <retval type="Word"/>
        </parameters>
      </function>
      <function name="GetMMHeight" visibility="private" file="Vcl.Graphics.pas" line="1242">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="GetMMWidth" visibility="private" file="Vcl.Graphics.pas" line="1243">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      </function>
      <procedure name="NewImage" visibility="private" file="Vcl.Graphics.pas" line="1244">
      </procedure>
      <procedure name="SetHandle" visibility="private" file="Vcl.Graphics.pas" line="1245">
        <parameters>
          <parameter name="Value" type="NativeUInt"/>
        </parameters>
      </procedure>
      <procedure name="SetInch" visibility="private" file="Vcl.Graphics.pas" line="1246">
        <parameters>
          <parameter name="Value" type="Word"/>
        </parameters>
      </procedure>
      <procedure name="SetMMHeight" visibility="private" file="Vcl.Graphics.pas" line="1247">
        <parameters>
          <parameter name="Value" type="Integer"/>
        </parameters>
      </procedure>
      <procedure name="SetMMWidth" visibility="private" file="Vcl.Graphics.pas" line="1248">
        <parameters>
          <parameter name="Value" type="Integer"/>
        </parameters>
      </procedure>
      <procedure name="UniqueImage" visibility="private" file="Vcl.Graphics.pas" line="1249">
      </procedure>
      <function name="GetEmpty" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="1251">
        <parameters>
          <retval type="Boolean"/>
        </parameters>
      <devnotes><summary>
Indicates whether graphics object contains graphic.
Vcl.Graphics.TMetafile.GetEmpty inherits from Vcl.Graphics.TGraphic.GetEmpty. All content below this line refers to Vcl.Graphics.TGraphic.GetEmpty.
Indicates whether graphics object contains graphic.
GetEmpty indicates whether the TGraphic object contains a graphic.
Each descendant of the TGraphic class should override the GetEmpty method to indicate whether a given TGraphic object is bound to an image.
</summary></devnotes></function>
      <function name="GetHeight" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="1252">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      <devnotes><summary>
Get vertical size of graphic in pixels.
Vcl.Graphics.TMetafile.GetHeight inherits from Vcl.Graphics.TGraphic.GetHeight. All content below this line refers to Vcl.Graphics.TGraphic.GetHeight.
Get vertical size of graphic in pixels.
GetHeight gets the vertical size of the TGraphic object in pixels.
Each descendant of TGraphic defines its own GetHeight and SetHeight methods to access the Height property.
</summary></devnotes></function>
      <function name="GetPalette" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="1253">
        <parameters>
          <retval type="HPALETTE"/>
        </parameters>
      <devnotes><summary>
Get color palette of graphical image.
Vcl.Graphics.TMetafile.GetPalette inherits from Vcl.Graphics.TGraphic.GetPalette. All content below this line refers to Vcl.Graphics.TGraphic.GetPalette.
Get color palette of graphical image.
GetPalette gets the color palette of the graphical image. You can also use the Palette property to get the color palette of a graphical image. If the graphic does not need or use a palette, the Palette property is zero.
</summary></devnotes></function>
      <function name="GetWidth" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="1254">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      <devnotes><summary>
Get horizontal size of graphic in pixels.
Vcl.Graphics.TMetafile.GetWidth inherits from Vcl.Graphics.TGraphic.GetWidth. All content below this line refers to Vcl.Graphics.TGraphic.GetWidth.
Get horizontal size of graphic in pixels.
GetWidth gets the horizontal size of the graphic in pixels.
Each descendant of the TGraphic class defines its own GetWidth and SetWidth methods to access the Width property. 
</summary></devnotes></function>
      <procedure name="Draw" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="1255">
        <parameters>
          <parameter name="ACanvas" type="TCanvas"/>
          <parameter name="Rect" type="TRect" paramflags="const"/>
        </parameters>
      <devnotes><summary>
Render graphic onto canvas at rectangle.
Vcl.Graphics.TMetafile.Draw inherits from Vcl.Graphics.TGraphic.Draw. All content below this line refers to Vcl.Graphics.TGraphic.Draw.
Render graphic onto canvas at rectangle.
TCanvas.Draw calls this function to render the graphic onto its canvas at the coordinates specified by the Rect parameter. Descendants of TGraphic should override this function with a specific rendering implementation.
</summary></devnotes></procedure>
      <procedure name="ReadData" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="1256">
        <parameters>
          <parameter name="Stream" type="TStream"/>
        </parameters>
      <devnotes><summary>
Read graphic data from TStream.
Vcl.Graphics.TMetafile.ReadData inherits from Vcl.Graphics.TGraphic.ReadData. All content below this line refers to Vcl.Graphics.TGraphic.ReadData.
Read graphic data from TStream.
ReadData is used to read the binary graphic from the virtual property Data (created by DefineProperties) when streaming in a TGraphic from the TStream Stream.
</summary></devnotes></procedure>
      <procedure name="ReadEMFStream" visibility="protected" file="Vcl.Graphics.pas" line="1257">
        <parameters>
          <parameter name="Stream" type="TStream"/>
        </parameters>
      <devnotes><summary>
Embarcadero Technologies does not currently have any additional information.


</summary></devnotes></procedure>
      <procedure name="ReadWMFStream" visibility="protected" file="Vcl.Graphics.pas" line="1258">
        <parameters>
          <parameter name="Stream" type="TStream"/>
          <parameter name="Length" type="Integer"/>
        </parameters>
      <devnotes><summary>
Embarcadero Technologies does not currently have any additional information.


</summary></devnotes></procedure>
      <procedure name="SetHeight" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="1259">
        <parameters>
          <parameter name="Value" type="Integer"/>
        </parameters>
      <devnotes><summary>
Set vertical size of graphic in pixels.
Vcl.Graphics.TMetafile.SetHeight inherits from Vcl.Graphics.TGraphic.SetHeight. All content below this line refers to Vcl.Graphics.TGraphic.SetHeight.
Set vertical size of graphic in pixels.
SetHeight sets the vertical size of the graphic in pixels.
Each descendant of the TGraphic class defines its own GetHeight and SetHeight methods to access the Height property. 
</summary></devnotes></procedure>
      <procedure name="SetTransparent" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="1260">
        <parameters>
          <parameter name="Value" type="Boolean"/>
        </parameters>
      <devnotes><summary>
Specify if graphic should be drawn transparently.
Vcl.Graphics.TMetafile.SetTransparent inherits from Vcl.Graphics.TGraphic.SetTransparent. All content below this line refers to Vcl.Graphics.TGraphic.SetTransparent.
Specify if graphic should be drawn transparently.
SetTransparent specifies if a graphic should be drawn transparently.
</summary></devnotes></procedure>
      <procedure name="SetWidth" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="1261">
        <parameters>
          <parameter name="Value" type="Integer"/>
        </parameters>
      <devnotes><summary>
Set horizontal size of graphic in pixels.
Vcl.Graphics.TMetafile.SetWidth inherits from Vcl.Graphics.TGraphic.SetWidth. All content below this line refers to Vcl.Graphics.TGraphic.SetWidth.
Set horizontal size of graphic in pixels.
SetWidth sets the horizontal size of the graphic in pixels.
Each descendant of the TGraphic class defines its own GetWidth and SetWidth methods to access the Width property. 
</summary></devnotes></procedure>
      <function name="TestEMF" visibility="protected" procflags="class" file="Vcl.Graphics.pas" line="1262">
        <parameters>
          <parameter name="Stream" type="TStream"/>
          <retval type="Boolean"/>
        </parameters>
      <devnotes><summary>
Embarcadero Technologies does not currently have any additional information.


</summary></devnotes></function>
      <procedure name="WriteData" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="1263">
        <parameters>
          <parameter name="Stream" type="TStream"/>
        </parameters>
      <devnotes><summary>
Write graphic data to TStream.
Vcl.Graphics.TMetafile.WriteData inherits from Vcl.Graphics.TGraphic.WriteData. All content below this line refers to Vcl.Graphics.TGraphic.WriteData.
Write graphic data to TStream.
WriteData is used to write the binary graphic to the virtual property Data (created by DefineProperties) when streaming a TGraphic out to the TStream Stream.
</summary></devnotes></procedure>
      <procedure name="WriteEMFStream" visibility="protected" file="Vcl.Graphics.pas" line="1264">
        <parameters>
          <parameter name="Stream" type="TStream"/>
        </parameters>
      <devnotes><summary>
Embarcadero Technologies does not currently have any additional information.


</summary></devnotes></procedure>
      <procedure name="WriteWMFStream" visibility="protected" file="Vcl.Graphics.pas" line="1265">
        <parameters>
          <parameter name="Stream" type="TStream"/>
        </parameters>
      <devnotes><summary>
Embarcadero Technologies does not currently have any additional information.


</summary></devnotes></procedure>
      <constructor name="Create" visibility="public" file="Vcl.Graphics.pas" line="1267">
        <parameters>
        </parameters>
      <devnotes><summary>
Instantiates a metafile object.
Call Create to instantiate a metafile at runtime.
Create allocates memory for a metafile object, and calls the inherited Create. Then sets the Enhanced and Transparent properties to true.
To create a metafile image from scratch, draw the image in a metafile canvas. When the metafile canvas is destroyed, it transfers the image into the metafile object provided to the metafile canvas constructor. After the image is drawn on the canvas and the canvas is destroyed, the image is 'playable' in the metafile object.
</summary></devnotes></constructor>
      <destructor name="Destroy" visibility="public" file="Vcl.Graphics.pas" line="1268">
        <parameters>
        </parameters>
      <devnotes><summary>
Destroys an instance of a metafile object.
Do not call Destroy directly in an application. Instead, an application should call Free. Free verifies that the TMetafile reference is not nil before it calls Destroy.
Destroy releases the image, which frees the image and the handle when the reference count on the metafile image is zero. Then Destroy calls the inherited Destroy.
</summary></devnotes></destructor>
      <procedure name="Clear" visibility="public" file="Vcl.Graphics.pas" line="1269">
      <devnotes><summary>
Deletes the metafile image.
Use Clear to release the old metafile image, create a new image, and increment a reference count on it.
</summary></devnotes></procedure>
      <function name="HandleAllocated" visibility="public" file="Vcl.Graphics.pas" line="1270">
        <parameters>
          <retval type="Boolean"/>
        </parameters>
      <devnotes><summary>
Indicates whether the TMetafile object has acquired a handle to the underlying GDI object.
Use HandleAllocated to determine whether the Handle property is set to an HMETAFILE value. HandleAllocated indicates whether the underlying GDI object has already been created. Use HandleAllocated rather than reading the Handle property. When an application reads the Handle property, it automatically creates a metafile and returns its handle if the underlying GDI object does not already exist.
</summary></devnotes></function>
      <function name="CanLoadFromStream" visibility="public" procflags="class override" file="Vcl.Graphics.pas" line="1271">
        <parameters>
          <parameter name="Stream" type="TStream"/>
          <retval type="Boolean"/>
        </parameters>
      <devnotes><summary>

Vcl.Graphics.TMetafile.CanLoadFromStream inherits from Vcl.Graphics.TGraphic.CanLoadFromStream. All content below this line refers to Vcl.Graphics.TGraphic.CanLoadFromStream.
CanLoadFromStream returns True when a specified stream contains a streamed image of a specific TGraphic subclass. 
The method uses current stream position, it does not change current stream position.


</summary></devnotes></function>
      <procedure name="LoadFromStream" visibility="public" procflags="override" file="Vcl.Graphics.pas" line="1272">
        <parameters>
          <parameter name="Stream" type="TStream"/>
        </parameters>
      <devnotes><summary>
Loads the metafile from a stream.
Use LoadFromStream by specifying the stream from which the metafile is loaded as the value of Stream. LoadFromStream reads a metafile from a stream and replaces the current image with it.
</summary></devnotes></procedure>
      <procedure name="SaveToFile" visibility="public" procflags="override" file="Vcl.Graphics.pas" line="1273">
        <parameters>
          <parameter name="Filename" type="string" paramflags="const"/>
        </parameters>
      <devnotes><summary>
Writes the metafile to disk.
Use SaveToFile to save the metafile to a file provided by the Filename parameter. To load a metafile from a file, call the LoadFromFile method.

 Note: If the Filename parameter has an extension of &quot;.wmf&quot;, the metafile is saved as a WMF file. It is not necessary to set the Enhanced property.

</summary></devnotes></procedure>
      <procedure name="SaveToStream" visibility="public" procflags="override" file="Vcl.Graphics.pas" line="1274">
        <parameters>
          <parameter name="Stream" type="TStream"/>
        </parameters>
      <devnotes><summary>
Writes the metafile to a stream.
Use SaveToStream to save the metafile to the stream specified by the Stream parameter. 
If the Enhanced property is True, the metafile is saved as an EMF; if False, it it saved as a WMF. 
</summary></devnotes></procedure>
      <procedure name="LoadFromClipboardFormat" visibility="public" procflags="override" file="Vcl.Graphics.pas" line="1275">
        <parameters>
          <parameter name="AFormat" type="Word"/>
          <parameter name="AData" type="NativeUInt"/>
          <parameter name="APalette" type="HPALETTE"/>
        </parameters>
      <devnotes><summary>
Loads a metafile from the Clipboard.
LoadFromClipboardFormat replaces the current image with the data in the clipboard. LoadFromClipboardFormat ignores the AData and APalette parameters. 
</summary></devnotes></procedure>
      <procedure name="SaveToClipboardFormat" visibility="public" procflags="override" file="Vcl.Graphics.pas" line="1277">
        <parameters>
          <parameter name="AFormat" type="Word" paramflags="var"/>
          <parameter name="AData" type="NativeUInt" paramflags="var"/>
          <parameter name="APalette" type="HPALETTE" paramflags="var"/>
        </parameters>
      <devnotes><summary>
Saves a metafile to a Clipboard format.
Use SaveToClipboardFormat to copy the metafile to a Clipboard format. The resulting values can then be copied to the Windows clipboard using the clipboard's SetAsHandle method.
The metafile's palette is returned in the APalette parameter, the format in the AFormat parameter, and a handle to the data in the AData parameter. Before the metafile can be saved, an application must have registered the format with the metafile object using the RegisterClipboardFormat method.
To save a metafile to a file, call SaveToFile.
</summary></devnotes></procedure>
      <procedure name="Assign" visibility="public" procflags="override" file="Vcl.Graphics.pas" line="1279">
        <parameters>
          <parameter name="Source" type="TPersistent"/>
        </parameters>
      <devnotes><summary>
Copies an object to the metafile.
Assign copies the Enhanced and Palette properties of an object to the metafile. If the metafile is nil (Delphi) or NULL (C++), Assign creates one. Otherwise, Assign calls the inherited method. For assignment, metafiles are polymorphic with other TGraphic objects, and with TPicture.
</summary></devnotes></procedure>
      <function name="ReleaseHandle" visibility="public" file="Vcl.Graphics.pas" line="1280">
        <parameters>
          <retval type="NativeUInt"/>
        </parameters>
      <devnotes><summary>
Releases the Windows GDI object represented by the metafile.
Call ReleaseHandle to release the resources used to represent the metafile. ReleaseHandle sets the Handle property to nil. NULL. 
Call ReleaseHandle before setting the Handle property, so that the resources associated with the metafile are not lost.
</summary></devnotes></function>
      <procedure name="SetSize" visibility="public" procflags="override" file="Vcl.Graphics.pas" line="1281">
        <parameters>
          <parameter name="AWidth" type="Integer"/>
          <parameter name="AHeight" type="Integer"/>
        </parameters>
      <devnotes><summary>
Specifies the size of the metafile.
Use the SetSize method to set both the height and width of the metafile. This results in better performance than setting the height and width separately.


</summary></devnotes></procedure>
      <property name="CreatedBy" visibility="public" read="GetAuthor" type="string" default="0" file="Vcl.Graphics.pas" line="1282"><devnotes><summary>
Specifies the name of the author or application used to create the metafile.
Use CreatedBy to set the string to an optional name of the author or application used to create the metafile. To set the CreatedBy string of a new metafile, call the TMetafileCanvas CreateWithComment constructor (Delphi) or the TMetafileCanvas constructor that takes a comment (C++).
</summary></devnotes></property>
      <property name="Description" visibility="public" read="GetDesc" type="string" default="0" file="Vcl.Graphics.pas" line="1283"><devnotes><summary>
Provides an optional text description that is embedded in the metafile.
Set the Description string of a new metafile by calling the TMetafileCanvas CreateWithComment constructor (Delphi) or the TMetafileCanvas constructor that takes a comment (C++)..
</summary></devnotes></property>
      <property name="Enhanced" visibility="public" read="FEnhanced" write="FEnhanced" type="Boolean" default="1" file="Vcl.Graphics.pas" line="1284"><devnotes><summary>
Determines how the metafile will be stored on disk.
Use Enhanced to determine how the metafile is stored on disk. If Enhanced is True, the metafile is stored as an .EMF (Win32 Enhanced Metafile). If Enhanced is False, the metafile is stored as a .WMF (Windows 3.1 Metafile, with Aldus header).
The in-memory format is always EMF. WMF has very limited capabilities; storing as WMF will lose information that would be retained by EMF. This property is set to match the metafile type when loaded from a stream or file. If loaded as WMF, then save as WMF.
By default, the Enhanced property is True.
</summary></devnotes></property>
      <property name="Handle" visibility="public" read="GetHandle" write="SetHandle" type="NativeUInt" file="Vcl.Graphics.pas" line="1285"><devnotes><summary>
Provides access to the Windows GDI metafile handle, for accessing the GDI metafile object.
Use Handle when calling a Windows API function that requires the handle of a metafile object. Pass the handle from the Handle property of the metafile object to the function.
</summary></devnotes></property>
      <property name="MMWidth" visibility="public" read="GetMMWidth" write="SetMMWidth" type="Integer" file="Vcl.Graphics.pas" line="1286"><devnotes><summary>
Contains the width of the metafile image in 0.01 millimeter units, the native scale used by enhanced metafiles.
MMWidth is used for a more accurate reading of the horizontal size of the graphic. The Width property, by contrast, is always in screen device pixel units; to avoid loss of precision in converting between device pixels and millimeters, set or read the dimensions in millimeters with MMWidth.
The MMWidth property is always in screen device pixel units. 
</summary></devnotes></property>
      <property name="MMHeight" visibility="public" read="GetMMHeight" write="SetMMHeight" type="Integer" file="Vcl.Graphics.pas" line="1287"><devnotes><summary>
Contains the height of the metafile image in 0.01 millimeter units, the native scale used by enhanced metafiles.
MMHeight is used for a more accurate reading of the vertical size of the graphic. The Height property, by contrast, is always in screen device pixel units; to avoid loss of precision in converting between device pixels and millimeters, set or read the dimensions in millimeters with MMHeight.
</summary></devnotes></property>
      <property name="Inch" visibility="public" read="GetInch" write="SetInch" type="Word" file="Vcl.Graphics.pas" line="1288"><devnotes><summary>
Returns the units per inch that are used for the metafile's coordinate mapping.
Use Inch to find the units per inch assumed by a WMF metafile, and to alter scale when writing as WMF, but otherwise this property is obsolete. Enhanced metafiles maintain complete scale information internally. For example, if the metafile was created in a Twips coordinate system (using MM_TWIPS mapping), the value of Inch is 1440.


</summary></devnotes></property>
    </members>
  <devnotes><summary>
TMetafile is an encapsulation of the Win32 Enhanced metafile.
TMetafile contains a metafile graphic (EMF file format).
Properties of TMetafile indicate the size and characteristics of the metafile.
To draw a metafile on a canvas, call the Draw or StretchDraw methods of a TCanvas object, passing a TMetafile as a parameter. The Enhanced property determines how the metafile will be stored on disk. If Enhanced is true, the metafile is stored as an .EMF (Win32 Enhanced Metafile) file. If Enhanced is false, the metafile is stored as a .WMF (Windows 3.1 Metafile, with Aldus header).
</summary></devnotes></class>
  <class name="TBitmapImage" file="Vcl.Graphics.pas" line="1311">
    <ancestor name="TSharedImage" namespace="Vcl.Graphics">
      <methodref name="Reference" visibility="protected" procflags="inline"/>
      <methodref name="Release" visibility="protected"/>
      <methodref name="FreeHandle" visibility="protected" procflags="abstract virtual"/>
      <propertyref name="RefCount" visibility="protected"/>
      <methodref name="Destroy" visibility="public" procflags="destructor override"/>
      <ancestor name="TObject" namespace="System">
        <methodref name="Create" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="Free" visibility="public">
        </methodref>
        <methodref name="DisposeOf" visibility="public" procflags="inline">
        </methodref>
        <methodref name="InitInstance" visibility="public" procflags="class">
        </methodref>
        <methodref name="CleanupInstance" visibility="public">
        </methodref>
        <methodref name="ClassType" visibility="public" procflags="inline">
        </methodref>
        <methodref name="ClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassNameIs" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassParent" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="ClassInfo" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InstanceSize" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InheritsFrom" visibility="public" procflags="class">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodName" visibility="public" procflags="class">
        </methodref>
        <methodref name="QualifiedClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="GetInterface" visibility="public">
        </methodref>
        <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
        </methodref>
        <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="UnitName" visibility="public" procflags="class">
        </methodref>
        <methodref name="UnitScope" visibility="public" procflags="class">
        </methodref>
        <methodref name="Equals" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetHashCode" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="ToString" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="SafeCallException" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="AfterConstruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Dispatch" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="DefaultHandler" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="NewInstance" visibility="public" procflags="class virtual">
        </methodref>
        <methodref name="FreeInstance" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor virtual">
        </methodref>
        <methodref name="GetDisposed" visibility="protected" procflags="inline">
        </methodref>
        <methodref name="CheckDisposed" visibility="protected" procflags="inline">
        </methodref>
        <propertyref name="Disposed" visibility="protected">
        </propertyref>
      </ancestor>
    </ancestor>
    <members>
      <field name="FHandle" type="HBITMAP" visibility="private" size="4" offset="8" file="Vcl.Graphics.pas" line="1313"/>
      <field name="FMaskHandle" type="HBITMAP" visibility="private" size="4" offset="12" file="Vcl.Graphics.pas" line="1314"/>
      <field name="FPalette" type="HPALETTE" visibility="private" size="4" offset="16" file="Vcl.Graphics.pas" line="1315"/>
      <field name="FDIBHandle" type="HBITMAP" visibility="private" size="4" offset="20" file="Vcl.Graphics.pas" line="1316"/>
      <field name="FSaveStream" type="TMemoryStream" visibility="private" size="4" offset="24" file="Vcl.Graphics.pas" line="1317"/>
      <field name="FHalftone" type="Boolean" visibility="private" size="1" offset="28" file="Vcl.Graphics.pas" line="1318"/>
      <field name="FOS2Format" type="Boolean" visibility="private" size="1" offset="29" file="Vcl.Graphics.pas" line="1322"/>
      <field name="FDIB" type="tagDIBSECTION" visibility="protected" size="84" offset="32" file="Vcl.Graphics.pas" line="1325"/>
      <procedure name="FreeHandle" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="1326">
      </procedure>
      <destructor name="Destroy" visibility="public" file="Vcl.Graphics.pas" line="1328">
        <parameters>
        </parameters>
      </destructor>
    </members>
  </class>
  <enum name="TBitmapHandleType" file="Vcl.Graphics.pas" line="1334">
    <element value="0" name="bmDIB" file="Vcl.Graphics.pas" line="1334"/>
    <element value="1" name="bmDDB" file="Vcl.Graphics.pas" line="1334"/>
  </enum>
  <enum name="TPixelFormat" file="Vcl.Graphics.pas" line="1335">
    <element value="0" name="pfDevice" file="Vcl.Graphics.pas" line="1335"/>
    <element value="1" name="pf1bit" file="Vcl.Graphics.pas" line="1335"/>
    <element value="2" name="pf4bit" file="Vcl.Graphics.pas" line="1335"/>
    <element value="3" name="pf8bit" file="Vcl.Graphics.pas" line="1335"/>
    <element value="4" name="pf15bit" file="Vcl.Graphics.pas" line="1335"/>
    <element value="5" name="pf16bit" file="Vcl.Graphics.pas" line="1335"/>
    <element value="6" name="pf24bit" file="Vcl.Graphics.pas" line="1335"/>
    <element value="7" name="pf32bit" file="Vcl.Graphics.pas" line="1335"/>
    <element value="8" name="pfCustom" file="Vcl.Graphics.pas" line="1335"/>
  </enum>
  <enum name="TAlphaFormat" file="Vcl.Graphics.pas" line="1336">
    <element value="0" name="afIgnored" file="Vcl.Graphics.pas" line="1336"/>
    <element value="1" name="afDefined" file="Vcl.Graphics.pas" line="1336"/>
    <element value="2" name="afPremultiplied" file="Vcl.Graphics.pas" line="1336"/>
  </enum>
  <enum name="TTransparentMode" file="Vcl.Graphics.pas" line="1337">
    <element value="0" name="tmAuto" file="Vcl.Graphics.pas" line="1337"/>
    <element value="1" name="tmFixed" file="Vcl.Graphics.pas" line="1337"/>
  </enum>
  <class name="TBitmap" file="Vcl.Graphics.pas" line="1339">
    <ancestor name="TGraphic" namespace="Vcl.Graphics">
      <interfaces>
        <implements name="IStreamPersist"/>
      </interfaces>
      <methodref name="SetModified" visibility="private"/>
      <methodref name="Changed" visibility="protected" procflags="virtual"/>
      <methodref name="DefineProperties" visibility="protected" procflags="override"/>
      <methodref name="Draw" visibility="protected" procflags="abstract virtual"/>
      <methodref name="DrawTransparent" visibility="protected" procflags="virtual"/>
      <methodref name="Equals" visibility="protected" procflags="overload virtual"/>
      <methodref name="GetEmpty" visibility="protected" procflags="abstract virtual"/>
      <methodref name="GetHeight" visibility="protected" procflags="abstract virtual"/>
      <methodref name="GetPalette" visibility="protected" procflags="virtual"/>
      <methodref name="GetTransparent" visibility="protected" procflags="virtual"/>
      <methodref name="GetWidth" visibility="protected" procflags="abstract virtual"/>
      <methodref name="Progress" visibility="protected" procflags="dynamic"/>
      <methodref name="ReadData" visibility="protected" procflags="virtual"/>
      <methodref name="SetHeight" visibility="protected" procflags="abstract virtual"/>
      <methodref name="SetPalette" visibility="protected" procflags="virtual"/>
      <methodref name="SetTransparent" visibility="protected" procflags="virtual"/>
      <methodref name="SetWidth" visibility="protected" procflags="abstract virtual"/>
      <methodref name="WriteData" visibility="protected" procflags="virtual"/>
      <methodref name="GetSupportsPartialTransparency" visibility="protected" procflags="virtual"/>
      <methodref name="Create" visibility="public" procflags="constructor overload virtual"/>
      <methodref name="Destroy" visibility="public" procflags="destructor override"/>
      <methodref name="Equals" visibility="public" procflags="overload override"/>
      <methodref name="LoadFromFile" visibility="public" procflags="virtual"/>
      <methodref name="SaveToFile" visibility="public" procflags="virtual"/>
      <methodref name="CanLoadFromStream" visibility="public" procflags="class virtual"/>
      <methodref name="LoadFromStream" visibility="public" procflags="abstract virtual"/>
      <methodref name="SaveToStream" visibility="public" procflags="abstract virtual"/>
      <methodref name="LoadFromClipboardFormat" visibility="public" procflags="abstract virtual"/>
      <methodref name="SaveToClipboardFormat" visibility="public" procflags="abstract virtual"/>
      <methodref name="SetSize" visibility="public" procflags="virtual"/>
      <methodref name="EnableScaledDrawer" visibility="public" procflags="virtual"/>
      <methodref name="DisableScaledDrawer" visibility="public" procflags="virtual"/>
      <methodref name="UpdateScaledDrawer" visibility="public" procflags="virtual"/>
      <propertyref name="Empty" visibility="public"/>
      <propertyref name="Height" visibility="public"/>
      <propertyref name="Modified" visibility="public"/>
      <propertyref name="Palette" visibility="public"/>
      <propertyref name="PaletteModified" visibility="public"/>
      <propertyref name="Transparent" visibility="public"/>
      <propertyref name="Width" visibility="public"/>
      <propertyref name="ScaledDrawer" visibility="public"/>
      <eventref name="OnChange" visibility="public"/>
      <eventref name="OnProgress" visibility="public"/>
      <propertyref name="SupportsPartialTransparency" visibility="public"/>
      <ancestor name="TInterfacedPersistent" namespace="System.Classes">
        <interfaces>
          <implements name="IInterface"/>
        </interfaces>
        <methodref name="_AddRef" visibility="protected">
        </methodref>
        <methodref name="_Release" visibility="protected">
        </methodref>
        <methodref name="QueryInterface" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="AfterConstruction" visibility="public" procflags="override">
        </methodref>
        <ancestor name="TPersistent" namespace="System.Classes">
          <methodref name="AssignError" visibility="private">
          </methodref>
          <methodref name="AssignTo" visibility="protected" procflags="virtual">
          </methodref>
          <methodref name="DefineProperties" visibility="protected" procflags="virtual">
          </methodref>
          <methodref name="GetOwner" visibility="protected" procflags="dynamic">
          </methodref>
          <methodref name="Destroy" visibility="public" procflags="destructor override">
          </methodref>
          <methodref name="Assign" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="GetNamePath" visibility="public" procflags="dynamic">
          </methodref>
          <ancestor name="TObject" namespace="System">
            <methodref name="Create" visibility="public" procflags="constructor">
            </methodref>
            <methodref name="Free" visibility="public">
            </methodref>
            <methodref name="DisposeOf" visibility="public" procflags="inline">
            </methodref>
            <methodref name="InitInstance" visibility="public" procflags="class">
            </methodref>
            <methodref name="CleanupInstance" visibility="public">
            </methodref>
            <methodref name="ClassType" visibility="public" procflags="inline">
            </methodref>
            <methodref name="ClassName" visibility="public" procflags="class">
            </methodref>
            <methodref name="ClassNameIs" visibility="public" procflags="class">
            </methodref>
            <methodref name="ClassParent" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="ClassInfo" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="InstanceSize" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="InheritsFrom" visibility="public" procflags="class">
            </methodref>
            <methodref name="MethodAddress" visibility="public" procflags="class overload">
            </methodref>
            <methodref name="MethodAddress" visibility="public" procflags="class overload">
            </methodref>
            <methodref name="MethodName" visibility="public" procflags="class">
            </methodref>
            <methodref name="QualifiedClassName" visibility="public" procflags="class">
            </methodref>
            <methodref name="FieldAddress" visibility="public" procflags="overload">
            </methodref>
            <methodref name="FieldAddress" visibility="public" procflags="overload">
            </methodref>
            <methodref name="GetInterface" visibility="public">
            </methodref>
            <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
            </methodref>
            <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="UnitName" visibility="public" procflags="class">
            </methodref>
            <methodref name="UnitScope" visibility="public" procflags="class">
            </methodref>
            <methodref name="Equals" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="GetHashCode" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="ToString" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="SafeCallException" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="AfterConstruction" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="Dispatch" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="DefaultHandler" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="NewInstance" visibility="public" procflags="class virtual">
            </methodref>
            <methodref name="FreeInstance" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="Destroy" visibility="public" procflags="destructor virtual">
            </methodref>
            <methodref name="GetDisposed" visibility="protected" procflags="inline">
            </methodref>
            <methodref name="CheckDisposed" visibility="protected" procflags="inline">
            </methodref>
            <propertyref name="Disposed" visibility="protected">
            </propertyref>
          </ancestor>
        </ancestor>
      </ancestor>
    </ancestor>
    <members>
      <field name="FCanvas" type="TCanvas" visibility="private" size="4" offset="48" file="Vcl.Graphics.pas" line="1341"/>
      <field name="FIgnorePalette" type="Boolean" visibility="private" size="1" offset="52" file="Vcl.Graphics.pas" line="1342"/>
      <field name="FMaskBitsValid" type="Boolean" visibility="private" size="1" offset="53" file="Vcl.Graphics.pas" line="1343"/>
      <field name="FMaskValid" type="Boolean" visibility="private" size="1" offset="54" file="Vcl.Graphics.pas" line="1344"/>
      <field name="FTransparentColor" type="TColor" visibility="private" size="4" offset="56" file="Vcl.Graphics.pas" line="1345"/>
      <field name="FTransparentMode" type="TTransparentMode" visibility="private" size="1" offset="60" file="Vcl.Graphics.pas" line="1346"/>
      <procedure name="Changing" visibility="private" file="Vcl.Graphics.pas" line="1347">
        <parameters>
          <parameter name="Sender" type="TObject"/>
        </parameters>
      </procedure>
      <procedure name="CopyImage" visibility="private" file="Vcl.Graphics.pas" line="1348">
        <parameters>
          <parameter name="AHandle" type="HBITMAP"/>
          <parameter name="APalette" type="HPALETTE"/>
          <parameter name="DIB" type="tagDIBSECTION"/>
        </parameters>
      </procedure>
      <procedure name="DIBNeeded" visibility="private" file="Vcl.Graphics.pas" line="1349">
      </procedure>
      <procedure name="FreeContext" visibility="private" file="Vcl.Graphics.pas" line="1350">
      </procedure>
      <function name="GetCanvas" visibility="private" file="Vcl.Graphics.pas" line="1351">
        <parameters>
          <retval type="TCanvas"/>
        </parameters>
      </function>
      <function name="GetHandle" visibility="private" procflags="virtual" file="Vcl.Graphics.pas" line="1352">
        <parameters>
          <retval type="HBITMAP"/>
        </parameters>
      </function>
      <function name="GetHandleType" visibility="private" file="Vcl.Graphics.pas" line="1353">
        <parameters>
          <retval type="TBitmapHandleType"/>
        </parameters>
      </function>
      <function name="GetMaskHandle" visibility="private" procflags="virtual" file="Vcl.Graphics.pas" line="1354">
        <parameters>
          <retval type="HBITMAP"/>
        </parameters>
      </function>
      <function name="GetMonochrome" visibility="private" file="Vcl.Graphics.pas" line="1355">
        <parameters>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <function name="GetPixelFormat" visibility="private" file="Vcl.Graphics.pas" line="1356">
        <parameters>
          <retval type="TPixelFormat"/>
        </parameters>
      </function>
      <function name="GetTransparentColor" visibility="private" file="Vcl.Graphics.pas" line="1357">
        <parameters>
          <retval type="TColor"/>
        </parameters>
      </function>
      <procedure name="ReadStream" visibility="private" file="Vcl.Graphics.pas" line="1358">
        <parameters>
          <parameter name="Stream" type="TStream"/>
          <parameter name="Size" type="Integer"/>
        </parameters>
      </procedure>
      <procedure name="SetHandle" visibility="private" file="Vcl.Graphics.pas" line="1359">
        <parameters>
          <parameter name="Value" type="HBITMAP"/>
        </parameters>
      </procedure>
      <procedure name="SetHandleType" visibility="private" procflags="virtual" file="Vcl.Graphics.pas" line="1360">
        <parameters>
          <parameter name="Value" type="TBitmapHandleType"/>
        </parameters>
      </procedure>
      <procedure name="SetMaskHandle" visibility="private" file="Vcl.Graphics.pas" line="1361">
        <parameters>
          <parameter name="Value" type="HBITMAP"/>
        </parameters>
      </procedure>
      <procedure name="SetMonochrome" visibility="private" file="Vcl.Graphics.pas" line="1362">
        <parameters>
          <parameter name="Value" type="Boolean"/>
        </parameters>
      </procedure>
      <procedure name="SetPixelFormat" visibility="private" file="Vcl.Graphics.pas" line="1363">
        <parameters>
          <parameter name="Value" type="TPixelFormat"/>
        </parameters>
      </procedure>
      <procedure name="SetTransparentColor" visibility="private" file="Vcl.Graphics.pas" line="1364">
        <parameters>
          <parameter name="Value" type="TColor"/>
        </parameters>
      </procedure>
      <procedure name="SetTransparentMode" visibility="private" file="Vcl.Graphics.pas" line="1365">
        <parameters>
          <parameter name="Value" type="TTransparentMode"/>
        </parameters>
      </procedure>
      <function name="TransparentColorStored" visibility="private" file="Vcl.Graphics.pas" line="1366">
        <parameters>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <procedure name="WriteStream" visibility="private" file="Vcl.Graphics.pas" line="1367">
        <parameters>
          <parameter name="Stream" type="TStream"/>
          <parameter name="WriteSize" type="Boolean"/>
        </parameters>
      </procedure>
      <function name="GetScanline" visibility="private" file="Vcl.Graphics.pas" line="1379">
        <parameters>
          <parameter name="Row" type="Integer"/>
          <retval type="Pointer"/>
        </parameters>
      </function>
      <procedure name="NewImage" visibility="private" file="Vcl.Graphics.pas" line="1380">
        <parameters>
          <parameter name="NewHandle" type="HBITMAP"/>
          <parameter name="NewPalette" type="HPALETTE"/>
          <parameter name="NewDIB" type="tagDIBSECTION" paramflags="const"/>
          <parameter name="OS2Format" type="Boolean"/>
          <parameter name="RLEStream" type="TStream">
            <value>
              nil
            </value>
          </parameter>
        </parameters>
      </procedure>
      <procedure name="ReadDIB" visibility="private" file="Vcl.Graphics.pas" line="1382">
        <parameters>
          <parameter name="Stream" type="TStream"/>
          <parameter name="ImageSize" type="Cardinal"/>
          <parameter name="bmf" type="PBitmapFileHeader">
            <value>
              nil
            </value>
          </parameter>
        </parameters>
      </procedure>
      <procedure name="PreMultiplyAlpha" visibility="private" file="Vcl.Graphics.pas" line="1384">
      </procedure>
      <procedure name="UnPreMultiplyAlpha" visibility="private" file="Vcl.Graphics.pas" line="1385">
      </procedure>
      <procedure name="SetAlphaFormat" visibility="private" file="Vcl.Graphics.pas" line="1386">
        <parameters>
          <parameter name="Value" type="TAlphaFormat"/>
        </parameters>
      </procedure>
      <field name="FImage" type="TBitmapImage" visibility="protected" size="4" offset="64" file="Vcl.Graphics.pas" line="1388"/>
      <field name="FAlphaFormat" type="TAlphaFormat" visibility="protected" size="1" offset="68" file="Vcl.Graphics.pas" line="1389"/>
      <function name="GetSupportsPartialTransparency" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="1390">
        <parameters>
          <retval type="Boolean"/>
        </parameters>
      <devnotes><summary>
Indicate whether graphic supports partial transparency.
Vcl.Graphics.TBitmap.GetSupportsPartialTransparency inherits from Vcl.Graphics.TGraphic.GetSupportsPartialTransparency. All content below this line refers to Vcl.Graphics.TGraphic.GetSupportsPartialTransparency.
Indicate whether graphic supports partial transparency.
GetSupportsPartialTransparency indicates whether the graphic supports partial transparency.
TGraphic descendants should override GetSupportsPartialTransparency if they are capable of having partially transparent pixels.
</summary></devnotes></function>
      <procedure name="Changed" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="1391">
        <parameters>
          <parameter name="Sender" type="TObject"/>
        </parameters>
      <devnotes><summary>
Called when graphic has changed.
Vcl.Graphics.TBitmap.Changed inherits from Vcl.Graphics.TGraphic.Changed. All content below this line refers to Vcl.Graphics.TGraphic.Changed.
Called when graphic has changed.
Changed is called automatically whenever the TGraphic object is modified. It sets the Modified property to True and triggers the OnChange event.
</summary></devnotes></procedure>
      <procedure name="Draw" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="1392">
        <parameters>
          <parameter name="ACanvas" type="TCanvas"/>
          <parameter name="Rect" type="TRect" paramflags="const"/>
        </parameters>
      <devnotes><summary>
Render graphic onto canvas at rectangle.
Vcl.Graphics.TBitmap.Draw inherits from Vcl.Graphics.TGraphic.Draw. All content below this line refers to Vcl.Graphics.TGraphic.Draw.
Render graphic onto canvas at rectangle.
TCanvas.Draw calls this function to render the graphic onto its canvas at the coordinates specified by the Rect parameter. Descendants of TGraphic should override this function with a specific rendering implementation.
</summary></devnotes></procedure>
      <procedure name="DrawTransparent" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="1393">
        <parameters>
          <parameter name="ACanvas" type="TCanvas"/>
          <parameter name="Rect" type="TRect" paramflags="const"/>
          <parameter name="Opacity" type="Byte"/>
        </parameters>
      <devnotes><summary>
Render graphic onto canvas at rectangle, blending with canvas's background.
Vcl.Graphics.TBitmap.DrawTransparent inherits from Vcl.Graphics.TGraphic.DrawTransparent. All content below this line refers to Vcl.Graphics.TGraphic.DrawTransparent.
Render graphic onto canvas at rectangle, blending with canvas's background.
DrawTransparent renders the graphic onto a canvas at the coordinates specified by the Rect parameter, blending it with the canvas's background.
</summary></devnotes></procedure>
      <function name="GetEmpty" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="1394">
        <parameters>
          <retval type="Boolean"/>
        </parameters>
      <devnotes><summary>
Indicates whether graphics object contains graphic.
Vcl.Graphics.TBitmap.GetEmpty inherits from Vcl.Graphics.TGraphic.GetEmpty. All content below this line refers to Vcl.Graphics.TGraphic.GetEmpty.
Indicates whether graphics object contains graphic.
GetEmpty indicates whether the TGraphic object contains a graphic.
Each descendant of the TGraphic class should override the GetEmpty method to indicate whether a given TGraphic object is bound to an image.
</summary></devnotes></function>
      <function name="GetHeight" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="1395">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      <devnotes><summary>
Get vertical size of graphic in pixels.
Vcl.Graphics.TBitmap.GetHeight inherits from Vcl.Graphics.TGraphic.GetHeight. All content below this line refers to Vcl.Graphics.TGraphic.GetHeight.
Get vertical size of graphic in pixels.
GetHeight gets the vertical size of the TGraphic object in pixels.
Each descendant of TGraphic defines its own GetHeight and SetHeight methods to access the Height property.
</summary></devnotes></function>
      <function name="GetPalette" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="1396">
        <parameters>
          <retval type="HPALETTE"/>
        </parameters>
      <devnotes><summary>
Get color palette of graphical image.
Vcl.Graphics.TBitmap.GetPalette inherits from Vcl.Graphics.TGraphic.GetPalette. All content below this line refers to Vcl.Graphics.TGraphic.GetPalette.
Get color palette of graphical image.
GetPalette gets the color palette of the graphical image. You can also use the Palette property to get the color palette of a graphical image. If the graphic does not need or use a palette, the Palette property is zero.
</summary></devnotes></function>
      <function name="GetWidth" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="1397">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      <devnotes><summary>
Get horizontal size of graphic in pixels.
Vcl.Graphics.TBitmap.GetWidth inherits from Vcl.Graphics.TGraphic.GetWidth. All content below this line refers to Vcl.Graphics.TGraphic.GetWidth.
Get horizontal size of graphic in pixels.
GetWidth gets the horizontal size of the graphic in pixels.
Each descendant of the TGraphic class defines its own GetWidth and SetWidth methods to access the Width property. 
</summary></devnotes></function>
      <procedure name="HandleNeeded" visibility="protected" file="Vcl.Graphics.pas" line="1398">
      <devnotes><summary>
Create GDI bitmap for TBitmap if it doesn't already exist.
HandleNeeded creates a GDI bitmap for the TBitmap if it doesn't already exist. 
</summary></devnotes></procedure>
      <procedure name="MaskHandleNeeded" visibility="protected" file="Vcl.Graphics.pas" line="1399">
      <devnotes><summary>
Create GDI bitmap for TBitmap's mask if it doesn't already exist.
MaskHandleNeeded is called to create a GDI bitmap for the TBitmap object's mask if it doesn't already exist.
</summary></devnotes></procedure>
      <procedure name="PaletteNeeded" visibility="protected" file="Vcl.Graphics.pas" line="1400">
      <devnotes><summary>
Create color palette for TBitmap's mask if it doesn't already exist.
PaletteNeeded is called to create a color palette for the TBitmap object if it doesn't already exist. A palette is not created if IgnorePalette is true. IgnorePalette is set to true if a palette can't be created.
</summary></devnotes></procedure>
      <procedure name="ReadData" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="1401">
        <parameters>
          <parameter name="Stream" type="TStream"/>
        </parameters>
      <devnotes><summary>
Read graphic data from TStream.
Vcl.Graphics.TBitmap.ReadData inherits from Vcl.Graphics.TGraphic.ReadData. All content below this line refers to Vcl.Graphics.TGraphic.ReadData.
Read graphic data from TStream.
ReadData is used to read the binary graphic from the virtual property Data (created by DefineProperties) when streaming in a TGraphic from the TStream Stream.
</summary></devnotes></procedure>
      <procedure name="SetHeight" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="1402">
        <parameters>
          <parameter name="Value" type="Integer"/>
        </parameters>
      <devnotes><summary>
Set vertical size of graphic in pixels.
Vcl.Graphics.TBitmap.SetHeight inherits from Vcl.Graphics.TGraphic.SetHeight. All content below this line refers to Vcl.Graphics.TGraphic.SetHeight.
Set vertical size of graphic in pixels.
SetHeight sets the vertical size of the graphic in pixels.
Each descendant of the TGraphic class defines its own GetHeight and SetHeight methods to access the Height property. 
</summary></devnotes></procedure>
      <procedure name="SetPalette" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="1403">
        <parameters>
          <parameter name="Value" type="HPALETTE"/>
        </parameters>
      <devnotes><summary>
Set color palette of graphical image.
Vcl.Graphics.TBitmap.SetPalette inherits from Vcl.Graphics.TGraphic.SetPalette. All content below this line refers to Vcl.Graphics.TGraphic.SetPalette.
Set color palette of graphical image.
SetPalette sets the color palette of the graphical image.
Use the Palette property to get the color palette of a graphical image. If the graphic does not need or does not use a palette, the Palette property is zero.
</summary></devnotes></procedure>
      <procedure name="SetWidth" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="1404">
        <parameters>
          <parameter name="Value" type="Integer"/>
        </parameters>
      <devnotes><summary>
Set horizontal size of graphic in pixels.
Vcl.Graphics.TBitmap.SetWidth inherits from Vcl.Graphics.TGraphic.SetWidth. All content below this line refers to Vcl.Graphics.TGraphic.SetWidth.
Set horizontal size of graphic in pixels.
SetWidth sets the horizontal size of the graphic in pixels.
Each descendant of the TGraphic class defines its own GetWidth and SetWidth methods to access the Width property. 
</summary></devnotes></procedure>
      <procedure name="WriteData" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="1405">
        <parameters>
          <parameter name="Stream" type="TStream"/>
        </parameters>
      <devnotes><summary>
Write graphic data to TStream.
Vcl.Graphics.TBitmap.WriteData inherits from Vcl.Graphics.TGraphic.WriteData. All content below this line refers to Vcl.Graphics.TGraphic.WriteData.
Write graphic data to TStream.
WriteData is used to write the binary graphic to the virtual property Data (created by DefineProperties) when streaming a TGraphic out to the TStream Stream.
</summary></devnotes></procedure>
      <constructor name="Create" visibility="public" file="Vcl.Graphics.pas" line="1407">
        <parameters>
        </parameters>
      <devnotes><summary>
Instantiates a bitmap object.
Call Create to instantiate a bitmap object at runtime. Create is also called automatically when a bitmap image is loaded into a TImage.
Create allocates memory for a bitmap object, and calls the inherited Create. Then it creates a TBitmapImage as the internal image that represents the bitmap.
</summary></devnotes></constructor>
      <constructor name="Create" visibility="public" file="Vcl.Graphics.pas" line="1408">
        <parameters>
          <parameter name="AWidth" type="Integer"/>
          <parameter name="AHeight" type="Integer"/>
        </parameters>
      <devnotes><summary>
Instantiates a bitmap object.
Call Create to instantiate a bitmap object at runtime. Create is also called automatically when a bitmap image is loaded into a TImage.
Create allocates memory for a bitmap object, and calls the inherited Create. Then it creates a TBitmapImage as the internal image that represents the bitmap.
</summary></devnotes></constructor>
      <destructor name="Destroy" visibility="public" file="Vcl.Graphics.pas" line="1409">
        <parameters>
        </parameters>
      <devnotes><summary>
Disposes of the instance of the bitmap object.
Destroy is the destructor for a TBitmap object.
Do not call the destructor directly in an application. Instead, call Free. Free verifies that the bitmap object is not nil before it calls Destroy.
Destroy releases the internal bitmap image (TBitmapImage object) and frees the canvas before calling the inherited destructor.
</summary></devnotes></destructor>
      <procedure name="Assign" visibility="public" procflags="override" file="Vcl.Graphics.pas" line="1410">
        <parameters>
          <parameter name="Source" type="TPersistent"/>
        </parameters>
      <devnotes><summary>
Copies a new bitmap image to the bitmap object.
Assign copies the bitmap image contained in Source to the bitmap object. If Source is not a bitmap, Assign calls the inherited Assign method, which can copy an image from any class that knows how to copy to a TBitmap object. If the bitmap needs to be changed, the actual bitmap image is copied before the changes are made (copy on write).

Note:  An object of one type can always be assigned to another object of the same type. Also, the Source can be of type TPicture if the Graphic property of the picture is a bitmap.</summary></devnotes></procedure>
      <procedure name="Dormant" visibility="public" file="Vcl.Graphics.pas" line="1411">
      <devnotes><summary>
Creates a memory bitmap image in order to release the bitmap handle, forcing the image into DIB format to save resources.
Use Dormant to change the format of the bitmap in memory thereby reducing the amount of GDI resources used by the application.
Dormant creates a bitmap image in memory using a memory stream object. This preserves the image so that the bitmap can then free the HBITMAP (accessed through the Handle property) that was assigned to it.
DIB handles may use fewer Win95 GDI resources than DDB, but DIBs may also use more memory than DDBs, depending on the current video driver and mode.
</summary></devnotes></procedure>
      <procedure name="FreeImage" visibility="public" file="Vcl.Graphics.pas" line="1412">
      <devnotes><summary>
Frees the cached file image stored in memory by the bitmap.
Use FreeImage to reduce the memory requirements of an application when color depth and pixel format are not an issue. Freeing the image releases the memory allocated for the bitmap image when it was originally loaded to disk. Consequently, some of the original pixel format of the bitmap is lost (for example, if you changed its format to a DIB) as well as the color depth of the bitmap.
When a bitmap is loaded into a bitmap object, the bitmap object creates an image of the loaded bitmap in memory. If the bitmap isn't changed, the memory image is used when saving the bitmap, to verify that the bitmap has not lost color depth or changed the pixel format.

Code Examples
LoadFromFile (Delphi)
LoadFromFile (C++)



</summary></devnotes></procedure>
      <function name="HandleAllocated" visibility="public" file="Vcl.Graphics.pas" line="1413">
        <parameters>
          <retval type="Boolean"/>
        </parameters>
      <devnotes><summary>
Indicates whether the TBitmap object has acquired a handle to the underlying GDI object.
Use HandleAllocated to determine whether the Handle property is set to an HBITMAP value. HandleAllocated indicates whether the underlying GDI object has already been created. Use HandleAllocated rather than reading the Handle property. When an application reads the Handle property, it automatically creates a bitmap and returns its handle if the underlying GDI object does not already exist.
</summary></devnotes></function>
      <procedure name="LoadFromClipboardFormat" visibility="public" procflags="override" file="Vcl.Graphics.pas" line="1414">
        <parameters>
          <parameter name="AFormat" type="Word"/>
          <parameter name="AData" type="NativeUInt"/>
          <parameter name="APalette" type="HPALETTE"/>
        </parameters>
      <devnotes><summary>
Loads a bitmap from the Clipboard into the bitmap object.
LoadFromClipboardFormat is called if the bitmap is registered with the TPicture object using the RegisterClipboardFormat method.
LoadFromClipboardFormat replaces the current image with the data pointed to by the AData parameter. The palette for the bitmap is specified by the APalette parameter.
The following code snippet shows how to load a bitmap from the clipboard and use that picture to draw on the canvas of the form.

Note: To load a bitmap into the clipboard, you can use the code snippet for the SaveToClipboardFormat method.

Delphi:

uses
  Vcl.Clipbrd;

procedure TForm1.Button1Click(Sender: TObject);
var
  Bitmap : TBitmap;
begin
 Bitmap := TBitMap.Create;
 try
   Bitmap.LoadFromClipBoardFormat(cf_BitMap, ClipBoard.GetAsHandle(cf_Bitmap), 0);
   Canvas.draw(0,0,Bitmap);
 finally
   Bitmap.Free;
   Clipboard.Clear;
 end;
end;



C++:

#include &lt;Vcl.Clipbrd.hpp&gt;

void __fastcall TForm1::Button1Click(TObject *Sender){
	TBitmap* Bitmap;
	TClipboard* cb = Clipboard();

	Bitmap = new TBitmap();
	try{
		Bitmap-&gt;LoadFromClipboardFormat(CF_BITMAP, cb-&gt;GetAsHandle(CF_BITMAP), 0);
		Canvas-&gt;Draw(0,0,Bitmap);
	}
	__finally{
		delete Bitmap;
		cb-&gt;Clear();
	}
}

</summary></devnotes></procedure>
      <function name="CanLoadFromStream" visibility="public" procflags="class override" file="Vcl.Graphics.pas" line="1416">
        <parameters>
          <parameter name="Stream" type="TStream"/>
          <retval type="Boolean"/>
        </parameters>
      <devnotes><summary>

Vcl.Graphics.TBitmap.CanLoadFromStream inherits from Vcl.Graphics.TGraphic.CanLoadFromStream. All content below this line refers to Vcl.Graphics.TGraphic.CanLoadFromStream.
CanLoadFromStream returns True when a specified stream contains a streamed image of a specific TGraphic subclass. 
The method uses current stream position, it does not change current stream position.


</summary></devnotes></function>
      <procedure name="LoadFromStream" visibility="public" procflags="override" file="Vcl.Graphics.pas" line="1417">
        <parameters>
          <parameter name="Stream" type="TStream"/>
        </parameters>
      <devnotes><summary>
Loads the bitmap from a stream into the bitmap object.
Use LoadFromStream to load the bitmap image from a stream. The Stream parameter specifies the stream from which to read the bitmap image. For example, use LoadFromStream to load a bitmap image from a BLOB stream that reads from a graphic field in a dataset.
</summary></devnotes></procedure>
      <procedure name="Mask" visibility="public" file="Vcl.Graphics.pas" line="1418">
        <parameters>
          <parameter name="TransparentColor" type="TColor"/>
        </parameters>
      <devnotes><summary>
Converts the current bitmap image into a monochrome mask, replacing TransparentColor with white and every other color with black.
Use Mask to produce a monochrome mask bitmap based on a given transparent color. Mask produces the same image that MaskHandle does, except that the resulting mask image replaces the image in the TBitmap object, so it only makes sense to call Mask once. Use MaskHandle when only a bitmap handle of the mask image is needed. 
</summary></devnotes></procedure>
      <function name="ReleaseHandle" visibility="public" file="Vcl.Graphics.pas" line="1419">
        <parameters>
          <retval type="HBITMAP"/>
        </parameters>
      <devnotes><summary>
Returns the handle to the bitmap so that the TBitmap object no longer knows about the handle.
Use ReleaseHandle to disassociate the bitmap from the bitmap handle. Use it when you need to give a bitmap handle to a routine or object that will assume ownership (or destroy) the bitmap handle.
</summary></devnotes></function>
      <function name="ReleaseMaskHandle" visibility="public" file="Vcl.Graphics.pas" line="1420">
        <parameters>
          <retval type="HBITMAP"/>
        </parameters>
      <devnotes><summary>
Returns the handle to the bitmap's mask so that the TBitmap object no longer knows about the mask handle.
Use ReleaseMaskHandle to disassociate the bitmap object from the bitmap mask handle.
</summary></devnotes></function>
      <function name="ReleasePalette" visibility="public" file="Vcl.Graphics.pas" line="1421">
        <parameters>
          <retval type="HPALETTE"/>
        </parameters>
      <devnotes><summary>
Returns the handle to the bitmap's palette and disassociates the palette from the TBitmap object.
Use ReleasePalette to disassociate the palette from the bitmap image.


</summary></devnotes></function>
      <procedure name="SaveToClipboardFormat" visibility="public" procflags="override" file="Vcl.Graphics.pas" line="1422">
        <parameters>
          <parameter name="Format" type="Word" paramflags="var"/>
          <parameter name="Data" type="NativeUInt" paramflags="var"/>
          <parameter name="APalette" type="HPALETTE" paramflags="var"/>
        </parameters>
      <devnotes><summary>
Creates a local copy of the bitmap in Clipboard format.
Use SaveToClipboardFormat to copy the bitmap to a Clipboard format. The bitmap's palette is returned in the APalette parameter, the format in the AFormat parameter, and a handle to the data in the AData parameter. Before the bitmap can be saved, an application must have registered the format with the TBitmap object using the RegisterClipboardFormat method.
The following code snippet shows how to save a bitmap to the clipboard.

Note: To load a bitmap from the clipboard, you can use the code snippet for the LoadFromClipboardFormat method.

Delphi:

uses
  Vcl.Clipbrd;

procedure TForm1.Button1Click(Sender: TObject);
var
  MyFormat : Word;
  Bitmap : TBitMap;
  AData : THandle;
  APalette : HPALETTE;
begin
  Bitmap := TBitmap.Create;
  try
    Bitmap.LoadFromFile('C:\Users\Public\Pictures\Sample Pictures\desert.bmp');
    Bitmap.SaveToClipBoardFormat(MyFormat, AData, APalette);
    ClipBoard.SetAsHandle(MyFormat,AData);
  finally
    Bitmap.Free;
  end;
end;



C++:

#include &lt;Vcl.Clipbrd.hpp&gt;

void __fastcall TForm1::Button1Click(TObject *Sender){
	TClipboard* cb = Clipboard();
	unsigned short MyFormat;
	TBitmap* Bitmap;
	unsigned int AData;
	HPALETTE APalette;

	Bitmap = new TBitmap();
	try{
		Bitmap-&gt;LoadFromFile(&quot;C:\\Users\\Public\\Pictures\\Sample Pictures\\desert.bmp&quot;);
		Bitmap-&gt;SaveToClipboardFormat(MyFormat, AData, APalette);
		cb-&gt;SetAsHandle(MyFormat, AData);
	}
	__finally{
		delete Bitmap;
	}
}

</summary></devnotes></procedure>
      <procedure name="SaveToStream" visibility="public" procflags="override" file="Vcl.Graphics.pas" line="1424">
        <parameters>
          <parameter name="Stream" type="TStream"/>
        </parameters>
      <devnotes><summary>
Saves the bitmap to a stream.
Use SaveToStream to write the bitmap image to the stream specified by the Stream parameter. For example, specify a TBlobStream object as the Stream parameter to save the bitmap image to a graphic field in a dataset.
</summary></devnotes></procedure>
      <procedure name="SetSize" visibility="public" procflags="override" file="Vcl.Graphics.pas" line="1425">
        <parameters>
          <parameter name="AWidth" type="Integer"/>
          <parameter name="AHeight" type="Integer"/>
        </parameters>
      <devnotes><summary>
Specifies the size of the bitmap.
Use the SetSize method to set both the height and width of the bitmap. This results in better performance than setting the height and width separately.


</summary></devnotes></procedure>
      <procedure name="LoadFromResourceName" visibility="public" file="Vcl.Graphics.pas" line="1440">
        <parameters>
          <parameter name="Instance" type="NativeUInt"/>
          <parameter name="ResName" type="string" paramflags="const"/>
        </parameters>
      <devnotes><summary>
Loads a bitmap resource into the bitmap object.
LoadFromResourceName loads the specified bitmap resource along with palette information from a module's executable file.
Instance is the handle of the module that contains the resource.
ResName is the name of the resource to load.

Note:  Use this routine to load bitmaps from RES files instead of the LoadBitmap API. LoadBitmap does not support 256-color images.</summary></devnotes></procedure>
      <procedure name="LoadFromResourceID" visibility="public" file="Vcl.Graphics.pas" line="1442">
        <parameters>
          <parameter name="Instance" type="NativeUInt"/>
          <parameter name="ResID" type="Integer"/>
        </parameters>
      <devnotes><summary>
Loads a bitmap from a resource into the bitmap object.
Use LoadFromResourceID to load a specified bitmap resource along with palette information from a module's executable file. 
Instance is the handle of the module that contains the resource.
ResID is the resource ID for the bitmap.
</summary></devnotes></procedure>
      <property name="Canvas" visibility="public" read="GetCanvas" type="TCanvas" file="Vcl.Graphics.pas" line="1445"><devnotes><summary>
Provides access to a drawing surface that represents the bitmap.
Canvas allows drawing on the bitmap by providing a T Canvas object for this purpose. Drawing on the canvas effectively modifies the underlying bitmap image pixels. Any canvas operation is valid on a bitmap (not just Draw and StretchDraw) including line drawing, rectangles, and circles. The bitmap object is passed as a parameter to these methods.
A canvas object is created automatically for the bitmap and the property is read-only.
</summary></devnotes></property>
      <property name="Handle" visibility="public" read="GetHandle" write="SetHandle" type="HBITMAP" file="Vcl.Graphics.pas" line="1446"><devnotes><summary>
Provides access to the Windows GDI bitmap handle for accessing the GDI bitmap object.
Use Handle to call a Windows API function that requires the handle of a bitmap object (HBITMAP). Pass Handle as the bitmap handle parameter to these functions.
Handle is the HBITMAP encapsulated by the bitmap object. Avoid grabbing the handle directly since it causes the HBITMAP to be copied if more than one TBitmap shares the handle.

Warning:  Be careful when giving the handle to an object or routine. If the receiver takes ownership (and destroys) the bitmap handle, call ReleaseHandle.</summary></devnotes></property>
      <property name="HandleType" visibility="public" read="GetHandleType" write="SetHandleType" type="TBitmapHandleType" file="Vcl.Graphics.pas" line="1447"><devnotes><summary>
Indicates whether the bitmap is a device-dependent bitmap, or a device-independent bitmap.
HandleType is used to find or modify the type of the bitmap. Device-dependent bitmaps (DDBs) may be faster to draw on the screen, but may be stored in memory in a device-specific format. Device-independent bitmaps (DIBs) are stored in memory in a standard format supported by all devices (including printers).
</summary></devnotes></property>
      <property name="IgnorePalette" visibility="public" read="FIgnorePalette" write="FIgnorePalette" type="Boolean" file="Vcl.Graphics.pas" line="1448"><devnotes><summary>
Determines whether the bitmap realizes its palette when drawing its image.
Use IgnorePalette when speed of drawing is a priority. When IgnorePalette is true, the bitmap does not realize its palette when drawing itself, resulting in lower picture quality on 256-color video drivers, but faster drawing of the bitmap image.

Note: </summary></devnotes></property>
      <property name="MaskHandle" visibility="public" read="GetMaskHandle" write="SetMaskHandle" type="HBITMAP" file="Vcl.Graphics.pas" line="1449"><devnotes><summary>
Provides access to the Windows GDI bitmap handle for accessing the GDI bitmap object.
Use MaskHandle to call a Windows API function that requires the handle of a bitmap object. Pass MaskHandle as the bitmap handle parameter to these functions. MaskHandle is the HBITMAP encapsulated by the bitmap object's mask.
</summary></devnotes></property>
      <property name="Monochrome" visibility="public" read="GetMonochrome" write="SetMonochrome" type="Boolean" file="Vcl.Graphics.pas" line="1450"><devnotes><summary>
Determines whether the bitmap displays its image in monochrome.
If Monochrome is true if the bitmap displays as a monochrome bitmap. Monochrome is false if the bitmap displays in color, that is, if it contains more than one bit per pixel.

Note: 
Code Examples
LoadFromFile (Delphi)
LoadFromFile (C++)



</summary></devnotes></property>
      <property name="PixelFormat" visibility="public" read="GetPixelFormat" write="SetPixelFormat" type="TPixelFormat" file="Vcl.Graphics.pas" line="1451"><devnotes><summary>
Indicates the bit format of the bitmap image, specifying how the image is displayed and how the pixels of the bitmap image are stored in memory.
Use PixelFormat to change a TBitmap's internal image to a particular memory format and color depth, or to find out what memory format and color depth a TBitmap is using. The possible formats are specified in TPixelFormat.
For example, PixelFormat can be used to set the pixel format of the bitmap image to 8-bit for video drivers that cannot display the native format of a bitmap image. 

Note: The PixelFormat of a JPEG image object applies to the bitmap if the JPEG image is copied to it.
Changing the pixel format is most commonly used with ScanLine, because your code must decode the pixel data accessed by ScanLine. Image-editing tools usually use one pixel for all internal image operations and copy the results to the screen (in whatever format) as the last step.
</summary></devnotes></property>
      <property name="TransparentColor" visibility="public" read="GetTransparentColor" write="SetTransparentColor" stored="TransparentColorStored" type="TColor" file="Vcl.Graphics.pas" line="1452"><devnotes><summary>
Determines which color of the bitmap is to be transparent when the bitmap is drawn.
Use TransparentColor to determine how to draw the bitmap transparently. When the TransparentMode property is set to tmAuto (default), TransparentColor returns the color of the first pixel in the bitmap image data. For &quot;bottom-up&quot; bitmaps, the first pixel is the bottom leftmost pixel shown onscreen. For &quot;top-down&quot; bitmaps (less common), the first pixel is in the top left corner shown onscreen. 
If TransparentColor is assigned, the TransparentMode is automatically set to tmFixed so that the new transparent color can be used later. If you want TransparentColor to disregard any assignments and return the bottom leftmost pixel color again, set TransparentMode to tmAuto.
</summary></devnotes></property>
      <property name="TransparentMode" visibility="public" read="FTransparentMode" write="SetTransparentMode" type="TTransparentMode" default="0" file="Vcl.Graphics.pas" line="1454"><devnotes><summary>
Determines whether the TransparentColor property's value is automatically calculated or stored with the bitmap object.
When TransparentMode is set to tmAuto (the default), the TransparentColor property returns the color of the bottom-leftmost pixel of the bitmap image. When TransparentMode is set to tmFixed, the TransparentColor property refers to the color stored in the bitmap object.
</summary></devnotes></property>
      <property name="ScanLine[Row]" visibility="public" read="GetScanline" type="Pointer" file="Vcl.Graphics.pas" line="1460"/>
      <property name="AlphaFormat" visibility="public" read="FAlphaFormat" write="SetAlphaFormat" type="TAlphaFormat" file="Vcl.Graphics.pas" line="1462"><devnotes><summary>
Indicates how reserved byte of each pixel is used in 32 bit bitmaps.
Use AlphaFormat to change the way a TBitmap uses the reserved byte of each pixel in a 32bit Bitmap.
</summary></devnotes></property>
    </members>
  <devnotes><summary>
TBitmap is an encapsulation of a Windows bitmap (HBITMAP), including its palette (HPALETTE).
A bitmap is a powerful graphics object used to create, manipulate and store images in memory and as files on a disk.
TBitmap contains an internal image of the bitmap graphic and automatically manages realization of the palette when drawn. 
To draw a bitmap on a canvas, call the Draw or StretchDraw methods of a TCanvas object, passing a TBitmap as a parameter.
Creating copies of a TBitmap is very fast since the handle is copied rather than the image. If the image is modified and the handle is shared by more than one TBitmap object, the image is copied before the modification is performed (that is, copy on write).
</summary></devnotes></class>
  <class name="TIconImage" file="Vcl.Graphics.pas" line="1470">
    <ancestor name="TSharedImage" namespace="Vcl.Graphics">
      <methodref name="Reference" visibility="protected" procflags="inline"/>
      <methodref name="Release" visibility="protected"/>
      <methodref name="FreeHandle" visibility="protected" procflags="abstract virtual"/>
      <propertyref name="RefCount" visibility="protected"/>
      <methodref name="Destroy" visibility="public" procflags="destructor override"/>
      <ancestor name="TObject" namespace="System">
        <methodref name="Create" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="Free" visibility="public">
        </methodref>
        <methodref name="DisposeOf" visibility="public" procflags="inline">
        </methodref>
        <methodref name="InitInstance" visibility="public" procflags="class">
        </methodref>
        <methodref name="CleanupInstance" visibility="public">
        </methodref>
        <methodref name="ClassType" visibility="public" procflags="inline">
        </methodref>
        <methodref name="ClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassNameIs" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassParent" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="ClassInfo" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InstanceSize" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InheritsFrom" visibility="public" procflags="class">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodName" visibility="public" procflags="class">
        </methodref>
        <methodref name="QualifiedClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="GetInterface" visibility="public">
        </methodref>
        <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
        </methodref>
        <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="UnitName" visibility="public" procflags="class">
        </methodref>
        <methodref name="UnitScope" visibility="public" procflags="class">
        </methodref>
        <methodref name="Equals" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetHashCode" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="ToString" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="SafeCallException" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="AfterConstruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Dispatch" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="DefaultHandler" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="NewInstance" visibility="public" procflags="class virtual">
        </methodref>
        <methodref name="FreeInstance" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor virtual">
        </methodref>
        <methodref name="GetDisposed" visibility="protected" procflags="inline">
        </methodref>
        <methodref name="CheckDisposed" visibility="protected" procflags="inline">
        </methodref>
        <propertyref name="Disposed" visibility="protected">
        </propertyref>
      </ancestor>
    </ancestor>
    <members>
      <field name="FMemoryImage" type="TCustomMemoryStream" visibility="private" size="4" offset="8" file="Vcl.Graphics.pas" line="1472"/>
      <field name="FSize" type="TPoint" visibility="private" size="8" offset="12" file="Vcl.Graphics.pas" line="1473"/>
      <field name="FHandle" type="HICON" visibility="private" size="4" offset="20" file="Vcl.Graphics.pas" line="1477"/>
      <procedure name="FreeHandle" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="1480">
      </procedure>
      <destructor name="Destroy" visibility="public" file="Vcl.Graphics.pas" line="1482">
        <parameters>
        </parameters>
      </destructor>
    </members>
  </class>
  <class name="TIcon" file="Vcl.Graphics.pas" line="1485">
    <ancestor name="TGraphic" namespace="Vcl.Graphics">
      <interfaces>
        <implements name="IStreamPersist"/>
      </interfaces>
      <methodref name="SetModified" visibility="private"/>
      <methodref name="Changed" visibility="protected" procflags="virtual"/>
      <methodref name="DefineProperties" visibility="protected" procflags="override"/>
      <methodref name="Draw" visibility="protected" procflags="abstract virtual"/>
      <methodref name="DrawTransparent" visibility="protected" procflags="virtual"/>
      <methodref name="Equals" visibility="protected" procflags="overload virtual"/>
      <methodref name="GetEmpty" visibility="protected" procflags="abstract virtual"/>
      <methodref name="GetHeight" visibility="protected" procflags="abstract virtual"/>
      <methodref name="GetPalette" visibility="protected" procflags="virtual"/>
      <methodref name="GetTransparent" visibility="protected" procflags="virtual"/>
      <methodref name="GetWidth" visibility="protected" procflags="abstract virtual"/>
      <methodref name="Progress" visibility="protected" procflags="dynamic"/>
      <methodref name="ReadData" visibility="protected" procflags="virtual"/>
      <methodref name="SetHeight" visibility="protected" procflags="abstract virtual"/>
      <methodref name="SetPalette" visibility="protected" procflags="virtual"/>
      <methodref name="SetTransparent" visibility="protected" procflags="virtual"/>
      <methodref name="SetWidth" visibility="protected" procflags="abstract virtual"/>
      <methodref name="WriteData" visibility="protected" procflags="virtual"/>
      <methodref name="GetSupportsPartialTransparency" visibility="protected" procflags="virtual"/>
      <methodref name="Create" visibility="public" procflags="constructor overload virtual"/>
      <methodref name="Destroy" visibility="public" procflags="destructor override"/>
      <methodref name="Equals" visibility="public" procflags="overload override"/>
      <methodref name="LoadFromFile" visibility="public" procflags="virtual"/>
      <methodref name="SaveToFile" visibility="public" procflags="virtual"/>
      <methodref name="CanLoadFromStream" visibility="public" procflags="class virtual"/>
      <methodref name="LoadFromStream" visibility="public" procflags="abstract virtual"/>
      <methodref name="SaveToStream" visibility="public" procflags="abstract virtual"/>
      <methodref name="LoadFromClipboardFormat" visibility="public" procflags="abstract virtual"/>
      <methodref name="SaveToClipboardFormat" visibility="public" procflags="abstract virtual"/>
      <methodref name="SetSize" visibility="public" procflags="virtual"/>
      <methodref name="EnableScaledDrawer" visibility="public" procflags="virtual"/>
      <methodref name="DisableScaledDrawer" visibility="public" procflags="virtual"/>
      <methodref name="UpdateScaledDrawer" visibility="public" procflags="virtual"/>
      <propertyref name="Empty" visibility="public"/>
      <propertyref name="Height" visibility="public"/>
      <propertyref name="Modified" visibility="public"/>
      <propertyref name="Palette" visibility="public"/>
      <propertyref name="PaletteModified" visibility="public"/>
      <propertyref name="Transparent" visibility="public"/>
      <propertyref name="Width" visibility="public"/>
      <propertyref name="ScaledDrawer" visibility="public"/>
      <eventref name="OnChange" visibility="public"/>
      <eventref name="OnProgress" visibility="public"/>
      <propertyref name="SupportsPartialTransparency" visibility="public"/>
      <ancestor name="TInterfacedPersistent" namespace="System.Classes">
        <interfaces>
          <implements name="IInterface"/>
        </interfaces>
        <methodref name="_AddRef" visibility="protected">
        </methodref>
        <methodref name="_Release" visibility="protected">
        </methodref>
        <methodref name="QueryInterface" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="AfterConstruction" visibility="public" procflags="override">
        </methodref>
        <ancestor name="TPersistent" namespace="System.Classes">
          <methodref name="AssignError" visibility="private">
          </methodref>
          <methodref name="AssignTo" visibility="protected" procflags="virtual">
          </methodref>
          <methodref name="DefineProperties" visibility="protected" procflags="virtual">
          </methodref>
          <methodref name="GetOwner" visibility="protected" procflags="dynamic">
          </methodref>
          <methodref name="Destroy" visibility="public" procflags="destructor override">
          </methodref>
          <methodref name="Assign" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="GetNamePath" visibility="public" procflags="dynamic">
          </methodref>
          <ancestor name="TObject" namespace="System">
            <methodref name="Create" visibility="public" procflags="constructor">
            </methodref>
            <methodref name="Free" visibility="public">
            </methodref>
            <methodref name="DisposeOf" visibility="public" procflags="inline">
            </methodref>
            <methodref name="InitInstance" visibility="public" procflags="class">
            </methodref>
            <methodref name="CleanupInstance" visibility="public">
            </methodref>
            <methodref name="ClassType" visibility="public" procflags="inline">
            </methodref>
            <methodref name="ClassName" visibility="public" procflags="class">
            </methodref>
            <methodref name="ClassNameIs" visibility="public" procflags="class">
            </methodref>
            <methodref name="ClassParent" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="ClassInfo" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="InstanceSize" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="InheritsFrom" visibility="public" procflags="class">
            </methodref>
            <methodref name="MethodAddress" visibility="public" procflags="class overload">
            </methodref>
            <methodref name="MethodAddress" visibility="public" procflags="class overload">
            </methodref>
            <methodref name="MethodName" visibility="public" procflags="class">
            </methodref>
            <methodref name="QualifiedClassName" visibility="public" procflags="class">
            </methodref>
            <methodref name="FieldAddress" visibility="public" procflags="overload">
            </methodref>
            <methodref name="FieldAddress" visibility="public" procflags="overload">
            </methodref>
            <methodref name="GetInterface" visibility="public">
            </methodref>
            <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
            </methodref>
            <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="UnitName" visibility="public" procflags="class">
            </methodref>
            <methodref name="UnitScope" visibility="public" procflags="class">
            </methodref>
            <methodref name="Equals" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="GetHashCode" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="ToString" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="SafeCallException" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="AfterConstruction" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="Dispatch" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="DefaultHandler" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="NewInstance" visibility="public" procflags="class virtual">
            </methodref>
            <methodref name="FreeInstance" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="Destroy" visibility="public" procflags="destructor virtual">
            </methodref>
            <methodref name="GetDisposed" visibility="protected" procflags="inline">
            </methodref>
            <methodref name="CheckDisposed" visibility="protected" procflags="inline">
            </methodref>
            <propertyref name="Disposed" visibility="protected">
            </propertyref>
          </ancestor>
        </ancestor>
      </ancestor>
    </ancestor>
    <members>
      <field name="FImage" type="TIconImage" visibility="private" size="4" offset="48" file="Vcl.Graphics.pas" line="1487"/>
      <field name="FRequestedSize" type="TPoint" visibility="private" size="8" offset="52" file="Vcl.Graphics.pas" line="1488"/>
      <function name="GetHandle" visibility="private" file="Vcl.Graphics.pas" line="1489">
        <parameters>
          <retval type="HICON"/>
        </parameters>
      </function>
      <procedure name="HandleNeeded" visibility="private" file="Vcl.Graphics.pas" line="1490">
      </procedure>
      <procedure name="ImageNeeded" visibility="private" file="Vcl.Graphics.pas" line="1491">
      </procedure>
      <procedure name="SetHandle" visibility="private" file="Vcl.Graphics.pas" line="1492">
        <parameters>
          <parameter name="Value" type="HICON"/>
        </parameters>
      </procedure>
      <procedure name="NewImage" visibility="private" file="Vcl.Graphics.pas" line="1496">
        <parameters>
          <parameter name="NewHandle" type="HICON"/>
          <parameter name="NewImage" type="TMemoryStream"/>
        </parameters>
      </procedure>
      <procedure name="Draw" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="1499">
        <parameters>
          <parameter name="ACanvas" type="TCanvas"/>
          <parameter name="Rect" type="TRect" paramflags="const"/>
        </parameters>
      <devnotes><summary>
Render graphic onto canvas at rectangle.
Vcl.Graphics.TIcon.Draw inherits from Vcl.Graphics.TGraphic.Draw. All content below this line refers to Vcl.Graphics.TGraphic.Draw.
Render graphic onto canvas at rectangle.
TCanvas.Draw calls this function to render the graphic onto its canvas at the coordinates specified by the Rect parameter. Descendants of TGraphic should override this function with a specific rendering implementation.
</summary></devnotes></procedure>
      <function name="GetEmpty" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="1500">
        <parameters>
          <retval type="Boolean"/>
        </parameters>
      <devnotes><summary>
Indicates whether graphics object contains graphic.
Vcl.Graphics.TIcon.GetEmpty inherits from Vcl.Graphics.TGraphic.GetEmpty. All content below this line refers to Vcl.Graphics.TGraphic.GetEmpty.
Indicates whether graphics object contains graphic.
GetEmpty indicates whether the TGraphic object contains a graphic.
Each descendant of the TGraphic class should override the GetEmpty method to indicate whether a given TGraphic object is bound to an image.
</summary></devnotes></function>
      <function name="GetHeight" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="1501">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      <devnotes><summary>
Get vertical size of graphic in pixels.
Vcl.Graphics.TIcon.GetHeight inherits from Vcl.Graphics.TGraphic.GetHeight. All content below this line refers to Vcl.Graphics.TGraphic.GetHeight.
Get vertical size of graphic in pixels.
GetHeight gets the vertical size of the TGraphic object in pixels.
Each descendant of TGraphic defines its own GetHeight and SetHeight methods to access the Height property.
</summary></devnotes></function>
      <function name="GetWidth" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="1502">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      <devnotes><summary>
Get horizontal size of graphic in pixels.
Vcl.Graphics.TIcon.GetWidth inherits from Vcl.Graphics.TGraphic.GetWidth. All content below this line refers to Vcl.Graphics.TGraphic.GetWidth.
Get horizontal size of graphic in pixels.
GetWidth gets the horizontal size of the graphic in pixels.
Each descendant of the TGraphic class defines its own GetWidth and SetWidth methods to access the Width property. 
</summary></devnotes></function>
      <procedure name="SetHeight" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="1503">
        <parameters>
          <parameter name="Value" type="Integer"/>
        </parameters>
      <devnotes><summary>
Set vertical size of graphic in pixels.
Vcl.Graphics.TIcon.SetHeight inherits from Vcl.Graphics.TGraphic.SetHeight. All content below this line refers to Vcl.Graphics.TGraphic.SetHeight.
Set vertical size of graphic in pixels.
SetHeight sets the vertical size of the graphic in pixels.
Each descendant of the TGraphic class defines its own GetHeight and SetHeight methods to access the Height property. 
</summary></devnotes></procedure>
      <procedure name="SetTransparent" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="1504">
        <parameters>
          <parameter name="Value" type="Boolean"/>
        </parameters>
      <devnotes><summary>
Specify if graphic should be drawn transparently.
Vcl.Graphics.TIcon.SetTransparent inherits from Vcl.Graphics.TGraphic.SetTransparent. All content below this line refers to Vcl.Graphics.TGraphic.SetTransparent.
Specify if graphic should be drawn transparently.
SetTransparent specifies if a graphic should be drawn transparently.
</summary></devnotes></procedure>
      <procedure name="SetWidth" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="1505">
        <parameters>
          <parameter name="Value" type="Integer"/>
        </parameters>
      <devnotes><summary>
Set horizontal size of graphic in pixels.
Vcl.Graphics.TIcon.SetWidth inherits from Vcl.Graphics.TGraphic.SetWidth. All content below this line refers to Vcl.Graphics.TGraphic.SetWidth.
Set horizontal size of graphic in pixels.
SetWidth sets the horizontal size of the graphic in pixels.
Each descendant of the TGraphic class defines its own GetWidth and SetWidth methods to access the Width property. 
</summary></devnotes></procedure>
      <constructor name="Create" visibility="public" file="Vcl.Graphics.pas" line="1507">
        <parameters>
        </parameters>
      <devnotes><summary>
Creates an instance of TIcon.
Call Create to create an empty icon object. Once an image has been read into the icon from a file or stream, or by assigning another icon object, the icon can be drawn on a canvas or added to an image list. Do not create an icon object for setting the icon property of a form or picture. These objects create a TIcon object in their own constructors. Instead, use the LoadFromFile, LoadFromStream, or LoadFromClipboardFormat method on the TIcon object that you can obtain by reading the Icon property.
</summary></devnotes></constructor>
      <destructor name="Destroy" visibility="public" file="Vcl.Graphics.pas" line="1508">
        <parameters>
        </parameters>
      <devnotes><summary>
Destroys an instance of TIcon.
Do not call Destroy directly in an application. Instead, call Free. Free verifies that the TIcon reference is not nil, and only then calls Destroy.
</summary></devnotes></destructor>
      <procedure name="Assign" visibility="public" procflags="override" file="Vcl.Graphics.pas" line="1509">
        <parameters>
          <parameter name="Source" type="TPersistent"/>
        </parameters>
      <devnotes><summary>
Copies an icon image from another TIcon object.
Call Assign to copy another icon object. Assign copies the icon image from the Source parameter if it is another TIcon object. Otherwise, Assign calls the inherited method, which copies the icon image from any source object that specifies how to copy to a TIcon in its AssignTo method.
</summary></devnotes></procedure>
      <procedure name="AssignTo" visibility="public" procflags="override" file="Vcl.Graphics.pas" line="1511">
        <parameters>
          <parameter name="Dest" type="TPersistent"/>
        </parameters>
      <devnotes><summary>
Copies an icon image to a TBitmap graphical object.
Call AssignTo to copy an icon to a TBitmap object. AssignTo copies the icon image to the Dest parameter if it is a TBitmap object. Otherwise, AssignTo fails. 
The preferred way to copy an icon image to a bitmap is to use the Assign method of the TBitmap class, passing the icon object as the Source parameter.

Note:  The bitmap resulted after a call to AssignTo always has alpha channel (transparency) information and a 32-bit color depth. </summary></devnotes></procedure>
      <function name="HandleAllocated" visibility="public" file="Vcl.Graphics.pas" line="1513">
        <parameters>
          <retval type="Boolean"/>
        </parameters>
      <devnotes><summary>
Indicates whether the TIcon object has acquired a handle to the underlying GDI object.
Use HandleAllocated to determine whether the Handle property is set to an HICON value. HandleAllocated indicates whether the underlying GDI object has already been created. Use HandleAllocated rather than reading the Handle property. When an application reads the Handle property, it automatically creates an icon and returns its handle if the underlying GDI object does not already exist.
</summary></devnotes></function>
      <procedure name="LoadFromClipboardFormat" visibility="public" procflags="override" file="Vcl.Graphics.pas" line="1514">
        <parameters>
          <parameter name="AFormat" type="Word"/>
          <parameter name="AData" type="NativeUInt"/>
          <parameter name="APalette" type="HPALETTE"/>
        </parameters>
      <devnotes><summary>
Prevents applications from loading icons from the clipboard.
LoadFromClipboardFormat is overridden in TIcon because the clipboard format is not supported.
</summary></devnotes></procedure>
      <function name="CanLoadFromStream" visibility="public" procflags="class override" file="Vcl.Graphics.pas" line="1516">
        <parameters>
          <parameter name="Stream" type="TStream"/>
          <retval type="Boolean"/>
        </parameters>
      <devnotes><summary>

Vcl.Graphics.TIcon.CanLoadFromStream inherits from Vcl.Graphics.TGraphic.CanLoadFromStream. All content below this line refers to Vcl.Graphics.TGraphic.CanLoadFromStream.
CanLoadFromStream returns True when a specified stream contains a streamed image of a specific TGraphic subclass. 
The method uses current stream position, it does not change current stream position.


</summary></devnotes></function>
      <procedure name="LoadFromStream" visibility="public" procflags="override" file="Vcl.Graphics.pas" line="1517">
        <parameters>
          <parameter name="Stream" type="TStream"/>
        </parameters>
      <devnotes><summary>
Loads the icon from a stream.
Use LoadFromStream to read the icon image from a stream. Set the Stream parameter to a stream object that provides access to the memory image of the icon. To load the icon from a .ico file, use the LoadFromFile method. To load the icon from the Clipboard, use the LoadFromClipboardFormat method.
</summary></devnotes></procedure>
      <function name="ReleaseHandle" visibility="public" file="Vcl.Graphics.pas" line="1518">
        <parameters>
          <retval type="HICON"/>
        </parameters>
      <devnotes><summary>
Releases the Windows GDI object represented by the icon.
Call ReleaseHandle to release the resources used to represent the icon. ReleaseHandle sets the Handle property to nil (Delphi) or NULL (C++).
ReleaseHandle informs the TIcon instance that it is no longer responsible for destroying the icon handle.
</summary></devnotes></function>
      <procedure name="SaveToClipboardFormat" visibility="public" procflags="override" file="Vcl.Graphics.pas" line="1519">
        <parameters>
          <parameter name="Format" type="Word" paramflags="var"/>
          <parameter name="Data" type="NativeUInt" paramflags="var"/>
          <parameter name="APalette" type="HPALETTE" paramflags="var"/>
        </parameters>
      <devnotes><summary>
Prevents applications from saving icons to the clipboard.
SaveToClipboardFormat is overridden in TIcon because the format is not supported for the Clipboard.
</summary></devnotes></procedure>
      <procedure name="SaveToStream" visibility="public" procflags="override" file="Vcl.Graphics.pas" line="1521">
        <parameters>
          <parameter name="Stream" type="TStream"/>
        </parameters>
      <devnotes><summary>
Saves the icon to a stream.
Use SaveToStream to write the icon image to a stream. Specify the Stream parameter as the stream object that receives the memory image of the icon. To write the icon to a .ico file, use the SaveToFile method. To write the icon to the Clipboard, use the SaveToClipboardFormat method.
</summary></devnotes></procedure>
      <procedure name="SetSize" visibility="public" procflags="override" file="Vcl.Graphics.pas" line="1522">
        <parameters>
          <parameter name="AWidth" type="Integer"/>
          <parameter name="AHeight" type="Integer"/>
        </parameters>
      <devnotes><summary>
Specifies the size of the icon.
Use the SetSize method to set both the height and width of the icon. This results in better performance than setting the height and width separately.


</summary></devnotes></procedure>
      <procedure name="LoadFromResourceName" visibility="public" file="Vcl.Graphics.pas" line="1534">
        <parameters>
          <parameter name="Instance" type="NativeUInt"/>
          <parameter name="ResName" type="string" paramflags="const"/>
        </parameters>
      <devnotes><summary>
Loads an icon resource into the icon object.
LoadFromResourceName loads the specified icon resource from a module's executable file.
Instance is the handle of the module that contains the resource.
ResName is the name of the resource to load.
</summary></devnotes></procedure>
      <procedure name="LoadFromResourceID" visibility="public" file="Vcl.Graphics.pas" line="1536">
        <parameters>
          <parameter name="Instance" type="NativeUInt"/>
          <parameter name="ResID" type="Integer"/>
        </parameters>
      <devnotes><summary>
Embarcadero Technologies does not currently have any additional information.


</summary></devnotes></procedure>
      <property name="Handle" visibility="public" read="GetHandle" write="SetHandle" type="HICON" file="Vcl.Graphics.pas" line="1539"><devnotes><summary>
Provides access to the Windows GDI icon handle.
Use Handle to specify the icon when using a Windows API function that requires the handle of an icon object. The Handle property is nil (Delphi) or NULL (C++) if the icon has not been loaded.
Call the ReleaseHandle method before changing the icon image by setting the Handle property. The icon image can also be loaded by assigning another icon object or using the LoadFromClipboardFormat, LoadFromFile, or LoadFromStream method. 
</summary></devnotes></property>
    </members>
  <devnotes><summary>
TIcon is an encapsulation of a Windows icon.
Use TIcon to represent one of the icons in an image list. Assign an icon to objects that have an Icon property, such as TForm or TPicture. 
Icon objects represent the value loaded from a Windows icon file (.ICO file). Draw an icon on a canvas, using the Draw method of the TCanvas object. Icons do not stretch, so do not use StretchDraw (TCanvas) with an icon.

Note: TIcon can be used to display the value of a multi-resolution (&gt;16 color) icon. However, it can not support the creation of multi-resolution icons, nor the resizing of the image after it is loaded from a file or stream.</summary></devnotes></class>
  <enum name="TWICImageFormat" file="Vcl.Graphics.pas" line="1548">
    <element value="0" name="wifBmp" file="Vcl.Graphics.pas" line="1548"/>
    <element value="1" name="wifPng" file="Vcl.Graphics.pas" line="1548"/>
    <element value="2" name="wifJpeg" file="Vcl.Graphics.pas" line="1548"/>
    <element value="3" name="wifGif" file="Vcl.Graphics.pas" line="1548"/>
    <element value="4" name="wifTiff" file="Vcl.Graphics.pas" line="1548"/>
    <element value="5" name="wifWMPhoto" file="Vcl.Graphics.pas" line="1548"/>
    <element value="6" name="wifOther" file="Vcl.Graphics.pas" line="1548"/>
  </enum>
  <enum name="TWICImageInterpolationMode" file="Vcl.Graphics.pas" line="1549">
    <element value="0" name="wipmNone" file="Vcl.Graphics.pas" line="1549"/>
    <element value="1" name="wipmHighQualityCubic" file="Vcl.Graphics.pas" line="1549"/>
    <element value="2" name="wipmFant" file="Vcl.Graphics.pas" line="1549"/>
    <element value="3" name="wipmCubic" file="Vcl.Graphics.pas" line="1549"/>
    <element value="4" name="wipmLinear" file="Vcl.Graphics.pas" line="1549"/>
    <element value="5" name="wipmNearestNeighbor" file="Vcl.Graphics.pas" line="1549"/>
  </enum>
  <class name="TWICImage" file="Vcl.Graphics.pas" line="1551">
    <ancestor name="TGraphic" namespace="Vcl.Graphics">
      <interfaces>
        <implements name="IStreamPersist"/>
      </interfaces>
      <methodref name="SetModified" visibility="private"/>
      <methodref name="Changed" visibility="protected" procflags="virtual"/>
      <methodref name="DefineProperties" visibility="protected" procflags="override"/>
      <methodref name="Draw" visibility="protected" procflags="abstract virtual"/>
      <methodref name="DrawTransparent" visibility="protected" procflags="virtual"/>
      <methodref name="Equals" visibility="protected" procflags="overload virtual"/>
      <methodref name="GetEmpty" visibility="protected" procflags="abstract virtual"/>
      <methodref name="GetHeight" visibility="protected" procflags="abstract virtual"/>
      <methodref name="GetPalette" visibility="protected" procflags="virtual"/>
      <methodref name="GetTransparent" visibility="protected" procflags="virtual"/>
      <methodref name="GetWidth" visibility="protected" procflags="abstract virtual"/>
      <methodref name="Progress" visibility="protected" procflags="dynamic"/>
      <methodref name="ReadData" visibility="protected" procflags="virtual"/>
      <methodref name="SetHeight" visibility="protected" procflags="abstract virtual"/>
      <methodref name="SetPalette" visibility="protected" procflags="virtual"/>
      <methodref name="SetTransparent" visibility="protected" procflags="virtual"/>
      <methodref name="SetWidth" visibility="protected" procflags="abstract virtual"/>
      <methodref name="WriteData" visibility="protected" procflags="virtual"/>
      <methodref name="GetSupportsPartialTransparency" visibility="protected" procflags="virtual"/>
      <methodref name="Create" visibility="public" procflags="constructor overload virtual"/>
      <methodref name="Destroy" visibility="public" procflags="destructor override"/>
      <methodref name="Equals" visibility="public" procflags="overload override"/>
      <methodref name="LoadFromFile" visibility="public" procflags="virtual"/>
      <methodref name="SaveToFile" visibility="public" procflags="virtual"/>
      <methodref name="CanLoadFromStream" visibility="public" procflags="class virtual"/>
      <methodref name="LoadFromStream" visibility="public" procflags="abstract virtual"/>
      <methodref name="SaveToStream" visibility="public" procflags="abstract virtual"/>
      <methodref name="LoadFromClipboardFormat" visibility="public" procflags="abstract virtual"/>
      <methodref name="SaveToClipboardFormat" visibility="public" procflags="abstract virtual"/>
      <methodref name="SetSize" visibility="public" procflags="virtual"/>
      <methodref name="EnableScaledDrawer" visibility="public" procflags="virtual"/>
      <methodref name="DisableScaledDrawer" visibility="public" procflags="virtual"/>
      <methodref name="UpdateScaledDrawer" visibility="public" procflags="virtual"/>
      <propertyref name="Empty" visibility="public"/>
      <propertyref name="Height" visibility="public"/>
      <propertyref name="Modified" visibility="public"/>
      <propertyref name="Palette" visibility="public"/>
      <propertyref name="PaletteModified" visibility="public"/>
      <propertyref name="Transparent" visibility="public"/>
      <propertyref name="Width" visibility="public"/>
      <propertyref name="ScaledDrawer" visibility="public"/>
      <eventref name="OnChange" visibility="public"/>
      <eventref name="OnProgress" visibility="public"/>
      <propertyref name="SupportsPartialTransparency" visibility="public"/>
      <ancestor name="TInterfacedPersistent" namespace="System.Classes">
        <interfaces>
          <implements name="IInterface"/>
        </interfaces>
        <methodref name="_AddRef" visibility="protected">
        </methodref>
        <methodref name="_Release" visibility="protected">
        </methodref>
        <methodref name="QueryInterface" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="AfterConstruction" visibility="public" procflags="override">
        </methodref>
        <ancestor name="TPersistent" namespace="System.Classes">
          <methodref name="AssignError" visibility="private">
          </methodref>
          <methodref name="AssignTo" visibility="protected" procflags="virtual">
          </methodref>
          <methodref name="DefineProperties" visibility="protected" procflags="virtual">
          </methodref>
          <methodref name="GetOwner" visibility="protected" procflags="dynamic">
          </methodref>
          <methodref name="Destroy" visibility="public" procflags="destructor override">
          </methodref>
          <methodref name="Assign" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="GetNamePath" visibility="public" procflags="dynamic">
          </methodref>
          <ancestor name="TObject" namespace="System">
            <methodref name="Create" visibility="public" procflags="constructor">
            </methodref>
            <methodref name="Free" visibility="public">
            </methodref>
            <methodref name="DisposeOf" visibility="public" procflags="inline">
            </methodref>
            <methodref name="InitInstance" visibility="public" procflags="class">
            </methodref>
            <methodref name="CleanupInstance" visibility="public">
            </methodref>
            <methodref name="ClassType" visibility="public" procflags="inline">
            </methodref>
            <methodref name="ClassName" visibility="public" procflags="class">
            </methodref>
            <methodref name="ClassNameIs" visibility="public" procflags="class">
            </methodref>
            <methodref name="ClassParent" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="ClassInfo" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="InstanceSize" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="InheritsFrom" visibility="public" procflags="class">
            </methodref>
            <methodref name="MethodAddress" visibility="public" procflags="class overload">
            </methodref>
            <methodref name="MethodAddress" visibility="public" procflags="class overload">
            </methodref>
            <methodref name="MethodName" visibility="public" procflags="class">
            </methodref>
            <methodref name="QualifiedClassName" visibility="public" procflags="class">
            </methodref>
            <methodref name="FieldAddress" visibility="public" procflags="overload">
            </methodref>
            <methodref name="FieldAddress" visibility="public" procflags="overload">
            </methodref>
            <methodref name="GetInterface" visibility="public">
            </methodref>
            <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
            </methodref>
            <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
            </methodref>
            <methodref name="UnitName" visibility="public" procflags="class">
            </methodref>
            <methodref name="UnitScope" visibility="public" procflags="class">
            </methodref>
            <methodref name="Equals" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="GetHashCode" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="ToString" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="SafeCallException" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="AfterConstruction" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="Dispatch" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="DefaultHandler" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="NewInstance" visibility="public" procflags="class virtual">
            </methodref>
            <methodref name="FreeInstance" visibility="public" procflags="virtual">
            </methodref>
            <methodref name="Destroy" visibility="public" procflags="destructor virtual">
            </methodref>
            <methodref name="GetDisposed" visibility="protected" procflags="inline">
            </methodref>
            <methodref name="CheckDisposed" visibility="protected" procflags="inline">
            </methodref>
            <propertyref name="Disposed" visibility="protected">
            </propertyref>
          </ancestor>
        </ancestor>
      </ancestor>
    </ancestor>
    <members>
      <field name="FWidth" type="Cardinal" visibility="private" size="4" offset="48" file="Vcl.Graphics.pas" line="1553"/>
      <field name="FHeight" type="Cardinal" visibility="private" size="4" offset="52" file="Vcl.Graphics.pas" line="1553"/>
      <field name="FBitmap" type="TBitmap" visibility="private" size="4" offset="56" file="Vcl.Graphics.pas" line="1554"/>
      <field name="FData" type="TMemoryStream" visibility="private" size="4" offset="60" file="Vcl.Graphics.pas" line="1555"/>
      <field name="FWicBitmap" type="IWICBitmap" visibility="private" size="4" offset="64" file="Vcl.Graphics.pas" line="1556"/>
      <field name="FScaledBuffer" type="TWICImage" visibility="private" size="4" offset="68" file="Vcl.Graphics.pas" line="1557"/>
      <field name="FFrameCount" type="Cardinal" visibility="private" size="4" offset="72" file="Vcl.Graphics.pas" line="1559"/>
      <field name="FFrameIndex" type="Cardinal" visibility="private" size="4" offset="76" file="Vcl.Graphics.pas" line="1560"/>
      <field name="FImageFormat" type="TWICImageFormat" visibility="private" size="1" offset="80" file="Vcl.Graphics.pas" line="1561"/>
      <field name="FEncoderContainerFormat" type="TGUID" visibility="private" size="16" offset="84" file="Vcl.Graphics.pas" line="1562"/>
      <field name="FFormatChanged" type="Boolean" visibility="private" size="1" offset="100" file="Vcl.Graphics.pas" line="1563"/>
      <field name="FInterpolationMode" type="TWICImageInterpolationMode" visibility="private" size="1" offset="101" file="Vcl.Graphics.pas" line="1564"/>
      <procedure name="SetImageFormat" visibility="private" file="Vcl.Graphics.pas" line="1566">
        <parameters>
          <parameter name="Value" type="TWICImageFormat" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="SetInterpolationMode" visibility="private" file="Vcl.Graphics.pas" line="1567">
        <parameters>
          <parameter name="Value" type="TWICImageInterpolationMode"/>
        </parameters>
      </procedure>
      <procedure name="SetEncoderContainerFormat" visibility="private" file="Vcl.Graphics.pas" line="1568">
        <parameters>
          <parameter name="Value" type="TGUID" paramflags="const"/>
        </parameters>
      </procedure>
      <procedure name="CreateWicBitmap" visibility="private" file="Vcl.Graphics.pas" line="1569">
      </procedure>
      <function name="GetHandle" visibility="private" file="Vcl.Graphics.pas" line="1570">
        <parameters>
          <retval type="IWICBitmap"/>
        </parameters>
      </function>
      <procedure name="SetHandle" visibility="private" file="Vcl.Graphics.pas" line="1571">
        <parameters>
          <parameter name="Value" type="IWICBitmap" paramflags="const"/>
        </parameters>
      </procedure>
      <field name="FImagingFactory" type="IWICImagingFactory" visibility="private" varflags="class" file="Vcl.Graphics.pas" line="1573"/>
      <function name="GetImagingFactory" visibility="private" procflags="static" file="Vcl.Graphics.pas" line="1574">
        <parameters>
          <retval type="IWICImagingFactory"/>
        </parameters>
      </function>
      <procedure name="AssignTo" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="1576">
        <parameters>
          <parameter name="Dest" type="TPersistent"/>
        </parameters>
      </procedure>
      <procedure name="Draw" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="1577">
        <parameters>
          <parameter name="ACanvas" type="TCanvas"/>
          <parameter name="Rect" type="TRect" paramflags="const"/>
        </parameters>
      </procedure>
      <function name="GetEmpty" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="1578">
        <parameters>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <function name="GetFrameCount" visibility="protected" file="Vcl.Graphics.pas" line="1579">
        <parameters>
          <retval type="Cardinal"/>
        </parameters>
      </function>
      <function name="GetHeight" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="1580">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      </function>
      <function name="GetWidth" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="1581">
        <parameters>
          <retval type="Integer"/>
        </parameters>
      </function>
      <procedure name="SetHeight" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="1582">
        <parameters>
          <parameter name="Value" type="Integer"/>
        </parameters>
      </procedure>
      <procedure name="SetWidth" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="1583">
        <parameters>
          <parameter name="Value" type="Integer"/>
        </parameters>
      </procedure>
      <procedure name="RequireBitmap" visibility="protected" file="Vcl.Graphics.pas" line="1584">
      </procedure>
      <constructor name="Create" visibility="public" file="Vcl.Graphics.pas" line="1586">
        <parameters>
        </parameters>
      </constructor>
      <destructor name="Destroy" visibility="public" file="Vcl.Graphics.pas" line="1587">
        <parameters>
        </parameters>
      </destructor>
      <procedure name="Assign" visibility="public" procflags="override" file="Vcl.Graphics.pas" line="1588">
        <parameters>
          <parameter name="Source" type="TPersistent"/>
        </parameters>
      </procedure>
      <function name="CreateScaledCopy" visibility="public" file="Vcl.Graphics.pas" line="1590">
        <parameters>
          <parameter name="ANewWidth" type="Integer"/>
          <parameter name="ANewHeight" type="Integer"/>
          <parameter name="AInterpolationMode" type="TWICImageInterpolationMode">
            <value>
              wipmHighQualityCubic
            </value>
          </parameter>
          <retval type="TWICImage"/>
        </parameters>
      </function>
      <procedure name="LoadFromStream" visibility="public" procflags="override" file="Vcl.Graphics.pas" line="1592">
        <parameters>
          <parameter name="Stream" type="TStream"/>
        </parameters>
      </procedure>
      <procedure name="SaveToStream" visibility="public" procflags="override" file="Vcl.Graphics.pas" line="1593">
        <parameters>
          <parameter name="Stream" type="TStream"/>
        </parameters>
      </procedure>
      <procedure name="LoadFromClipboardFormat" visibility="public" procflags="override" file="Vcl.Graphics.pas" line="1594">
        <parameters>
          <parameter name="AFormat" type="Word"/>
          <parameter name="AData" type="NativeUInt"/>
          <parameter name="APalette" type="HPALETTE"/>
        </parameters>
      </procedure>
      <procedure name="SaveToClipboardFormat" visibility="public" procflags="override" file="Vcl.Graphics.pas" line="1596">
        <parameters>
          <parameter name="AFormat" type="Word" paramflags="var"/>
          <parameter name="AData" type="NativeUInt" paramflags="var"/>
          <parameter name="APalette" type="HPALETTE" paramflags="var"/>
        </parameters>
      </procedure>
      <procedure name="LoadFromResourceName" visibility="public" file="Vcl.Graphics.pas" line="1598">
        <parameters>
          <parameter name="Instance" type="NativeUInt"/>
          <parameter name="ResName" type="string" paramflags="const"/>
        </parameters>
      </procedure>
      <property name="FrameCount" visibility="public" read="GetFrameCount" type="Cardinal" file="Vcl.Graphics.pas" line="1600"/>
      <property name="FrameIndex" visibility="public" read="FFrameIndex" write="FFrameIndex" type="Cardinal" file="Vcl.Graphics.pas" line="1601"/>
      <property name="Handle" visibility="public" read="GetHandle" write="SetHandle" type="IWICBitmap" file="Vcl.Graphics.pas" line="1602"/>
      <property name="ImageFormat" visibility="public" read="FImageFormat" write="SetImageFormat" type="TWICImageFormat" file="Vcl.Graphics.pas" line="1603"/>
      <property name="InterpolationMode" visibility="public" read="FInterpolationMode" write="SetInterpolationMode" type="TWICImageInterpolationMode" file="Vcl.Graphics.pas" line="1604"/>
      <property name="EncoderContainerFormat" visibility="public" read="FEncoderContainerFormat" write="SetEncoderContainerFormat" type="TGUID" file="Vcl.Graphics.pas" line="1605"/>
      <property name="ImagingFactory" visibility="public" read="GetImagingFactory" type="IWICImagingFactory" file="Vcl.Graphics.pas" line="1607"/>
      <procedure name="Create@" visibility="class private" procflags="class constructor noself" generated="true">
      </procedure>
      <procedure name="Destroy@" visibility="class private" procflags="class destructor noself" generated="true">
      </procedure>
    </members>
  </class>
  <class name="TWICScaledGraphicDrawer" file="Vcl.Graphics.pas" line="1610">
    <ancestor name="TScaledGraphicDrawer" namespace="Vcl.Graphics">
      <methodref name="GetInitialized" visibility="protected" procflags="virtual"/>
      <propertyref name="Graphic" visibility="protected"/>
      <methodref name="Create" visibility="public" procflags="constructor virtual"/>
      <methodref name="Initialize" visibility="public" procflags="abstract virtual"/>
      <methodref name="Draw" visibility="public" procflags="abstract overload virtual"/>
      <propertyref name="Initialized" visibility="public"/>
      <ancestor name="TPersistent" namespace="System.Classes">
        <methodref name="AssignError" visibility="private">
        </methodref>
        <methodref name="AssignTo" visibility="protected" procflags="virtual">
        </methodref>
        <methodref name="DefineProperties" visibility="protected" procflags="virtual">
        </methodref>
        <methodref name="GetOwner" visibility="protected" procflags="dynamic">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor override">
        </methodref>
        <methodref name="Assign" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetNamePath" visibility="public" procflags="dynamic">
        </methodref>
        <ancestor name="TObject" namespace="System">
          <methodref name="Create" visibility="public" procflags="constructor">
          </methodref>
          <methodref name="Free" visibility="public">
          </methodref>
          <methodref name="DisposeOf" visibility="public" procflags="inline">
          </methodref>
          <methodref name="InitInstance" visibility="public" procflags="class">
          </methodref>
          <methodref name="CleanupInstance" visibility="public">
          </methodref>
          <methodref name="ClassType" visibility="public" procflags="inline">
          </methodref>
          <methodref name="ClassName" visibility="public" procflags="class">
          </methodref>
          <methodref name="ClassNameIs" visibility="public" procflags="class">
          </methodref>
          <methodref name="ClassParent" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="ClassInfo" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="InstanceSize" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="InheritsFrom" visibility="public" procflags="class">
          </methodref>
          <methodref name="MethodAddress" visibility="public" procflags="class overload">
          </methodref>
          <methodref name="MethodAddress" visibility="public" procflags="class overload">
          </methodref>
          <methodref name="MethodName" visibility="public" procflags="class">
          </methodref>
          <methodref name="QualifiedClassName" visibility="public" procflags="class">
          </methodref>
          <methodref name="FieldAddress" visibility="public" procflags="overload">
          </methodref>
          <methodref name="FieldAddress" visibility="public" procflags="overload">
          </methodref>
          <methodref name="GetInterface" visibility="public">
          </methodref>
          <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
          </methodref>
          <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
          </methodref>
          <methodref name="UnitName" visibility="public" procflags="class">
          </methodref>
          <methodref name="UnitScope" visibility="public" procflags="class">
          </methodref>
          <methodref name="Equals" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="GetHashCode" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="ToString" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="SafeCallException" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="AfterConstruction" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="Dispatch" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="DefaultHandler" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="NewInstance" visibility="public" procflags="class virtual">
          </methodref>
          <methodref name="FreeInstance" visibility="public" procflags="virtual">
          </methodref>
          <methodref name="Destroy" visibility="public" procflags="destructor virtual">
          </methodref>
          <methodref name="GetDisposed" visibility="protected" procflags="inline">
          </methodref>
          <methodref name="CheckDisposed" visibility="protected" procflags="inline">
          </methodref>
          <propertyref name="Disposed" visibility="protected">
          </propertyref>
        </ancestor>
      </ancestor>
    </ancestor>
    <members>
      <field name="FScaledBuffer" type="TWICImage" visibility="private" size="4" offset="8" file="Vcl.Graphics.pas" line="1612"/>
      <field name="FInterpolationMode" type="TWICImageInterpolationMode" visibility="private" size="1" offset="12" file="Vcl.Graphics.pas" line="1613"/>
      <procedure name="SetInterpolationMode" visibility="private" file="Vcl.Graphics.pas" line="1614">
        <parameters>
          <parameter name="AValue" type="TWICImageInterpolationMode"/>
        </parameters>
      </procedure>
      <function name="GetInitialized" visibility="protected" procflags="override" file="Vcl.Graphics.pas" line="1616">
        <parameters>
          <retval type="Boolean"/>
        </parameters>
      </function>
      <constructor name="Create" visibility="public" file="Vcl.Graphics.pas" line="1618">
        <parameters>
          <parameter name="AGraphic" type="TGraphic"/>
          <parameter name="AInitialize" type="Boolean"/>
        </parameters>
      </constructor>
      <destructor name="Destroy" visibility="public" file="Vcl.Graphics.pas" line="1619">
        <parameters>
        </parameters>
      </destructor>
      <procedure name="Initialize" visibility="public" procflags="override" file="Vcl.Graphics.pas" line="1620">
      </procedure>
      <procedure name="Draw" visibility="public" procflags="overload override" file="Vcl.Graphics.pas" line="1621">
        <parameters>
          <parameter name="ACanvas" type="TCanvas"/>
          <parameter name="ARect" type="TRect" paramflags="const"/>
        </parameters>
      </procedure>
      <property name="InterpolationMode" visibility="public" read="FInterpolationMode" write="SetInterpolationMode" type="TWICImageInterpolationMode" file="Vcl.Graphics.pas" line="1622"/>
    </members>
  </class>
  <class name="TGDIHandleRecall" file="Vcl.Graphics.pas" line="1629">
    <ancestor name="TObject" namespace="System">
      <methodref name="Create" visibility="public" procflags="constructor">
      </methodref>
      <methodref name="Free" visibility="public">
      </methodref>
      <methodref name="DisposeOf" visibility="public" procflags="inline">
      </methodref>
      <methodref name="InitInstance" visibility="public" procflags="class">
      </methodref>
      <methodref name="CleanupInstance" visibility="public">
      </methodref>
      <methodref name="ClassType" visibility="public" procflags="inline">
      </methodref>
      <methodref name="ClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassNameIs" visibility="public" procflags="class">
      </methodref>
      <methodref name="ClassParent" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="ClassInfo" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InstanceSize" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="InheritsFrom" visibility="public" procflags="class">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodAddress" visibility="public" procflags="class overload">
      </methodref>
      <methodref name="MethodName" visibility="public" procflags="class">
      </methodref>
      <methodref name="QualifiedClassName" visibility="public" procflags="class">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="FieldAddress" visibility="public" procflags="overload">
      </methodref>
      <methodref name="GetInterface" visibility="public">
      </methodref>
      <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
      </methodref>
      <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
      </methodref>
      <methodref name="UnitName" visibility="public" procflags="class">
      </methodref>
      <methodref name="UnitScope" visibility="public" procflags="class">
      </methodref>
      <methodref name="Equals" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="GetHashCode" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="ToString" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="SafeCallException" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="AfterConstruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Dispatch" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="DefaultHandler" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="NewInstance" visibility="public" procflags="class virtual">
      </methodref>
      <methodref name="FreeInstance" visibility="public" procflags="virtual">
      </methodref>
      <methodref name="Destroy" visibility="public" procflags="destructor virtual">
      </methodref>
      <methodref name="GetDisposed" visibility="protected" procflags="inline">
      </methodref>
      <methodref name="CheckDisposed" visibility="protected" procflags="inline">
      </methodref>
      <propertyref name="Disposed" visibility="protected">
      </propertyref>
    </ancestor>
    <members>
      <field name="FCanvas" type="TCanvas" visibility="private" size="4" offset="4" file="Vcl.Graphics.pas" line="1631"/>
      <field name="FDC" type="HDC" visibility="private" size="4" offset="8" file="Vcl.Graphics.pas" line="1632"/>
      <field name="FGDIObj" type="HGDIOBJ" visibility="private" size="4" offset="12" file="Vcl.Graphics.pas" line="1633"/>
      <constructor name="Create" visibility="public" file="Vcl.Graphics.pas" line="1635">
        <parameters>
          <parameter name="DC" type="HDC"/>
          <parameter name="GDIObject" type="Cardinal"/>
        </parameters>
      </constructor>
      <destructor name="Destroy" visibility="public" file="Vcl.Graphics.pas" line="1636">
        <parameters>
        </parameters>
      </destructor>
      <property name="Canvas" visibility="public" read="FCanvas" type="TCanvas" file="Vcl.Graphics.pas" line="1637"/>
    </members>
  </class>
  <variable name="DefFontData" type="TFontData" visibility="public" file="Vcl.Graphics.pas" line="1645"/>
  <variable name="SystemPalette16" type="HPALETTE" file="Vcl.Graphics.pas" line="1654"/>
  <variable name="DDBsOnly" type="Boolean" visibility="public" file="Vcl.Graphics.pas" line="1658"/>
  <procedure name="PaletteChanged" visibility="public" file="Vcl.Graphics.pas" line="2247">
  </procedure>
  <function name="ColorToRGB" visibility="public" file="Vcl.Graphics.pas" line="2329">
    <parameters>
      <parameter name="Color" type="TColor"/>
      <retval type="Integer"/>
    </parameters>
  </function>
  <function name="ColorToString" visibility="public" file="Vcl.Graphics.pas" line="2336">
    <parameters>
      <parameter name="Color" type="TColor"/>
      <retval type="string"/>
    </parameters>
  </function>
  <function name="StringToColor" visibility="public" file="Vcl.Graphics.pas" line="2341">
    <parameters>
      <parameter name="S" type="string" paramflags="const"/>
      <retval type="TColor"/>
    </parameters>
  </function>
  <procedure name="GetColorValues" visibility="public" file="Vcl.Graphics.pas" line="2346">
    <parameters>
      <parameter name="Proc" type="TGetStrProc"/>
    </parameters>
  </procedure>
  <function name="ColorToIdent" visibility="public" file="Vcl.Graphics.pas" line="2351">
    <parameters>
      <parameter name="Color" type="Integer"/>
      <parameter name="Ident" type="string" paramflags="var"/>
      <retval type="Boolean"/>
    </parameters>
  </function>
  <function name="IdentToColor" visibility="public" file="Vcl.Graphics.pas" line="2356">
    <parameters>
      <parameter name="Ident" type="string" paramflags="const"/>
      <parameter name="Color" type="Integer" paramflags="var"/>
      <retval type="Boolean"/>
    </parameters>
  </function>
  <procedure name="GetCharsetValues" visibility="public" file="Vcl.Graphics.pas" line="2425">
    <parameters>
      <parameter name="Proc" type="TGetStrProc"/>
    </parameters>
  </procedure>
  <function name="CharsetToIdent" visibility="public" file="Vcl.Graphics.pas" line="2432">
    <parameters>
      <parameter name="Charset" type="Integer"/>
      <parameter name="Ident" type="string" paramflags="var"/>
      <retval type="Boolean"/>
    </parameters>
  </function>
  <function name="IdentToCharset" visibility="public" file="Vcl.Graphics.pas" line="2437">
    <parameters>
      <parameter name="Ident" type="string" paramflags="const"/>
      <parameter name="Charset" type="Integer" paramflags="var"/>
      <retval type="Boolean"/>
    </parameters>
  </function>
  <function name="BytesPerScanline" visibility="public" file="Vcl.Graphics.pas" line="4509">
    <parameters>
      <parameter name="PixelsPerScanline" type="Integer"/>
      <parameter name="BitsPerPixel" type="Integer"/>
      <parameter name="Alignment" type="Integer"/>
      <retval type="Integer"/>
    </parameters>
  </function>
  <function name="TransparentStretchBlt" visibility="public" file="Vcl.Graphics.pas" line="4518">
    <parameters>
      <parameter name="DstDC" type="HDC"/>
      <parameter name="DstX" type="Integer"/>
      <parameter name="DstY" type="Integer"/>
      <parameter name="DstW" type="Integer"/>
      <parameter name="DstH" type="Integer"/>
      <parameter name="SrcDC" type="HDC"/>
      <parameter name="SrcX" type="Integer"/>
      <parameter name="SrcY" type="Integer"/>
      <parameter name="SrcW" type="Integer"/>
      <parameter name="SrcH" type="Integer"/>
      <parameter name="MaskDC" type="HDC"/>
      <parameter name="MaskX" type="Integer"/>
      <parameter name="MaskY" type="Integer"/>
      <retval type="Boolean"/>
    </parameters>
  </function>
  <procedure name="GetDIBSizes" visibility="public" file="Vcl.Graphics.pas" line="5271">
    <parameters>
      <parameter name="Bitmap" type="HBITMAP"/>
      <parameter name="InfoHeaderSize" type="Cardinal" paramflags="var"/>
      <parameter name="ImageSize" type="Cardinal" paramflags="var"/>
    </parameters>
  </procedure>
  <function name="GetDIB" visibility="public" file="Vcl.Graphics.pas" line="5321">
    <parameters>
      <parameter name="Bitmap" type="HBITMAP"/>
      <parameter name="Palette" type="HPALETTE"/>
      <parameter name="BitmapInfo" paramflags="var"/>
      <parameter name="Bits" paramflags="var"/>
      <retval type="Boolean"/>
    </parameters>
  </function>
  <procedure name="FreeMemoryContexts" visibility="public" file="Vcl.Graphics.pas" line="7273">
  </procedure>
  <function name="CreateMappedBmp" visibility="public" file="Vcl.Graphics.pas" line="7577">
    <parameters>
      <parameter name="Handle" type="HBITMAP"/>
      <parameter name="OldColors" paramflags="const">
        <array name="OldColors" file="Vcl.Graphics.pas" line="7577">
          <element type="TColor"/>
        </array>
      </parameter>
      <parameter name="NewColors" paramflags="const">
        <array name="NewColors" file="Vcl.Graphics.pas" line="7577">
          <element type="TColor"/>
        </array>
      </parameter>
      <retval type="HBITMAP"/>
    </parameters>
  </function>
  <function name="CreateMappedRes" visibility="public" file="Vcl.Graphics.pas" line="7645">
    <parameters>
      <parameter name="Instance" type="NativeUInt"/>
      <parameter name="ResName" type="PWideChar"/>
      <parameter name="OldColors" paramflags="const">
        <array name="OldColors" file="Vcl.Graphics.pas" line="7645">
          <element type="TColor"/>
        </array>
      </parameter>
      <parameter name="NewColors" paramflags="const">
        <array name="NewColors" file="Vcl.Graphics.pas" line="7645">
          <element type="TColor"/>
        </array>
      </parameter>
      <retval type="HBITMAP"/>
    </parameters>
  </function>
  <function name="CreateGrayMappedBmp" visibility="public" file="Vcl.Graphics.pas" line="7745">
    <parameters>
      <parameter name="Handle" type="HBITMAP"/>
      <retval type="HBITMAP"/>
    </parameters>
  </function>
  <function name="CreateGrayMappedRes" visibility="public" file="Vcl.Graphics.pas" line="7754">
    <parameters>
      <parameter name="Instance" type="NativeUInt"/>
      <parameter name="ResName" type="PWideChar"/>
      <retval type="HBITMAP"/>
    </parameters>
  </function>
  <function name="CopyPalette" visibility="public" file="Vcl.Graphics.pas" line="8013">
    <parameters>
      <parameter name="Palette" type="HPALETTE"/>
      <retval type="HPALETTE"/>
    </parameters>
  </function>
  <function name="GraphicFilter" visibility="public" file="Vcl.Graphics.pas" line="11105">
    <parameters>
      <parameter name="GraphicClass" type="TGraphicClass"/>
      <retval type="string"/>
    </parameters>
  </function>
  <function name="GraphicExtension" visibility="public" file="Vcl.Graphics.pas" line="11112">
    <parameters>
      <parameter name="GraphicClass" type="TGraphicClass"/>
      <retval type="string"/>
    </parameters>
  </function>
  <function name="GraphicFileMask" visibility="public" file="Vcl.Graphics.pas" line="11125">
    <parameters>
      <parameter name="GraphicClass" type="TGraphicClass"/>
      <retval type="string"/>
    </parameters>
  </function>
  <function name="GetDefFontCharSet" visibility="public" file="Vcl.Graphics.pas" line="11154">
    <devnotes>
      CLR
    </devnotes>
    <parameters>
      <retval type="TFontCharset"/>
    </parameters>
  </function>
  <function name="AllocPatternBitmap" visibility="public" file="Vcl.Graphics.pas" line="11382">
    <parameters>
      <parameter name="BkColor" type="TColor"/>
      <parameter name="FgColor" type="TColor"/>
      <retval type="TBitmap"/>
    </parameters>
  </function>
</namespace>