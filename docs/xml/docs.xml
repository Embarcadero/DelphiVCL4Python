<?xml version="1.0" encoding="UTF-8"?>
<docs>
  <class unit="Vcl.Buttons" name="TBitBtn">
    <docstr>TBitBtn is a push button control that can include a bitmap on its face.
Bitmap buttons exhibit the same behavior as button controls. Use them to initiate actions from forms and dialog boxes.
Bitmap buttons implement properties that specify the bitmap images, along with their appearance and placement on the button. You can choose from predefined bitmap buttons styles or use your own customized bitmap for the button. Although the button can be associated with only one bitmap, the bitmap (glyph property) can be subdivided into four equal-sized portions, which are displayed based on the state of the button: up, down, disabled, and clicked.
The Kind property of TBitBtn provides commonly used buttons, such as OK, Cancel, Help, and so on. These predefined button types have corresponding graphical images and default behaviors, so you can easily add them to your application with little or no coding necessary.
The recommended way to implement the response of other button kinds to user clicks is to assign an action from an action list as the value of the Action property. By setting the Action property, you make the button a client of the action, and the action handles updating the button&apos;s properties and responding when the user clicks the button.
If you are not using the built-in response to a specific kind of button or an action to respond when the user clicks the button, then you can specify the button&apos;s response by writing an OnClick event handler.</docstr>
    <members>
      <procedure name="ActionChange">
        <docstr>Updates the button control to reflect changes in its associated action.
Vcl.Buttons.TBitBtn.ActionChange inherits from Vcl.StdCtrls.TButtonControl.ActionChange. All content below this line refers to Vcl.StdCtrls.TButtonControl.ActionChange.
Updates the button control to reflect changes in its associated action.
ActionChange is called automatically when the associated action changes. It updates the button control to reflect the action&apos;s current Checked state. Then it calls the inherited method, which checks the associated properties for that client type.
The Sender parameter is the associated action. The CheckDefaults parameter specifies whether properties and event handlers should be changed if they differ from the default values. When CheckDefaults is true, properties and event handlers are only changed when the current values are the default values (that is, when the values have not been previously changed). When CheckDefaults is false, properties and event handlers are changed, regardless of their current values.</docstr>
      </procedure>
      <procedure name="CopyImage">
        <docstr>Copy any TGraphic from a TImageList into the Glyph property of a TBitBtn.
CopyImage can be used to display any TGraphic on a TBitBtn.  You can use any image that can be loaded into an imagelist using an Image List Editor.</docstr>
      </procedure>
      <procedure name="CreateHandle">
        <docstr>Creates underlying screen object.
Vcl.Buttons.TBitBtn.CreateHandle inherits from Vcl.Controls.TWinControl.CreateHandle. All content below this line refers to Vcl.Controls.TWinControl.CreateHandle.
Creates underlying screen object.
CreateHandle creates the Microsoft Windows screen object that underlies the control. if it does not already exist. The new window handle becomes the value of the Handle property.
CreateHandle creates or locates the parent control&apos;s window before it creates a window for the control itself.

Note:  If the Parent property is nil (Delphi) or NULL (C++), CreateHandle raises an exception.</docstr>
      </procedure>
      <procedure name="CreateParams">
        <docstr>Initializes a window-creation parameter data structure.
Vcl.Buttons.TBitBtn.CreateParams inherits from Vcl.Controls.TWinControl.CreateParams. All content below this line refers to Vcl.Controls.TWinControl.CreateParams.
Initializes a window-creation parameter data structure.
The CreateWnd method calls CreateParams to initialize the parameters it passes to CreateWindowHandle. Override CreateParams to customize the way a control creates its Windows representation. When overriding CreateParams, always call the inherited method first to set the default values, then make any desired adjustments.
CreateParams fills in the parameter that is passed as the value of the Params parameter. This data structure holds information needed when telling Windows to create a window handle. The fields of a TCreateParams record become the parameters to a call to the CreateWindowEx API function.
TWinControl implements CreateParams by setting all the fields of Params to generic base values. A number of the standard controls override CreateParams to change one or more of the default values in Params.</docstr>
      </procedure>
      <function name="GetActionLinkClass">
        <docstr>Returns the appropriate action link class that is associated with button controls.
Vcl.Buttons.TBitBtn.GetActionLinkClass inherits from Vcl.StdCtrls.TButtonControl.GetActionLinkClass. All content below this line refers to Vcl.StdCtrls.TButtonControl.GetActionLinkClass.
Returns the appropriate action link class that is associated with button controls.
GetActionLinkClass is used to get the appropriate class type for the action link used with button controls. GetActionLinkClass is used internally to create action link objects for clients when a button control has an associated action. The action link is used to link the action to the button control client. Each Action link class type is designed to link specific actions to clients based upon the types of properties the client supports. For button controls, GetActionLinkClass returns the TButtonActionLink class type.</docstr>
      </function>
      <function name="GetPalette">
        <docstr>Returns the handle to a palette for use by the control.
Vcl.Buttons.TBitBtn.GetPalette inherits from Vcl.Controls.TControl.GetPalette. All content below this line refers to Vcl.Controls.TControl.GetPalette.
Returns the handle to a palette for use by the control.
As implemented in TControl, GetPalette returns a null handle, indicating that the control does not have a palette. Override GetPalette to implement derived objects that use a palette. Create a palette handle for the control by a call to the Windows API function CreatePalette. GetPalette should return the palette handle for the control.
Specifying the palette for a control tells the application that the control&apos;s palette needs to be realized and designates the palette to use for realization.
GetPalette is called only if the run-time video mode requires color palette support, for example, in 256-color mode.</docstr>
      </function>
      <procedure name="SetButtonStyle">
        <docstr>Sets the Style property for a button.
Vcl.Buttons.TBitBtn.SetButtonStyle inherits from Vcl.StdCtrls.TCustomButton.SetButtonStyle. All content below this line refers to Vcl.StdCtrls.TCustomButton.SetButtonStyle.
Sets the Style property for a button.
The SetButtonStyle method is called to change the Style property according to the button&apos;s state, whenever a button changes its focus state.</docstr>
      </procedure>
      <procedure name="UpdateStyleElements">
        <docstr>Called when the StyleElements property changes.
Vcl.Buttons.TBitBtn.UpdateStyleElements inherits from Vcl.Controls.TControl.UpdateStyleElements. All content below this line refers to Vcl.Controls.TControl.UpdateStyleElements.
Called when the StyleElements property changes.
Override the UpdateStyleElements method in a descendant class to provide customized behavior for the control when the value of the StyleElements property changes.</docstr>
      </procedure>
      <procedure name="UpdateImageList">
        <docstr>Rebuilds the image list associated with the button.
Vcl.Buttons.TBitBtn.UpdateImageList inherits from Vcl.StdCtrls.TCustomButton.UpdateImageList. All content below this line refers to Vcl.StdCtrls.TCustomButton.UpdateImageList.
Rebuilds the image list associated with the button.
The UpdateImageList method is called to update the image list associated with the button control.</docstr>
      </procedure>
      <procedure name="UpdateImages">
        <docstr>Updates the image list associated with the button.
Vcl.Buttons.TBitBtn.UpdateImages inherits from Vcl.StdCtrls.TCustomButton.UpdateImages. All content below this line refers to Vcl.StdCtrls.TCustomButton.UpdateImages.
Updates the image list associated with the button.
The UpdateImages method is called to add images to the image list associated with the button control.</docstr>
      </procedure>
      <procedure name="UpdateImage">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="SetImageList">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Constructs an instance of the button control and initializes its values.
Use Create to programmatically instantiate a button. Buttons added using the form designer are created automatically.
The AOwner parameter specifies the component, typically a form, that is responsible for freeing the button.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys the bitmap button object.
Do not call Destroy directly in an application. Instead, call Free. Free checks that the bitmap button is not nil, and only then calls Destroy.</docstr>
      </destructor>
      <procedure name="Click">
        <docstr>Simulates a mouse click, as if the user had clicked the button.
Use Click to simulate a mouse click. Click performs the following tasks:

If the value of the Kind property is bkClose, Click closes the form.
If the value of Kind is bkHelp, Click displays the Help screen assigned with the HelpContext property.
Any associated action fires, or, if there is no associated action, any code attached to the OnClick event is executed.</docstr>
      </procedure>
      <property name="Glyph">
        <docstr>Specifies the bitmap that appears on the bitmap button.
Use the Open dialog box that appears as an editor in the Object Inspector to choose a bitmap file (with a .BMP extension) to use on the button, or specify a TBitmap object at runtime.
You can provide up to four images within a single bitmap. All images must be the same size and next to each other in a row. Bit buttons display one of these images depending on their state.





Image position

Button state

Description



First



Up



This image appears when the button is up (unselected). This image is also used when the button has focus (for example, if the user tabs to it); in this case, a focus rectangle is drawn around the button. If no other images exist in the bitmap, bit buttons also use this image for all other states.




Second



Disabled



This image usually appears dimmed to indicate that the button can&apos;t be selected.




Third



Clicked



This image appears when the button is clicked. The Up image reappears when the user releases the mouse button.




Fourth



Down



This image appears when the button stays down (indicating that it remains selected).




If only one image is present, bit buttons attempt to represent the other states by altering the image slightly for the different states, although the Down state is always the same as the Up state. If you aren&apos;t satisfied with the results, you can provide additional images in the bitmap.
If you have multiple images in a bitmap, you must specify the number of images that are in the bitmap with the Num Glyphs property.

Note:  The lower left pixel of the bitmap is reserved for the &quot;transparent&quot; color. Any pixel in the bitmap which matches that lower left pixel will be transparent.</docstr>
      </property>
      <property name="Kind">
        <docstr>Specifies the kind of bitmap button.
Use Kind to specify the appearance of the TBitBtn control and its response when the user clicks the button. A standard set of buttons are included and operate as expected without the addition of code. However, you can write additional code in the button events, if you want to. This does not include the Custom button kind, which can be programmed in any way you like.
The images (such as the green check mark on the OK button) appear on the button when using this version of TBitBtn.</docstr>
      </property>
      <property name="Layout">
        <docstr>Specifies where the image appears on the bitmap button.
Layout indicates whether the text appears on the left of the button (blGlyphLeft), the right of the button (blGlyphRight), the top (blGlyphTop) or the bottom (blGlyphBottom).</docstr>
      </property>
      <property name="Margin">
        <docstr>Specifies the number of pixels between the edge of the image (specified in the Glyph property) and the edge of the button.
The margin is the space between the image edge and the button edge. The format of the edges depends on the layout of the image and text (specified in the Layout property). For example, if Layout is blGlyphLeft, the margin appears between the left edge of the image and the left edge of the button. If Margin is 3, three pixels separate the image and the button edges. If Margin is 0, there is no space between the image and the button edges.
If Margin is -1 (the default value), the image and text (specified in the Caption property) are centered. The number of pixels between the image and button edge is equal to the number of pixels between the opposite edge of the button and the text.</docstr>
      </property>
      <property name="NumGlyphs">
        <docstr>Indicates the number of images that are in the graphic specified in the Glyph property.
If you have multiple images in a bitmap, you must specify the number of images that are in the bitmap with the NumGlyphs property. The default value is 1.</docstr>
      </property>
      <property name="Style">
        <docstr>Determines the appearance of a bitmap button.
Style indicates whether the TBitBtn control uses the modern button look, or reflects the look of a 16-bit Windows pushbutton.</docstr>
      </property>
      <property name="Spacing">
        <docstr>Determines where the image and text appear on a bitmap or speed button.
Spacing determines the number of pixels between the image (specified in the Glyph property) and the text (specified in the Caption property). The default value is 4 pixels.
If Spacing is a positive number, its value is the number of pixels between the image and text. If Spacing is 0, no pixels will be between the image and text. If Spacing is -1, the text appears centered between the image and the button edge. The number of pixels between the image and text is equal to the number of pixels between the text and the button edge opposite the glyph.</docstr>
      </property>
    </members>
  </class>
  <class unit="Vcl.ActnList" name="TCustomActionList">
    <docstr>The usual list of actions (without published properties) in VCL</docstr>
  </class>
  <class unit="Vcl.ActnList" name="TActionList">
    <docstr>TActionList maintains a list of actions that can be used by components and controls such as menu items and buttons.
Use Action lists to centralize the response to user commands (actions). Action list components maintain a list of actions that are available to the client controls in an application. Add action list components to your form or data module from the standard page of the component palette. Double-click the action list to display the Action List editor, from which you can add, delete, and rearrange actions.

Note:  While it is  possible to maintain the actions for an application using TActionList, it can be simpler to use Vcl.ActnMan.TActionManager instead.</docstr>
  </class>
  <class unit="Vcl.ActnList" name="TActionLink">
    <docstr>This class is designed to communicate with some of the object in VCL</docstr>
  </class>
  <class unit="Vcl.ActnList" name="TShortCutList">
    <docstr>List of additional combinations of hot keys in VCL</docstr>
  </class>
  <class unit="Vcl.ActnList" name="TCustomAction">
    <docstr>TCustomAction is the base class for VCL actions intended to be used with menu items and controls.
TCustomAction introduces support for the properties, events, and methods of menu items and controls that are clients of action objects.
Most properties and events introduced in TCustomAction are public; therefore, use TCustomAction as a base class when deriving your own actions that publish specific subset of properties of associated controls. 
Action objects centralize the response to user commands (actions) and represent user interface elements in applications that use actions. They provide an easy way to synchronize, for example, the enabled state and caption of a speed button and a menu item, and handle the response when users click these components. Each such component, called the client, has its properties dynamically updated by the action and forwards user actions to the action for a response.
At design time, you can work in the Action List editor with actions contained in an action list or in the Action Manager editor of the action manager. The action list or action manager is a container for actions, which it organizes into categories.
Component and control public properties and events that are supported in TCustomAction, either directly or through an ancestor, are:

Caption
Checked
Enabled
HelpType
HelpContext
HelpKeyword
Hint
ImageIndex
ShortCut
Visible
OnHint
OnUpdate
OnExecute
Because the OnHint, OnUpdate, and OnExecute events are public, they do not appear in the Object Inspector. That is, the Object Inspector does not support generating custom event handlers for these events.
TCustomAction can also act as the base class for predefined action classes. You can derive from TCustomAction if you want to retain the public scope of supported properties and events or modify the public scope to the published scope.  
For predefined actions that augment the behavior of TCustomAction, see the action classes in the Vcl.StdActns, Vcl.DBActns, and Vcl.ExtActns units.</docstr>
    <members>
      <procedure name="AssignTo">
        <docstr>Copies the properties of this action to a destination object.
AssignTo is overridden so that existing objects of type TCustomAction can be copied to other action objects of the same type. AssignTo ensures the correct assignment of property values.</docstr>
      </procedure>
      <function name="CreateShortCutList">
        <docstr>Creates the TShortCutList object for the action.
CreateShortCutList creates an empty VCL shortcut list object for the current action. 
Notice that implementations of shortcuts are FireMonkey or VCL framework-specific.</docstr>
      </function>
      <procedure name="SetImageIndex">
        <docstr>Sets the new Value of the ImageIndex property for the action and action&apos;s clients.
Vcl.ActnList.TCustomAction.SetImageIndex inherits from System.Actions.TContainedAction.SetImageIndex. All content below this line refers to System.Actions.TContainedAction.SetImageIndex.
Sets the new Value of the ImageIndex property for the action and action&apos;s clients.
SetImageIndex always propagates this Value to all clients of the action.</docstr>
      </procedure>
      <procedure name="Change">
        <docstr>Generates an OnChange event.
Vcl.ActnList.TCustomAction.Change inherits from System.Classes.TBasicAction.Change. All content below this line refers to System.Classes.TBasicAction.Change.
Generates an OnChange event.
Change is called automatically when the action&apos;s properties change. This method calls the OnChange event handler, if one is assigned.</docstr>
      </procedure>
      <function name="GetImages">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="Loaded">
        <docstr>Initializes the component after the form file has been read into memory.
Vcl.ActnList.TCustomAction.Loaded inherits from System.Classes.TComponent.Loaded. All content below this line refers to System.Classes.TComponent.Loaded.
Initializes the component after the form file has been read into memory.
Do not call the protected Loaded method. The streaming system calls this method after it loads the component&apos;s form from a stream.
When the streaming system loads a form or data module from its form file, it first constructs the form component by calling its constructor, then reads its property values from the form file. After reading all the property values for all the components, the streaming system calls the Loaded methods of each component in the order the components were created. This gives the components a chance to initialize any data that depends on the values of other components or other parts of itself.

Note:  All references to sibling components are resolved by the time Loaded is called. Loaded is the first place that sibling pointers can be used after being streamed in.
As implemented in TComponent, Loaded clears the csLoading flag in the ComponentState property, indicating that the component is no longer loading.

Warning: Loaded may be called multiple times on inherited forms. It is called every time a level of inheritance is streamed in. Do not allocate memory in an overridden Loaded method without first checking that the memory has not been allocated in a previous call.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Instantiates and initializes a VCL TCustomAction object.
Applications do not need to call the constructor directly. Actions are created automatically when you add them to an action manager (in the Action Manager editor) or action list component (in the Action List editor) at design time.
If you want to create an action at run time, assign a
TActionList or TActionManager component to its ActionList property after calling Create.
AOwner is the component that is responsible for freeing the action. It becomes the value of the Owner property.
Create simply calls an inherited System.Actions.TContainedAction.Create constructor.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Frees an instance of TCustomAction.
Do not call the destructor directly in an application. Instead, call Free. Free ensures that the action is not nil before calling the destructor.
If the action is contained in an action list or action manager, Destroy removes the action from that list.</docstr>
      </destructor>
      <function name="Execute">
        <docstr>Responds when a client control &quot;fires&quot;.
Execute is called automatically when a client control &quot;fires&quot; (for example, when the user clicks a button or selects a menu item). It returns True if an event handler is found to handle the action, False if there was no event handler or if the action was not enabled.
Execute first ensures that the action is updated. Then, if the Enabled property is True, it attempts to handle the action by generating an OnExecute event on the action list that contains this action (if the action belongs to an action list). If the action list&apos;s OnExecute event handler does not handle the action, Execute generates an OnActionExecute event on the application itself. If neither the action list nor the application handles the action in response to these events, Execute generates an OnExecute event on itself. If this action has no OnExecute event handler, Execute instructs the application to locate the current target control and call the ExecuteTarget method, which is the mechanism by which predefined action classes perform their function.</docstr>
      </function>
      <function name="Update">
        <docstr>Provides an opportunity to execute centralized code when an application is idle.
Vcl.ActnList.TCustomAction.Update inherits from System.Classes.TBasicAction.Update. All content below this line refers to System.Classes.TBasicAction.Update.
Provides an opportunity to execute centralized code when an application is idle.
Update triggers the OnUpdate event handler. Update returns True if an event handler was found, False otherwise. When the application is idle, the OnUpdate event occurs for every action. This provides an opportunity for applications to execute centralized code for enabling and disabling, checking and unchecking, and so on.</docstr>
      </function>
      <property name="Images">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="ImageName">
        <docstr>Displays the name of linked items from the Image Collection.</docstr>
      </property>
      <property name="ActionList">
        <docstr>Holds the action list to which the action belongs.
Vcl.ActnList.TCustomAction.ActionList inherits from System.Actions.TContainedAction.ActionList. All content below this line refers to System.Actions.TContainedAction.ActionList.
Holds the action list to which the action belongs.</docstr>
      </property>
    </members>
  </class>
  <class unit="Vcl.ActnList" name="TAction">
    <docstr>TAction is the base class for VCL action objects. TAction implements actions to be used with menu items and controls. The published properties and events of TAction actions can be managed in the Object Inspector at design time.
The TAction class is almost the same as TCustomAction. TAction extends only the following features of TCustomAction:

Changes the public scope to published for the AutoCheck, Caption, Checked, Enabled, GroupIndex, HelpType, HelpContext, HelpKeyword, Hint, ImageIndex, SecondaryShortCuts, ShortCut, and Visible properties.
Sets the published scope for the OnExecute, OnUpdate, and OnHint events.
The published scope of these properties and events provides the possibility to use the Object Inspector assistance for editing values of these properties and events.
The DisableIfNoHandler property is set to True while an action is created, that is, the action is inaccessible if it does not have an OnExecute event handler.
TAction is a generic action component. It can be added to action lists when there is no predefined action class that implements the desired response to user commands. Unlike predefined action classes, which have built-in methods that respond when users click the client controls, TAction has no built-in response to user commands. Instead, when using TAction, you can provide the response when the action &quot;fires&quot; by writing (using the Object Inspector&apos;s assistance) an OnExecute event handler, and configure the properties of TAction to reflect the current conditions by writing an OnUpdate event handler.
Action objects are used to centralize the response to user commands (actions) and to represent user interface elements in applications that use action lists or action bands. 
TAction can also act as a base class for predefined action classes. You can derive from TAction if you want to retain the published scope of the supported properties and events. If you want to use the public scope to some of the supported properties and events, you can derive from TCustomAction.
For predefined actions that augment the behavior of TAction, see the action classes in the Vcl.StdActns, Vcl.DBActns, and Vcl.ExtActns units.</docstr>
    <members>
      <constructor name="Create">
        <docstr>Creates and initializes a TAction object.
Applications do not usually create action objects explicitly. Actions are created automatically when you add them to an action manager or action list component at design time. When instantiating TAction at run time, assign a TActionList or TActionManager component to the new action&apos;s ActionList property after calling Create.
Create sets the DisableIfNoHandler to True, that is, the action is inaccessible if it does not have an OnExecute event handler.</docstr>
      </constructor>
    </members>
  </class>
  <class unit="Vcl.WinXCtrls" name="TCustomActivityIndicator">
    <docstr>The base class for TActivityIndicator.
An animated rotating display indicating that the application is performing some activity. 
Create the activity indicator, set the color, size and type, and call StartAnimation to start the animation. You can modify the speed of the animation with the FrameDelay property.</docstr>
    <members>
      <procedure name="ReloadFrames">
        <docstr>Loads the appropriate animation frames from resources.
ReloadFrames takes into account the current values IndicatorType, IndicatorSize, and IndicatorColor.</docstr>
      </procedure>
      <procedure name="DrawFrame">
        <docstr>Displays a single frame of the current activity indicator animation sequence.</docstr>
      </procedure>
      <procedure name="Paint">
        <docstr>Renders the image of a custom control.
Vcl.WinXCtrls.TCustomActivityIndicator.Paint inherits from Vcl.Controls.TCustomControl.Paint. All content below this line refers to Vcl.Controls.TCustomControl.Paint.
Renders the image of a custom control.
The Paint method for TCustomControl does nothing other than provide the interface for a method that responds to WM_PAINT messages. Paint is called by the PaintWindow method, after that method has supplied the Canvas with the handle to a device context. When creating a custom control, always override Paint to draw the image of the control.

Tip:  To determine which portions of the control&apos;s canvas need to be repainted when Paint is called, use the ClipRect property of the canvas.</docstr>
      </procedure>
      <procedure name="Resize">
        <docstr>Respond to control resize.
Vcl.WinXCtrls.TCustomActivityIndicator.Resize inherits from Vcl.Controls.TControl.Resize. All content below this line refers to Vcl.Controls.TControl.Resize.
Respond to control resize.
Resize is called automatically immediately after the control&apos;s dimensions change. As implemented in TControl, Resize calls the control&apos;s OnResize event handler if it is assigned.</docstr>
      </procedure>
      <property name="Animate">
        <docstr>Specifies whether the activity indicator is currently animated.
Default is False.</docstr>
      </property>
      <property name="FrameDelay">
        <docstr>Specifies how fast the activity indicator displays its animation sequence.
Set this property to a lower value to speed up the animation.</docstr>
      </property>
      <property name="IndicatorColor">
        <docstr>The color of the activity indicator.
Possible values are:

aicBlack: Default. The elements of the indicator are black.
aicWhite: The elements of the indicator are white.</docstr>
      </property>
      <property name="IndicatorSize">
        <docstr>The size of the activity indicator.
Possible values are:

aisSmall: 24 x 24 pixels.
aisMedium: Default. 32 x 32 pixels.
aisLarge: 48 x 48 pixels.
aisXLarge: 64 x 64 pixels.</docstr>
      </property>
      <property name="IndicatorType">
        <docstr>The type of the activity indicator.
Possible values are:

aitMomentumDots : Default. Traditional Windows 8/10 rotating sequence of dots, accelerating and deccelerating in a circular pattern.
aitRotatingSector : Alternating sectors of a segmented ring are highlighted in sequence to indicate activity.
aitSectorRing : Sectors of a segmented ring are highlighted in sequence until the ring is completely highlighted. On the next pass, each sector is displayed in a dimmed state.</docstr>
      </property>
      <constructor name="Create">
        <docstr>Creates an instance of the TCustomActivityIndicator.
Create sets the default values for all the activity indicator properties.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys an instance of TCustomControl.
Vcl.WinXCtrls.TCustomActivityIndicator.Destroy inherits from Vcl.Controls.TCustomControl.Destroy. All content below this line refers to Vcl.Controls.TCustomControl.Destroy.
Destroys an instance of TCustomControl.
Do not call Destroy directly in an application. Instead, call Free. Free verifies that the control is not nil, and only then calls Destroy. 
Applications should only free controls explicitly when the constructor was called without assigning an owner to the control.
As the control is destroyed, it destroys the TCanvas object in its Canvas property. 
Override Destroy to free any memory or resources allocated in the Create method. When declaring a Destroy method in a descendent control type, always add the override directive to the declaration and call the inherited Destroy as the last statement in the redeclared method. 
When a control is created, Delphi automatically provides exception handling around the constructor call. The destructor is called if an exception escapes from the constructor. This means that the destructor code must be prepared to clean up a partially constructed instance. Check all data fields for zero before disposing of their contents.</docstr>
      </destructor>
      <procedure name="StartAnimation">
        <docstr>Sets the Animate property to True.</docstr>
      </procedure>
      <procedure name="StopAnimation">
        <docstr>Sets the Animate property to False.</docstr>
      </procedure>
    </members>
  </class>
  <class unit="Vcl.WinXCtrls" name="TActivityIndicator">
    <docstr>An animated rotating display indicating that the application is performing some activity.
Create the activity indicator, set the color, size and type, and set the Animate property to True to start the animation. You can modify the speed of the animation with the FrameDelay property.</docstr>
  </class>
  <class unit="Vcl.WinXCtrls" name="TToggleSwitchStateCaptions">
    <docstr>TToggleSwitchStateCaptions encapsulates the text strings used to depict the Off and On states.</docstr>
    <members>
      <property name="CaptionOn">
        <docstr>Specifies the text string to be used when the toggle switch is in the Off state.</docstr>
      </property>
      <property name="CaptionOff">
        <docstr>Specifies the text string to be used when the toggle switch is in the On state.</docstr>
      </property>
    </members>
  </class>
  <class unit="Vcl.WinXCtrls" name="TToggleSwitchActionLink">
    <docstr>Internal class used to connect an action to a TToggleSwitch</docstr>
    <members>
      <field name="FClient">
        <docstr>Protected field that holds reference to the associated client control.</docstr>
      </field>
    </members>
  </class>
  <class unit="Vcl.WinXCtrls" name="TCustomToggleSwitch">
    <docstr>The base class for TToggleSwitch.
TToggleSwitch implements a clickable control that allows a user to toggle between an On state and an Off state.</docstr>
    <members>
      <field name="FClicksDisabled">
        <docstr>Protected field used to control whether mouse clicks should be processed by the control.</docstr>
      </field>
      <field name="FBackgroundBmp">
        <docstr>Protected field used to hold the image of the background of the control. This field is used to
           support transparency.</docstr>
      </field>
      <field name="FUsingMouse">
        <docstr>Protected field used to indicate that the control is being manipulated with the mouse instead of
           the keyboard.</docstr>
      </field>
      <procedure name="CreateWnd">
        <docstr>Creates the underlying window.
Vcl.WinXCtrls.TCustomToggleSwitch.CreateWnd inherits from Vcl.Controls.TWinControl.CreateWnd. All content below this line refers to Vcl.Controls.TWinControl.CreateWnd.
Creates the underlying window.
CreateWnd is called automatically when the control is first created or when the underlying screen object must be destroyed and recreated to reflect property changes. Override CreateWnd to pass additional initialization messages to the screen object when it is created.</docstr>
      </procedure>
      <procedure name="Loaded">
        <docstr>Initializes the control after it is loaded from a stream.
Vcl.WinXCtrls.TCustomToggleSwitch.Loaded inherits from Vcl.Controls.TControl.Loaded. All content below this line refers to Vcl.Controls.TControl.Loaded.
Initializes the control after it is loaded from a stream.
Do not call Loaded. The VCL streaming system calls Loaded automatically after the control&apos;s form is loaded into memory so that the control can complete any initializations that depend on other objects in the form.
Loaded overrides the inherited method in order to initialize the control from its associated Action. To change the properties the control copies from its action, override the ActionChange method.</docstr>
      </procedure>
      <procedure name="AdjustBounds">
        <docstr>Modifies the size of the toggle switch.
AdjustBounds takes into account the size of the toggle switch and the size of the caption text.</docstr>
      </procedure>
      <procedure name="ChangeScale">
        <docstr>Resize and reposition children and self.
Vcl.WinXCtrls.TCustomToggleSwitch.ChangeScale inherits from Vcl.Controls.TWinControl.ChangeScale. All content below this line refers to Vcl.Controls.TWinControl.ChangeScale.
Resize and reposition children and self.
ChangeScale rescales the control in the same manner as the ChangeScale method in TControl. If the control contains any children, their ChangeScale methods are called before the parent itself is rescaled.
To rescale the control&apos;s children without rescaling the control itself, use ScaleControls. To rescale the control without repositioning, use ScaleBy.</docstr>
      </procedure>
      <procedure name="ChangeState">
        <docstr>Changes the current state of the toggle switch.</docstr>
      </procedure>
      <procedure name="ActionChange">
        <docstr>Updates the control to reflect changes in its associated action.
Vcl.WinXCtrls.TCustomToggleSwitch.ActionChange inherits from Vcl.Controls.TWinControl.ActionChange. All content below this line refers to Vcl.Controls.TWinControl.ActionChange.
Updates the control to reflect changes in its associated action.
ActionChange is called automatically when the associated action changes. It updates the control to reflect the action&apos;s current Caption, Enabled, Hint, Visible, and HelpContext properties and its OnClick event handler.
The Sender parameter is the associated action. The CheckDefaults parameter specifies whether properties and event handlers should be changed if they differ from the default values. When CheckDefaults is true, properties and event handlers are only changed when the current values are the default values (that is, when the values have not been previously changed). When CheckDefaults is false, properties and event handlers are changed, regardless of their current values.</docstr>
      </procedure>
      <function name="GetActionLinkClass">
        <docstr>Returns the associated action link class TToggleSwitchActionLink.</docstr>
      </function>
      <procedure name="GetGlyphPosition">
        <docstr>Returns the position of the switch portion of the control.
GetGlyphPosition takes into account the size of the switch, the size of the caption text and the alignment.</docstr>
      </procedure>
      <procedure name="UpdateDisplay">
        <docstr>Repaints the control when the keyboard toggles the switch.</docstr>
      </procedure>
      <procedure name="RepaintDisplay">
        <docstr>Repaints the toggle switch.</docstr>
      </procedure>
      <function name="GetActiveStateCaption">
        <docstr>The caption text of the current toggle switch state.</docstr>
      </function>
      <procedure name="DrawSwitch">
        <docstr>Draws the toggle switch.</docstr>
      </procedure>
      <procedure name="Paint">
        <docstr>Renders the image of a custom control.
Vcl.WinXCtrls.TCustomToggleSwitch.Paint inherits from Vcl.Controls.TCustomControl.Paint. All content below this line refers to Vcl.Controls.TCustomControl.Paint.
Renders the image of a custom control.
The Paint method for TCustomControl does nothing other than provide the interface for a method that responds to WM_PAINT messages. Paint is called by the PaintWindow method, after that method has supplied the Canvas with the handle to a device context. When creating a custom control, always override Paint to draw the image of the control.

Tip:  To determine which portions of the control&apos;s canvas need to be repainted when Paint is called, use the ClipRect property of the canvas.</docstr>
      </procedure>
      <procedure name="Click">
        <docstr>Respond to user click.
Vcl.WinXCtrls.TCustomToggleSwitch.Click inherits from Vcl.Controls.TControl.Click. All content below this line refers to Vcl.Controls.TControl.Click.
Respond to user click.
Click is called automatically when the user left-clicks the control. Component or application code can call Click to simulate a user mouse click. This is often done in menu actions and hotkey handlers.
As implemented in TControl, Click queries whether the OnClick event handler exists and is different from the OnExecute handler for the control&apos;s Action. If this is true, the OnClick event handler is called. If this is false, and the Action OnExecute event handler exists, the Action&apos;s Execute method is called. Override Click to provide additional behavior.</docstr>
      </procedure>
      <procedure name="DoExit">
        <docstr>Responds to losing input focus.
Vcl.WinXCtrls.TCustomToggleSwitch.DoExit inherits from Vcl.Controls.TWinControl.DoExit. All content below this line refers to Vcl.Controls.TWinControl.DoExit.
Responds to losing input focus.
DoExit is called automatically when the control loses the input focus. As implemented in TWinControl, DoExit calls the OnExit event handler, if defined.
Descendant classes that override DoExit should always call the inherited method.</docstr>
      </procedure>
      <procedure name="KeyDown">
        <docstr>Responds to a key press.
If the Key is vk_Space, KeyDown sets a flag that KeyUp uses.</docstr>
      </procedure>
      <procedure name="KeyUp">
        <docstr>Responds to an end of a key press.
If the Key is vk_Space, the toggle switch changes state.</docstr>
      </procedure>
      <procedure name="MouseDown">
        <docstr>Responds to a mouse click.
If the Button is mbLeft, MouseDown sets a flag that MouseUp uses.</docstr>
      </procedure>
      <procedure name="MouseUp">
        <docstr>Responds to a mouse click.
If the Button is mbLeft, the toggle switch changes state.</docstr>
      </procedure>
      <procedure name="SetAutoSize">
        <docstr>Setter for the AutoSize property.</docstr>
      </procedure>
      <property name="Alignment">
        <docstr>Specifies whether the toggle switch caption is displayed on the right or the left side.
Default is taRightJustify.</docstr>
      </property>
      <property name="AutoSize">
        <docstr>Indicates whether the control adjusts its bounds based on the SwitchHeight, SwitchWidth, and StateCaptions properties.
Default is True.</docstr>
      </property>
      <property name="DisabledColor">
        <docstr>The color of the toggle switch when it is disabled.
Default is clBtnShadow.</docstr>
      </property>
      <property name="FrameColor">
        <docstr>The color of the toggle switch frame.
Default is clWindowText.</docstr>
      </property>
      <property name="ReadOnly">
        <docstr>Indicates whether the toggle switch is in read-only mode.
If True, the user cannot change the state of the toggle switch. You can still change the State programatically.
Default is False.</docstr>
      </property>
      <property name="State">
        <docstr>The current state of the toggle switch.
Possible values are:

tssOff: Default. The toggle switch is in the off state.
tssOn: The toggle switch is in the on state.</docstr>
      </property>
      <property name="StateCaptions">
        <docstr>The captions of the toggle switch.</docstr>
      </property>
      <property name="ShowStateCaption">
        <docstr>Indicates whether to display the captions of the switch.
Default is True.</docstr>
      </property>
      <property name="SwitchHeight">
        <docstr>The height of the toggle switch excluding the captions.</docstr>
      </property>
      <property name="SwitchWidth">
        <docstr>The width of the toggle switch excluding the captions.</docstr>
      </property>
      <property name="ThumbColor">
        <docstr>The color of the toggle switch thumb.
Default is clWindowText.</docstr>
      </property>
      <property name="ThumbWidth">
        <docstr>The width of the thumb inside the toggle switch frame.</docstr>
      </property>
      <property name="Color">
        <docstr>Specifies the background color of the control.
Use Color to read or change the background color of the control.
If a control&apos;s Vcl.Controls.TControl.ParentColor property is True, then changing the Color property of the control&apos;s parent automatically changes the Color property of the control. When the value of the Color property is changed, the control&apos;s ParentColor property is automatically set to False.
The Color of a TLabel is always the color of the background unless you set TLabel.Transparent to False.</docstr>
      </property>
      <property name="ParentColor">
        <docstr>Specifies where a control looks for its color information.
To have a control use the same color as its parent control, set ParentColor to True. If ParentColor is False, the control uses its own Color property.
Set ParentColor to True for all controls to ensure that all the controls on a form have a uniform appearance. For example, if ParentColor is True for all controls in a form, changing the background color of the form to gray causes all the controls on the form to also have a gray background.
When the value of a control&apos;s Color property changes, ParentColor becomes False automatically.</docstr>
      </property>
      <property name="TabStop">
        <docstr>Determines whether the user can tab to a control.
Use the TabStop to allow or disallow access to the control using the Tab key.
If TabStop is True, the control is in the tab order. If TabStop is False, the control is not in the tab order and the user cannot press the TAB key to move to the control. 

Note: TabStop is not meaningful for a form unless the form assigns another form to be its parent.</docstr>
      </property>
      <constructor name="Create">
        <docstr>Creates an instance of the TCustomToggleSwitch.
Create sets the default values for all the toggle switch properties.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys an instance of TCustomControl.
Vcl.WinXCtrls.TCustomToggleSwitch.Destroy inherits from Vcl.Controls.TCustomControl.Destroy. All content below this line refers to Vcl.Controls.TCustomControl.Destroy.
Destroys an instance of TCustomControl.
Do not call Destroy directly in an application. Instead, call Free. Free verifies that the control is not nil, and only then calls Destroy. 
Applications should only free controls explicitly when the constructor was called without assigning an owner to the control.
As the control is destroyed, it destroys the TCanvas object in its Canvas property. 
Override Destroy to free any memory or resources allocated in the Create method. When declaring a Destroy method in a descendent control type, always add the override directive to the declaration and call the inherited Destroy as the last statement in the redeclared method. 
When a control is created, Delphi automatically provides exception handling around the constructor call. The destructor is called if an exception escapes from the constructor. This means that the destructor code must be prepared to clean up a partially constructed instance. Check all data fields for zero before disposing of their contents.</docstr>
      </destructor>
      <function name="GetControlsAlignment">
        <docstr>Indicates how text is aligned within the control.
Vcl.WinXCtrls.TCustomToggleSwitch.GetControlsAlignment inherits from Vcl.Controls.TControl.GetControlsAlignment. All content below this line refers to Vcl.Controls.TControl.GetControlsAlignment.
Indicates how text is aligned within the control.
Use GetControlsAlignment to determine the alignment of the control. For controls that do not have an Alignment property, GetControlsAlignment returns taLeftJustify.

Note: GetControlsAlignment returns the alignment of text before it is altered by the BiDiMode property. To check whether the alignment should be reversed to reflect the BiDiMode property, call UseRightToLeftAlignment.</docstr>
      </function>
      <function name="IsOn">
        <docstr>Indicates whether the toggle switch is in the On state.</docstr>
      </function>
    </members>
  </class>
  <class unit="Vcl.WinXCtrls" name="TToggleSwitch">
    <docstr>A clickable control that allows a user to toggle between an On state and an Off state.</docstr>
  </class>
  <class unit="Vcl.WinXCtrls" name="TSearchBoxStyleHook">
    <docstr>Internal class used to implement custom VCL Style support for the TSearchBox.</docstr>
  </class>
  <class unit="Vcl.WinXCtrls" name="TSearchBox">
    <docstr>TSearchBox implements an edit box with an embedded button displaying a search indicator icon.
       Use this control to present an edit box to capture search criteria. When the search indicator icon is clicked or
       the Enter key is pressed (Text indicator), the OnInvokeSearch event is generated.</docstr>
    <members>
      <field name="FCanvas">
        <docstr>Protected field providing access to the canvas upon which the search indicator button is drawn.</docstr>
      </field>
      <procedure name="LoadImages">
        <docstr>LoadImages is used to load the search indicator icons from resources.</docstr>
      </procedure>
      <procedure name="RepaintButton">
        <docstr>RepaintButton sends a WM_NCPAINT message to the control to instruct the nonclient area of the
           control to be repainted. The search indicator is positioned in the nonclient area of the control.</docstr>
      </procedure>
      <procedure name="DrawButton">
        <docstr>DrawButton is used to display the search indicator button.</docstr>
      </procedure>
      <procedure name="MouseCancel">
        <docstr>MouseCancel is used to release mouse capturing when the control loses keyboard focus.</docstr>
      </procedure>
      <procedure name="InvokeSearch">
        <docstr>Event dispatch method used to generate the OnInvokeSearch event.</docstr>
      </procedure>
      <property name="Canvas">
        <docstr>Property providing access to the internal FCanvas field. Used for drawing search indicator.</docstr>
      </property>
      <property name="ButtonWidth">
        <docstr>Specifies the width of the search indicator button.</docstr>
      </property>
      <property name="SearchIndicator">
        <docstr>Specifies the type of indicator icon to display.
           sbiText - Magnifier icon to indicate text based searching
           sbiAudio - Microphone icon to indicate audio based searching</docstr>
      </property>
      <event name="OnInvokeSearch">
        <docstr>This event occurs when the search indicator button is clicked. When SearchIndicator is set to sbiText,
           the OnInvokeSearch event also occurs when the Enter key is pressed.</docstr>
      </event>
    </members>
  </class>
  <class unit="Vcl.WinXCtrls" name="ERelativePanelException">
    <docstr>Exception class representing errors in the TRelativePanel control.</docstr>
  </class>
  <class unit="Vcl.WinXCtrls" name="TRelativePanelControlItem">
    <docstr>TRelativePanelControlItem determines how the associated TControl instance is positioned with respect to the
       TRelativePanel or to other sibling controls on the same TRelativePanel.</docstr>
    <members>
      <procedure name="CheckControl">
        <docstr>Protected method that is used to validate that the specified control is indeed a sibling to the associated TControl.</docstr>
      </procedure>
      <property name="RelativePanel">
        <docstr>Protected method that returns the TRelativePanel that owns the collection of which this item belongs.</docstr>
      </property>
      <procedure name="CheckSaveWidth">
        <docstr>This method determines if the associated control&apos;s width needs to be restored to its previous value.</docstr>
      </procedure>
      <procedure name="CheckSaveHeight">
        <docstr>This method determines if the associated control&apos;s height needs to be restored to its previous value.</docstr>
      </procedure>
      <property name="SaveWidth">
        <docstr>This property is used to store the previous width of the associated control. This value is used in
           situations where the control&apos;s size is changed because of complementary alignment values being chosen. For
           example, AlignLeftWith and AlignRightWith.</docstr>
      </property>
      <property name="SaveHeight">
        <docstr>This property is used to store the previous height of the associated control. This value is used
           in situations where the control&apos;s size is changed because of complementary alignment values being chosen.
           For example, AlignTopWith and AlignBottomWith.</docstr>
      </property>
      <property name="Control">
        <docstr>This property provides access to the TControl instance associated with this collection item.</docstr>
      </property>
      <property name="Above">
        <docstr>The associated TControl is positioned to above the sibling control referenced in this property.</docstr>
      </property>
      <property name="AlignBottomWith">
        <docstr>The associated TControl is aligned with the bottom of the sibling control referenced in this property.</docstr>
      </property>
      <property name="AlignBottomWithPanel">
        <docstr>The associated TControl is aligned with the bottom edge of the panel.</docstr>
      </property>
      <property name="AlignHorizontalCenterWith">
        <docstr>The associated TControl is aligned horizontally centered with the sibling control referenced in this property.</docstr>
      </property>
      <property name="AlignHorizontalCenterWithPanel">
        <docstr>The associated TControl is centered horizontally in the panel.</docstr>
      </property>
      <property name="AlignLeftWith">
        <docstr>The associated TControl is aligned with the left edge of the sibling control referenced in this property.</docstr>
      </property>
      <property name="AlignLeftWithPanel">
        <docstr>The associated TControl is aligned with the left edge of the panel.</docstr>
      </property>
      <property name="AlignRightWith">
        <docstr>The associated TControl is aligned with the right edge of the sibling control referenced in this property.</docstr>
      </property>
      <property name="AlignRightWithPanel">
        <docstr>The associated TControl is aligned with the right edge of the panel.</docstr>
      </property>
      <property name="AlignTopWith">
        <docstr>The associated TControl is aligned with the top of the sibling control referenced in this property.</docstr>
      </property>
      <property name="AlignTopWithPanel">
        <docstr>The associated TControl is aligned with the top edge of the panel.</docstr>
      </property>
      <property name="AlignVerticalCenterWith">
        <docstr>The associated TControl is aligned vertically centered with the sibling control referenced in this property.</docstr>
      </property>
      <property name="AlignVerticalCenterWithPanel">
        <docstr>The associated TControl is centered vertically in the panel.</docstr>
      </property>
      <property name="Below">
        <docstr>The associated TControl is positioned to below of the sibling control referenced in this property.</docstr>
      </property>
      <property name="LeftOf">
        <docstr>The associated TControl is positioned to the left of the sibling control referenced in this property.</docstr>
      </property>
      <property name="RightOf">
        <docstr>The associated TControl is positioned to the right of the sibling control referenced in this property.</docstr>
      </property>
    </members>
  </class>
  <class unit="Vcl.WinXCtrls" name="TRelativePanelControlCollection">
    <docstr>Internal class used to implement the TRelativePanel.ControlCollection property.</docstr>
    <members>
      <function name="GetControl">
        <docstr>Read access method supporting the Controls array property.</docstr>
      </function>
      <function name="GetItem">
        <docstr>Read accessor method supporting the Items array property.</docstr>
      </function>
      <procedure name="SetControl">
        <docstr>This method is used to associate a TControl instance with a particular item in the collection.</docstr>
      </procedure>
      <procedure name="SetItem">
        <docstr>Protected method overrides inherited method to add typecasting for TRelativePanelControlItem type.</docstr>
      </procedure>
      <function name="Add">
        <docstr>Use this method to add a new item to the collection.</docstr>
      </function>
      <procedure name="AddControl">
        <docstr>Use this method to add a TControl instance to the collection.</docstr>
      </procedure>
      <procedure name="RemoveControl">
        <docstr>Use this method to remove a TControl instance from the collection.</docstr>
      </procedure>
      <function name="IndexOf">
        <docstr>Use this method to get the index of the TRelativePanelControlItem instance that is asociated with
           the specified TControl.</docstr>
      </function>
      <function name="Owner">
        <docstr>Returns the TRelativePanel that owns the collection.</docstr>
      </function>
      <property name="Controls[Index]">
        <docstr>Array property that provides access to the individual TControl instances managed by the associated control item.</docstr>
      </property>
      <property name="Items[Index]">
        <docstr>Array property that provides access to the individual TRelativePanelControlItem instances in the collection.</docstr>
      </property>
    </members>
  </class>
  <class unit="Vcl.WinXCtrls" name="TCustomRelativePanel">
    <docstr>TCustomRelativePanel is the base class for the TRelativePanel.</docstr>
    <members>
      <function name="GetControlIndex">
        <docstr>Helper function that returns the index of the specified child control in the ControlCollection.</docstr>
      </function>
      <procedure name="SetControlIndex">
        <docstr>Helper function that sets the index of the specified child control within the ControlCollection.
           Changing the index of a child control will affect the alignment process. Child controls are aligned based on
           their position in the collection.</docstr>
      </procedure>
      <property name="ControlCollection">
        <docstr>This property is defined as published in order to support the TSelectionEditor descendant that is responsible for adding the set of new properties to child controls. The custom selection editor also removes the ControlCollection property from the Object Inspector.</docstr>
      </property>
    </members>
  </class>
  <class unit="Vcl.WinXCtrls" name="TRelativePanel">
    <docstr>TRelativePanel implements a container control that allows child controls to be positioned relative to the panel
       itself, or relative to other child controls of the panel. When a control is placed on a TRelativePanel and the
       child control is selected in the Form Designer, the Object Inspector will display several additional properties
       at the bottom of the list that determine how the child control will be aligned within the TRelativePanel.
      
       The TRelativePanel positions child controls by first aligning each control to the panel as specified. Centering
       child controls (vertically and horizontally) takes precedence over left-right and top-bottom alignment. Next,
       each child control is positioned relative to its sibling controls. The list of child controls is processed in
       order. Therefore, if a child control is to be positioned relative to a sibling, the sibling control should
       have a lower index in the collection.
      
       Note, that it is possible to specify relationships between controls that lead to controls being positioned
       outside of the TRelativePanel. For example, if Label1 is positioned Above Edit1, but Edit1 is aligned to the
       Top of the TRelativePanel, Label1 will not be visible because it will be clipped by the panel.</docstr>
  </class>
  <class unit="Vcl.WinXCtrls" name="TCustomSplitView">
    <docstr>TCustomSplitView is the base class for TSplitView.</docstr>
    <members>
      <procedure name="SetState">
        <docstr>Proteced method used to change the opened and closed state of the control.</docstr>
      </procedure>
      <procedure name="DoClosing">
        <docstr>Event dispatch method that generates the OnClosing event.</docstr>
      </procedure>
      <procedure name="DoClosed">
        <docstr>Event dispatch method that generates the OnClosed event.</docstr>
      </procedure>
      <procedure name="DoOpening">
        <docstr>Event dispatch method that generates the OnOpening event.</docstr>
      </procedure>
      <procedure name="DoOpened">
        <docstr>Event dispatch method that generates the OnOpened event.</docstr>
      </procedure>
      <property name="AnimationDelay">
        <docstr>Use this property to control the speed of the opening and closing animation. The smaller the
           AnimationDelay, the faster the animation.</docstr>
      </property>
      <property name="AnimationStep">
        <docstr>Specifies the number of pixels by which the width of the control is adjusted during each step of the
           opening and closing animation.</docstr>
      </property>
      <property name="CloseStyle">
        <docstr>Specifies the appearance of the control when closed.
           svcCollapse - The TSplitView is completely hidden.
           svcCompact -  A smaller potion of the TSplitView remains visible.</docstr>
      </property>
      <property name="CompactWidth">
        <docstr>Specifies the width of the control when closed and CloseStyle is set to svcCompact.</docstr>
      </property>
      <property name="DisplayMode">
        <docstr>Specifies how the TSplitView appears when opened.
           svmDocked - The control is docked to the left or right edge of the form, and the client area is reduced by the
                       width of the control.
           svmOverlay - The control is displayed on top of the client area of the form.</docstr>
      </property>
      <property name="Opened">
        <docstr>Specifies whether the TSplitView is currently open.</docstr>
      </property>
      <property name="OpenedWidth">
        <docstr>Specifies the width of the TSplitView when in the opened state.</docstr>
      </property>
      <property name="Placement">
        <docstr>Specifies whether the TSplitView is placed on the left or right side of the form.</docstr>
      </property>
      <property name="UseAnimation">
        <docstr>Specifies whether the control animates the opening and closing process.</docstr>
      </property>
      <property name="Width">
        <docstr>Specifies the current width of the control.</docstr>
      </property>
      <event name="OnClosed">
        <docstr>This event occurs when the TSplitView is closed.</docstr>
      </event>
      <event name="OnClosing">
        <docstr>This event occurs when the TSplitView is starting to close. This event only occurs if UseAnimation is True.</docstr>
      </event>
      <event name="OnOpened">
        <docstr>This event occurs when the TSplitView is opened.</docstr>
      </event>
      <event name="OnOpening">
        <docstr>This event occurs when the TSplitView is starting to open. This event only occurs if UseAnimation is True.</docstr>
      </event>
      <procedure name="Open">
        <docstr>Use this method to open the TSplitView.</docstr>
      </procedure>
      <procedure name="Close">
        <docstr>Use this method to close the TSplitView. If CloseStyle is set to svcCollapse, the TSplitView will be
           completely hidden. If CloseStyle is set to svcCompact, the width of the TSplitView will be changed to the
           CompactWidth size.</docstr>
      </procedure>
    </members>
  </class>
  <class unit="Vcl.WinXCtrls" name="TSplitView">
    <docstr>TSplitView implements a container that can be opened and closed. When opened, the TSplitView can be docked to
       the left or right edge of the form, or it can be displayed on top of the form&apos;s client area. When closed, the
       TSplitView can be completely hidden (CloseStyle := svcCollapse), or a smaller portion of the split view can
       remain visible (CloseStyle := svcCompact).</docstr>
  </class>
  <class unit="Data.Bind.ObjectScope" name="TBaseObjectBindSource">
    <docstr>Is a bind source that supports adapters to connect to different types of data.
The TBaseObjectBindSource class implements a bind source that supports adapters to connect to different types of data. The adapter can be provided by setting a property (InternalAdapter) or by implementing the OnCreateAdapter event.</docstr>
    <members>
      <procedure name="UpdateAdapterChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="UpdateAdapterChanging">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="SetInternalAdapter">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="CheckRuntimeAdapter">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetRuntimeAdapter">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="ConnectAdapter">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DisconnectAdapter">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoMemberRenamed">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoMemberRenaming">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="OnAdapterUpdateState">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="OnAdapterDataSetChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="OnAdapterDataSetScrolled">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="OnAdapterEdit">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="OnAdapterEditingChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="OnAdapterLayoutChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="OnAdapterUpdateRecord">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="OnAdapterRecordChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="SetActive">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="CheckAdapter">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetInternalAdapter">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="SetRuntimeAdapter">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GetValue">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetMember">
        <docstr>Returns the member for the given member name.
Data.Bind.ObjectScope.TBaseObjectBindSource.GetMember inherits from Data.Bind.Components.TBaseBindScopeComponent.GetMember. All content below this line refers to Data.Bind.Components.TBaseBindScopeComponent.GetMember.
Returns the member for the given member name.
The GetMember method returns the scope member, as a TObject, for the member name given through the AMemberName parameter. This member is later used in the generated bindings expressions.

Tip: This member object or its properties may be referenced by bindings expressions.</docstr>
      </function>
      <procedure name="Notification">
        <docstr>Forwards notification messages to all owned components.
Data.Bind.ObjectScope.TBaseObjectBindSource.Notification inherits from System.Classes.TComponent.Notification. All content below this line refers to System.Classes.TComponent.Notification.
Forwards notification messages to all owned components.
Do not call the Notification method in an application. Notification is called automatically when the component specified by AComponent is about to be inserted or removed, as specified by Operation. By default, components pass along the notification to their owned components, if any.
A component can, if needed, act on the notification that a component is being inserted or removed. For example, if a component has object fields or properties that contain references to other components, it can check the notifications of component removals and invalidate those references as needed.

Note: Notification is not called for components that are freed implicitly (because their Owner is freed).</docstr>
      </procedure>
      <procedure name="Loaded">
        <docstr>Initializes the component after the form file has been read into memory.
Data.Bind.ObjectScope.TBaseObjectBindSource.Loaded inherits from System.Classes.TComponent.Loaded. All content below this line refers to System.Classes.TComponent.Loaded.
Initializes the component after the form file has been read into memory.
Do not call the protected Loaded method. The streaming system calls this method after it loads the component&apos;s form from a stream.
When the streaming system loads a form or data module from its form file, it first constructs the form component by calling its constructor, then reads its property values from the form file. After reading all the property values for all the components, the streaming system calls the Loaded methods of each component in the order the components were created. This gives the components a chance to initialize any data that depends on the values of other components or other parts of itself.

Note:  All references to sibling components are resolved by the time Loaded is called. Loaded is the first place that sibling pointers can be used after being streamed in.
As implemented in TComponent, Loaded clears the csLoading flag in the ComponentState property, indicating that the component is no longer loading.

Warning: Loaded may be called multiple times on inherited forms. It is called every time a level of inheritance is streamed in. Do not allocate memory in an overridden Loaded method without first checking that the memory has not been allocated in a previous call.</docstr>
      </procedure>
      <procedure name="AddExpression">
        <docstr>Adds the given bind component to the Expressions list.
Data.Bind.ObjectScope.TBaseObjectBindSource.AddExpression inherits from Data.Bind.Components.TBaseBindScopeComponent.AddExpression. All content below this line refers to Data.Bind.Components.TBaseBindScopeComponent.AddExpression.
Adds the given bind component to the Expressions list. The binding component is given through the AExpression parameter.</docstr>
      </procedure>
      <procedure name="RemoveExpression">
        <docstr>Removes the given binding component from the Expressions list.
Data.Bind.ObjectScope.TBaseObjectBindSource.RemoveExpression inherits from Data.Bind.Components.TBaseBindScopeComponent.RemoveExpression. All content below this line refers to Data.Bind.Components.TBaseBindScopeComponent.RemoveExpression.
Removes the given binding component from the Expressions list. The binding component to be removed is given through the AExpression parameter.</docstr>
      </procedure>
      <function name="Edit">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetIsEditing">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="SetModified">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GetIsModified">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetCanModify">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="UpdateRecord">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Reset">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="SetField">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="SetReadOnly">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="ClearModified">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="PosChanging">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GetEnumerator">
        <docstr>Returns a TComponent enumerator.
Data.Bind.ObjectScope.TBaseObjectBindSource.GetEnumerator inherits from System.Classes.TComponent.GetEnumerator. All content below this line refers to System.Classes.TComponent.GetEnumerator.
Returns a TComponent enumerator.
GetEnumerator returns a TComponentEnumerator reference, which enumerates the components contained within a specified containing component. 
To process all these subcomponents, call the TComponentEnumerator GetCurrent method within a While MoveNext do loop.</docstr>
      </function>
      <function name="GetBOF">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetEOF">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetSelected">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetActive">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetCanModify">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetCanInsert">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetCanDelete">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetEditing">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetCanRefresh">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="AddActiveChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="RemoveActiveChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="AddEditingChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="RemoveEditingChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="AddDataSetScrolled">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="RemoveDataSetScrolled">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="AddDataSetChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="RemoveDataSetChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="GetMemberNames">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GetCurrentRecord">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetMemberGetter">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetMemberSetter">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetMemberType">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetPositionGetter">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetPositionSetter">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="GetRecord">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoCreateAdapter">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="GetLookupMemberNames">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GetCanApplyUpdates">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetCanCancelUpdates">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="UpdateControlComponent">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="Locate">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="Lookup">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="ApplyUpdates">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="CancelUpdates">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Next">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Prior">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="First">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Last">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Insert">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Delete">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Cancel">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Post">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Edit">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Refresh">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="IsValidChar">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="IsRequired">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetFormatLink">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <property name="Eof">
        <docstr>Indicates whether the bind source adapter is positioned in the last record. 
Read Eof (end of file) to determine if ItemIndex is located in the last record. If Eof is True, the bind source has an adapter and the active record is the last one or there are no records. Eof is False if the ItemIndex is located in any other position.</docstr>
      </property>
      <property name="BOF">
        <docstr>Indicates whether the bind source adapter is positioned in the first record.
Read BOF (beginning of file) to determine if ItemIndex is located in the first record. If BOF is True, the bind source has an adapter and the active record is the first one. BOF is also True if there is no active record. BOF is False in all other cases.</docstr>
      </property>
      <property name="CanModify">
        <docstr>Specifies whether the bind source has permission to modify the data.
Check CanModify to determine if data can be edited. When CanModify is set to True, the bind source can edit the data. When CanModify is set to False, the bind source cannot edit the data.</docstr>
      </property>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Data.Bind.ObjectScope.TBaseObjectBindSource.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of the component and its owned components.
Data.Bind.ObjectScope.TBaseObjectBindSource.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
Disposes of the component and its owned components.
Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
To destroy a form, call its Release method. Release waits for all the form&apos;s event handlers and the event handlers of the form&apos;s components to finish executing before destroying the form.

Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates.</docstr>
      </destructor>
      <property name="Active">
        <docstr>Specifies whether the bind source adapter is active. 
Read Active to determine whether the bind source adapter is active. By default, the Active property is set to True.
When Active is False, the bind source does not have an adapter or its adapter is not active. When Active is True, the bind source has an active adapter.</docstr>
      </property>
      <property name="AutoActivate">
        <docstr>Specifies whether the bind source is automatically activated.  Set AutoActive to True for automatic activation.</docstr>
      </property>
      <property name="ItemIndex">
        <docstr>Specifies the index of the current record. 
ItemIndex holds the index of the current record of the dataset the bind source adapter is currently on. The first item has the index 0, the second item has the index 1, and so on. If no item is selected, the value of ItemIndex is -1.</docstr>
      </property>
      <property name="Editing">
        <docstr>Indicates whether the data is in edit mode. 
Read Editing to determine whether the bind source adapter can currently edit the data. If the Editing property is True, the data provided by the bind source adapter is in editing mode. Otherwise, it is False.</docstr>
      </property>
      <event name="OnCreateAdapter">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </event>
      <property name="InternalAdapter">
        <docstr>Returns the internal adapter of the bind source. 
The InternalAdapter property holds the internal adapter of the bind source. InternalAdapter uses the GetInternalAdapter method to return the internal adapter of the bind source.

Note:  The GetInternalAdapter method always returns nil. Descendant classes must override this method to return the internal adapter.</docstr>
      </property>
    </members>
  </class>
  <class unit="Data.Bind.ObjectScope" name="TBaseObjectBindSourceDelegate">
    <docstr>Bind source which delegates</docstr>
  </class>
  <class unit="Data.Bind.ObjectScope" name="TAdapterBindSource">
    <docstr>Bind source which supports adapters to connect to different types of data</docstr>
  </class>
  <class unit="Data.Bind.ObjectScope" name="TCustomPrototypeBindSource">
    <docstr>Is a base class that implements a bind source for creating sample data.
If you want to create your own custom prototype bind source, then you should derive your class from TCustomPrototypeBindSource. When designing applications, TPrototypeBindSource is available from the Tool Palette.</docstr>
    <members>
      <function name="GetInternalAdapter">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Data.Bind.ObjectScope.TCustomPrototypeBindSource.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <property name="AutoEdit">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="AutoPost">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="FieldDefs">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="RecordCount">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="DataGenerator">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
    </members>
  </class>
  <class unit="Data.Bind.ObjectScope" name="TPrototypeBindSource">
    <docstr>Is a bind source for creating sample data.
If you want to create your own custom prototype bind source, then you should derive your class from TCustomPrototypeBindSource. When designing applications that make use of the LiveBindings framework, you can use a TPrototypeBindSource component readily available in the Tool Palette to generate sample data for your bindings.
These tutorials in the Tutorials section describe the use of TPrototypeBindSource:

Tutorial: Using TPrototypeBindSource and the LiveBindings Designer
Mobile Tutorial: Using LiveBindings to Populate a ListView (iOS and Android)
Tutorial: Using LiveBindings and DataModules with the Metropolis UI
Mobile Tutorial: Using LiveBindings to Populate a ListBox in Mobile Applications (iOS and Android)</docstr>
  </class>
  <class unit="Data.Bind.ObjectScope" name="TBindSourceAdapter">
    <docstr>Adapter base class for providing data to a TAdapterBindScope</docstr>
  </class>
  <class unit="Data.Bind.ObjectScope" name="TListBindSourceAdapter`1">
    <docstr>Adapter to provide a generic TList to TAdapterBindSource</docstr>
  </class>
  <class unit="Data.Bind.ObjectScope" name="TObjectBindSourceAdapter`1">
    <docstr>Adapter to provide an arbitrary object to TAdapterBindSource</docstr>
  </class>
  <class unit="Data.Bind.ObjectScope" name="TBindSourceAdapterField">
    <docstr>Base class for an adapter field</docstr>
  </class>
  <class unit="Data.Bind.ObjectScope" name="TValueAccessor">
    <docstr>Base class to get a value using RTTI</docstr>
  </class>
  <class unit="Data.Bind.ObjectScope" name="TValueReader`1">
    <docstr>Base class to get a value of a particular type using RTTI</docstr>
  </class>
  <class unit="Data.Bind.ObjectScope" name="TFieldValueReader`1">
    <docstr>Use RTTI to read the value of a field</docstr>
  </class>
  <class unit="Data.Bind.ObjectScope" name="TPropertyValueReader`1">
    <docstr>Use RTTI to read the value of a property</docstr>
  </class>
  <class unit="Data.Bind.ObjectScope" name="TValueWriter`1">
    <docstr>Base class to set a value using RTTI</docstr>
  </class>
  <class unit="Data.Bind.ObjectScope" name="TFieldValueWriter`1">
    <docstr>Use RTTI to set the value of a field</docstr>
  </class>
  <class unit="Data.Bind.ObjectScope" name="TPropertyValueWriter`1">
    <docstr>Use RTTI to set the value of a property</docstr>
  </class>
  <class unit="Data.Bind.ObjectScope" name="TBindSourceAdapterReadField`1">
    <docstr>Adapter field which supports reading</docstr>
  </class>
  <class unit="Data.Bind.ObjectScope" name="TBindSourceAdapterReadWriteField`1">
    <docstr>Adapter field which supports reading and writing</docstr>
  </class>
  <class unit="Data.Bind.ObjectScope" name="TBindSourceAdapterReadObjectField">
    <docstr>Adapter field which supports an object property</docstr>
  </class>
  <class unit="Data.Bind.ObjectScope" name="TBindSourceAdapterCustomScope">
    <docstr>Custom scope to allow the expression engine to access field names as if they are members of the
        wrapped TBindSourceAdapter</docstr>
  </class>
  <class unit="Data.Bind.ObjectScope" name="TBindSourceAdapterObjectFieldCustomScope">
    <docstr>Custom scope to allow the expression engine to access field names as if they are members of the
        wrapped field</docstr>
  </class>
  <class unit="Data.Bind.ObjectScope" name="TBindSourceAdapterGetMemberObject">
    <docstr>Implementation of IGetMemberObject to get the object associated with an adapter</docstr>
  </class>
  <class unit="Data.Bind.ObjectScope" name="TBindSourceAdapteObjectFieldGetMemberObject">
    <docstr>Implementation of IGetMemberObject to get the object associated with object field</docstr>
  </class>
  <class unit="Data.Bind.ObjectScope" name="TCustomDataGeneratorAdapter">
    <docstr>Adapter to provide a generic TList to TAdaptiveBindScope</docstr>
  </class>
  <class unit="Vcl.StdCtrls" name="TGroupBox">
    <docstr>TGroupBox represents a Windows group box.
The TGroupBox component represents a standard Windows group box, used to group related controls on a form. When another control component is placed within a group box, the group box becomes the parent of that component.</docstr>
  </class>
  <class unit="Vcl.StdCtrls" name="TLabel">
    <docstr>TLabel is a nonwindowed control that displays text on a form.
Use TLabel to add text that the user cannot edit on a form. This text can be used to label another control, and can set focus to that control when the user types an accelerator key. The Caption property can be used to define an accelerator key to a label control. 
Because TLabel is not a descendant of TWinControl, it does not have its own window and cannot receive direct input from the keyboard. To add an object to a form that can respond to keyboard input (other than setting focus to another object when an accelerator key is typed) in addition to displaying text, use TStaticText.
To add an object to a form that displays text that a user can scroll or edit, use TEdit.</docstr>
  </class>
  <class unit="Vcl.StdCtrls" name="TCustomEdit">
    <docstr>TCustomEdit is the base class from which all edit-box and memo controls are derived.
TCustomEdit encapsulates the behavior common to all components for editing text by introducing methods and properties that provide:
Basic text editing functions such as selecting text, modifying selected text, and case conversions.
Ability to respond to changes in the contents of the text.
Access control of the text for making it read-only or introducing a password character to hide the actual value.
Do not create instances of TCustomEdit. Use TCustomEdit as a base class when declaring control objects that permit the user to enter or modify text. Properties and methods of TCustomEdit provide basic behavior that descendant classes inherit as well as behavior that components can override to customize their behavior.</docstr>
    <members>
      <function name="CanObserve">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="ObserverAdded">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="ObserverToggle">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Change">
        <docstr>Generates an OnChange event.
Applications do not call the Change method directly. It is triggered automatically by Windows events. Change is exposed as a protected method so that derived classes can make additional responses when the text changes beyond invoking the OnChange event handler. If Derived classes that override the Change method do not call the inherited method, the OnChange event handler will not be called.</docstr>
      </procedure>
      <procedure name="KeyDown">
        <docstr>Responds to key press events.
Vcl.StdCtrls.TCustomEdit.KeyDown inherits from Vcl.Controls.TWinControl.KeyDown. All content below this line refers to Vcl.Controls.TWinControl.KeyDown.
Responds to key press events.
When a windowed control receives a key-down message (WM_KEYDOWN) from Windows, its message handler calls the DoKeyDown method. If DoKeyDown determines that the control should, in fact, process the character, it calls KeyDown, passing the key code and shift-key state in the Key and Shift parameters, respectively.
KeyDown calls any event handler attached to the OnKeyDown event. Override KeyDown to provide other responses in addition to the event handler call.
The Key parameter is the key on the keyboard. For nonalphanumeric keys, you must use WinAPI virtual key codes to determine the key pressed. For more information see Representing Keys and Shortcuts.
The Shift parameter indicates whether the SHIFT, ALT, or CTRL keys are combined with the keystroke.
Either KeyDown or the OnKeyDown event handler it calls can suppress further processing of a key by setting the Key parameter to zero.</docstr>
      </procedure>
      <procedure name="KeyPress">
        <docstr>Responds to keyboard input.
Vcl.StdCtrls.TCustomEdit.KeyPress inherits from Vcl.Controls.TWinControl.KeyPress. All content below this line refers to Vcl.Controls.TWinControl.KeyPress.
Responds to keyboard input.
When a windowed control receives a key-press message (WM_CHAR) from Windows, its message handler calls the DoKeyPress method. If DoKeyPress determines that the control should, in fact, process the character, it calls KeyPress, passing the key code in the Key parameter.
KeyPress calls any event handler attached to the OnKeyPress event. Override KeyPress to provide other responses in addition to the event handler call.
Either KeyPress or the OnKeyPress event handler it calls can suppress further processing of a character by setting the Key parameter to zero.

Note: The Key parameter is the character represented by the key that is pressed, not a Windows virtual key code.</docstr>
      </procedure>
      <procedure name="CreateParams">
        <docstr>Initializes a window-creation parameter record passed in the Params parameter.
The CreateWnd method calls CreateParams to initialize the parameters it passes to CreateWindowHandle. TCustomEdit overrides the inherited method to specify a scrollable single-line edit control that reflects the current values of the BorderStyle, HideSelection, PasswordChar, and ReadOnly properties.</docstr>
      </procedure>
      <procedure name="CreateWindowHandle">
        <docstr>Creates a Windows control to represent the control.
CreateWindowHandle calls the inherited CreateWindowHandle method after working around a Win95 bug involving setting the read-only style on machines with Far East locales.</docstr>
      </procedure>
      <procedure name="CreateWnd">
        <docstr>Creates a Windows control corresponding to the edit control.
CreateWnd is called when the edit control is created, and whenever a change to the edit control requires the window to be recreated. After calling the inherited method, CreateWnd sends the newly created window messages to enforce the MaxLength and PasswordChar properties.</docstr>
      </procedure>
      <procedure name="DestroyWnd">
        <docstr>Destroys the Windows control that corresponds to the edit control.
The Windows control for the edit box can be temporarily destroyed and recreated in order to set properties that require changing the window creation parameters. When this happens, DestroyWnd is called.
Before the window is destroyed, DestroyWnd saves a copy of any properties that are needed to recreate the window after it is destroyed.</docstr>
      </procedure>
      <procedure name="DoSetMaxLength">
        <docstr>Sets the MaxLength property.
DoSetMaxLength is the property access function for the MaxLength property. It is exposed as a protected method so that descendants of TCustomEdit can customize the implementation of the MaxLength property. 
DoSetMaxLength sends an EM_LIMITTEXT message to the window of the edit control.</docstr>
      </procedure>
      <procedure name="DoSetTextHint">
        <docstr>Sets the value of the TextHint property.
DoSetTextHint is a protected method used to set the value of the TextHint property.</docstr>
      </procedure>
      <procedure name="UpdateEditMargins">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GetSelLength">
        <docstr>Returns the SelLength property.
GetSelLength is the property access function for the SelLength property. It is exposed as a protected method so that descendants of TCustomEdit can customize the implementation of the SelLength property. 
GetSelLength sends an EM_GETSEL message to the window of the edit control and returns the difference between the starting position and the ending position.</docstr>
      </function>
      <function name="GetSelStart">
        <docstr>Returns the SelStart property.
GetSelStart is the property access method for the SelStart property. It is exposed as a protected method so that descendants of TCustomEdit can customize the implementation of the SelStart property. 
GetSelStart sends an EM_GETSEL message to the window of the edit control and returns the starting position.</docstr>
      </function>
      <function name="GetSelText">
        <docstr>Returns the SelText property.
GetSelText is the property access method for the SelText property. It is exposed as a protected method so that descendants of TCustomEdit can customize the implementation of the SelText property.</docstr>
      </function>
      <procedure name="SetAlignment">
        <docstr>Sets the Alignment property.
SetAlignment is exposed as a protected method so derived classes can customize their implementation of the Alignment property.</docstr>
      </procedure>
      <procedure name="SetAutoSize">
        <docstr>Sets the AutoSize property.
SetAutoSize is the protected write implementation of the AutoSize property.
TCustomEdit overrides the inherited method to update the height of the edit control to reflect the current font when the value of AutoSize changes to true.</docstr>
      </procedure>
      <procedure name="SetSelLength">
        <docstr>Sets the SelLength property.
SetSelLength is the property access method for the SelLength property. It is exposed as a protected method so that descendants of TCustomEdit can customize the implementation of the SelLength property. 
SetSelLength sends an EM_SETSEL message to the window of the edit control, specifying a selection that begins at SelStart and ends at SelStart + Value.</docstr>
      </procedure>
      <procedure name="SetSelStart">
        <docstr>Sets the SelStart property.
SetSelStart is the property access method for the SelStart property. It is exposed as a protected method so that descendants of TCustomEdit can customize the implementation of the SelStart property. 
SetSelLength sends an EM_SETSEL message to the window of the edit control to position the cursor on the position indicated by Value.</docstr>
      </procedure>
      <procedure name="UpdateTIPStatus">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <property name="AutoSelect">
        <docstr>Determines whether all the text in the edit control is automatically selected when the control gets focus.
Set AutoSelect to select all the text when the edit control gets focus. AutoSelect only applies to single-line edit controls.
Use AutoSelect when the user is more likely to replace the text in the edit control than to append to it.</docstr>
      </property>
      <property name="AutoSize">
        <docstr>Determines whether the height of the edit control automatically resizes to accommodate the text.
Use AutoSize to make the edit control adjust its size automatically so the client area accommodates the height of the text. When AutoSize is false, the edit control has a fixed height. When AutoSize is true, the size of the control is readjusted whenever a change occurs that could affect the height of the control, such as a change to the font or border style.

Note: AutoSize only adjusts the height of the edit control. Even with AutoSize set to true, text in the edit control may appear truncated if it extends beyond the width of the control.</docstr>
      </property>
      <property name="BorderStyle">
        <docstr>Determines whether the edit control has a single line border around the client area.
Use BorderStyle to affect the sharpness with which the client area of the edit control stands out. BorderStyle can have a value of either bsSingle or bsNone. If BorderStyle is bsSingle, the edit control has a single-line border around the client area. If BorderStyle is bsNone, there will be no border.</docstr>
      </property>
      <property name="CharCase">
        <docstr>Determines the case of the text within the edit control.
Use CharCase to force the contents of the edit control to assume a particular case.
When CharCase is set to ecLowerCase or ecUpperCase, the case of characters is converted as the user types them into the edit control. Changing the CharCase property to ecLowerCase or ecUpperCase changes the actual contents of the text, not just the appearance. Any case information is lost and can&apos;t be recaptured by changing CharCase to ecNormal.</docstr>
      </property>
      <property name="HideSelection">
        <docstr>Determines whether the visual indication of the selected text remains when focus shifts to another control.
Set HideSelection to false to provide visual feedback of the selected portion of the text even when the edit control does not have focus. Set HideSelection to true to show the selection only when the edit control has focus. HideSelection does not affect the actual value of the selection, only the visual indication. Always setting HideSelection to false can make forms with many edit controls look too busy.</docstr>
      </property>
      <property name="MaxLength">
        <docstr>Specifies the maximum number of characters the user can enter into the edit control.
Use MaxLength to limit the number of characters that can be entered into the edit control. A value of 0 indicates that there is no application-defined limit on the length.
Use MaxLength to limit the length of the text in an edit control if that text will be copied into a fixed-length buffer.

Note:  Setting MaxLength will not truncate the existing text, it merely prevents the user from adding more text after reaching the limit of MaxLength characters.
Note:  Even when MaxLength is 0, there may be limitations imposed by the operating system on the number of characters that may be entered into an edit control.
Note:  The unit of MaxLength is characters (not bytes) if the application is using themes.</docstr>
      </property>
      <property name="OEMConvert">
        <docstr>Determines whether characters typed in the edit control are converted from ANSI to OEM and then back to ANSI.
To ensure that any characters typed in the edit control can be unambiguously converted to the OEM character set, set OEMConvert to true. This causes all characters to be converted from ANSI to OEM and then back to ANSI as they are typed. Set OEMConvert to false to avoid the overhead of this conversion when it does not matter whether the text can be unambiguously mapped to an OEM string.
OEMConvert is most useful for edit controls used to enter file names when the application does not use Unicode file names.</docstr>
      </property>
      <property name="NumbersOnly">
        <docstr>Allows only numbers to be typed into the text edit.
Use NumbersOnly to prohibit entry of non-numeric characters in the textfield. Note, however, that a user can paste non-numeric characters in the textfield even when this property is set.

Code Examples
StdCtrlsProp (Delphi)
StdCtrlsProp (C++)</docstr>
      </property>
      <property name="PasswordChar">
        <docstr>Indicates the character, if any, to display in place of the actual characters typed in the control.
Use the PasswordChar property to create an edit control that displays a special character in place of any entered text. If PasswordChar is set to the null character (ANSI character zero), the edit control displays its text normally. If PasswordChar is any other character, the edit control displays PasswordChar in place of each character typed. PasswordChar affects the appearance of the edit control only. The value of the Text property reflects the actual characters that are typed.</docstr>
      </property>
      <property name="ParentColor">
        <docstr>Specifies where a control looks for its color information.
To have a control use the same color as its parent control, set ParentColor to True. If ParentColor is False, the control uses its own Color property.
Set ParentColor to True for all controls to ensure that all the controls on a form have a uniform appearance. For example, if ParentColor is True for all controls in a form, changing the background color of the form to gray causes all the controls on the form to also have a gray background.
When the value of a control&apos;s Color property changes, ParentColor becomes False automatically.</docstr>
      </property>
      <event name="OnChange">
        <docstr>Occurs when the text for the edit control may have changed.
Write an OnChange event handler to take specific action whenever the text for the edit control may have changed. Use the Modified property to see if a change actually occurred. The Text property of the edit control will already be updated to reflect any changes. This event provides the first opportunity to respond to modifications that the user types into the edit control.</docstr>
      </event>
      <constructor name="Create">
        <docstr>Creates an instance of TCustomEdit.
Call Create to create and initialize an instance of TCustomEdit.
AOwner is another component, typically the form, that is responsible for freeing the edit control. It becomes the value of the Owner property.
Derived objects that override the Create method should call the inherited Create before performing any additional initialization.</docstr>
      </constructor>
      <procedure name="Clear">
        <docstr>Deletes all text from the edit control.
Use Clear to replace the Text property with an empty string. Clear removes all text, not just the selected text. To remove just the selected text, use ClearSelection.</docstr>
      </procedure>
      <procedure name="ClearSelection">
        <docstr>Removes the selected text from the edit control.
Use ClearSelection to delete the selected text from the edit control. If no text is selected, ClearSelection does nothing. If all of the text is selected, ClearSelection clears all text, like the Clear method.

Note:  Calling ClearSelection does the same thing as sending the edit control a WM_CLEAR message.</docstr>
      </procedure>
      <procedure name="CopyToClipboard">
        <docstr>Copies the selected text in the edit control to the Clipboard in CF_TEXT format.
Use CopyToClipboard to replace the contents of the Clipboard with the selected text. CopyToClipboard does not clear the Clipboard if no text is selected. If no text is selected, CopyToClipboard does nothing.

Note:  Calling CopyToClipboard does the same thing as sending the edit control a WM_COPY message.</docstr>
      </procedure>
      <procedure name="CutToClipboard">
        <docstr>Copies the selected text to the Clipboard in CF_TEXT format and then deletes the selection.
Use CutToClipboard to replace the contents of the Clipboard with the selected text while clearing the selected text. If no text is selected, CutToClipboard does nothing.

Note:  Calling CopyToClipboard does the same thing as sending the edit control a WM_CUT message.</docstr>
      </procedure>
      <procedure name="DefaultHandler">
        <docstr>Provides message handling for all messages that the control does not fully process itself.
Override DefaultHandler to change the default message handling for the edit control. The Message parameter can be cast to a TMessage type to obtain the WParam, LParam, and Result of the message. If the Result of the message is non-zero, the message has already been handled. Set the Result field to a non-zero value to prevent further processing of the message by the inherited method.

Note: In Delphi, calling inherited in a message-handling method results in a call to the ancestor&apos;s DefaultHandler method if that ancestor does not specify a handler for the message being handled.</docstr>
      </procedure>
      <function name="GetControlsAlignment">
        <docstr>Indicates how text is aligned within the control.
Vcl.StdCtrls.TCustomEdit.GetControlsAlignment inherits from Vcl.Controls.TControl.GetControlsAlignment. All content below this line refers to Vcl.Controls.TControl.GetControlsAlignment.
Indicates how text is aligned within the control.
Use GetControlsAlignment to determine the alignment of the control. For controls that do not have an Alignment property, GetControlsAlignment returns taLeftJustify.

Note: GetControlsAlignment returns the alignment of text before it is altered by the BiDiMode property. To check whether the alignment should be reversed to reflect the BiDiMode property, call UseRightToLeftAlignment.</docstr>
      </function>
      <procedure name="PasteFromClipboard">
        <docstr>Pastes the contents of the Clipboard into edit control, replacing the current selection.
Use PasteFromClipboard to replace the selected text with the contents of the Clipboard, or, if no text is selected, to insert the contents of the Clipboard at the cursor. If the Clipboard is empty, or if it does not contain anything in CF_TEXT format, PasteFromClipboard does nothing.

Note:  Calling PasteFromClipboard does the same thing as sending the edit control a WM_PASTE message.</docstr>
      </procedure>
      <procedure name="Undo">
        <docstr>Backs out all changes in the undo buffer.
Call Undo to cancel all changes made to the Text property since the last call to the ClearUndo method. If ClearUndo was never called, Undo rolls back all changes.
To determine whether there are any changes in the undo buffer, check the CanUndo property.</docstr>
      </procedure>
      <procedure name="ClearUndo">
        <docstr>Clears the undo buffer so that no changes to the text can be backed out.
Use ClearUndo to commit changes to the Text property. After calling ClearUndo, the CanUndo property is false and the Undo method does nothing.</docstr>
      </procedure>
      <procedure name="SetSelText">
        <docstr>Sets the SelText property.
SetSelText is the property access method for the SelText property.</docstr>
      </procedure>
      <procedure name="SelectAll">
        <docstr>Selects all text in the edit control.
Use SelectAll to select all text in the edit control. To select only part of the text, use the SelStart and SelLength properties.</docstr>
      </procedure>
      <function name="GetSelTextBuf">
        <docstr>Copies the selected text into a buffer and returns the number of characters copied.
Use GetSelTextBuf to copy the selected text into a character buffer. If there is no selection, the buffer receives an empty string. If the selection contains more than (BufSize - 1) characters, only the first (BufSize - 1) characters are copied. GetSelTextBuf returns the number of characters that were actually copied into the buffer.</docstr>
      </function>
      <procedure name="SetSelTextBuf">
        <docstr>Replaces the selected text with a null-terminated string.
Use SetSelTextBuf to replace the current selection by the contents of the null-terminated string pointed to by Buffer. If no text is selected, the contents of Buffer are inserted at the cursor. SetSelTextBuf does the same thing as setting the SelText property, except that it takes a pointer to a char type rather than a string.</docstr>
      </procedure>
      <property name="Alignment">
        <docstr>Determines how the text is aligned within the text edit control.
Use Alignment to change the way the text is formatted in the text edit control. Alignment can take one of the following values:





Value

Meaning



taLeftJustify



Align text to the left side of the control




taCenter



Center text horizontally in the control.




taRightJustify



Align text to the right side of the control.</docstr>
      </property>
      <property name="CanUndo">
        <docstr>Indicates whether the edit control contains changes that can be backed out.
Read CanUndo to determine whether the user has made any changes to the text that can be undone by calling the Undo method. This is useful when enabling or disabling menu items that correspond to these commands.</docstr>
      </property>
      <property name="Modified">
        <docstr>Indicates whether the user edited the text of the edit control.
Use Modified to determine whether the user changed the Text property of the edit control. Modified is only reset to False when you assign a value to the Text property. In particular, it is not reset when the control receives focus.</docstr>
      </property>
      <property name="CanUndoSelText">
        <docstr>When set to True, it allows you to call or invoke an Undo operation in order to undo a change previously made by using SetSelText or SetSelTextBuf. By default it is set to false.</docstr>
      </property>
      <property name="ReadOnly">
        <docstr>Determines whether the user can change the text of the edit control.
To restrict the edit control to display only, set the ReadOnly property to true. Set ReadOnly to false to allow the contents of the edit control to be edited.
Setting ReadOnly to true ensures that the text is not altered, while still allowing the user to select text. The selected text can then be manipulated by the application, or copied to the Clipboard.</docstr>
      </property>
      <property name="SelLength">
        <docstr>Specifies the number of characters (bytes) that are selected.
Read SelLength to determine the length, in bytes, of the selected text. This is the same as the number of characters, unless you are using a multi-byte character set. Set SelLength to change the selection to consist of the first SelLength bytes starting at SelStart.

Note:  Setting SelLength to a value greater than the number of characters from SelStart to the end of the text results in the selection of all characters from SelStart to the end of the text. Reading SelLength immediately after setting it to a value greater than the number of available characters returns the number of characters actually selected, not the value that was just set.</docstr>
      </property>
      <property name="SelStart">
        <docstr>Specifies the position of the first selected character in the text.
Read SelStart to determine the position of the first selected character, where 0 indicates the first character. If there is no selected text, SelStart indicates the position of the cursor. Set SelStart to remove the current selection and position the cursor just before the indicated character.
To select a particular range of the text, first set SelStart to position the cursor, and then set SelLength to extend the selection.</docstr>
      </property>
      <property name="SelText">
        <docstr>Specifies the selected portion of the edit control&apos;s text.
Read SelText to determine the value of the selected text. Set SelText to replace the selected text with a new string. If there is no selection, but the edit control has focus, set SelText to insert a new string into the text at the cursor.</docstr>
      </property>
      <property name="TextHint">
        <docstr>A hint or message to be displayed when the Text property is empty.
Use TextHint to cue the user on what kind of entry is expected in the text field. Runtime themes must be enabled.

Code Examples
StdCtrlsProp (Delphi)
StdCtrlsProp (C++)</docstr>
      </property>
    </members>
  </class>
  <class unit="Vcl.StdCtrls" name="TEdit">
    <docstr>TEdit is a wrapper for a Windows single-line edit control.
Use a TEdit object to put a standard Windows edit control on a form. Edit controls are used to retrieve text that users type. Edit controls can also display text to the user. 
When only displaying text to the user, choose an edit control to allow users to select text and copy it to the Clipboard. Choose a label object if the selection capabilities of an edit control are not needed.
TEdit implements the generic behavior introduced in TCustomEdit. TEdit publishes many of the properties inherited from TCustomEdit, but does not introduce any new behavior. For specialized edit controls, use other descendant classes of TCustomEdit or derive from it.</docstr>
  </class>
  <class unit="Vcl.StdCtrls" name="TCustomMemo">
    <docstr>TCustomMemo is the base type for memo components, which are multiline edit boxes, including TMemo and TDBMemo.
TCustomMemo introduces new properties and methods to expand the capabilities of TCustomEdit for handling multiline edit boxes.
Do not create instances of TCustomMemo. Use TCustomMemo as a base class when declaring control objects that implement a multiline edit control. Properties and methods of TCustomMemo provide basic behavior that descendant classes inherit as well as behavior that components can override to customize their behavior.</docstr>
    <members>
      <procedure name="CreateParams">
        <docstr>Initializes a window-creation parameter record passed in the Params parameter.
The CreateWnd method calls CreateParams to initialize the parameters it passes to CreateWindowHandle. TCustomMemo overrides the inherited method to specify a scrollable multiline edit control. The Params parameter is updated to reflect the current values of the Alignment, ScrollBars, and WordWrap properties, in addition to the BorderStyle, HideSelection, PasswordChar, and ReadOnly properties that the inherited method specifies.</docstr>
      </procedure>
      <procedure name="CreateWindowHandle">
        <docstr>Creates a window based on the window-creation parameter record.
The CreateWnd method calls CreateWindowHandle to create the edit control window once it has been specified in the window-creation parameters. CreateWindowHandle creates the window by calling the CreateWindowEx API function, passing parameters from the record passed in the Params parameter. CreateWindowHandle overrides the inherited method to interpret the Caption in Params as the initial text rather than as the window caption.</docstr>
      </procedure>
      <procedure name="CreateWnd">
        <docstr>Creates a Windows control corresponding to the edit control.
Vcl.StdCtrls.TCustomMemo.CreateWnd inherits from Vcl.StdCtrls.TCustomEdit.CreateWnd. All content below this line refers to Vcl.StdCtrls.TCustomEdit.CreateWnd.
Creates a Windows control corresponding to the edit control.
CreateWnd is called when the edit control is created, and whenever a change to the edit control requires the window to be recreated. After calling the inherited method, CreateWnd sends the newly created window messages to enforce the MaxLength and PasswordChar properties.</docstr>
      </procedure>
      <function name="GetCaretPos">
        <docstr>Returns the value of the CaretPos property.
CaretPos represents the coordinates of the cursor. GetCaretPos is the protected implementation of the CaretPos property. Override this method to change the way the caret position is computed.</docstr>
      </function>
      <procedure name="DoGetGestureOptions">
        <docstr>Returns the interactive gestures and their options.
Vcl.StdCtrls.TCustomMemo.DoGetGestureOptions inherits from Vcl.Controls.TControl.DoGetGestureOptions. All content below this line refers to Vcl.Controls.TControl.DoGetGestureOptions.
Returns the interactive gestures and their options.
DoGetGestureOptions is used internally to access the interactive gestures and their options associated with a TControl.</docstr>
      </procedure>
      <procedure name="DoUpdateEditMargins">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="IsTouchPropertyStored">
        <docstr>Checks whether the associated touch manager stored any of the given options.
Vcl.StdCtrls.TCustomMemo.IsTouchPropertyStored inherits from Vcl.Controls.TControl.IsTouchPropertyStored. All content below this line refers to Vcl.Controls.TControl.IsTouchPropertyStored.
Checks whether the associated touch manager stored any of the given options.
IsTouchPropertyStored is used internally by the VCL framework to check whether the associated touch manager component has stored the given options. Do not call IsTouchPropertyStored directly. IsTouchPropertyStored is used primarily to ensure that controls that do not require gesturing are not storing useless data in the DFMs or executables.</docstr>
      </function>
      <procedure name="KeyPress">
        <docstr>Ensures that return characters are not entered into the text when WantReturns is false.
KeyPress is called automatically when the user presses a key. After calling the inherited KeyPress, which calls the OnKeyPress event handler, KeyPress discards return characters when WantReturns is false.</docstr>
      </procedure>
      <procedure name="Loaded">
        <docstr>Initializes the memo control when it is first loaded into memory.
Loaded overrides the inherited method so that the Modified property is set to false when the form containing the memo is first loaded into memory. Derived classes can override the Loaded method to perform additional initializations after the memo&apos;s form is loaded.</docstr>
      </procedure>
      <procedure name="SetCaretPos">
        <docstr>Sets the CaretPos property.
SetCaretPos is the property write access method for the CaretPos property. The CaretPos property returns the coordinates of the cursor. SetCaretPos sets the cursor position to Value.</docstr>
      </procedure>
      <procedure name="SetEditMargins">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="SetLines">
        <docstr>Sets the Lines property.
SetLines is the protected write implementation for the Lines property.
SetLines is exposed as a protected method so derived classes can customize their implementation of the Lines property.</docstr>
      </procedure>
      <procedure name="SetScrollBars">
        <docstr>Sets the ScrollBars property.
SetScrollBars is the property access method for the ScrollBars property. 
SetScrollBars is exposed as a protected method so derived classes can customize their implementation of the ScrollBars property.</docstr>
      </procedure>
      <procedure name="SetWordWrap">
        <docstr>Sets the WordWrap property.
SetWordWrap is the property access method for the WordWrap property.</docstr>
      </procedure>
      <procedure name="UpdateEditMargins">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <property name="ScrollBars">
        <docstr>Determines whether the memo control has scroll bars.
Use ScrollBars to give a multiline edit control horizontal or vertical scroll bars. ScrollBars can take one of the following values:





Value

Meaning



ssNone



The control has no scroll bars.




ssHorizontal



The control has a single scroll bar on the bottom edge.




ssVertical



The control has a single scroll bar on the right edge.




ssBoth



The control has a scroll bar on both the bottom and right edges.</docstr>
      </property>
      <property name="WantReturns">
        <docstr>Determines whether the user can insert return characters into the text.
Set WantReturns to true to allow users to enter return characters into the text. Set WantReturns to false to allow the form to handle return characters instead. 
For example, in a form with a default button (such as an OK button) and a memo control, if WantReturns is false, pressing Enter chooses the default button. If WantReturns is true, pressing Enter inserts a return character in the text.

Note:  If WantReturns is false, users can still enter return characters into the text by pressing Ctrl+Enter.</docstr>
      </property>
      <property name="WantTabs">
        <docstr>Determines whether the user can insert tab characters into the text.
Set WantTabs to true to allow users to enter tab characters into the text. Set WantTabs to false if you want the tab character to select the next control on the form instead. 

Note:  If WantTabs is true, users can tab into the edit control, but they can&apos;t tab out.</docstr>
      </property>
      <property name="WordWrap">
        <docstr>Determines whether the edit control inserts soft carriage returns so that the text wraps at the right margin.
Set WordWrap to true to make the edit control wrap text at the right margin so that it fits in the client area. The wrapping has cosmetic purposes only. The text does not include any return characters that were not explicitly entered. Set WordWrap to false to have the edit control display a separate line only where return characters were explicitly entered into the text. 

Note:  Most of the times when WordWrap is true, the horizontal scroll bar is not necessary. However, exceptions appear; when the line cannot be cut into pieces, the wrapping cannot occur. In these cases, the scroll bar is still required.</docstr>
      </property>
      <constructor name="Create">
        <docstr>Creates and initializes an instance of TCustomMemo.
Call Create to instantiate a TCustomMemo object.
AOwner is the component, typically the form, that is responsible for freeing the memo object. This becomes the value of the Owner property.
Derived objects that override the Create method should call the inherited Create before making any additional initializations.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys an instance of TCustomMemo.
Do not call Destroy directly in an application. Instead, call Free. Free checks that the TCustomMemo reference is not nil, and only then calls Destroy.
Destroy frees the TStrings object that implements the Lines property before calling the inherited destructor.</docstr>
      </destructor>
      <property name="CaretPos">
        <docstr>Indicates the position of the caret in the client area of the memo.
Use CaretPos to determine the coordinates of the cursor. CaretPos defines a location onscreen, in characters, with the origin in the top left corner of the memo. X specifies the horizontal coordinate of the point, Y specifies the vertical coordinate.
To determine the position of the caret in terms of characters of text only (rather than X/Y location), use the SelStart property.</docstr>
      </property>
      <property name="EditMargins">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="Lines">
        <docstr>Contains the individual lines of text in the memo control.
Use Lines to manipulate text in an memo control on a line-by-line basis. Lines is a TStrings object, so the TStrings methods may be used for Lines to perform manipulations such as counting the lines of text, adding new lines, deleting lines, or replacing lines with new text. For example:

MyMemo.Lines.Add(...);

To work with all the text at once, use the Text property. To manipulate individual lines of text, the Lines property works better.

Note:  Although Lines is implemented as a TStrings descendant, it does not implement the support for associating objects with the strings in the list.</docstr>
      </property>
    </members>
  </class>
  <class unit="Vcl.StdCtrls" name="TMemo">
    <docstr>TMemo is a wrapper for a Windows multiline edit control.
Use TMemo to put a standard Windows multiline edit control on a form. Multiline edit boxes allow the user to enter more than one line of text. They are appropriate for representing lengthy information.
TMemo implements the generic behavior introduced in TCustomMemo. TMemo publishes many of the properties inherited from TCustomMemo, but does not introduce any new behavior.</docstr>
  </class>
  <class unit="Vcl.StdCtrls" name="TComboBox">
    <docstr>TComboBox combines an edit box with a scrollable list.
A TComboBox component is an edit box with a scrollable drop-down list attached to it. Users can select an item from the list or type directly into the edit box.

Note:  The width of the button in a TComboBox is equal to the width that Windows uses for scrollbars. This width depends on the color scheme that the user has chosen (by right-clicking the desktop, selecting Properties, and choosing Appearance). If you carefully size your combo box so all the text is visible, then a user running under a different color scheme may find that the text is obscured by the button. One solution is to set the scrollbar wide when developing the application. Most color schemes use a scrollbar that is at most 21 pixels wide.</docstr>
  </class>
  <class unit="Vcl.StdCtrls" name="TButton">
    <docstr>TButton is a push button control.
Use TButton to put a standard push button on a form. TButton introduces several properties to control its behavior in a dialog box setting. Users choose button controls to initiate actions.
To use a button that displays a bitmap instead of a label, use TBitBtn. To use a button that can remain in a pressed position, use TSpeedButton.
The Caption property can be used to define an accelerator key to a control. 

Note: Because the TButton caption is always centered, changing the BiDiMode alignment has no effect.
Note: Changing the color of the Caption is not supported for TButton. Instead, use a button type whose Caption color can be changed using the Font property, such as TSpeedButton or TBitBtn.</docstr>
  </class>
  <class unit="Vcl.StdCtrls" name="TCheckBox">
    <docstr>TCheckBox represents a check box that can be on (checked) or off (unchecked).
A TCheckBox component presents an option for the user. The user can check the box to select the option, or uncheck it to deselect the option. 
The Caption property can be used to define an accelerator key to a control.</docstr>
  </class>
  <class unit="Vcl.StdCtrls" name="TRadioButton">
    <docstr>TRadioButton is a wrapper for a system radio button.
Use TRadioButton to add a radio button to a form. Radio buttons present a set of mutually exclusive options to the user- that is, only one radio button in a set can be selected at a time. When the user selects a radio button, the previously selected radio button becomes unselected. Radio buttons are frequently grouped in a radio group box (TGroupBox). Add the group box to the form first, then get the radio buttons from the Component palette and put them into the group box. Or you can add a TRadioGroup, a group that already has radio buttons in it, so that you do not have to get the buttons from the Tool Palette.
By default, all radio buttons that are directly contained in the same windowed control container, such as a TRadioGroup or TPanel, are grouped. For example, two radio buttons on a form can be checked at the same time only if they are contained in separate containers, such as two different group boxes.
The Caption property can be used to define an accelerator key to the control.</docstr>
    <members>
      <function name="GetChecked">
        <docstr>Returns whether the button control is checked.
Vcl.StdCtrls.TRadioButton.GetChecked inherits from Vcl.StdCtrls.TButtonControl.GetChecked. All content below this line refers to Vcl.StdCtrls.TButtonControl.GetChecked.
Returns whether the button control is checked.
GetChecked is the read implementation of the Checked property.</docstr>
      </function>
      <procedure name="UpdateStyleElements">
        <docstr>Called when the StyleElements property changes.
Vcl.StdCtrls.TRadioButton.UpdateStyleElements inherits from Vcl.Controls.TControl.UpdateStyleElements. All content below this line refers to Vcl.Controls.TControl.UpdateStyleElements.
Called when the StyleElements property changes.
Override the UpdateStyleElements method in a descendant class to provide customized behavior for the control when the value of the StyleElements property changes.</docstr>
      </procedure>
      <procedure name="SetChecked">
        <docstr>Sets the Checked property.
Vcl.StdCtrls.TRadioButton.SetChecked inherits from Vcl.StdCtrls.TButtonControl.SetChecked. All content below this line refers to Vcl.StdCtrls.TButtonControl.SetChecked.
Sets the Checked property.
SetChecked is the write implementer for the Checked property.</docstr>
      </procedure>
      <procedure name="CreateParams">
        <docstr>Initializes a window-creation parameter data structure.
Vcl.StdCtrls.TRadioButton.CreateParams inherits from Vcl.Controls.TWinControl.CreateParams. All content below this line refers to Vcl.Controls.TWinControl.CreateParams.
Initializes a window-creation parameter data structure.
The CreateWnd method calls CreateParams to initialize the parameters it passes to CreateWindowHandle. Override CreateParams to customize the way a control creates its Windows representation. When overriding CreateParams, always call the inherited method first to set the default values, then make any desired adjustments.
CreateParams fills in the parameter that is passed as the value of the Params parameter. This data structure holds information needed when telling Windows to create a window handle. The fields of a TCreateParams record become the parameters to a call to the CreateWindowEx API function.
TWinControl implements CreateParams by setting all the fields of Params to generic base values. A number of the standard controls override CreateParams to change one or more of the default values in Params.</docstr>
      </procedure>
      <procedure name="CreateWnd">
        <docstr>Creates the underlying window.
Vcl.StdCtrls.TRadioButton.CreateWnd inherits from Vcl.Controls.TWinControl.CreateWnd. All content below this line refers to Vcl.Controls.TWinControl.CreateWnd.
Creates the underlying window.
CreateWnd is called automatically when the control is first created or when the underlying screen object must be destroyed and recreated to reflect property changes. Override CreateWnd to pass additional initialization messages to the screen object when it is created.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Creates an instance of TRadioButton.
Call Create to instantiate a radio button at runtime. Radio buttons added to forms at design time are created automatically.
AOwner is the component, typically a form, that becomes the value of the Owner property. The Owner is responsible for freeing the radio button object.</docstr>
      </constructor>
      <function name="GetControlsAlignment">
        <docstr>Returns the alignment of any text in the control.
Use GetControlsAlignment to determine the orientation of text in controls that do not have an Alignment property.
GetControlsAlignment overrides the inherited method, returning taRightJustify if UseRightToLeftAlignment returns false. If UseRightToLeftAlignment returns true, GetControlsAlignment returns the opposite of the Alignment property.</docstr>
      </function>
      <property name="Alignment">
        <docstr>Determines the position of the caption relative to the radio button.
Set Alignment to determine whether the caption of the radio button should appear to the left of the radio button (taLeftJustify) or to the right of the radio button (taRightJustify).

Note:  Do not confuse the Alignment property with the alignment of the caption in the text area of the radio button. The caption always appears left aligned. Alignment only controls on which side of the button the text area appears.</docstr>
      </property>
    </members>
  </class>
  <class unit="Vcl.StdCtrls" name="TListBox">
    <docstr>TListBox displays a collection of items in a scrollable list.
Use TListBox to display a scrollable list of items that users can select, add, or delete. TListBox is a wrapper for the Windows listbox control. For specialized list boxes, use other descendant classes of TCustomListBox or derive your own class from TCustomListBox.
TListBox implements the generic behavior introduced in TCustomListBox. TListBox publishes many of the properties inherited from TCustomListBox, but does not introduce any new behavior.</docstr>
  </class>
  <class unit="Vcl.StdCtrls" name="TStaticText">
    <docstr>TStaticText is a windowed control that displays text on a form.
The TStaticText component functions like TLabel, except that it descends from TWinControl and therefore has a window handle. Use TStaticText instead of TLabel when the component&apos;s accelerator key must belong to a windowed control for example, on an ActiveX property page.</docstr>
  </class>
  <class unit="Vcl.Samples.Spin" name="TSpinButton">
    <docstr>TSpinButton allows the user to navigate through a range of values using the arrow buttons.
A TSpinButton is a control with two TTimerSpeedButtons, each button displaying an arrow. TSpinButton allows the navigation through a range of values using the arrow buttons to customize the value held by the control. Usually, it is used to increase or decrease the value of the focused control.</docstr>
    <members>
      <procedure name="Loaded">
        <docstr>Initializes the control after it is loaded from a stream.
Loaded overrides the inherited method in order to set the button bounds.
Do not call Loaded. The VCL streaming system calls Loaded automatically after the control&apos;s form is loaded into memory so that the control can complete any initializations that depend on other objects in the form.</docstr>
      </procedure>
      <procedure name="KeyDown">
        <docstr>Responds to keypress events.
The KeyDown responds to keypress events.
Shift indicates which shift keys (SHIFT, CTRL, or ALT) are combined with the keystroke. 
The Key parameter is one of the following keyboard keys: Space, Down, or Up. 
If Key is Down, the OnDownClick event is handled, if Up - OnUpClick, and if Space - the click event for the focused button.</docstr>
      </procedure>
      <procedure name="Notification">
        <docstr>Responds to notifications indicating that components are being destroyed.
Notification responds to notifications indicating that the focus controls are about to be destroyed.
Notification calls the Notification inherited method.</docstr>
      </procedure>
      <procedure name="CreateWnd">
        <docstr>Creates the underlying window.
Vcl.Samples.Spin.TSpinButton.CreateWnd inherits from Vcl.Controls.TWinControl.CreateWnd. All content below this line refers to Vcl.Controls.TWinControl.CreateWnd.
Creates the underlying window.
CreateWnd is called automatically when the control is first created or when the underlying screen object must be destroyed and recreated to reflect property changes. Override CreateWnd to pass additional initialization messages to the screen object when it is created.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Creates and initializes a TSpinButton instance.
The Create method creates and initializes a TSpinButton instance.</docstr>
      </constructor>
      <procedure name="SetBounds">
        <docstr>Sets the Left, Top, Width, and Height properties of the control in a single operation.
SetBounds sets the Left, Top, Width, and Height properties of the control in a single operation. Specify the values for the Left, Top, Width, and Height properties as the value of the ALeft, ATop, AWidth, and AHeight parameters, respectively. The same effect can be achieved by setting the Left, Top, Width, and Height properties separately.
SetBounds calls the SetBounds inherited method.</docstr>
      </procedure>
      <property name="DownGlyph">
        <docstr>The bitmap that appears on the Down button.
DownGlyph represents the bitmap that appears on the Down button.
You can provide up to four images (one for each state) within a single bitmap, depending on the value of the DownNumGlyphs property. All images must be the same size and next to each other in a row.
The four states of the button are described in the following table:



Button state

Description



Up



This image appears when the button is up. This image is also used when the button has focus (for example, if the user tabs to it); in this case, a focus rectangle is drawn around the button. If no other images exist in the bitmap, bit buttons also use this image for all other states.




Disabled



This image usually appears dimmed to indicate that the button cannot be selected.




Clicked



This image appears when the button is clicked. The Up image reappears when the user releases the mouse button.




Down



This image appears when the button stays down.</docstr>
      </property>
      <property name="DownNumGlyphs">
        <docstr>Specifies the number of Glyphs that appear on the Down button.
DownNumGlyphs specifies the number of Glyphs that appear on the Down button. If you have multiple images in a bitmap, you must specify the number of images that are in the bitmap with the NumGlyphs property. The default value is 1.</docstr>
      </property>
      <property name="FocusControl">
        <docstr>Designates a windowed control associated with the TSpinButton.
Use FocusControl to set focus to a control.</docstr>
      </property>
      <property name="UpGlyph">
        <docstr>The bitmap that appears on the Up button.
UpGlyph specifies the bitmap that appears on the Up button.
You can provide up to four images (one for each state) within a single bitmap, depending on the value of the UpNumGlyphs property. All images must be the same size and next to each other in a row.
The four states of the button are described in the following table:



Button state

Description



Up



This image appears when the button is up. This image is also used when the button has focus (for example, if the user tabs to it); in this case, a focus rectangle is drawn around the button. If no other images exist in the bitmap, bit buttons also use this image for all other states.




Disabled



This image usually appears dimmed to indicate that the button cannot be selected.




Clicked



This image appears when the button is clicked. The Up image reappears when the user releases the mouse button.




Down



This image appears when the button stays down.</docstr>
      </property>
      <property name="UpNumGlyphs">
        <docstr>Number of Glyphs that appear on the Up button.
UpNumGlyphs specifies the number of Glyphs that appear on the Up button. If you have multiple images in a bitmap, you must specify the number of images that are in the bitmap with the NumGlyphs property. The default value is 1.</docstr>
      </property>
      <event name="OnDownClick">
        <docstr>Occurs when the user clicks the down button of the TSpinButton.
Use the OnDownClick event handler to specify what happens with the focused control value when the user clicks the down button of the TSpinButton.</docstr>
      </event>
      <event name="OnUpClick">
        <docstr>Occurs when the user clicks the up button of the TSpinButton.
Use the OnUpClick event handler to specify what happens with the focused control value when the user clicks the up button of the TSpinButton.</docstr>
      </event>
    </members>
  </class>
  <class unit="Vcl.Samples.Spin" name="TSpinEdit">
    <docstr>TSpinEdit combines a TEdit box with a TSpinButton.
A TSpinEdit component is a TEdit with a TSpinButton attached.
The Value of the edit box is numerical. By pressing the up and down buttons of TSpinButton, the Value is increased or decreased.</docstr>
    <members>
      <function name="IsValidChar">
        <docstr>Verifies whether the pressed key is valid.
IsValidChar verifies whether the pressed key is valid. IsValidChar returns True if the Key is &quot;+&quot;, &quot;-&quot;, or one of the number keys.</docstr>
      </function>
      <procedure name="UpClick">
        <docstr>Is the control&apos;s action in response to a mouse click on the up button of the TSpinEdit.
UpClick is called automatically when the user left-clicks the up button of the control. The method increases the edit box&apos;s Value.</docstr>
      </procedure>
      <procedure name="DownClick">
        <docstr>Represents the control&apos;s action in response to a mouse click on the down button of the TSpinEdit.
DownClick is called automatically when the user left-clicks the down button of the control. The method decreases the edit box&apos;s Value.</docstr>
      </procedure>
      <procedure name="KeyDown">
        <docstr>Responds to key press events.
KeyDown responds to key press events considering the Key parameter.
Shift indicates which shift keys (SHIFT, CTRL, or ALT) were down when the user moved the mouse.
The Key parameter can be either the Down or Up keyboard key. If the key is Up, then the method calls UpClick; if the key is Down, then the method calls DownClick.</docstr>
      </procedure>
      <procedure name="KeyPress">
        <docstr>Responds to keyboard input.
KeyPress responds to key press events. The method uses IsValidChar to validate the key. 
The Key parameter is a keyboard key. KeyPress calls the KeyPress inherited method.</docstr>
      </procedure>
      <procedure name="CreateParams">
        <docstr>Initializes a window creation parameter record passed in the Params parameter.
The CreateWnd method calls CreateParams to initialize the parameters it passes to CreateWindowHandle.
CreateWnd calls the inherited method and then specifies the style for the created window.</docstr>
      </procedure>
      <procedure name="CreateWnd">
        <docstr>Creates a Windows control corresponding to the edit control.
CreateWnd is called when the edit control is created and whenever a change to the edit control requires the window to be re-created.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Creates and initializes a TSpinEdit instance.
The Create method creates and initializes a TSpinEdit instance.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys a TSpinEdit instance.
The Destroy method destroys a TSpinEdit instance. Destroy calls the Destroy inherited method.</docstr>
      </destructor>
      <procedure name="GetChildren">
        <docstr>The method is blank.
TSpinEdit has no need to call a specified method for the control&apos;s child, so GetChildren doesn&apos;t perform any action.</docstr>
      </procedure>
      <property name="Button">
        <docstr>Specifies the TSpinButton of the TSpinEdit.
Button is a read-only property that specifies the spin button of the TSpinEdit.</docstr>
      </property>
      <property name="EditorEnabled">
        <docstr>Specifies whether Value can be edited.
EditorEnabled specifies whether Value can be edited or not.</docstr>
      </property>
      <property name="Increment">
        <docstr>Specifies the increment value.
Increment specifies the increment used to increase or decrease the Value property by clicking one of the TSpinEdit buttons or using the Up and Down keys while TSpinEdit is focused.</docstr>
      </property>
      <property name="MaxValue">
        <docstr>Specifies the maximum value.
MaxValue specifies the maximum Value that TSpinEdit can take.</docstr>
      </property>
      <property name="MinValue">
        <docstr>Specifies the minimum value.
MinValue specifies the minimum Value that TSpinEdit can take.</docstr>
      </property>
      <property name="Value">
        <docstr>Specifies the value listed in the TSpinEdit.
Value specifies the value listed in the TSpinEdit. The value can be changed by clicking one of the TSpinEdit buttons or using the Up and Down keys while TSpinEdit is focused.</docstr>
      </property>
    </members>
  </class>
  <class unit="System.Classes" name="TPersistent">
    <docstr>TPersistent is the ancestor for all objects that have assignment and streaming capabilities.
TPersistent encapsulates the behavior common to all objects that can be assigned to other objects, and that can read and write their properties to and from a form file (.xfm or .dfm file). For this purpose, TPersistent introduces methods that can be overridden to:

Define the procedure for loading and storing unpublished data to a stream.
Provide the means to assign values to properties.
Provide the means to assign the contents of one object to another.
Do not create instances of TPersistent. Use TPersistent as a base class when declaring objects that are not components, but that need to be saved to a stream or have their properties assigned to other objects.</docstr>
    <members>
      <procedure name="AssignTo">
        <docstr>Copies the properties of an object to a destination object.
Override the AssignTo method to extend the functionality of the Assign method of destination objects so that they handle newly created object classes. When defining a new object class, override the Assign method for every existing object class that should be able to copy its properties to the new class. Override the AssignTo method for every existing class to which the new class can copy.
The Assign method of TPersistent calls AssignTo if the descendant object does not succeed in copying the properties of a source object. The AssignTo method defined by TPersistent raises an EConvertError exception. 
For example, given the following code in which A and B are instance variables:

A.Assign(B); {Delphi}

A-&gt;Assign(B); // C++

if A knows how to handle B, then it does so and returns. If A doesn&apos;t know how to handle B&apos;s type, execution will trickle to the TPersistent version of Assign, which calls:

B.AssignTo(A); {Delphi}

B-&gt;AssignTo(A); // C++

If B knows how to copy to A, the assignment succeeds. Otherwise, TPersistent raises an exception.</docstr>
      </procedure>
      <procedure name="DefineProperties">
        <docstr>Provides an interface for a method that reads and writes otherwise unpublished data.
Descendants of TPersistent override DefineProperties to designate a method for storing the object&apos;s unpublished data to a stream such as a form file. By default, writing an object to a stream writes the values of all its published properties, and reading the object in reads those values and assigns them to the properties. Objects can also specify methods that read and write data other than published properties by overriding the DefineProperties method.
When overriding DefineProperties, consider including some or all of the following:

A call to the inherited method
Calls to the filer object&apos;s DefineProperty method
Calls to the filer object&apos;s DefineBinaryProperty method
DefineProperties is virtual, so descendant classes can override it as necessary but are not required to do so.</docstr>
      </procedure>
      <function name="GetOwner">
        <docstr>Returns the owner of an object.
GetOwner is used by the GetNamePath method to find the owner of a persistent object. GetNamePath and GetOwner are introduced in TPersistent so descendants such as collections can appear in the Object Inspector. As implemented in TPersistent, GetOwner returns nil (Delphi) or NULL (C++). 
For TOwnedCollection, GetOwner returns the owner of the collection. For TCollectionItem collection items, GetOwner returns the collection object into which the collection item has been inserted. For TComponent, GetOwner returns the value of the Owner property.</docstr>
      </function>
      <destructor name="Destroy">
        <docstr>Destroys the TPersistent instance and frees its memory.
Do not call Destroy directly. Call Free instead. Free checks that the object reference is not nil before calling Destroy.</docstr>
      </destructor>
      <procedure name="Assign">
        <docstr>Copies the contents of another similar object.
Assign copies properties and other attributes of the specified Source object to the current object. The standard form of a call to Assign is:

Destination.Assign(Source); {Delphi}

Destination-&gt;Assign(Source); // C++

which tells the current object to copy the contents of the Source object to itself.
Most objects override Assign to handle the assignment of properties from similar objects. When overriding Assign, call the inherited method if the destination object cannot handle the assignment of properties from the class of the Source parameter.
If no overridden Assign method can handle the assignment of properties from Source, the method implemented in TPersistent calls the source object&apos;s AssignTo method. This allows the source object to handle the assignment. If the Source object is nil (Delphi) or NULL (C++), Assign raises an EConvertError exception.
In general, the statement

Destination := Source; {Delphi}

Destination = Source; // C++

is not the same as the statement

Destination.Assign(Source); {Delphi}

Destination-&gt;Assign(Source); // C++

The assignment operator makes Destination reference the same object as Source, whereas the Assign method copies the contents of the object referenced by Source into the object referenced by Destination.

Note: The types of some properties are also objects. If these properties have written methods that use Assign to set the value of the property, then in these cases the assignment operator does the same thing as the Assign method.</docstr>
      </procedure>
      <function name="GetNamePath">
        <docstr>Returns the name of the object as it appears in the Object Inspector.
GetNamePath is for internal use only. It determines the text that the Object Inspector displays for the name of the object being edited. GetNamePath is introduced in TPersistent so descendants such as collections can appear in the Object Inspector. Do not call GetNamePath directly.
For components, GetNamePath returns the component name. For TCollectionItem objects it returns the name of the hosting component, the name of the property, and the index into the collection surrounded by brackets.</docstr>
      </function>
    </members>
  </class>
  <class unit="System.Classes" name="TCollection">
    <docstr>TCollection is a container for TCollectionItem objects.
Each TCollection holds a group of TCollectionItem descendants. TCollection maintains an index of the collection items in its Items array. The Count property contains the number of items in the collection. Use the Add and Delete methods to add items to the collection and delete items from the collection.
Objects descended from TCollection can contain objects descended from TCollectionItem. Thus, for each TCollection descendant, there is a corresponding TCollectionItem descendant. 
The following table lists some typical descendants of TCollection with the corresponding TCollectionItem descendant and the component that uses each pair:



TCollection descendant

TCollectionItem descendant

Component



TBitmapLinks



TBitmapLink



TCustomStyleObject




TAggregates



TAggregate



TClientDataSet




TCookieCollection



TCookie



TWebResponse




TCoolBands



TCoolBand



TCoolBar




TDBGridColumns



TColumn



TDBGrid




TDependencies



TDependency



TService




THeaderSections



THeaderSection



THeaderControl




TListColumns



TListColumn



TListView




TParams



TParam



many datasets




TStatusPanels



TStatusPanel



TStatusBar


The controls that use TCollection and TCollectionItem descendants have a published property that holds a collection. (For example, the Panels property of TStatusBar holds a TStatusPanels.) A standard property editor, referred to generically as the Collection editor, can be invoked from the Object Inspector to edit the items in the collection. 

Note: When writing a TCollection descendant that is used by another control, be sure to override the protected GetOwner method of the collection so that the descendant class instances can appear in the Object Inspector.
Note: TCollection has the TOwnedCollection descendant that maintains information about its owner. TOwnedCollection implements the GetOwner method. Therefore, classes derived from TOwnedCollection do not need to add anything in order to appear in the Object Inspector.</docstr>
    <members>
      <procedure name="Added">
        <docstr>Warning: Added is deprecated.  


Responds when items are added to the collection.
Applications cannot call the protected Added method. It is called automatically immediately after items are added to the collection.
Item is the item that was just added to the collection.
Added is a deprecated method. Descendent classes should override the Notify method instead when responding to changes in the list of items.</docstr>
      </procedure>
      <procedure name="Deleting">
        <docstr>Warning: Deleting is deprecated.  


Responds when items are deleted from the collection.
Applications cannot call the protected Deleting method. The Delete method calls Deleting immediately before it removes an item from the collection.
Item is the item that is about to be removed.
Deleting is a deprecated method. Descendent classes should override the Notify method instead when responding to changes in the list of items.</docstr>
      </procedure>
      <property name="NextID">
        <docstr>Specifies a unique ID that can be assigned to the next added collection item.
TCollection uses NextID internally to assign unique identifiers to collection items. When a new item is added to the collection, its ID property is given the value of NextID and NextID is incremented.</docstr>
      </property>
      <procedure name="Notify">
        <docstr>Responds when items are added to or removed from the collection.
Notify is called automatically when the items in the collection change.
Item is the item that was just added to or that is about to be removed from the collection.
Action indicates whether the item was added, is about to be extracted or is about to be deleted.
As implemented in TCollection, Notify calls Added when Action is cnAdded and calls Deleting when Action is cnDeleting. TCollection ignores the cnExtracting action. Descendant classes can override Notify to modify this behavior.</docstr>
      </procedure>
      <function name="GetAttrCount">
        <docstr>Returns the number of custom attributes associated with items in the collection.
TCollection descendants can associate user-defined attributes with the items in the collection. Each attribute has a name and, for each item in the collection, a value that is a string. GetAttrCount returns the number of distinct attributes assigned to each item in the collection.
As implemented in TCollection, GetAttrCount always returns 0, because TCollection defines no custom attributes.</docstr>
      </function>
      <function name="GetAttr">
        <docstr>Returns the name of a custom attribute that can be retrieved using the GetItemAttr method.
TCollection descendants can associate user-defined attributes with the items in the collection. Each attribute has a name and, for each item in the collection, a value that is a string. The GetAttr method returns the name of an attribute.
Index identifies the attribute whose name is requested. This is a value between 0 and n-1, where n is the value returned by GetAttrCount.
As implemented by TCollection, GetAttr always returns an empty string, because TCollection defines no custom attributes.</docstr>
      </function>
      <function name="GetItemAttr">
        <docstr>Returns the value of a custom attribute assigned to one of the collection&apos;s items.
TCollection descendants can associate user-defined attributes with the items in the collection. Each attribute has a name and -- for each item in the collection -- a value, which is a string. GetItemAttr returns the value of one of these attributes for a specified item in the collection.
Index identifies which of the attribute&apos;s values is desired. This is a value between 0 and n-1, where n is the value returned by GetAttrCount.
ItemIndex identifies the item whose attribute value is desired. This is an index into the Items property array.
As implemented in TCollection, GetItemAttr always returns an empty string, because TCollection defines no custom attributes.</docstr>
      </function>
      <procedure name="Changed">
        <docstr>Responds when the collection or any of its items changes.
Changed is called automatically when items in the collection change or when the EndUpdate method signals that an update is complete. It checks the value of UpdateCount, and if it is 0, calls the Update method, which performs any necessary updates.
When writing a TCollection descendant, there is no need to call Changed. Instead, bracket any changes by calls to BeginUpdate and EndUpdate.</docstr>
      </procedure>
      <function name="GetItem">
        <docstr>Returns a specified item in the collection.
GetItem is the protected read implementation of the Items property.</docstr>
      </function>
      <procedure name="SetItem">
        <docstr>Copies the properties of another item to a specified item in the collection.
SetItem is the protected write implementation of the Items property. It calls the Assign method of the item specified by Index, so that the properties of the item specified by Value are copied to that item.</docstr>
      </procedure>
      <procedure name="SetItemName">
        <docstr>Initializes the name of a newly inserted collection item.
The Insert method calls SetItemName to initialize the Name property of items when it inserts them into the collection.
As implemented in TCollection, SetItemName does nothing. Some TCollection descendants override this method to provide collection items with default names.</docstr>
      </procedure>
      <procedure name="Update">
        <docstr>Updates the collection to reflect changes to its items.
Override Update in a descendent class to make any necessary changes when the items in the collection change. This method is called automatically when an update is complete.
Item identifies the item that changed. If the Item parameter is nil (Delphi) or NULL (C++), then the change affects more than one item in the collection.
As implemented in TCollection, Update does nothing. Descendent classes override this method to make any necessary adjustments.</docstr>
      </procedure>
      <property name="PropName">
        <docstr>Specifies the name of the property that the collection implements.
The GetNamePath method uses this protected property to assemble the name of the collection as it appears in the Object Inspector. It identifies the name of the property in the object returned by the protected GetOwner method that is implemented using this collection object.</docstr>
      </property>
      <property name="UpdateCount">
        <docstr>Counts the number of times BeginUpdate was called without a corresponding call to EndUpdate.
UpdateCount keeps track of calls to BeginUpdate and EndUpdate so that they can be nested. Every call to BeginUpdate increments UpdateCount. Every call to EndUpdate decrements it. When UpdateCount returns to 0, the collection updates itself to reflect all changes that occurred since the first call to BeginUpdate.</docstr>
      </property>
      <constructor name="Create">
        <docstr>Creates and initializes a collection.
Call Create to instantiate a TCollection object at run time. Typically, TCollection descendants are created by a component that uses the collection to implement a property.
ItemClass identifies the TCollectionItem descendants that must be used to represent the items in the collection. The Add method uses this class to create items of the appropriate type.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys the collection and each item in it.
Destroy uses the Clear method to free each item referenced in the Items array, then destroys the collection itself.</docstr>
      </destructor>
      <function name="Owner">
        <docstr>Returns the Owner of the collection.
Call Owner to obtain a reference to the object that owns this collection. Typically, the owner uses the collection to implement one of its properties.</docstr>
      </function>
      <function name="Add">
        <docstr>Creates a new TCollectionItem instance and adds it to the Items array.
Call Add to create an item in the collection. The new item is placed at the end of the Items array.
Add returns the new collection item.</docstr>
      </function>
      <procedure name="Assign">
        <docstr>Copies the contents of the Source collection to the current object.
Use Assign to copy the contents of one TCollection instance to another. The Assign method deletes all items from the destination collection (the object where it is executed), then adds a copy of each item in the source collection&apos;s Items array.
Source is another object (typically another collection) that contains the items that replace this collection&apos;s items.</docstr>
      </procedure>
      <procedure name="BeginUpdate">
        <docstr>Signals the start of an update operation.
Call BeginUpdate before starting an operation that performs changes to TCollection. After completing all the changes, call EndUpdate to signal the end of the operation. Every call to BeginUpdate must be matched by a corresponding call to the EndUpdate method. 
For example, the method is used to suspend screen repainting until changes to a component that involves TCollection are completed.</docstr>
      </procedure>
      <procedure name="Clear">
        <docstr>Deletes all items from the collection.
Clear empties the Items array and destroys each TCollectionItem.</docstr>
      </procedure>
      <procedure name="ClearAndResetID">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Delete">
        <docstr>Deletes a single item from the collection.
Delete removes the specified collection item, moving up any items that come after that item in the Items property array.
Index identifies the item to delete. This is the index of the item in the Items property array. 0 specifies the first item, 1 specifies the second item, and so on.</docstr>
      </procedure>
      <procedure name="EndUpdate">
        <docstr>Signals the end of an update operation.
Call EndUpdate after completing an operation that was preceded by a call to the BeginUpdate method. Every call to BeginUpdate must be matched by a corresponding call to the EndUpdate method.
For example, use EndUpdate to re-enable screen repainting that was turned off with the BeginUpdate method for the components that involve TCollection.</docstr>
      </procedure>
      <procedure name="Sort">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="FindItemID">
        <docstr>Returns the item with the specified ID.
The FindItemID method returns the item in the collection whose ID property is passed to it as a parameter. If no item has the specified ID, FindItemID returns nil (Delphi) or NULL (C++).</docstr>
      </function>
      <function name="GetEnumerator">
        <docstr>Returns a TCollection enumerator.
GetEnumerator returns a TCollectionEnumerator reference, which enumerates all items in the collection. 
To do so, call the TCollectionEnumerator GetCurrent method within a While MoveNext do loop.</docstr>
      </function>
      <function name="GetNamePath">
        <docstr>Returns a string used by the Object Inspector.
If the collection has no owner, GetNamePath returns the name of the collection&apos;s actual (runtime) type. If the collection is owned, GetNamePath returns the owner&apos;s name followed, if applicable, by a dot and the name of the owner&apos;s property that holds the collection. For example, GetNamePath might return &quot;TreeView1.Items&quot;.

Note:  For a collection to have an owner, it must override the GetOwner method.</docstr>
      </function>
      <function name="Insert">
        <docstr>Creates a new TCollectionItem instance and adds it to the Items array.
Call Insert to add a new item at a specified position in the collection. Existing items (starting from the specified position) are moved up in the Items array.
Insert returns the new collection item.</docstr>
      </function>
      <property name="Capacity">
        <docstr>Provides access to the internal TList.Capacity property.
The Capacity property specifies the allocated size of the array of pointers maintained by the TList object. This value is set to the number of pointers the list will need to contain.</docstr>
      </property>
      <property name="Count">
        <docstr>Returns the number of items in the collection.
Count contains the number of items in the Items array. Since Items is indexed starting with 0, the value of Count is always one greater than the index of the last member of Items.</docstr>
      </property>
      <property name="ItemClass">
        <docstr>Indicates the class to which the collection&apos;s items belong.
ItemClass is the class (descended from TCollectionItem) to which the items in the collection belong. For example, in an instance of the TCollection descendant THeaderSections, the value of the ItemClass property is THeaderSection.</docstr>
      </property>
    </members>
  </class>
  <class unit="System.Classes" name="TStrings">
    <docstr>TStrings is the base class for objects that represent a list of strings.
Derive a class from TStrings to store and manipulate a list of strings. TStrings contains abstract or, in C++ terminology, pure virtual methods and should not be directly instantiated.
Descendants of TStrings can represent several individual strings, such as the individual lines that appear in a list box. Some objects use descendants of TStrings to represent one long body of text so that it can be manipulated in smaller chunks.
TStrings introduces many properties and methods to:

Add or delete strings at specified positions in the list.
Rearrange the strings in the list.
Access the string at a particular location.
Read the strings from or write the strings to a file or stream.
Associate an object with each string in the list.
Store and retrieve strings as name-value pairs.
For an explanation of name-value pairs, refer to the NameValueSeparator property.</docstr>
    <members>
      <procedure name="DefineProperties">
        <docstr>Reads and writes the Strings property as if it were published.
TStrings overrides DefineProperties so that the strings in the list can be loaded and saved with a form file as if the Strings property were published.</docstr>
      </procedure>
      <procedure name="Error">
        <docstr>Raises an EStringListError exception.
TStrings calls Error internally to raise an EStringListError exception when it encounters a problem.
Msg specifies the string with a single format specifier for an integer, that appears in the exception message box. It can be either a string, or a pointer to a record structure that indicates the module and resource identifier for a string.
Data is an integer value that is inserted into Msg.</docstr>
      </procedure>
      <procedure name="Error">
        <docstr>Raises an EStringListError exception.
TStrings calls Error internally to raise an EStringListError exception when it encounters a problem.
Msg specifies the string with a single format specifier for an integer, that appears in the exception message box. It can be either a string, or a pointer to a record structure that indicates the module and resource identifier for a string.
Data is an integer value that is inserted into Msg.</docstr>
      </procedure>
      <function name="ExtractName">
        <docstr>Returns the name portion of a string that is a name value pair.
TStrings calls ExtractName internally to parse strings that are name-value pairs and return the name portion.
S is the string to parse. If the string S:

Is a name-value pair, ExtractName returns the name portion.
Is not a name-value pair, ExtractName returns:
The entire string S when AllNames is True.
An empty string when AllNames is False.
Note: If AllNames is not specified is False by default.</docstr>
      </function>
      <function name="ExtractName">
        <docstr>Returns the name portion of a string that is a name value pair.
TStrings calls ExtractName internally to parse strings that are name-value pairs and return the name portion.
S is the string to parse. If the string S:

Is a name-value pair, ExtractName returns the name portion.
Is not a name-value pair, ExtractName returns:
The entire string S when AllNames is True.
An empty string when AllNames is False.
Note: If AllNames is not specified is False by default.</docstr>
      </function>
      <function name="Get">
        <docstr>Returns a string given its index.
Get is the protected read implementation of the Strings property.
In TStrings Get is abstract or, in C++ terminology, pure virtual, meaning it has no implementation. Descendant classes must override this method to return the string with the specified index.</docstr>
      </function>
      <function name="GetCapacity">
        <docstr>Returns the currently allocated size of the list of strings.
GetCapacity is the protected read implementation of the Capacity property. In TStrings, GetCapacity returns the value of the Count property. Descendants of TStrings can override this property to let a string list allocate memory for entries that have not been added to the list.</docstr>
      </function>
      <function name="GetCount">
        <docstr>Returns the number of strings in the list
GetCount is the protected read implementation of the Count property.
In TStrings GetCount is abstract or, in C++ terminology, pure virtual, meaning it has no implementation. Descendant classes must override this method to return the number of strings that have been added to the list.</docstr>
      </function>
      <function name="GetObject">
        <docstr>Returns the object associated with the string at a specified index.
GetObject is the protected read implementation of the Objects property.
Index is the index of the string with which the object is associated.
In TStrings, GetObject always returns nil (Delphi) or NULL (C++). This provides a default implementation for descendants that do not support associating objects with the strings in the list. Descendants that support this feature override GetObject to return the specified object.</docstr>
      </function>
      <function name="GetTextStr">
        <docstr>Returns the value of the Text property.
GetTextStr is the protected read implementation of the Text property. It returns a string that lists all the strings in the list, with individual strings separated by the string terminator characters LineBreak. By default, LineBreak is a carriage return and a line feed (#13#10) characters on Windows operating systems and a carriage return (#13) character on the macOS operating system.</docstr>
      </function>
      <procedure name="Put">
        <docstr>Changes the value of the string with a specified index.
Put is the protected write implementation of the Strings property.
Put changes the value of the string with the index specified by Index to S. Put does not change the object at the specified position. That is, any object associated with the previous string becomes associated with the new string.</docstr>
      </procedure>
      <procedure name="PutObject">
        <docstr>Changes the object associated with the string at a specified index.
PutObject is the protected write implementation of the Objects property.
As implemented in TStrings, PutObject does nothing. This provides a default implementation for descendants that do not support associating objects with the strings in the list. Descendants that support this feature override PutObject to change the specified object.</docstr>
      </procedure>
      <procedure name="SetCapacity">
        <docstr>Changes the amount of memory allocated to hold strings in the list.
SetCapacity is the protected write implementation of the Capacity property.
NewCapacity is the number of strings the list can hold after the capacity has changed.
In TStrings, the SetCapacity method does nothing. Descendent classes must override this method to change the number of strings that the list can hold. 

Note: For descendent classes that implement SetCapacity, assigning a value smaller than Count removes strings from the end of the list. Assigning a value greater than Count allocates space for more strings to be added.</docstr>
      </procedure>
      <procedure name="SetEncoding">
        <docstr>Protected setter of the Encoding property.
If Value is one of standard encoding values, SetEncoding sets the Encoding property to Value. Otherwise, SetEncoding sets the Encoding property to default.
Internally, Assign and LoadFromStream call SetEncoding.</docstr>
      </procedure>
      <procedure name="SetTextStr">
        <docstr>Sets the Text property.
GetTextStr is the protected write implementation of the Text property. It replaces the list with the strings specified by the Value parameter. SetTextStr adds strings one at a time to the list, using the carriage returns or linefeed characters in Value as delimiters indicating when to add a new string.</docstr>
      </procedure>
      <procedure name="SetUpdateState">
        <docstr>Performs internal adjustments before or after a series of updates.
SetUpdateState is called at the beginning or end of a series of updates. When the BeginUpdate method is first called and the TStrings object is not already in the middle of an update, TStrings calls SetUpdateState internally, with Updating set to true. When the EndUpdate method is called and it cancels out the last unmatched call to BeginUpdate, TStrings calls SetUpdateState internally, with Updating set to false.
As implemented in TStrings, SetUpdateState does nothing. Descendant classes can override this method to optimize the response to updates.</docstr>
      </procedure>
      <function name="CompareStrings">
        <docstr>Compares two strings.
TStrings uses CompareStrings internally to compare the values of strings that appear in the list. For example, the IndexOf and IndexOfName methods use CompareStrings to compare a specified string with the strings in the list.
S1 and S2 are the strings to compare.
CompareStrings returns a value less than 0 if S1 &lt; S2, 0 if S1 == S2, and a value greater than 0 if S1 &gt; S2.
As implemented in TStrings, CompareStrings uses the global AnsiCompareText function, which compares strings case insensitively. Some descendant classes override this method to change the way strings are compared (for example, to introduce case sensitivity).</docstr>
      </function>
      <property name="UpdateCount">
        <docstr>Indicates the number of calls to BeginUpdate that have not been matched by a call to EndUpdate.
TStrings uses UpdateCount to keep track of calls to the BeginUpdate and EndUpdate methods. Every time a call is made to BeginUpdate, TStrings increments the value of UpdateCount. Every call to EndUpdate causes TStrings to decrement UpdateCount.
When UpdateCount changes from 0 to 1, TStrings calls the SetUpdateState method with a parameter of true. When UpdateCount changes from 1 to 0, TStrings calls the SetUpdateState method with a parameter of false. This allows descendant classes to perform optimizations when handling multiple updates.</docstr>
      </property>
      <constructor name="Create">
        <docstr>Creates an instance of a TStrings object.
Do not call the Create method for TStrings directly. TStrings is an abstract class and its constructor should only be called as an inherited method from the constructor of a derived class.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys the TStrings instance and frees its memory.
Do not call Destroy directly. Call Free instead. Free checks that the object reference is not nil before calling Destroy.</docstr>
      </destructor>
      <function name="Add">
        <docstr>Adds a string at the end of the list.
Call Add to add a string to the end of the list. Add returns the index of the new string.</docstr>
      </function>
      <function name="AddPair">
        <docstr>Adds name-value pairs to the list of strings using fluent-style coding.
AddPair adds name-value pairs using the current NameValueSeparator. You can also use AddPair to add name-value pairs and the corresponding AObject.
TStrings returns a reference to the string list, allowing to populate the list using the fluent-style coding.</docstr>
      </function>
      <function name="AddPair">
        <docstr>Adds name-value pairs to the list of strings using fluent-style coding.
AddPair adds name-value pairs using the current NameValueSeparator. You can also use AddPair to add name-value pairs and the corresponding AObject.
TStrings returns a reference to the string list, allowing to populate the list using the fluent-style coding.</docstr>
      </function>
      <function name="AddObject">
        <docstr>Adds a string to the list, and associates an object with the string.
Call AddObject to add a string and its associated object to the list. AddObject returns the index of the new string and object.

Note:  The TStrings object does not own the objects you add this way. Objects added to the TStrings object still exist even if the TStrings instance is destroyed. They must be explicitly destroyed by the application.</docstr>
      </function>
      <procedure name="Append">
        <docstr>Adds a string to the list.
Append is the same as the Add method, except that it does not return a value. Use Append when there is no need to know the index of the string after it has been added, or with descendants of TStrings for which the index returned is not meaningful. 
For example, the TStrings descendant used by memo objects uses an index to determine where to insert a string, but the inserted string does not necessarily end up as a single string in the list. Part of the inserted text may become part of the previous string, and part may be broken off into a subsequent string. The index returned by Add is not meaningful in this case. 
Use Append rather than Add as a parameter for a function requiring a TGetStrProc.</docstr>
      </procedure>
      <procedure name="AddStrings">
        <docstr>Adds the specified strings (and objects) to the current TStrings object.
AddStrings, with the Strings parameter of the TStrings type, appends strings and associated objects from the Strings object at the end of the string list in the current TStrings object.
AddStrings with the Strings parameter representing the array of strings, appends strings from Strings array at the end of the string list in the current TStrings object.
AddStrings, with two parameters, appends strings from Strings array at the end of the string list in the current TStrings object and associates references to objects from Objects with their strings (having the same numbers in Strings and Objects arrays).
If the number of strings in Strings is not equal to the number of objects in Objects, then an exception is raised.</docstr>
      </procedure>
      <procedure name="AddStrings">
        <docstr>Adds the specified strings (and objects) to the current TStrings object.
AddStrings, with the Strings parameter of the TStrings type, appends strings and associated objects from the Strings object at the end of the string list in the current TStrings object.
AddStrings with the Strings parameter representing the array of strings, appends strings from Strings array at the end of the string list in the current TStrings object.
AddStrings, with two parameters, appends strings from Strings array at the end of the string list in the current TStrings object and associates references to objects from Objects with their strings (having the same numbers in Strings and Objects arrays).
If the number of strings in Strings is not equal to the number of objects in Objects, then an exception is raised.</docstr>
      </procedure>
      <procedure name="AddStrings">
        <docstr>Adds the specified strings (and objects) to the current TStrings object.
AddStrings, with the Strings parameter of the TStrings type, appends strings and associated objects from the Strings object at the end of the string list in the current TStrings object.
AddStrings with the Strings parameter representing the array of strings, appends strings from Strings array at the end of the string list in the current TStrings object.
AddStrings, with two parameters, appends strings from Strings array at the end of the string list in the current TStrings object and associates references to objects from Objects with their strings (having the same numbers in Strings and Objects arrays).
If the number of strings in Strings is not equal to the number of objects in Objects, then an exception is raised.</docstr>
      </procedure>
      <procedure name="Assign">
        <docstr>Sets the strings in the Strings array, possibly associated Objects, and some other properties of the current TStrings object, from the Source object.
Use Assign to set the properties of the TStrings object from the Source object. If Source is of the TStrings type, Assign copies the following properties:

Strings
Objects
DefaultEncoding
Encoding
LineBreak
Delimiter
QuoteChar
NameValueSeparator
Options
If Source is not of the TStrings type, the inherited Assign will set the value of the string array from any object that supports TStrings in its AssignTo method.</docstr>
      </procedure>
      <procedure name="SetStrings">
        <docstr>Sets the strings from another TStrings object to the list of strings.
Use SetStrings to assign the value of the TStrings object from another TStrings object (Source).

Note: SetStrings is similar to Assign, but Assign also copies multiple additional properties.</docstr>
      </procedure>
      <procedure name="BeginUpdate">
        <docstr>Enables the TStrings object to track when the list of strings is changing.
BeginUpdate is called automatically by any property or method that changes the list of strings. Once the changes are complete, the property or method calls EndUpdate. Call BeginUpdate before directly modifying the strings in the list, and EndUpdate after. When implementing properties or methods that change the list in descendants of TStrings, call BeginUpdate before the changes are made, and EndUpdate when the changes are complete.
TStrings simply keeps track of when the list of strings is being changed. Some descendants of TStrings use this information to perform certain actions, such as telling a control to repaint, when updates are complete.</docstr>
      </procedure>
      <procedure name="Clear">
        <docstr>Introduces an abstract (Delphi) or pure virtual (C++) method to empty the list and any associated objects.
Descendants of TStrings implement a Clear method to delete all the strings in the list, and to remove any references to associated objects.</docstr>
      </procedure>
      <procedure name="Delete">
        <docstr>Introduces an abstract (Delphi) or pure virtual (C++) method to delete a specified string from the list.
Descendants of TStrings implement a Delete method to remove a specified string from the list. If an object is associated with the string, the reference to the object is removed as well. Index gives the position of the string, where 0 is the first string, 1 is the second string, and so on.</docstr>
      </procedure>
      <procedure name="EndUpdate">
        <docstr>Enables the TStrings object to keep track of when the list of strings has finished changing.
EndUpdate is called automatically by any property or method that changes the list of strings. Call BeginUpdate before directly modifying the strings in the list, and EndUpdate after. When implementing properties or methods that change the list in descendants of TStrings, call BeginUpdate before the changes are made, and EndUpdate when the changes are complete.
TStrings simply keeps track of when the list of strings is being changed. Some descendants of TStrings use this information to perform certain actions, such as telling a control to repaint, when updates are complete.</docstr>
      </procedure>
      <function name="Equals">
        <docstr>Compares the list of strings to the list from another TStrings object and returns true if the two lists match.
Call Equals to compare the lists in two TStrings objects. Equals compares only the strings, not any references to associated objects. Equals returns true if the lists for both TStrings objects have the same number of strings and the strings in each list match. Equals returns false if the lists are different in length, if they contain different strings, or if the order of the strings in the two lists differ.

Note:  The Equals method uses an overridden Get method to perform the compare, thus it does not provide a context-insensitive option.</docstr>
      </function>
      <procedure name="Exchange">
        <docstr>Swaps the position of two strings in the list.
Call Exchange to rearrange the strings in the list. The strings are specified by their index values in the Index1 and Index2 parameters. Indexes are zero-based, so the first string in the list has an index value of 0, the second has an index value of 1, and so on.
If either string has an associated object, Exchange changes the position of the object as well.</docstr>
      </procedure>
      <function name="GetEnumerator">
        <docstr>Returns a TStrings enumerator.
GetEnumerator returns a TStringsEnumerator reference, which enumerates the strings in a TStrings object. 
To process all these strings, call the TStringsEnumerator GetCurrent method within a While MoveNext do loop.</docstr>
      </function>
      <function name="GetText">
        <docstr>Allocates a text buffer and fills it with the value of the Text property.
Call GetText to obtain a dynamically allocated character buffer containing all of the strings in the list. Individual strings are separated by a carriage return (#13) on the OS X operating system, or by a carriage return and a line feed (#13#10) on Windows operating systems. The caller is responsible for freeing the returned value using the StrDispose procedure.</docstr>
      </function>
      <function name="IndexOf">
        <docstr>Returns the position of a string in the list.
Call IndexOf to obtain the position of the first occurrence of the S string. IndexOf is not case-sensitive; this means that the given string may differ in case from the string in the list. For example:

String1 := MyStrings.Items.IndexOf(&apos;My First String&apos;);

is equivalent to

String1 := MyStrings.Items.IndexOf(&apos;My FIRST String&apos;);

IndexOf returns the 0-based index of the string. Thus, if S matches the first string in the list, IndexOf returns 0, if S is the second string, IndexOf returns 1, and so on. If the string is not in the string list, IndexOf returns -1. 

Note: If the string appears in the list more than once, IndexOf returns the position of the first occurrence.</docstr>
      </function>
      <function name="IndexOfName">
        <docstr>Returns the position of the first name-value pair with the specified name.
Call IndexOfName to locate the first occurrence of a name-value pair where the name part is equal to the Name parameter or differs only in case. IndexOfName returns the 0-based index of the string. If no string in the list has the indicated name, IndexOfName returns -1.

Note:  If there is more than one name-value pair with a name portion matching the Name parameter, IndexOfName returns the position of the first such string.</docstr>
      </function>
      <function name="IndexOfObject">
        <docstr>Returns the index of the first string in the list associated with a given object.
Call IndexOfObject to locate the first string in the list associated with the object AObject. Specify the object you want to locate as the value of the AObject parameter. IndexOfObject returns the 0-based index of the string and object. If the object is not associated with any of the strings, IndexOfObject returns -1.</docstr>
      </function>
      <procedure name="Insert">
        <docstr>Introduces abstract (Delphi) or pure virtual (C++) method to insert a string at a specified position.
Descendants of TStrings implement an Insert method to add the string S to the list at the position specified by Index. If Index is 0, the string is inserted at the beginning of the list. If Index is 1, the string is put in the second position of the list, and so on.
All methods that add strings to the list use the Insert method to add the string.
If the string has an associated object, use the InsertObject method instead.</docstr>
      </procedure>
      <procedure name="InsertObject">
        <docstr>Inserts a string into the list at the specified position, and associates it with an object.
Call InsertObject to insert the string S into the list at the position identified by Index, and associate it with the object AObject. If Index is 0, the string is inserted at the beginning of the list. If Index is 1, the string is put in the second position of the list, and so on.</docstr>
      </procedure>
      <procedure name="LoadFromFile">
        <docstr>Fills the string list with the lines of text in a specified file.
LoadFromFile fills the string list of the TStrings object from the file specified by FileName. LoadFromFile first clears any strings already in the list. Lines in the file are separated by a carriage return and a line feed (#13#10) on Windows operating systems and a carriage return (#13) on the OS X operating system. Each line in the file is then appended in the list as a string.
If the Encoding parameter is not given, then the strings are loaded using the appropriate encoding. The value of the encoding is obtained by calling the GetBufferEncoding routine of the TEncoding class. LoadFromFile then saves the value of the encoding in the Encoding property, to be used if the file is saved.

Note: LoadFromFile uses the Add method to add the strings that are read from the file.
If the specified file is not found, an EFOpenError is raised.</docstr>
      </procedure>
      <procedure name="LoadFromFile">
        <docstr>Fills the string list with the lines of text in a specified file.
LoadFromFile fills the string list of the TStrings object from the file specified by FileName. LoadFromFile first clears any strings already in the list. Lines in the file are separated by a carriage return and a line feed (#13#10) on Windows operating systems and a carriage return (#13) on the OS X operating system. Each line in the file is then appended in the list as a string.
If the Encoding parameter is not given, then the strings are loaded using the appropriate encoding. The value of the encoding is obtained by calling the GetBufferEncoding routine of the TEncoding class. LoadFromFile then saves the value of the encoding in the Encoding property, to be used if the file is saved.

Note: LoadFromFile uses the Add method to add the strings that are read from the file.
If the specified file is not found, an EFOpenError is raised.</docstr>
      </procedure>
      <procedure name="LoadFromStream">
        <docstr>Fills the list with lines of text read from a stream.
LoadFromStream fills the string list of the TStrings object from the stream specified by Stream. The text read from the stream is parsed into strings separated by a carriage return and a line feed (#13#10) characters on Windows operating systems and a carriage return (#13) character on the macOS operating system. Thus, LoadFromStream reads the value of the Text property.
If the Encoding parameter is not given, then the strings are loaded using the appropriate encoding. The value of the encoding is obtained by calling the GetBufferEncoding routine of the TEncoding class. LoadFromStream then saves the value of the encoding in the Encoding property, to be used if the stream is saved.
If the stream is a file stream, LoadFromStream does the same thing as LoadFromFile, except that LoadFromFile creates and destroys the file stream.</docstr>
      </procedure>
      <procedure name="LoadFromStream">
        <docstr>Fills the list with lines of text read from a stream.
LoadFromStream fills the string list of the TStrings object from the stream specified by Stream. The text read from the stream is parsed into strings separated by a carriage return and a line feed (#13#10) characters on Windows operating systems and a carriage return (#13) character on the macOS operating system. Thus, LoadFromStream reads the value of the Text property.
If the Encoding parameter is not given, then the strings are loaded using the appropriate encoding. The value of the encoding is obtained by calling the GetBufferEncoding routine of the TEncoding class. LoadFromStream then saves the value of the encoding in the Encoding property, to be used if the stream is saved.
If the stream is a file stream, LoadFromStream does the same thing as LoadFromFile, except that LoadFromFile creates and destroys the file stream.</docstr>
      </procedure>
      <procedure name="Move">
        <docstr>Changes the position of a string in the list.
Use Move to move the string at position CurIndex so that it occupies the position NewIndex. The positions are specified as 0-based indexes. For example, the following lines of code move the string in the first position to the last position:
For Delphi:

MyStringsObject.Move(0, MyStringsObject.Count - 1);

For C++: 

MyStringsObject-&gt;Move(0, MyStringsObject-&gt;Count - 1);

If the string has an associated object, the object remains associated with the string in its new position.</docstr>
      </procedure>
      <procedure name="SaveToFile">
        <docstr>Saves the strings in the current object to the specified FileName file.
SaveToFile does the same thing as SaveToStream when it writes to a file stream, except that SaveToFile creates and destroys the file stream.
Each string from the list is written to a separate line in the file.
If the Encoding parameter is not given, then the strings are saved with the encoding specified in the Encoding property.</docstr>
      </procedure>
      <procedure name="SaveToFile">
        <docstr>Saves the strings in the current object to the specified FileName file.
SaveToFile does the same thing as SaveToStream when it writes to a file stream, except that SaveToFile creates and destroys the file stream.
Each string from the list is written to a separate line in the file.
If the Encoding parameter is not given, then the strings are saved with the encoding specified in the Encoding property.</docstr>
      </procedure>
      <procedure name="SaveToStream">
        <docstr>Writes the  value of the Text property to the Stream stream.
SaveToStream gets all strings from the current TStrings object and combines them into the single string containing these strings delimited by LineBreak sequence. Then SaveToStream encodes this string using the specified Encoding. Then SaveToStream writes the encoded string into the specified Stream stream.
If WriteBOM is True then SaveToStream first gets the preamble of the specified Encoding or of the DefaultEncoding (if Encoding = nil)  and writes the preamble bytes into the stream before the main string.
If the Encoding parameter is not given, then the strings are saved with the encoding specified in the Encoding property. 

Note:  On Windows, the default LineBreak value is a carriage return and line feed combination (#13#10), whereas on macOS, it is just a line feed (#10).
Note:  If TrailingLineBreak is True, then SaveToStream writes a finishing line break LineBreak after the last string.
If the stream is a file stream, SaveToStream does the same thing as SaveToFile, except that SaveToFile creates and destroys the file stream.</docstr>
      </procedure>
      <procedure name="SaveToStream">
        <docstr>Writes the  value of the Text property to the Stream stream.
SaveToStream gets all strings from the current TStrings object and combines them into the single string containing these strings delimited by LineBreak sequence. Then SaveToStream encodes this string using the specified Encoding. Then SaveToStream writes the encoded string into the specified Stream stream.
If WriteBOM is True then SaveToStream first gets the preamble of the specified Encoding or of the DefaultEncoding (if Encoding = nil)  and writes the preamble bytes into the stream before the main string.
If the Encoding parameter is not given, then the strings are saved with the encoding specified in the Encoding property. 

Note:  On Windows, the default LineBreak value is a carriage return and line feed combination (#13#10), whereas on macOS, it is just a line feed (#10).
Note:  If TrailingLineBreak is True, then SaveToStream writes a finishing line break LineBreak after the last string.
If the stream is a file stream, SaveToStream does the same thing as SaveToFile, except that SaveToFile creates and destroys the file stream.</docstr>
      </procedure>
      <procedure name="SetText">
        <docstr>Sets the Text property.
Call SetText to replace the list with the strings specified by the Text parameter. SetText adds strings one at a time to the list, using the carriage returns or linefeed characters in Text as delimiters indicating when to add a new string.</docstr>
      </procedure>
      <function name="ToStringArray">
        <docstr>Converts a TStrings descendant to a string array.
 
Use ToStringArray to obtain an array of strings for each string in the list.</docstr>
      </function>
      <function name="ToObjectArray">
        <docstr>Returns the TObject array associated with Strings.
 
Use ToObjectArray to obtain the array of TObject associated with Strings.

Note: TStrings is an abstract class and this method has no effect. Descendent classes can associate objects with strings.
Note:  The TStrings object does not own the objects in the Objects array. Objects added to the Objects array still exist even if the TStrings object is destroyed. They must be explicitly destroyed by the application.</docstr>
      </function>
      <property name="Updating">
        <docstr>Indicates whether or not the list of strings is in the middle of an update.</docstr>
      </property>
      <property name="Capacity">
        <docstr>Indicates the number of strings the TStrings object can hold.
Read Capacity to determine the currently allocated size of the string list. For the TStrings object, reading Capacity returns the Count property, and setting Capacity does nothing. Descendants of TStrings can override this property to allow a string list to allocate memory for entries that have not been added to the list.</docstr>
      </property>
      <property name="CommaText">
        <docstr>Lists the strings in the TStrings object in a single comma-delimited string.
Use CommaText to get or set all the strings in the TStrings object in a single comma-delimited string. The single comma-delimited string format is also known as the system data format (SDF).
When retrieving CommaText, any string in the list that include spaces, commas or double quotes will be contained in double quotes, and any double quotes in a string will be repeated. For example, if the list contains the following strings:

Stri,ng1
Stri&quot;ng2
String 3
String4

CommaText will return: 

&quot;Stri,ng1&quot;,&quot;Stri&quot;&quot;ng2&quot;,&quot;String 3&quot;,String4

When assigning CommaText, the value is parsed as SDF formatted text. For SDF format, strings are separated by commas or spaces, and optionally enclosed in double quotes. Double quote marks that are part of the string are repeated to distinguish them from the quotes that surround the string. Spaces and commas that are not contained within double quote marks are delimiters. Two commas next to each other will indicate an empty string, but spaces that appear next to another delimiter are ignored. For example, suppose CommaText is set to:

&quot;Stri,ng 1&quot;,&quot;Stri&quot;&quot;ng 2&quot;,String 3,String4

The list will then contain:

Stri,ng 1
Stri&quot;ng 2
String
3
String4

Note: CommaText is the same as the DelimitedText property with a delimiter of &apos;,&apos; and a quote character of &apos;&quot;&apos;.
Including a trailing comma in the source string causes a blank item to be included in the string list. For example, if CommaText is set to

&quot;String1,String2,String3, &quot;

the string list will contain

String1
String2
String3
&lt;Blank&gt;</docstr>
      </property>
      <property name="Count">
        <docstr>Introduces an abstract property to represent the number of strings in the list.
Descendants of TStrings implement a Count property to indicate the number of strings in the list.
Use the Count property when iterating over all the strings in the list, or when trying to locate the position of a string relative to the last string in the list.</docstr>
      </property>
      <property name="DefaultEncoding">
        <docstr>The default encoding for the current object.
DefaultEncoding is used when the nil encoding is specified in a call to LoadFromStream or SaveToStream. 
By default, DefaultEncoding is set to Default. The user can change DefaultEncoding if another default encoding is desired for LoadFromStream or SaveToStream.</docstr>
      </property>
      <property name="Delimiter">
        <docstr>Specifies the delimiter used by the DelimitedText property.
Use Delimiter to get or set the delimiter used by the DelimitedText property. DelimitedText represents all of the strings in the TStrings object as a single string, with individual strings separated by the character that is the value of Delimiter.
The default delimiter is represented by comma (,).</docstr>
      </property>
      <property name="DelimitedText">
        <docstr>Represents all the strings in the TStrings object as a single delimited string.
Use DelimitedText to get or set all the strings in the TStrings object in a single string, separated by the character specified by the Delimiter property. 
When retrieving DelimitedText, any string in the list that includes spaces or the delimiter and quotation marks characters specified in the Delimiter and QuoteChar properties will be surrounded (before and after) by the quotation mark character (QuoteChar). In addition, any QuoteChar character contained in an individual string will be repeated. 
When retrieving DelimitedText, the resulting value delimits individual strings in two ways: each string is surrounded (before and after) by the quotation marks character specified by the QuoteChar property. In addition, individual strings are separated by the character specified by the Delimiter property. 
When assigning DelimitedText, individual strings must be separated using Delimiter marks, and optionally enclosed in QuoteChar characters. 
When assigning DelimitedText, the value is parsed as SDF formatted text. For SDF format, strings are separated by Delimiter characters or spaces, and optionally enclosed in QuoteChar characters. QuoteChar marks that are part of the string are repeated to distinguish them from the QuoteChar characters that surround the string. Spaces and Delimiter characters that are not contained within QuoteChar marks are delimiters. Two Delimiter characters next to each other will indicate an empty string, but spaces that appear next to another Delimiter character are ignored. 
If StrictDelimiter is set to False, the space character is also interpreted as a delimiter, regardless of the value of Delimiter. This is not true when the space character occurs between quotation marks. 

Note: CommaText is the same as the DelimitedText property when Delimiter is &apos;,&apos; and QuoteChar is &apos;&quot;&apos;. Including a trailing Delimiter in the source string causes a blank item to be included in the string list.</docstr>
      </property>
      <property name="Encoding">
        <docstr>Character encoding determined during reading from a stream or file.
Encoding is a read-only property that contains the value of the character encoding detected when the LoadFromStream or LoadFromFile methods are called. If a file or stream does not contain a BOM (the encoding value cannot be detected) then Encoding is set to the value specified in the DefaultEncoding property.
Encoding is used in the SaveToStream and SaveToFile methods.</docstr>
      </property>
      <property name="LineBreak">
        <docstr>Defines line-break characters.
The LineBreak property is used internally in TStrings to set the string terminator characters. Set or read the LineBreak property to determine the string terminator characters in multistring output operations. 
For example, the GetText method returns a long string containing all TStrings strings, each of which is terminated by the LineBreak value.

Note:  On Windows, the default LineBreak value is a carriage return and line feed combination (#13#10), whereas on Android, Linux, macOS and iOS it is just a line feed (#10).</docstr>
      </property>
      <property name="KeyNames[Index]">
        <docstr>When the list of strings includes strings that are name-value pairs or just names,
              read Keys to access the name part of a string. If the string is not a name-value
              pair, Keys returns full string. Assigning Keys will write new name for name-value
              pair. This is in contrast to Names property.</docstr>
      </property>
      <property name="QuoteChar">
        <docstr>Specifies the quote character used by the DelimitedText property.
Use QuoteChar to get or set the quote character that is used to enclose individual strings in the DelimitedText property.
When QuoteChar is set to the null character, then DelimitedText does the following: 

At reading, does not return quoted list items.
At assigning, does not check an assigning value for quote char.
That is, you can set QuoteChar to the null character to disable quoting in DelimitedText. To set the QuoteChar to the null character, do the following:


Delphi:

MyStringList.QuoteChar := #0;



C++:

MyStringList-&gt;QuoteChar = &apos;\0&apos;;</docstr>
      </property>
      <property name="NameValueSeparator">
        <docstr>Indicates the character used to separate names from values.
Strings that contain the NameValueSeparator character are considered name-value pairs. NameValueSeparator defaults to the equal sign (=). TStrings defines various methods for accessing names and values and for searching for specific names.
Strings that are name-value pairs consist of a name part, the separator character, and a value part. Any spaces around the separator character are part of the name or value. This convention corresponds to the format used in many initialization files. For example:

DisplayGrid=1
SnapToGrid=1
GridSizeX=8
GridSizeY=8</docstr>
      </property>
      <property name="StrictDelimiter">
        <docstr>Determines how the Delimiter property is used.
If StrictDelimiter is True, individual strings in DelimitedText are only separated by Delimiter or quoted between  QuoteChar. If StrictDelimiter is False, spaces and non-printable character are also used as delimiters.

Tip: You can set QuoteChar to the null character (#0 in Delphi, &apos;\0&apos; in C++) if you do not want quoted strings to be extracted as if they where surrounded by Delimiter.</docstr>
      </property>
      <property name="Text">
        <docstr>Lists the strings in the TStrings object as a single string with the individual strings delimited by carriage returns and line feeds.
Use Text to get or set all the strings in the TStrings object in a single string delimited by carriage return, line feed pairs.
When setting Text, the value will be parsed and separated into substrings whenever the LineBreak value is encountered. For backward compatibility, on POSIX, if the LineBreak separator is LF, then LF, CR, or CRLF are treated as separators. On Windows if the LineBreak separator is CRLF, then LF, CR, or CRLF are treated as separators. 
If the strings in the list contain carriage return or linefeed characters, a less ambiguous format for the strings is available through the CommaText or DelimitedText property.</docstr>
      </property>
      <property name="StringsAdapter">
        <docstr>Implements an IStringsAdapter interface for the TStrings object.

StringsAdapter specifies the attached TStringsAdapter when it is used in OLE applications.

Note: To create a StringsAdapter you can use GetOleStrings and SetOleStrings instead of creating an instance of TStringsAdapter. StringsAdapter is used internally with OLE applications.</docstr>
      </property>
      <property name="WriteBOM">
        <docstr>Will cause SaveToStream and SaveToFile to write a BOM.
Set WriteBOM to True to cause SaveToStream to write a BOM (byte-order mark) to the stream and to cause SaveToFile to write a BOM to the file.</docstr>
      </property>
      <property name="TrailingLineBreak">
        <docstr>Determines whether to add a line Break after the last line of the Text property or not.
Use TrailingLineBreak to add a finishing line break to Text. Set TrailingLineBreak to True to add a  line Break after the last line of Text. Set TrailingLineBreak to False to finish Text without a  line Break. Default is True.</docstr>
      </property>
      <property name="UseLocale">
        <docstr>Determines the implementation that the list of strings must use for string comparison.
Set UseLocale to True to use AnsiCompareStr and AnsiCompareText to compare strings.
Set UseLocale to False to use CompareStr and CompareText. Default is True.</docstr>
      </property>
      <property name="Options">
        <docstr>Controls a set of boolean properties of TStrings.
Use Options to specify the value of the following boolean properties of the list of strings:



Option

Property


soStrictDelimiter

StrictDelimiter


soWriteBOM

WriteBOM


soTrailingLineBreak

TrailingLineBreak


soUseLocale

UseLocale</docstr>
      </property>
    </members>
  </class>
  <class unit="System.Classes" name="TStringList">
    <docstr></docstr>
    <members>
      <constructor name="Create">
        <docstr>This constructor creates new string list with specified QuoteChar
              and Delimiter property values.</docstr>
      </constructor>
      <constructor name="Create">
        <docstr>This constructor creates new string list with specified QuoteChar,
              Delimiter and Options property values.</docstr>
      </constructor>
      <constructor name="Create">
        <docstr>This constructor creates new string list with specified Duplicates,
              Sorted and CaseSensitive property values.</docstr>
      </constructor>
    </members>
  </class>
  <class unit="System.Classes" name="TStream">
    <docstr>TStream is the base class type for stream objects that can read from or write to various kinds of storage media, such as disk files, dynamic memory, and so on.
Use specialized stream objects to read from, write to, or copy information stored in a particular medium. Each descendant of TStream implements methods for transferring information to and from a particular storage medium, such as a disk file, dynamic memory, and so on. In addition to methods for reading, writing, and copying bytes to and from the stream, stream objects permit applications to seek to an arbitrary position in the stream. Properties of TStream provide information about the stream, such as its size and the current position in the stream.
TStream also introduces methods that work in conjunction with components and filers for loading and saving components in simple and inherited forms. These methods are called automatically by global routines that initiate component streaming. They can also be called directly to initiate the streaming process. Note, however, that component streaming always involves two additional objects:

A component object that is passed as a parameter to the stream&apos;s methods.
A filer object that is automatically created by the stream, and associated with the stream.
Descendant stream objects, such as memory and file streams used for component streaming, are created automatically by the global functions ReadComponentRes and WriteComponentRes. For streaming other kinds of information, choose a descendent class according to the specific data and storage needs. These include:

TFileStream -- for working with files.
TStringStream -- for manipulating in-memory strings.
TMemoryStream -- for working with a memory buffer.
TWinSocketStream -- for reading and writing over a socket connection.
TOleStream -- for using a COM interface to read and write.</docstr>
    <members>
      <function name="Read">
        <docstr>Methods responsible for reading  up to Count bytes of data  from the stream into Buffer.
Descendant stream classes can define its own Read methods that read data from its particular storage medium (such as memory or a disk file) into a Buffer buffer.
Read is used in cases where the number of bytes to read from the stream is not necessarily fixed. 
Read attempts to read, into Buffer, up to Count bytes from the stream, starting at the current position, and then advances the current position in the stream by the number of bytes actually transferred. Read returns the number of bytes actually read, which may be less than Count.
Offset specifies a zero-based position in Buffer from which to write the first byte into Buffer. 
All the other data-reading methods of a stream (ReadBuffer, ReadData) call Read to do their actual reading.</docstr>
      </function>
      <function name="Write">
        <docstr>Methods responsible for writing up to Count bytes from Buffer to the stream.
Write attempts to write up to Count bytes from the Buffer to the current position in the stream, and returns the number of bytes written.
After writing to the stream, Write advances the current position by the number of bytes written. 
Offset specifies a zero-based position in Buffer of the first byte to write. 
All other data-writing methods of a stream (WriteBuffer, WriteData) call Write to do their actual writing.
Each descendent stream object defines a Write method that writes data to its particular storage medium (such as memory or a disk file).</docstr>
      </function>
      <function name="Read">
        <docstr>Methods responsible for reading  up to Count bytes of data  from the stream into Buffer.
Descendant stream classes can define its own Read methods that read data from its particular storage medium (such as memory or a disk file) into a Buffer buffer.
Read is used in cases where the number of bytes to read from the stream is not necessarily fixed. 
Read attempts to read, into Buffer, up to Count bytes from the stream, starting at the current position, and then advances the current position in the stream by the number of bytes actually transferred. Read returns the number of bytes actually read, which may be less than Count.
Offset specifies a zero-based position in Buffer from which to write the first byte into Buffer. 
All the other data-reading methods of a stream (ReadBuffer, ReadData) call Read to do their actual reading.</docstr>
      </function>
      <function name="Write">
        <docstr>Methods responsible for writing up to Count bytes from Buffer to the stream.
Write attempts to write up to Count bytes from the Buffer to the current position in the stream, and returns the number of bytes written.
After writing to the stream, Write advances the current position by the number of bytes written. 
Offset specifies a zero-based position in Buffer of the first byte to write. 
All other data-writing methods of a stream (WriteBuffer, WriteData) call Write to do their actual writing.
Each descendent stream object defines a Write method that writes data to its particular storage medium (such as memory or a disk file).</docstr>
      </function>
      <function name="Read">
        <docstr>Methods responsible for reading  up to Count bytes of data  from the stream into Buffer.
Descendant stream classes can define its own Read methods that read data from its particular storage medium (such as memory or a disk file) into a Buffer buffer.
Read is used in cases where the number of bytes to read from the stream is not necessarily fixed. 
Read attempts to read, into Buffer, up to Count bytes from the stream, starting at the current position, and then advances the current position in the stream by the number of bytes actually transferred. Read returns the number of bytes actually read, which may be less than Count.
Offset specifies a zero-based position in Buffer from which to write the first byte into Buffer. 
All the other data-reading methods of a stream (ReadBuffer, ReadData) call Read to do their actual reading.</docstr>
      </function>
      <function name="Write">
        <docstr>Methods responsible for writing up to Count bytes from Buffer to the stream.
Write attempts to write up to Count bytes from the Buffer to the current position in the stream, and returns the number of bytes written.
After writing to the stream, Write advances the current position by the number of bytes written. 
Offset specifies a zero-based position in Buffer of the first byte to write. 
All other data-writing methods of a stream (WriteBuffer, WriteData) call Write to do their actual writing.
Each descendent stream object defines a Write method that writes data to its particular storage medium (such as memory or a disk file).</docstr>
      </function>
      <function name="Read64">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="Write64">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="ReadData">
        <docstr>Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.</docstr>
      </function>
      <function name="ReadData">
        <docstr>Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.</docstr>
      </function>
      <function name="ReadData">
        <docstr>Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.</docstr>
      </function>
      <function name="ReadData">
        <docstr>Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.</docstr>
      </function>
      <function name="ReadData">
        <docstr>Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.</docstr>
      </function>
      <function name="ReadData">
        <docstr>Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.</docstr>
      </function>
      <function name="ReadData">
        <docstr>Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.</docstr>
      </function>
      <function name="ReadData">
        <docstr>Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.</docstr>
      </function>
      <function name="ReadData">
        <docstr>Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.</docstr>
      </function>
      <function name="ReadData">
        <docstr>Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.</docstr>
      </function>
      <function name="ReadData">
        <docstr>Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.</docstr>
      </function>
      <function name="ReadData">
        <docstr>Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.</docstr>
      </function>
      <function name="ReadData">
        <docstr>Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.</docstr>
      </function>
      <function name="ReadData">
        <docstr>Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.</docstr>
      </function>
      <function name="ReadData">
        <docstr>Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.</docstr>
      </function>
      <function name="ReadData">
        <docstr>Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.</docstr>
      </function>
      <function name="ReadData">
        <docstr>Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.</docstr>
      </function>
      <function name="ReadData">
        <docstr>Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.</docstr>
      </function>
      <function name="ReadData">
        <docstr>Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.</docstr>
      </function>
      <function name="ReadData">
        <docstr>Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.</docstr>
      </function>
      <function name="ReadData">
        <docstr>Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.</docstr>
      </function>
      <function name="ReadData">
        <docstr>Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.</docstr>
      </function>
      <function name="ReadData">
        <docstr>Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.</docstr>
      </function>
      <function name="ReadData">
        <docstr>Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.</docstr>
      </function>
      <function name="ReadData">
        <docstr>Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.</docstr>
      </function>
      <function name="ReadData">
        <docstr>Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.</docstr>
      </function>
      <function name="ReadData">
        <docstr>Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.</docstr>
      </function>
      <function name="ReadData">
        <docstr>Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.</docstr>
      </function>
      <function name="ReadData">
        <docstr>Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.</docstr>
      </function>
      <function name="ReadData">
        <docstr>Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.</docstr>
      </function>
      <function name="ReadData">
        <docstr>Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.</docstr>
      </function>
      <function name="ReadData">
        <docstr>Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.</docstr>
      </function>
      <function name="ReadData">
        <docstr>Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.</docstr>
      </function>
      <function name="ReadData">
        <docstr>Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
ReadData works using the following algorithms:

When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
When ReadData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
If Count  &lt;= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
ReadData methods call Read to do their actual reading.</docstr>
      </function>
      <function name="WriteData">
        <docstr>Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.</docstr>
      </function>
      <function name="WriteData">
        <docstr>Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.</docstr>
      </function>
      <function name="WriteData">
        <docstr>Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.</docstr>
      </function>
      <function name="WriteData">
        <docstr>Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.</docstr>
      </function>
      <function name="WriteData">
        <docstr>Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.</docstr>
      </function>
      <function name="WriteData">
        <docstr>Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.</docstr>
      </function>
      <function name="WriteData">
        <docstr>Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.</docstr>
      </function>
      <function name="WriteData">
        <docstr>Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.</docstr>
      </function>
      <function name="WriteData">
        <docstr>Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.</docstr>
      </function>
      <function name="WriteData">
        <docstr>Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.</docstr>
      </function>
      <function name="WriteData">
        <docstr>Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.</docstr>
      </function>
      <function name="WriteData">
        <docstr>Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.</docstr>
      </function>
      <function name="WriteData">
        <docstr>Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.</docstr>
      </function>
      <function name="WriteData">
        <docstr>Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.</docstr>
      </function>
      <function name="WriteData">
        <docstr>Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.</docstr>
      </function>
      <function name="WriteData">
        <docstr>Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.</docstr>
      </function>
      <function name="WriteData">
        <docstr>Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.</docstr>
      </function>
      <function name="WriteData">
        <docstr>Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.</docstr>
      </function>
      <function name="WriteData">
        <docstr>Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.</docstr>
      </function>
      <function name="WriteData">
        <docstr>Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.</docstr>
      </function>
      <function name="WriteData">
        <docstr>Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.</docstr>
      </function>
      <function name="WriteData">
        <docstr>Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.</docstr>
      </function>
      <function name="WriteData">
        <docstr>Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.</docstr>
      </function>
      <function name="WriteData">
        <docstr>Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.</docstr>
      </function>
      <function name="WriteData">
        <docstr>Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.</docstr>
      </function>
      <function name="WriteData">
        <docstr>Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.</docstr>
      </function>
      <function name="WriteData">
        <docstr>Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.</docstr>
      </function>
      <function name="WriteData">
        <docstr>Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.</docstr>
      </function>
      <function name="WriteData">
        <docstr>Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.</docstr>
      </function>
      <function name="WriteData">
        <docstr>Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.</docstr>
      </function>
      <function name="WriteData">
        <docstr>Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.</docstr>
      </function>
      <function name="WriteData">
        <docstr>Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.</docstr>
      </function>
      <function name="WriteData">
        <docstr>Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.</docstr>
      </function>
      <function name="WriteData">
        <docstr>Methods responsible for writing up to Count bytes from Buffer to the stream.
WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
WriteData works using the following algorithms: 

When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
When WriteData has the Count parameter, then:
If Count  &gt; SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
If Count  &lt;= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
WriteData methods call Write to do their actual writing.</docstr>
      </function>
      <function name="Seek32">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="Seek">
        <docstr>Moves to a specified position in the streamed resource.
Call Seek to move the current position of the stream in its particular storage medium (such as memory or a disk file).
The Origin parameter indicates how to interpret the Offset parameter. Origin should be one of the following values:



Value

Meaning



soBeginning



Offset is from the beginning of the resource. Seek moves to the position Offset. Offset must be &gt;= 0.




soCurrent



Offset is from the current position in the resource. Seek moves to Position + Offset.




soEnd



Offset is from the end of the resource. Offset must be &lt;= 0 to indicate a number of bytes before the end of the file.



Seek returns the new value of the Position property.
Seek is called by the Position and Size properties.

Note: As implemented in TStream, the two versions (the 32-bit or 64-bit syntax) call each other. Descendent stream classes must override at least one of these versions, and the override must not call the inherited default implementation.</docstr>
      </function>
      <function name="Seek">
        <docstr>Moves to a specified position in the streamed resource.
Call Seek to move the current position of the stream in its particular storage medium (such as memory or a disk file).
The Origin parameter indicates how to interpret the Offset parameter. Origin should be one of the following values:



Value

Meaning



soBeginning



Offset is from the beginning of the resource. Seek moves to the position Offset. Offset must be &gt;= 0.




soCurrent



Offset is from the current position in the resource. Seek moves to Position + Offset.




soEnd



Offset is from the end of the resource. Offset must be &lt;= 0 to indicate a number of bytes before the end of the file.



Seek returns the new value of the Position property.
Seek is called by the Position and Size properties.

Note: As implemented in TStream, the two versions (the 32-bit or 64-bit syntax) call each other. Descendent stream classes must override at least one of these versions, and the override must not call the inherited default implementation.</docstr>
      </function>
      <function name="Seek">
        <docstr>Moves to a specified position in the streamed resource.
Call Seek to move the current position of the stream in its particular storage medium (such as memory or a disk file).
The Origin parameter indicates how to interpret the Offset parameter. Origin should be one of the following values:



Value

Meaning



soBeginning



Offset is from the beginning of the resource. Seek moves to the position Offset. Offset must be &gt;= 0.




soCurrent



Offset is from the current position in the resource. Seek moves to Position + Offset.




soEnd



Offset is from the end of the resource. Offset must be &lt;= 0 to indicate a number of bytes before the end of the file.



Seek returns the new value of the Position property.
Seek is called by the Position and Size properties.

Note: As implemented in TStream, the two versions (the 32-bit or 64-bit syntax) call each other. Descendent stream classes must override at least one of these versions, and the override must not call the inherited default implementation.</docstr>
      </function>
      <procedure name="ReadBuffer">
        <docstr>Reads Count bytes from the stream into Buffer.
Use ReadBuffer to read Count bytes from the stream into a Buffer buffer in cases where the number of bytes to read is known and fixed, for example when reading in structures. ReadBuffer is used internally for loading from a stream and copying from a stream.
Read attempts to read exactly Count bytes from the stream, starting at the current position, and then advances the current position in the stream by the number of bytes actually transferred. 
Offset specifies a zero-based position in Buffer from which to write the first byte into Buffer. 
ReadBuffer calls Read to do the actual reading. If Count bytes cannot be read from the stream, an EReadError exception is raised.</docstr>
      </procedure>
      <procedure name="ReadBuffer">
        <docstr>Reads Count bytes from the stream into Buffer.
Use ReadBuffer to read Count bytes from the stream into a Buffer buffer in cases where the number of bytes to read is known and fixed, for example when reading in structures. ReadBuffer is used internally for loading from a stream and copying from a stream.
Read attempts to read exactly Count bytes from the stream, starting at the current position, and then advances the current position in the stream by the number of bytes actually transferred. 
Offset specifies a zero-based position in Buffer from which to write the first byte into Buffer. 
ReadBuffer calls Read to do the actual reading. If Count bytes cannot be read from the stream, an EReadError exception is raised.</docstr>
      </procedure>
      <procedure name="ReadBuffer">
        <docstr>Reads Count bytes from the stream into Buffer.
Use ReadBuffer to read Count bytes from the stream into a Buffer buffer in cases where the number of bytes to read is known and fixed, for example when reading in structures. ReadBuffer is used internally for loading from a stream and copying from a stream.
Read attempts to read exactly Count bytes from the stream, starting at the current position, and then advances the current position in the stream by the number of bytes actually transferred. 
Offset specifies a zero-based position in Buffer from which to write the first byte into Buffer. 
ReadBuffer calls Read to do the actual reading. If Count bytes cannot be read from the stream, an EReadError exception is raised.</docstr>
      </procedure>
      <procedure name="ReadBufferData">
        <docstr>Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.</docstr>
      </procedure>
      <procedure name="ReadBufferData">
        <docstr>Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.</docstr>
      </procedure>
      <procedure name="ReadBufferData">
        <docstr>Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.</docstr>
      </procedure>
      <procedure name="ReadBufferData">
        <docstr>Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.</docstr>
      </procedure>
      <procedure name="ReadBufferData">
        <docstr>Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.</docstr>
      </procedure>
      <procedure name="ReadBufferData">
        <docstr>Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.</docstr>
      </procedure>
      <procedure name="ReadBufferData">
        <docstr>Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.</docstr>
      </procedure>
      <procedure name="ReadBufferData">
        <docstr>Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.</docstr>
      </procedure>
      <procedure name="ReadBufferData">
        <docstr>Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.</docstr>
      </procedure>
      <procedure name="ReadBufferData">
        <docstr>Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.</docstr>
      </procedure>
      <procedure name="ReadBufferData">
        <docstr>Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.</docstr>
      </procedure>
      <procedure name="ReadBufferData">
        <docstr>Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.</docstr>
      </procedure>
      <procedure name="ReadBufferData">
        <docstr>Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.</docstr>
      </procedure>
      <procedure name="ReadBufferData">
        <docstr>Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.</docstr>
      </procedure>
      <procedure name="ReadBufferData">
        <docstr>Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.</docstr>
      </procedure>
      <procedure name="ReadBufferData">
        <docstr>Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.</docstr>
      </procedure>
      <procedure name="ReadBufferData">
        <docstr>Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.</docstr>
      </procedure>
      <procedure name="ReadBufferData">
        <docstr>Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.</docstr>
      </procedure>
      <procedure name="ReadBufferData">
        <docstr>Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.</docstr>
      </procedure>
      <procedure name="ReadBufferData">
        <docstr>Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.</docstr>
      </procedure>
      <procedure name="ReadBufferData">
        <docstr>Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.</docstr>
      </procedure>
      <procedure name="ReadBufferData">
        <docstr>Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.</docstr>
      </procedure>
      <procedure name="ReadBufferData">
        <docstr>Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.</docstr>
      </procedure>
      <procedure name="ReadBufferData">
        <docstr>Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.</docstr>
      </procedure>
      <procedure name="ReadBufferData">
        <docstr>Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.</docstr>
      </procedure>
      <procedure name="ReadBufferData">
        <docstr>Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.</docstr>
      </procedure>
      <procedure name="ReadBufferData">
        <docstr>Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.</docstr>
      </procedure>
      <procedure name="ReadBufferData">
        <docstr>Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.</docstr>
      </procedure>
      <procedure name="ReadBufferData">
        <docstr>Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.</docstr>
      </procedure>
      <procedure name="ReadBufferData">
        <docstr>Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
ReadBufferData works using the following algorithms:

When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
ReadBufferData calls ReadData to do the actual reading.</docstr>
      </procedure>
      <procedure name="WriteBuffer">
        <docstr>Writes Count bytes from Buffer onto the stream.
WriteBuffer attempts to write Count  bytes from the Buffer to the current position in the stream, then WriteBuffer advances the current position by Count. If the stream fails to write all the requested bytes, an EWriteError exception is raised.
Offset specifies a zero-based position in Buffer of the first byte to write.
Use WriteBuffer to save data to a stream. WriteBuffer is used in cases, where the number of bytes to write is known and required, for example when writing in structures. Use WriteBuffer for standard file I/O streaming.
WriteBuffer is used internally for writing to a stream. It is used by other objects, such as strings and lists, for writing strings stored in a buffer.
WriteBuffer calls Write to handle the actual writing.</docstr>
      </procedure>
      <procedure name="WriteBuffer">
        <docstr>Writes Count bytes from Buffer onto the stream.
WriteBuffer attempts to write Count  bytes from the Buffer to the current position in the stream, then WriteBuffer advances the current position by Count. If the stream fails to write all the requested bytes, an EWriteError exception is raised.
Offset specifies a zero-based position in Buffer of the first byte to write.
Use WriteBuffer to save data to a stream. WriteBuffer is used in cases, where the number of bytes to write is known and required, for example when writing in structures. Use WriteBuffer for standard file I/O streaming.
WriteBuffer is used internally for writing to a stream. It is used by other objects, such as strings and lists, for writing strings stored in a buffer.
WriteBuffer calls Write to handle the actual writing.</docstr>
      </procedure>
      <procedure name="WriteBuffer">
        <docstr>Writes Count bytes from Buffer onto the stream.
WriteBuffer attempts to write Count  bytes from the Buffer to the current position in the stream, then WriteBuffer advances the current position by Count. If the stream fails to write all the requested bytes, an EWriteError exception is raised.
Offset specifies a zero-based position in Buffer of the first byte to write.
Use WriteBuffer to save data to a stream. WriteBuffer is used in cases, where the number of bytes to write is known and required, for example when writing in structures. Use WriteBuffer for standard file I/O streaming.
WriteBuffer is used internally for writing to a stream. It is used by other objects, such as strings and lists, for writing strings stored in a buffer.
WriteBuffer calls Write to handle the actual writing.</docstr>
      </procedure>
      <procedure name="WriteBufferData">
        <docstr>Writes up to 4 four or Count bytes from Buffer onto the stream.
WriteBufferData works using the following algorithms: 

If Count  &lt;= 4, then WriteBufferData tries to write up to Count bytes to the stream starting at the current position and advances the current position in the stream by the number of bytes transferred.
If Count  &gt; 4, then WriteBufferData tries to write up to 4 four bytes to the stream, starting at the current position, and then advances the current position in the stream until Count number of bytes from the initial position that was before the starting of WriteBufferData execution.</docstr>
      </procedure>
      <function name="CopyFrom">
        <docstr>Copies a specified number of bytes from one stream to another.
Use CopyFrom to copy data from one stream to a different one. Using CopyFrom eliminates the need to create, read into, write from, and free a buffer when copying data. 
CopyFrom copies Count bytes from the stream specified by Source into the stream. It then moves the current position by Count bytes and returns the number of bytes copied. 
If Count is 0, CopyFrom sets Source position to 0 before reading and then copies the entire contents of Source into the stream. If Count is greater than or less than 0, CopyFrom reads from the current position in Source. 
Because the CopyFrom method uses ReadBuffer and WriteBuffer to do the effective copying, if the Count is greater than the SourceStream size, ReadBuffer throws an exception stating that a stream read error has occured.</docstr>
      </function>
      <function name="ReadComponent">
        <docstr>Initiates streaming of components and their properties.
ReadComponent is called indirectly by the global routine ReadComponentRes, by the ReadComponentRes method, or it can be called directly to initiate component streaming.
ReadComponent reads data values from the stream and assigns them to Instance&apos;s properties. It then constructs a reader object and calls the reader&apos;s ReadRootComponent method to read the Instance&apos;s property values and construct child objects defined in the stream as children of Instance. ReadComponent returns the component.
If Instance is nil (Delphi) or NULL (C++), ReadComponent constructs a component based on the type information in the stream and returns the newly-constructed component.</docstr>
      </function>
      <function name="ReadComponentRes">
        <docstr>Reads components and their properties from a stream in a resource file format.
ReadComponentRes is called automatically by the global routine ReadComponentResFile. It can also be called directly if the current position of the stream points to a component written using the WriteComponentRes method.
ReadComponentResFile creates a file stream object, which then calls its ReadComponentRes method.
ReadComponentRes first calls the ReadResHeader method to read a resource header from the stream. If the stream does not contain a resource header at the current position, ReadResHeader will raise an EInvalidImage exception. ReadComponentRes then calls ReadComponent to read the properties that must be set on Instance.</docstr>
      </function>
      <procedure name="WriteComponent">
        <docstr>Initiates the writing of components and their properties to a stream.
WriteComponent is used internally in the component streaming system, but can also be called directly when writing components to memory streams or database blobs.
WriteComponent constructs a writer object and calls its WriteRootComponent method to write the component specified by Instance, and its owned objects, to the stream.</docstr>
      </procedure>
      <procedure name="WriteComponentRes">
        <docstr>Writes components and their properties to a stream from a resource file format.
WriteComponentRes is used internally in the streaming system, but can also be called directly when sending data to other applications on disk. WriteComponentRes is used for streaming components that need data, such as a bitmap or icon to be stored in a resource-file format.
WriteComponentRes calls WriteDescendentRes, passing in nil (Delphi) or NULL (C++) as the Ancestor. Therefore, WriteDescendentRes initiates the remainder of the streaming process for a component that, in this case, is not a descendant.
To read a component written with WriteComponentRes, call the ReadComponentRes method.</docstr>
      </procedure>
      <procedure name="WriteDescendent">
        <docstr>Streams components and their properties in inherited forms.
Do not call WriteDescendent directly. WriteDescendent is called automatically by WriteComponent.
WriteDescendent constructs a writer object, then calls the writer object&apos;s WriteDescendent method to write the component passed in Instance to the stream. Instance is either an inherited form descended from Ancestor or nil (Delphi) or NULL (C++). However, WriteDescendent is never used to write owned components, only to initiate streaming on the root component.</docstr>
      </procedure>
      <procedure name="WriteDescendentRes">
        <docstr>Streams components and their properties in inherited forms.
Do not call WriteDescendentRes directly. WriteDescendentRes is called automatically by WriteComponentRes.
WriteDescendentRes writes a resource-file header to the stream, using the resource name passed in ResName as the name of the resource. It then calls WriteDescendent to write Instance to the stream as a descendant of Ancestor.</docstr>
      </procedure>
      <procedure name="WriteResourceHeader">
        <docstr>Writes a resource-file header to the stream.
Do not call WriteResourceHeader; it is used internally. The WriteDescendentRes method calls WriteResourceHeader before writing a component to the stream. This method writes the resource-file header, using the value passed as ResName for the name of the resource. It returns a position in FixupInfo that must be used to adjust the header after the size of the resource is known. WriteDescendentRes calls FixupResourceHeader with the value returned as FixupInfo after streaming out the component.</docstr>
      </procedure>
      <procedure name="FixupResourceHeader">
        <docstr>Patches the resource header for a resource that has been written to the stream.
Do not call FixupResourceHeader� it is used internally. The WriteDescendentRes method calls FixupResourceHeader after writing a component to the stream. This method then uses the current position to determine the size of the resource just written and adjust the resource header accordingly.
The FixupInfo parameter is the value returned by WriteResourceHeader when it writes the resource header (before WriteDescendentRes streams out the component.)</docstr>
      </procedure>
      <procedure name="ReadResHeader">
        <docstr>Reads a resource-file header from the stream.
Do not call ReadResHeader directly. It is called automatically by ReadComponentRes before reading a component from a resource file.
After reading the resource-file header, ReadResHeader moves the current position of the stream to just beyond the header. If the stream does not contain a valid resource-file header, ReadResHeader raises an EInvalidImage exception.</docstr>
      </procedure>
      <property name="Position">
        <docstr>Indicates the current offset into the stream for reading and writing.
Use Position to obtain the current position of the stream. This is the number of bytes from the beginning of the streamed data.</docstr>
      </property>
      <property name="Size">
        <docstr>Indicates the size in bytes of the stream.
Use Size to find the size of the stream. Size is used internally in routines that read and write to and from the stream. Setting the Size property of TStream does nothing. However, descendants of TStream can override this property to allow applications to change the size of the resource accessed using the stream. 
The Size property typically indicates the size of the stream in bytes.  But  a descendent of TStream can use -1 to indicate an unknown size.  When the size is unknown, use the return value from TStream.Read to determine end of the stream.

Example of Stream Size using DataSnap and DBX
When you are reading a DataSnap stream in blocks, the actual TStream descendant that is used to read the stream is  TDBXStreamReaderStream.  TDBXStreamReaderStream overrides methods of TStream such as the method System.Classes.TStream.GetSize, which is the reader for the property Size.
DBX connections support reading streams in block. The default block size is 32K. Streams can be passed from the client to the server, or from the server to the client. When the receiver is reading the stream (whether the receiver is the client or the server), the stream is passed from the sender to the receiver in blocks. When the stream is large enough to require multiple block readings, the Size property of the receiver&apos;s stream will be -1, which indicates that the size of the stream is unknown. As the receiver reads the stream, DataSnap makes a request to the sender for the next block, as needed. To read the stream, the client calls the Read() method until the return value is less than the value requested.
The following code shows how to read a stream to the end, by checking the return value from Read():

var
  LBuffer: TArray&lt;Byte&gt;;
  LReadCount: Integer;
begin
  SetLength(LBuffer, 1024*10); // 10K buffer for this example.  The buffer size can be larger or smaller.
  repeat
    LReadCount := AStream.Read(LBuffer[0], Length(LBuffer));
    if LReadCount &gt; 0 then
    begin
      // Process buffer
    end;
  until LReadCount &lt; Length(LBuffer);</docstr>
      </property>
    </members>
  </class>
  <class unit="System.Classes" name="THandleStream">
    <docstr>THandleStream enables applications to read from and write to communications resources identified by a handle.
Use THandleStream to access files, sockets, named pipes, mailslots, or other communications resources that provide a handle when opened. For example, the FileOpen function provides a handle for a file on disk. THandleStream allows applications to use a uniform stream interface when performing I/O using a handle.
To avoid the overhead of managing file handles, use TFileStream to work with disk files.</docstr>
    <members>
      <procedure name="SetSize">
        <docstr>Sets the end of the file marker to truncate the resource at the indicated position.
Call SetSize to set the size of the resource. SetSize calls Seek to go to the indicated position, and then writes an end of file marker. If the size of the resource cannot be changed, an exception is raised. For example, calling SetSize for a file handle that was opened in fmOpenRead mode will raise an exception.</docstr>
      </procedure>
      <procedure name="SetSize">
        <docstr>Sets the end of the file marker to truncate the resource at the indicated position.
Call SetSize to set the size of the resource. SetSize calls Seek to go to the indicated position, and then writes an end of file marker. If the size of the resource cannot be changed, an exception is raised. For example, calling SetSize for a file handle that was opened in fmOpenRead mode will raise an exception.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Creates an instance of THandleStream.
Call Create to instantiate a THandleStream for a given handle.
The handle must be obtained by opening or creating the resource in the appropriate mode. For example, to create a handle stream for reading from a file, obtain the file handle by opening the file with an fmOpenRead or fmOpenReadWrite mode. To create a handle stream for writing to a file, obtain the file handle by opening the file with an fmOpenWrite or fmOpenReadWrite mode.</docstr>
      </constructor>
      <function name="Read">
        <docstr>Reads up to Count bytes of data from the resource associated with the handle stream into Buffer.
Use Read to read data from the resource associated with the handle stream when the number of bytes in the file is not known. Read transfers up to Count bytes from the resource, starting at the current position, and then advances the current position in the resource by the number of bytes actually transferred. Read returns the number of bytes actually transferred, which may be less than Count if the end of file marker is encountered.
All other data-reading methods of a handle stream (ReadBuffer, ReadComponent) call Read to do the actual reading.</docstr>
      </function>
      <function name="Write">
        <docstr>Writes Count bytes from the Buffer to the current position in the resource.
Use Write to write Count bytes to the resource associated with the handle stream, starting at the current position. After writing to the resource, Write advances the current position by the number bytes written, and returns the number of bytes written.
All other data-writing methods of a handle stream (WriteBuffer, WriteComponent) call Write to do the actual writing.</docstr>
      </function>
      <function name="Seek">
        <docstr>Resets the current position of the handle stream.
Use Seek to move the current position within the resource associated with the handle stream by the indicated offset. Seek allows an application to read from or write to a particular location within the resource.
The Origin parameter indicates how to interpret the Offset parameter. Origin should be one of the following values:



Value

Meaning



soFromBeginning



Offset is from the beginning of the resource. Seek moves to the position Offset. Offset must be &gt;= 0.




soFromCurrent



Offset is from the current position in the resource. Seek moves to Position + Offset.




soFromEnd



Offset is from the end of the resource. Offset must be &lt;= 0 to indicate a number of bytes before the end of the file.


Or you can also use TSeekOrigin and its values to indicate where to start a seek operation.
Seek returns the new value of the Position property, the new current position in the resource.</docstr>
      </function>
      <property name="Handle">
        <docstr>Specifies the handle for the communications resource the stream reads from and writes to.
Read Handle to get the handle for file management functions. To read from or write to the resource, use the methods of the THandleStream object.
Handle is a read-only property. The handle property cannot be changed to allow the handle stream to switch from reading to writing or vice versa. For example, to change from a file handle that is opened in read-only mode to one that is opened in write mode:

Free the stream object.
Call FileClose to close the file.
Reopen the file in write mode and use the handle to create a new instance of a handle stream. Alternately, open a TFileStream object for the file, specifying a write mode for the stream.
Note: Do not call the FileClose function on the Handle until after the THandleStream object has been destroyed.</docstr>
      </property>
    </members>
  </class>
  <class unit="System.Classes" name="TFileStream">
    <docstr>TFileStream enables applications to read from and write to a file on disk.
Use TFileStream to access the information in disk files. TFileStream will open a named file and provide methods to read from or write to it. If an application already has a handle to the file, opened in the appropriate mode, use THandleStream instead.</docstr>
    <members>
      <constructor name="Create">
        <docstr>Creates an instance of TFileStream.
Call Create to instantiate a file stream for reading from or writing to the named file. Specify the name of the file and the way the file should be opened as parameters. 
The Mode parameter indicates how the file is to be opened. The Mode parameter consists of an open mode and (possibly) a share mode or&apos;ed together. The open mode must be one of the following values:



Value

Meaning

Declared In



fmCreate



Create a file with the given name. If a file with the given name exists, override the existing file and open it in write mode.



System.Classes




fmOpenRead



Open the file for reading only.



System.SysUtils




fmOpenWrite



Open the file for writing only. Writing to the file completely replaces the current contents.



System.SysUtils




fmOpenReadWrite



Open the file to modify the current contents rather than replace them.



System.SysUtils



The share mode must be one of the following values:



Value

Meaning

Declared In



fmShareCompat



Sharing is compatible with the way FCBs are opened.



System.SysUtils




fmShareExclusive



Other applications cannot open the file for any reason.



System.SysUtils




fmShareDenyWrite



Other applications can open the file for reading but not for writing.



System.SysUtils




fmShareDenyRead



Other applications can open the file for writing but not for reading.



System.SysUtils




fmShareDenyNone



No attempt is made to prevent other applications from reading from or writing to the file.



System.SysUtils


Note: On Windows, the Rights parameter is ignored.
If the file cannot be opened, Create raises an exception.</docstr>
      </constructor>
      <constructor name="Create">
        <docstr>Creates an instance of TFileStream.
Call Create to instantiate a file stream for reading from or writing to the named file. Specify the name of the file and the way the file should be opened as parameters. 
The Mode parameter indicates how the file is to be opened. The Mode parameter consists of an open mode and (possibly) a share mode or&apos;ed together. The open mode must be one of the following values:



Value

Meaning

Declared In



fmCreate



Create a file with the given name. If a file with the given name exists, override the existing file and open it in write mode.



System.Classes




fmOpenRead



Open the file for reading only.



System.SysUtils




fmOpenWrite



Open the file for writing only. Writing to the file completely replaces the current contents.



System.SysUtils




fmOpenReadWrite



Open the file to modify the current contents rather than replace them.



System.SysUtils



The share mode must be one of the following values:



Value

Meaning

Declared In



fmShareCompat



Sharing is compatible with the way FCBs are opened.



System.SysUtils




fmShareExclusive



Other applications cannot open the file for any reason.



System.SysUtils




fmShareDenyWrite



Other applications can open the file for reading but not for writing.



System.SysUtils




fmShareDenyRead



Other applications can open the file for writing but not for reading.



System.SysUtils




fmShareDenyNone



No attempt is made to prevent other applications from reading from or writing to the file.



System.SysUtils


Note: On Windows, the Rights parameter is ignored.
If the file cannot be opened, Create raises an exception.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys an instance of TFileStream.
Do not call Destroy directly in an application. Instead, call Free, which checks that the TFileStream reference is not nil and only then calls Destroy.
Destroy closes the Handle for the file stream before freeing the object.</docstr>
      </destructor>
      <property name="FileName">
        <docstr>Preserves the file name of the file associated with the file stream.
Use FileName to display the name of the file that TFileStream has accessed from disk. This is a read only property.</docstr>
      </property>
    </members>
  </class>
  <class unit="System.Classes" name="TBufferedFileStream">
    <docstr>TBufferedFileStream adds buffering support to TFileStream.
TBufferedFileStream optimizes multiple consecutive small reads or writes. However, TBufferedFileStream can be used as a drop-in replacement for TFileStream, enabling applications to read from and write to a file on a disk.

Note: TBufferedFileStream will not give performance gain for random position reads or writes, or large reads or writes.</docstr>
    <members>
      <procedure name="SetSize">
        <docstr>Sets the end of the file marker to truncate the resource at the indicated position.
System.Classes.TBufferedFileStream.SetSize inherits from System.Classes.THandleStream.SetSize. All content below this line refers to System.Classes.THandleStream.SetSize.
Sets the end of the file marker to truncate the resource at the indicated position.
Call SetSize to set the size of the resource. SetSize calls Seek to go to the indicated position, and then writes an end of file marker. If the size of the resource cannot be changed, an exception is raised. For example, calling SetSize for a file handle that was opened in fmOpenRead mode will raise an exception.</docstr>
      </procedure>
      <procedure name="SyncBuffer">
        <docstr>Writes the buffered data that have not yet been written to the file.
When using a buffered file stream, call SyncBuffer to empty the buffer and write to the file the buffered data that are still not written. 
The ReRead parameter specifies whether the buffer is repopulated or not before the call to SyncBuffer. The possible ReRead values are:

True -- The buffer is refilled with the corresponding data from the file.
False -- The buffer will remain empty until the next read or write operation.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Creates an instance of TBufferedFileStream.
Call Create to instantiate a file stream for reading from or writing to the named file. Specify the name of the file and the way the file should be opened as parameters. 
The Mode parameter indicates how the file is to be opened. The Mode parameter consists of an open mode and (possibly) a share mode or&apos;ed together. The open mode must be one of the following values:



Value

Meaning

Declared In



fmCreate



Create a file with the given name. If a file with the given name exists, override the existing file and open it in write mode.



System.Classes




fmOpenRead



Open the file for reading only.



System.SysUtils




fmOpenWrite



Open the file for writing only. Writing to the file completely replaces the current contents.



System.SysUtils




fmOpenReadWrite



Open the file to modify the current contents rather than replace them.



System.SysUtils



The share mode must be one of the following values:



Value

Meaning

Declared In



fmShareCompat



Sharing is compatible with the way FCBs are opened.



System.SysUtils




fmShareExclusive



Other applications cannot open the file for any reason.



System.SysUtils




fmShareDenyWrite



Other applications can open the file for reading but not for writing.



System.SysUtils




fmShareDenyRead



Other applications can open the file for writing but not for reading.



System.SysUtils




fmShareDenyNone



No attempt is made to prevent other applications from reading from or writing to the file.



System.SysUtils


Note: On Windows, the Rights parameter is ignored.
The BufferSize parameter determines the size of the buffer used to read from or write to the file.
If the file cannot be opened, Create raises an exception.</docstr>
      </constructor>
      <constructor name="Create">
        <docstr>Creates an instance of TBufferedFileStream.
Call Create to instantiate a file stream for reading from or writing to the named file. Specify the name of the file and the way the file should be opened as parameters. 
The Mode parameter indicates how the file is to be opened. The Mode parameter consists of an open mode and (possibly) a share mode or&apos;ed together. The open mode must be one of the following values:



Value

Meaning

Declared In



fmCreate



Create a file with the given name. If a file with the given name exists, override the existing file and open it in write mode.



System.Classes




fmOpenRead



Open the file for reading only.



System.SysUtils




fmOpenWrite



Open the file for writing only. Writing to the file completely replaces the current contents.



System.SysUtils




fmOpenReadWrite



Open the file to modify the current contents rather than replace them.



System.SysUtils



The share mode must be one of the following values:



Value

Meaning

Declared In



fmShareCompat



Sharing is compatible with the way FCBs are opened.



System.SysUtils




fmShareExclusive



Other applications cannot open the file for any reason.



System.SysUtils




fmShareDenyWrite



Other applications can open the file for reading but not for writing.



System.SysUtils




fmShareDenyRead



Other applications can open the file for writing but not for reading.



System.SysUtils




fmShareDenyNone



No attempt is made to prevent other applications from reading from or writing to the file.



System.SysUtils


Note: On Windows, the Rights parameter is ignored.
The BufferSize parameter determines the size of the buffer used to read from or write to the file.
If the file cannot be opened, Create raises an exception.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys this instance of TBufferedFileStream.</docstr>
      </destructor>
      <procedure name="FlushBuffer">
        <docstr>Writes the buffered data that have not yet been written to the file.
When using a buffered file stream, call FlushBuffer to write to the file the data from the buffer that are still not written.
Once you call FlushBuffer, the buffer will remain empty until the next read or write operation.</docstr>
      </procedure>
      <function name="Read">
        <docstr>Reads up to Count bytes of data from the resource associated with the handle stream into Buffer.
System.Classes.TBufferedFileStream.Read inherits from System.Classes.THandleStream.Read. All content below this line refers to System.Classes.THandleStream.Read.
Reads up to Count bytes of data from the resource associated with the handle stream into Buffer.
Use Read to read data from the resource associated with the handle stream when the number of bytes in the file is not known. Read transfers up to Count bytes from the resource, starting at the current position, and then advances the current position in the resource by the number of bytes actually transferred. Read returns the number of bytes actually transferred, which may be less than Count if the end of file marker is encountered.
All other data-reading methods of a handle stream (ReadBuffer, ReadComponent) call Read to do the actual reading.</docstr>
      </function>
      <function name="Write">
        <docstr>Writes Count bytes from the Buffer to the current position in the resource.
System.Classes.TBufferedFileStream.Write inherits from System.Classes.THandleStream.Write. All content below this line refers to System.Classes.THandleStream.Write.
Writes Count bytes from the Buffer to the current position in the resource.
Use Write to write Count bytes to the resource associated with the handle stream, starting at the current position. After writing to the resource, Write advances the current position by the number bytes written, and returns the number of bytes written.
All other data-writing methods of a handle stream (WriteBuffer, WriteComponent) call Write to do the actual writing.</docstr>
      </function>
      <function name="Seek">
        <docstr>Resets the current position of the handle stream.
System.Classes.TBufferedFileStream.Seek inherits from System.Classes.THandleStream.Seek. All content below this line refers to System.Classes.THandleStream.Seek.
Resets the current position of the handle stream.
Use Seek to move the current position within the resource associated with the handle stream by the indicated offset. Seek allows an application to read from or write to a particular location within the resource.
The Origin parameter indicates how to interpret the Offset parameter. Origin should be one of the following values:



Value

Meaning



soFromBeginning



Offset is from the beginning of the resource. Seek moves to the position Offset. Offset must be &gt;= 0.




soFromCurrent



Offset is from the current position in the resource. Seek moves to Position + Offset.




soFromEnd



Offset is from the end of the resource. Offset must be &lt;= 0 to indicate a number of bytes before the end of the file.


Or you can also use TSeekOrigin and its values to indicate where to start a seek operation.
Seek returns the new value of the Position property, the new current position in the resource.</docstr>
      </function>
    </members>
  </class>
  <class unit="System.Classes" name="TCustomMemoryStream">
    <docstr>TCustomMemoryStream is an abstract base class used as the common ancestor for memory streams.
Use TCustomMemoryStream as a base class when defining a stream object that can transfer data that is stored in memory. Memory streams are useful for providing file-like access to data that is stored in a less accessible medium. Data can be moved to an internal memory buffer when the memory stream is created. After manipulating the data in a memory stream, the data can be written out to its actual storage medium when the memory stream is destroyed.
Do not instantiate an instance of TCustomMemoryStream. It is an abstract class that implements behavior common to all memory streams. To work with an instance of a memory stream, use one of the descendants of TCustomMemoryStream, such as TMemoryStream or TResourceStream.</docstr>
    <members>
      <procedure name="SetPointer">
        <docstr>Replaces the memory buffer associated with the memory stream.
Use SetPointer to set the internal memory buffer, Memory, to be the value passed in by Ptr. Size is the number of bytes Ptr points to.
Descendants of TCustomMemoryStream should use SetPointer to associate the memory stream with the memory buffer that holds the data for the memory stream.

Note: SetPointer does not free the existing value of Memory, if any, when it replaces the memory buffer. Descendants of TCustomMemoryStream that use SetPointer to replace the stream&apos;s memory pool should free the memory pointed to by the Memory property before calling SetPointer to replace the memory buffer.</docstr>
      </procedure>
      <function name="Read">
        <docstr>Reads up to Count bytes from the memory stream into Buffer and advances the current position of the stream by the number of bytes read.
Use Read to read the contents of the memory stream into a buffer, starting at the current position. Read will read up to Count bytes from the current position in Memory. If Count bytes extends beyond the end of the memory buffer, Read will only transfer the data up to the end of the associated memory buffer. Read returns the number of bytes actually transferred to Buffer, and advances the current position accordingly. If the return value is less than Count, it means that reading reached the end of the stream data.
All the other data-reading methods of the memory stream (ReadBuffer, ReadComponent) call Read to do the actual reading.

Note: Read treats Count as an upper bound. The ReadBuffer method, by contrast, raises an exception if Count bytes cannot be read.</docstr>
      </function>
      <function name="Seek">
        <docstr>Moves the current position of the stream by Offset bytes, relative to the origin specified by Origin.
Use Seek to move the current position within the memory stream by the indicated offset. Seek allows an application to read from or write to a particular location within the Memory associated with the memory stream.
If Offset is a negative number, the seeking is backward from the specified origin. The following table shows the different values of Origin and their meanings for seeking:



Value

Meaning



soBeginning



Offset is from the beginning of Memory. Seek moves to the position Offset. Offset must be &gt;= 0.




soCurrent



Offset is from the current position. Seek moves to Position + Offset.




soEnd



Offset is from the end of Memory. Offset must be &lt;= 0 to indicate a number of bytes before the end of the memory buffer.


Seek returns the new value of the Position property.

Note: Seek does no error checking on the value provided for Offset. Do not call Seek with an offset that would move the current position less than 0 (before the start of Memory) or greater than Size (beyond the end of the memory buffer).</docstr>
      </function>
      <procedure name="SaveToStream">
        <docstr>Writes the entire contents of the memory stream to the stream object specified by Stream.
Use SaveToStream to copy data that is stored in memory into another storage medium. SaveToStream writes the entire contents of Memory into the indicated stream object, starting at the current position in the stream that was passed as a parameter.
When the Stream parameter is a TFileStream object, SaveToStream does much the same thing as the SaveToFile method. However, SaveToStream writes to the current position in the target stream. Thus, for example, SaveToStream can be used to append the contents of Memory to a file stream, rather than replace the contents of the file the way SaveToFile does.
If the entire contents of the memory stream cannot be written to the target stream, SaveToStream raises an EWriteError exception.</docstr>
      </procedure>
      <procedure name="SaveToFile">
        <docstr>Writes the entire contents of the memory stream to the file with a given file name.
Use SaveToFile to write the contents of Memory to a file. SaveToFile allows an application to write out the contents of the memory stream without having to explicitly create and free a file stream object. In case the file already exists, the current file contents will be completely replaced with the new. If the named file cannot be created or opened, SaveToFile raises an EFCreateError exception.</docstr>
      </procedure>
      <property name="Memory">
        <docstr>Provides direct access to the memory pool allocated for the memory stream.
Use Memory to get access to the memory for the stream. The memory for the stream holds the data that is being transferred by means of the memory stream. Size is the number of bytes of Memory that were allocated, and Position is the current position within Memory.

Note: Memory is a read-only property. Memory can be used to change the contents of the memory, but to set the actual memory the stream works with, descendants of TCustomMemoryStream must assign a pointer to a memory buffer by calling the SetPointer method.</docstr>
      </property>
    </members>
  </class>
  <class unit="System.Classes" name="TMemoryStream">
    <docstr>TMemoryStream is a stream that stores its data in dynamic memory.
Use TMemoryStream to store data in a dynamic memory buffer that is enhanced with file-like access capabilities. TMemoryStream provides the general I/O capabilities of a stream object while introducing methods and properties to manage a dynamic memory buffer.
Memory streams are useful as intermediary objects that can hold information as well as read it from or write it to another storage medium. They provide a useful format for comparing the contents of streams, or for manipulating data that is stored in a less accessible medium.</docstr>
    <members>
      <procedure name="SetCapacity">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="Realloc">
        <docstr>Sets the size of the internal buffer to the given capacity.
Realloc is used by the memory stream to resize the internal buffer to the new capacity. Realloc requires a parameter that specifies the new capacity of the internal buffer. A pointer to the start of the internal buffer is returned. If Realloc cannot resize the memory block, an EStreamError error is raised.</docstr>
      </function>
      <property name="Capacity">
        <docstr>Specifies the buffer size allocated for the memory stream.
Use the Capacity property to read or change the capacity of the memory stream. 
Capacity is different from the Size property, which is the size of the stream, in bytes. The value of Capacity is always greater than or equal to the value of Size.</docstr>
      </property>
      <destructor name="Destroy">
        <docstr>Destroys an instance of TMemoryStream.
Do not call Destroy directly in an application. Instead, call Free. Free verifies that the TMemoryStream reference is not nil, and only then calls Destroy.
Destroy a TMemoryStream object when it is no longer needed to store or write data. Destroy calls Clear to free the memory buffer before calling the inherited destructor.</docstr>
      </destructor>
      <procedure name="Clear">
        <docstr>Frees the memory buffer, discarding all data associated with the memory stream.
Use Clear to empty the memory buffer for the memory stream and free all associated memory. In addition to freeing the memory associated with the memory buffer, Clear:

Sets the Memory property to nil (Delphi) or NULL (C++).
Sets the Position property to 0.
Sets the Size property to 0.</docstr>
      </procedure>
      <procedure name="LoadFromStream">
        <docstr>Loads the entire contents of a stream into the memory buffer.
Use LoadFromStream to fill the memory stream with the contents of the stream specified by the Stream parameter. LoadFromStream always sets the Position of the source stream to 0, before streaming in the number of bytes indicated by the source stream&apos;s Size property.
LoadFromStream reallocates the memory buffer so that the contents of the source stream will exactly fit. It sets the Size property accordingly, and then reads the entire contents of the source stream into the memory buffer. Thus, LoadFromStream will discard any pre-existing data stored in the memory stream.
If the source stream is a TFileStream object, LoadFromStream does the same thing as LoadFromFile, except that the application must create and free the TFileStream object. LoadFromStream also allows applications to fill a memory stream object from other types of stream objects.</docstr>
      </procedure>
      <procedure name="LoadFromFile">
        <docstr>Loads the entire contents of a file into the memory buffer.
Use LoadFromFile to fill the memory stream with the contents of a file. Pass the name of the file as the FileName parameter. LoadFromFile allows an application to read the contents of a file into the memory stream without having to explicitly create and free a file stream object.
LoadFromFile reallocates the memory buffer so that the contents of the file will exactly fit. It sets the Size property accordingly, and then reads the entire contents of the file into the memory buffer. Thus, LoadFromFile will discard any pre-existing data stored in the memory stream.</docstr>
      </procedure>
      <procedure name="SetSize">
        <docstr>Sets the Size property of the memory stream.
Use SetSize to set the Size of a memory stream before filling it with data. SetSize allocates the memory buffer to hold NewSize bytes, preserving as much of the existing data as possible.
Use SetSize before filling the memory buffer with data from various sources, or from a portion of another stream. If the intended contents of the memory stream is exactly the same as the contents of another stream or file, use LoadFromStream or LoadFromFile instead.</docstr>
      </procedure>
      <procedure name="SetSize">
        <docstr>Sets the Size property of the memory stream.
Use SetSize to set the Size of a memory stream before filling it with data. SetSize allocates the memory buffer to hold NewSize bytes, preserving as much of the existing data as possible.
Use SetSize before filling the memory buffer with data from various sources, or from a portion of another stream. If the intended contents of the memory stream is exactly the same as the contents of another stream or file, use LoadFromStream or LoadFromFile instead.</docstr>
      </procedure>
      <function name="Write">
        <docstr>Writes Count bytes from Buffer to the current position in the memory buffer and updates the current position by Count bytes.
Use Write to insert Count bytes into the memory buffer of the memory stream, starting at the current position. Write will increase the size of the memory buffer, if necessary, to accommodate the data being written in. If the current position is not the end of the memory buffer, Write will overwrite the data following the current position.
Write updates the Size property to Position + Count, and sets the Position property to the new value of Size. Thus, any data that was stored in the memory stream in the Count bytes after the current position is lost when calling Write.
Write always writes the Count bytes in the Buffer, unless there is a memory failure. Thus, for TMemoryStream, Write is equivalent to the WriteBuffer method.
All other data-writing methods of a memory stream (WriteBuffer, WriteComponent) call Write to do the actual writing.</docstr>
      </function>
    </members>
  </class>
  <class unit="System.Classes" name="TBytesStream">
    <docstr>TBytesStream is a stream that stores its data in bytes.
Use TBytesStream to store data as bytes in a memory buffer. 
Memory streams are useful as intermediary objects that can hold information as well as read it from or write it to another storage medium. They provide a useful format for comparing the contents of streams, or for manipulating data that is stored in a less accessible medium.</docstr>
    <members>
      <function name="Realloc">
        <docstr>Sets the size of the internal buffer to the given capacity.
Realloc is used by the memory stream to resize the internal buffer to the new capacity. Realloc requires a parameter that specifies the new capacity of the internal buffer. A pointer to the resized stream of bytes is returned. If Realloc cannot resize the memory block, an EStreamError error is raised.</docstr>
      </function>
      <constructor name="Create">
        <docstr>Constructs an object and initializes its data before the object is first used.
System.Classes.TBytesStream.Create inherits from System.TObject.Create. All content below this line refers to System.TObject.Create.
Constructs an object and initializes its data before the object is first used.
Create constructs an object. The purpose, size, and behavior of objects differ greatly. The Create constructor defined by TObject allocates memory but does not initialize data. 
Descendant objects usually define a constructor that creates the particular kind of object and initializes its data.

Note: If an exception escapes from a constructor, the object&apos;s destructor is called to clean up the failed instance.</docstr>
      </constructor>
      <property name="Bytes">
        <docstr>Specifies the stored data.
The Bytes property returns the buffer in which the data is stored. Use the Size property to find the actual amount of data in the buffer.</docstr>
      </property>
    </members>
  </class>
  <class unit="System.Classes" name="TStringStream">
    <docstr>TStringStream provides file-like access to information stored as a long string.
Use TStringStream to store data as a long string enhanced with I/O capabilities. TStringStream is useful as an intermediary object that can hold text as well as read it from or write it to another storage medium. TStringStream provides a mechanism for manipulating text that is obtained from a less accessible medium.</docstr>
    <members>
      <constructor name="Create">
        <docstr>Creates an instance of TStringStream.
Call Create to instantiate a TStringStream object. Create initializes the DataString property to the AString parameter.</docstr>
      </constructor>
      <constructor name="Create">
        <docstr>Creates an instance of TStringStream.
Call Create to instantiate a TStringStream object. Create initializes the DataString property to the AString parameter.</docstr>
      </constructor>
      <constructor name="Create">
        <docstr>Creates an instance of TStringStream.
Call Create to instantiate a TStringStream object. Create initializes the DataString property to the AString parameter.</docstr>
      </constructor>
      <constructor name="Create">
        <docstr>Creates an instance of TStringStream.
Call Create to instantiate a TStringStream object. Create initializes the DataString property to the AString parameter.</docstr>
      </constructor>
      <constructor name="Create">
        <docstr>Creates an instance of TStringStream.
Call Create to instantiate a TStringStream object. Create initializes the DataString property to the AString parameter.</docstr>
      </constructor>
      <constructor name="Create">
        <docstr>Creates an instance of TStringStream.
Call Create to instantiate a TStringStream object. Create initializes the DataString property to the AString parameter.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys an instance of TMemoryStream.
System.Classes.TStringStream.Destroy inherits from System.Classes.TMemoryStream.Destroy. All content below this line refers to System.Classes.TMemoryStream.Destroy.
Destroys an instance of TMemoryStream.
Do not call Destroy directly in an application. Instead, call Free. Free verifies that the TMemoryStream reference is not nil, and only then calls Destroy.
Destroy a TMemoryStream object when it is no longer needed to store or write data. Destroy calls Clear to free the memory buffer before calling the inherited destructor.</docstr>
      </destructor>
      <function name="ReadString">
        <docstr>Returns a string that consists of up to Count bytes from the current position in the string stream, and advances the current position of the stream by the number of bytes read.
Use Read to read the contents of the string stream into a string, starting at the current position. If Count extends beyond the end of the DataString, the returned string will only contain the characters up to the end of DataString, and the current position is advanced accordingly.

Note: ReadString does the same thing as Read, except that it returns a string rather than filling a buffer.</docstr>
      </function>
      <procedure name="WriteString">
        <docstr>Concatenates a specified string to the current position in the string stream, and updates the current position accordingly.
Use WriteString to replace the end of the string from the current position on with the string specified by the AString parameter. WriteString changes the Size property to reflect the new length of the DataString.</docstr>
      </procedure>
      <property name="DataString">
        <docstr>Provides direct access to the string that stores the text represented by the TStringStream object.
Use DataString to get access to the text of the stream. The text represents the information that is being transferred by means of the string stream. Size is the number of bytes in the string, and Position is the current position within DataString.

Note: DataString is a read-only property. DataString can be used to change the contents of the string, but applications can&apos;t change the DataString itself.</docstr>
      </property>
      <property name="Encoding">
        <docstr>Represents the encoding used internally by the TStringStream instance to store the data.
Encoding represents the encoding that is used to get the corresponding array of bytes from a given string, or to obtain the corresponding string from the contained array of bytes. (A string stream contains an array of bytes.)
The encoding of a stream string is set in the constructor (you can specify what encoding to use).</docstr>
      </property>
    </members>
  </class>
  <class unit="System.Classes" name="TResourceStream">
    <docstr>TResourceStream is a memory stream that provides access to the compiled resources in an application.
Use TResourceStream to read the resources of an application. An instance of TResourceStream holds the value of a single resource in a memory buffer where it is accessible to the application.
The global ReadComponentRes function uses TResourceStream to access the compiled resources used by the application.</docstr>
    <members>
      <constructor name="Create">
        <docstr>Creates an instance of TResourceStream associated with a particular resource name and type.
Call Create to instantiate a TResourceStream, passing in parameters that identify the resource in a specified instance. TResourceStream finds the resource data and loads it into the Memory buffer for the TResourceStream.
The Instance parameter is the instance handle associated with the executable or shared library that contains the resource.
In the first constructor syntax, the ResName is the string associated with the resource in the .rc file that was compiled with the application. If the resource is associated with an integer ID rather than a string, use the string representation of the integer after a pound sign. Thus, for example, a resource with an integer identifier of 128 be identified by a ResName of #128.

Note:  Specifying resources by ID requires less memory than specifying resources by name.
The ResType parameter is a string identifying the type of the resource. Applications can define their own resource types and identify them by name in the .rc file. In addition, there are a number of predefined resource types (which reflect Windows resource types). To identify a resource that is one of the predefined resource types, set ResType to the appropriate value from the following table:





ResType

Type of resource



RT_ACCELERATOR



Accelerator table




RT_BITMAP



Bitmap resource




RT_DIALOG



Dialog box




RT_FONT



Font resource




RT_FONTDIR



Font directory resource




RT_MENU



Menu resource




RT_RCDATA



Application-defined resource (raw data)




RT_STRING



String-table entry




RT_MESSAGETABLE



Message-table entry




RT_CURSOR



Hardware-dependent cursor resource




RT_GROUP_CURSOR



Hardware-independent cursor resource




RT_ICON



Hardware-dependent icon resource




RT_GROUP_ICON



Hardware-independent icon resource




RT_VERSION



Version resource</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys an instance of TResourceStream.
Do not call Destroy directly in an application to destroy an instance of TResourceStream. Instead, call Free. Free verifies that the TResourceStream reference is not nil, and only then calls Destroy.
Destroy frees the memory buffer that stores the resource before calling the inherited destructor.</docstr>
      </destructor>
      <function name="Write">
        <docstr>Overrides the inherited method to raise an exception when an attempt is made to write the resource back to the application.
Applications should not use a TResourceStream to write the resources of the running application. Write overrides the inherited method to raise an EStreamError exception when an application tries to write to the application&apos;s resources.
As all other data-writing methods of TResourceStream (WriteBuffer, WriteComponent) call Write to do the actual writing, calling any of the data-writing methods of TResourceStream will raise an exception.</docstr>
      </function>
    </members>
  </class>
  <class unit="System.Classes" name="TThread">
    <docstr></docstr>
    <members>
      <procedure name="ForceQueue">
        <docstr>Queue the method to delay its  synchronous execution. Unlike the Queue method, this will queue it even
              if the caller is in the main thread.</docstr>
      </procedure>
      <procedure name="ForceQueue">
        <docstr>Queue the procedure to delay its synchronous execution. Unlike the Queue method, this will queue it even
              if the caller is in the main thread.</docstr>
      </procedure>
      <function name="IsTimeout">
        <docstr>Returns True if after AStartTime the specified ATimeout is passed.
              When ATimeout &lt;= 0, then timeout is inifinite and function always returns False.</docstr>
      </function>
      <property name="Current">
        <docstr>The currently executing thread. This is the same as TThread.CurrentThread.</docstr>
      </property>
      <property name="CurrentThread">
        <docstr>The currently executing thread. This is the same as TThread.Current.
              Please use TThread.Current, which is more clear and less redundant.</docstr>
      </property>
      <property name="ProcessorCount">
        <docstr>The number of processor cores on which this application is running. This will include virtual
              &quot;Hyper-threading&quot; cores on many modern Intel CPUs. It is ultimately based on what the underlying
              operating system reports.</docstr>
      </property>
      <property name="IsSingleProcessor">
        <docstr>Simple Boolean property to quickly determine wether running on a single CPU based system.</docstr>
      </property>
      <property name="OnSynchronize">
        <docstr>Event handler, which is called before each Synchronize or Queue call.</docstr>
      </property>
    </members>
  </class>
  <class unit="System.Classes" name="TBaseAsyncResult">
    <docstr>Base class used for implementing all asynchronous procedure calls. Never pass this instance around as
          an instance reference. The intent is that this object is only ever referenced through the IAsyncResult
          interface. Failure to heed this warning will result in unpredictable behavior. See the information about the
          Invoke method.</docstr>
    <members>
      <field name="FInvokingException">
        <docstr>This field will hold the acquired exception instance raised from the execution of the async method call.
              It will be re-raised in the context of the invoking thread when the corresponding EndXXXX method is called.</docstr>
      </field>
      <procedure name="AsyncDispatch">
        <docstr>Override this method to dispatch the actual asynchronous procedure call. Descendants will use whatever context
              or other state information contained in the instance to pass along to the procedure or function.</docstr>
      </procedure>
      <procedure name="Complete">
        <docstr>Override this method to perform any extra state or signaling required by the descendant. The descendant must
              call this inherited method in order to properly set the completion and possibly signal the FAsyncHandle if
              previously created. Failure to call this method can result in a dead lock or hang.</docstr>
      </procedure>
      <procedure name="DoAsyncDispatch">
        <docstr>Calls the actual target asynchronous method within the context of however it is scheduled. This could be
              in the context of the main or GUI thread, or within a background thread. This depends on the implementation
              of a specific asynchronous BeginXXXX method call.</docstr>
      </procedure>
      <procedure name="Schedule">
        <docstr>Override this method to schedule the asynchronous procedure call in the manner specific to
              a given instance, component or class. By default, this will schedule the async procedure onto
              the main thread or execute the procedure synchronously if already on the main thread.
              Other classes may schedule the procedure call into a separate thread or thread pool.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>This constructor must be called from a descendent protected constructor.</docstr>
      </constructor>
      <property name="Context">
        <docstr>Opaque user-supplied context. This context is available via the IAsyncResult.GetAsyncContext and descendents
              if this class.</docstr>
      </property>
      <function name="DoCancel">
        <docstr>Returns true if the operation can be cancelled. When cancelling the async operation, do any additional processing.</docstr>
      </function>
      <constructor name="Create">
        <docstr>This constructor should never be called directly. Only descendents should be constructed using the
              protected Create constructor above. Calling this constructor will raise an exception.</docstr>
      </constructor>
      <function name="Cancel">
        <docstr>Cancels the async operation. Returns True when the asynchronous operation can be cancelled.</docstr>
      </function>
      <function name="Invoke">
        <docstr>This method must be called prior in order to return itself as an IAsyncResult and actually schedule/invoke the
              async call.</docstr>
      </function>
      <procedure name="WaitForCompletion">
        <docstr>As long as the rules for only ever accessing this object through the IAsynsResult interface, this method
              should only ever be called by a given &quot;EndInvoke&quot; method by casting the IAsyncResult interface instance
              back to a specific descendant instance of this class. Never call this method directly outside the context
              of an &quot;EndInvoke&quot; style method.</docstr>
      </procedure>
      <procedure name="Dispatch">
        <docstr>This method is called from VCL.TControl (and possibly other similar) descendants in order to call the
              asynchronous procedure/function as a result of a posted Window message.</docstr>
      </procedure>
      <property name="IsCancelled">
        <docstr>Set to True when the asynchronous call has been cancelled.</docstr>
      </property>
    </members>
  </class>
  <class unit="System.Classes" name="TComponent">
    <docstr>TComponent is the common ancestor of all component classes.
TComponent is the base class for all components. Components are persistent objects that have the following capabilities:

IDE integration. The ability to appear on an IDE palette and be manipulated in a Form Designer.
Ownership. The ability to manage other components. If component A owns component B, then A is responsible for destroying B when A is destroyed.
Streaming and filing. Enhancements of the persistence features inherited from TPersistent.
COM support. Components can be converted into ActiveX controls or other COM objects using wizards provided with Windows products. Components can serve as wrappers for COM objects.
Note: COM features are present in all implementations of TComponent, including those provided for compatibility with OS X. However, COM features are Windows only and cannot be used in multi-device (cross-platform) applications.
TComponent does not provide any user interface or display features. These features are provided by two classes that directly descend from TComponent:

TControl, in the FMX.Types unit, is the base class for visual components in applications built with the FireMonkey (FMX) framework.
TControl, in the Vcl.Controls unit, is the base class for visual components in Windows-only (VCL) applications.
Note: Only the FMX.Types unit and other FireMonkey-specific units can be used with OS X applications. That is, you cannot use VCL units in multi-device applications.
Components that can be visible at run time are sometimes called visual components. Other components, which are never visible at run time, are sometimes called non-visual components. However it is more common to refer to visual components as controls and non-visual components simply as components.
Do not create instances of TComponent. Use TComponent as a base class when declaring non-visual components that can appear on the component palette and be used in the Form Designer. Properties and methods of TComponent provide basic behavior that descendant classes inherit as well as behavior that components can override to customize their behavior.</docstr>
    <members>
      <procedure name="AsyncSchedule">
        <docstr>Schedules asynch method calls.
By default, AsyncSchedule uses Queue in order to queue the asynch method call with the main thread.
Override AsyncSchedule in descendant components in order to modify the management of the asynchronous scheduling.</docstr>
      </procedure>
      <procedure name="ChangeName">
        <docstr>Sets the private, internal storage for the Name property to the string passed in NewName.
Do not use ChangeName directly in an application. Instead, use the Name property.

Note: The property setter for Name -- SetName-- uses ChangeName to change the component&apos;s name. ChangeName is not virtual; do not override it.</docstr>
      </procedure>
      <procedure name="DefineProperties">
        <docstr>Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
TComponent overrides the DefineProperties method defined in TPersistent to define &quot;fake&quot; Top and Left properties. These are defined so that components that are not controls can be manipulated at design time. However, the Top and Left properties are hidden, that is, they are not published, because only controls appear at run time.
DefineProperties is virtual; descendent classes can override it. When overriding DefineProperties, be aware that the Ancestor property of Filer might be set, and that this property can determine whether or not it is appropriate to write properties.
DefineProperties is called automatically as part of the component streaming system; do not call it directly.</docstr>
      </procedure>
      <procedure name="GetChildren">
        <docstr>Enumerates all child components.
GetChildren is used internally in the component streaming system. It is not necessary to call it directly. 
GetChildren expects a TGetChildProc routine that receives all enumerated components. 
Root represents the owner of the components that will be enumerated.
This method does nothing in TComponent and is expected to be overridden in descendants.</docstr>
      </procedure>
      <function name="GetChildOwner">
        <docstr>Returns the owner of a child component being read from a stream.
GetChildOwner is used internally by the component streaming system. It is rarely necessary to call it directly.
In TComponent, GetChildOwner always returns nil (Delphi) or NULL (C++), indicating that the owner is the root component currently being read (usually a form or data module). The Owner of a component is responsible for destroying it.</docstr>
      </function>
      <function name="GetChildParent">
        <docstr>Returns the parent or, if there is no parent, returns the owner of a child component being read from a stream.
GetChildParent is used internally in the component streaming system. It is not necessary to call it directly.
As implemented in TComponent, GetChildParent returns Self (Delphi) or this (C++). If GetChildParent returns nil (Delphi) or NULL (C++), the parent is assumed to be the root component currently being read (usually a form).</docstr>
      </function>
      <function name="GetOwner">
        <docstr>Returns the owner of a component.
GetOwner is called by GetNamePath to find the owner of a component. GetNamePath and GetOwner are introduced in TPersistent so descendants such as collections can appear in the Object Inspector. For TComponent, GetOwner returns the value of the Owner property.</docstr>
      </function>
      <procedure name="Loaded">
        <docstr>Initializes the component after the form file has been read into memory.
Do not call the protected Loaded method. The streaming system calls this method after it loads the component&apos;s form from a stream.
When the streaming system loads a form or data module from its form file, it first constructs the form component by calling its constructor, then reads its property values from the form file. After reading all the property values for all the components, the streaming system calls the Loaded methods of each component in the order the components were created. This gives the components a chance to initialize any data that depends on the values of other components or other parts of itself.

Note:  All references to sibling components are resolved by the time Loaded is called. Loaded is the first place that sibling pointers can be used after being streamed in.
As implemented in TComponent, Loaded clears the csLoading flag in the ComponentState property, indicating that the component is no longer loading.

Warning: Loaded may be called multiple times on inherited forms. It is called every time a level of inheritance is streamed in. Do not allocate memory in an overridden Loaded method without first checking that the memory has not been allocated in a previous call.</docstr>
      </procedure>
      <procedure name="Notification">
        <docstr>Forwards notification messages to all owned components.
Do not call the Notification method in an application. Notification is called automatically when the component specified by AComponent is about to be inserted or removed, as specified by Operation. By default, components pass along the notification to their owned components, if any.
A component can, if needed, act on the notification that a component is being inserted or removed. For example, if a component has object fields or properties that contain references to other components, it can check the notifications of component removals and invalidate those references as needed.

Note: Notification is not called for components that are freed implicitly (because their Owner is freed).</docstr>
      </procedure>
      <procedure name="GetDeltaStreams">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="ReadState">
        <docstr>Reads the state of the component.
ReadState is used internally in the component streaming system. It is not necessary to call it directly. 
ReadState expects a TReader object, which is used for reading the state of the component.</docstr>
      </procedure>
      <function name="CanObserve">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="ObserverAdded">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GetObservers">
        <docstr>Getter of Observers.</docstr>
      </function>
      <procedure name="SetAncestor">
        <docstr>Clears or sets csAncestor state in the component&apos;s ComponentState property.
SetAncestor is used internally in the component streaming system. It is not necessary to call it directly. 
If Value is set to True, the csAncestor flag is included into the component state; otherwise, it is excluded.</docstr>
      </procedure>
      <procedure name="SetDesigning">
        <docstr>Ensures that components inserted at design time have their design-mode flag set.
SetDesigning is used internally by the Form designer. Do not call SetDesigning directly.
SetDesigning sets the csDesigning flag in the ComponentState property if Value is True; otherwise, it removes csDesigning. 
If the SetChildren parameter is True, SetDesigning then calls the SetDesigning methods of any owned components, passing Value, so that the owned components&apos; ComponentState properties are synchronized with the owner&apos;s.
The InsertComponent and RemoveComponent methods call SetDesigning for inserted or removed components to ensure that their design-mode flags are set properly.</docstr>
      </procedure>
      <procedure name="SetInline">
        <docstr>Sets the csInline bit of the component&apos;s ComponentState property.
SetInline is used internally to indicate whether the component can act as a root component in the designer but also be embedded in a form.
SetInline sets the csInline flag in the ComponentState property if Value is True; otherwise, it removes csInline.</docstr>
      </procedure>
      <procedure name="SetDesignInstance">
        <docstr>Ensures that components inserted at design time have their design-mode flag set.
SetDesignInstance is used internally by the Form designer to identify objects that act as a design surface. Do not call SetDesignInstance directly.
SetDesignInstance sets the csDesignInstance flag in the ComponentState property if Value is 
True; otherwise, it removes csDesignInstance.</docstr>
      </procedure>
      <procedure name="SetName">
        <docstr>Sets the value of the Name property.
SetName is the virtual property setter for the Name property. It calls the ChangeName method, which performs the actual name change.
ChangeName is not virtual; override SetName instead when modifying the behavior of the Name property.

Warning: Using SetName to change the name of a component at run time causes any references to the old name to become undefined. Any subsequent code that uses the old name will cause an exception.</docstr>
      </procedure>
      <procedure name="SetChildOrder">
        <docstr>Sets the visual ordering of a child control.
SetChildOrder is used internally in the component streaming system. It is not necessary to call it directly. 
Derived classes override this method to actually implement the ordering. TWinControl uses this ordering information to Z-align the controls.</docstr>
      </procedure>
      <procedure name="SetParentComponent">
        <docstr>Sets the parent component.
SetParentComponent is used internally in the component streaming system. It is not necessary to call it directly. 
Derived classes override this method to implement proper handling for parenting.</docstr>
      </procedure>
      <procedure name="Updating">
        <docstr>Sets the csUpdating state in the component&apos;s ComponentState property.
Do not call Updating directly. It is used internally to indicate that the component is about to be updated. A call to Updating, which sets the csUpdating flag, is always followed by a call to Updated, which clears the flag.</docstr>
      </procedure>
      <procedure name="Updated">
        <docstr>Clears the csUpdating state in the component&apos;s ComponentState property when the component finishes updating.
Do not call Updated directly. It is used internally to clear the csUpdating flag of the ComponentState property. A call to Updated always follows a call to Updating, which sets the flag.</docstr>
      </procedure>
      <procedure name="UpdateRegistry">
        <docstr>Provides the interface for a method that adds type library and version information to the Registry on components that implement COM interfaces.
Do not call UpdateRegistry directly. It is for internal use only.</docstr>
      </procedure>
      <procedure name="ValidateRename">
        <docstr>Ensures that renaming an owned component does not create a name conflict.
ValidateRename checks whether a component can rename one of its owned components, passed in AComponent, from its current name (CurName) to the string passed in NewName. If AComponent is nil (Delphi) or NULL (C++) or NewName is already the name of a component in the Components list, ValidateRename raises an EComponentError exception.
ValidateRename is used internally when the Name property is modified. It is not necessary to call it directly.</docstr>
      </procedure>
      <procedure name="ValidateContainer">
        <docstr>Determines whether an object can be inserted into a container.
ValidateContainer is called by a component when it is about to be inserted into a container object. By default, ValidateContainer calls the ValidateInsert method of the component specified by the AComponent parameter. 
Descendent components can override ValidateContainer to disallow a component from being inserted into specific containers. To disallow an insertion, raise an exception in the derived method.</docstr>
      </procedure>
      <procedure name="ValidateInsert">
        <docstr>Provides the interface for a method that validates a child component before it is inserted.
ValidateInsert does nothing in TComponent. Descendent classes can override it to disallow a component from accepting an object as a child. By default, ValidateInsert allows any object to be inserted into the component. 
If a component needs to validate only certain objects, descendent classes can override ValidateInsert to filter out those objects. To disallow an insertion, raise an exception in the derived method.</docstr>
      </procedure>
      <procedure name="WriteState">
        <docstr>Writes the state of the component.
WriteState is used internally in the component streaming system. It is not necessary to call it directly. 
This method expects a TWriter object that is used for storing the state of the component.</docstr>
      </procedure>
      <procedure name="RemoveFreeNotifications">
        <docstr>Notifies all owned components of the owner component&apos;s imminent destruction.
The RemoveFreeNotifications method notifies all owned components of the owner component&apos;s imminent destruction. RemoveFreeNotifications is called automatically when the component is destroyed.</docstr>
      </procedure>
      <function name="QueryInterface">
        <docstr>Returns a reference to a specified interface if the current component supports that interface.
QueryInterface checks whether the component supports the interface specified by IID and, if so, returns a reference to that interface as the Obj parameter. If the component does not support the interface, the Obj parameter returns nil (Delphi) or NULL (C++).
QueryInterface returns the S_OK execution code on success. HResult type 
defines the following execution codes: S_OK, S_FALSE, E_NOINTERFACE, E_UNEXPECTED, and E_NOTIMPL.

Note: For components that act as COM object wrappers, QueryInterface calls the QueryInterface method of the internal COM object.</docstr>
      </function>
      <function name="_AddRef">
        <docstr>Called when an application uses a component interface.
_AddRef is a basic implementation of the IInterface method, _AddRef.

Note: If the component is a wrapper for a COM object, _AddRef calls the _AddRef method of that COM object, and returns the resulting reference count.
In all other cases, _AddRef simply returns �1 and takes no action. This allows the component to implement interfaces where reference counting is not required. More sophisticated components should override _AddRef to implement reference counting.</docstr>
      </function>
      <function name="_Release">
        <docstr>Called when an application releases a component interface.
_Release is a basic implementation of the IInterface method, _Release.
_Release returns the resulting value of the reference count for the component&apos;s interface.

Note: In all other cases, _Release simply returns �1 and takes no action. This allows the component to implement interfaces where reference counting is not required. More sophisticated components should override _Release to implement reference counting.</docstr>
      </function>
      <function name="GetTypeInfoCount">
        <docstr>Returns the number of type information interfaces that an object provides (either 0 or 1).
GetTypeInfoCount implements the IDispatch interface GetTypeInfoCount method. For components that support interfaces, GetTypeInfoCount calls this method for the interface supported by the component. The Count parameter points to a location that receives the number of type information interfaces provided by the object. If the object provides type information, this number is 1; otherwise the number is 0.</docstr>
      </function>
      <function name="GetTypeInfo">
        <docstr>Retrieves the type information for an object.
GetTypeInfo implements the IDispatch interface GetTypeInfo method. For components that support interfaces, GetTypeInfo calls the GetTypeInfo method for the interface supported by the component, passing it the specified parameters. Use the returned value to get the type information for an interface implemented by the component.</docstr>
      </function>
      <function name="GetIDsOfNames">
        <docstr>Maps a single member and an optional set of argument names to a corresponding set of integer dispatch identifiers (dispIDs).
GetIDsOfNames implements the IDispatch interface GetIDsOfNames method. For components that support interfaces, GetIDsOfNames calls this method for the interface supported by the component, passing the specified parameters. The returned value can be used on subsequent calls to the Invoke method.</docstr>
      </function>
      <function name="Invoke">
        <docstr>Provides access to Automation properties and methods when the component wraps an Automation object.
Invoke is the standard mechanism for accessing the exposed properties and methods of an Automation object. For components that wrap the IDispatch interface of an Automation object, Invoke calls the Invoke method for the interface supported by the component, passing it the parameters specified by the function.</docstr>
      </function>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of the component and its owned components.
Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
To destroy a form, call its Release method. Release waits for all the form&apos;s event handlers and the event handlers of the form&apos;s components to finish executing before destroying the form.

Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates.</docstr>
      </destructor>
      <procedure name="BeforeDestruction">
        <docstr>Performs any necessary actions before the first destructor is called.
BeforeDestruction is called automatically immediately before the component&apos;s first destructor executes. Do not call it explicitly in your applications.
As implemented in TComponent, BeforeDestruction checks whether the Destroying method has been called, and if not, calls it. Descendants that override this method to perform other actions before a component is destroyed should call the inherited method first to ensure that this check takes place.</docstr>
      </procedure>
      <function name="BeginInvoke">
        <docstr>Performs an asynchronous call to the method specified by either AProc or AFunc.
The AContext parameter specifies the context where the method executes in. This context corresponds to the main thread. In case of a Tcontrol descendant, it executes in the context of the thread on which the closest window handle was created.
BeginInvoke returns the results of the asynchronous execution in an interface IAsyncResult used as a return type.</docstr>
      </function>
      <function name="BeginInvoke">
        <docstr>Performs an asynchronous call to the method specified by either AProc or AFunc.
The AContext parameter specifies the context where the method executes in. This context corresponds to the main thread. In case of a Tcontrol descendant, it executes in the context of the thread on which the closest window handle was created.
BeginInvoke returns the results of the asynchronous execution in an interface IAsyncResult used as a return type.</docstr>
      </function>
      <function name="BeginInvoke">
        <docstr>Performs an asynchronous call to the method specified by either AProc or AFunc.
The AContext parameter specifies the context where the method executes in. This context corresponds to the main thread. In case of a Tcontrol descendant, it executes in the context of the thread on which the closest window handle was created.
BeginInvoke returns the results of the asynchronous execution in an interface IAsyncResult used as a return type.</docstr>
      </function>
      <function name="BeginInvoke">
        <docstr>Performs an asynchronous call to the method specified by either AProc or AFunc.
The AContext parameter specifies the context where the method executes in. This context corresponds to the main thread. In case of a Tcontrol descendant, it executes in the context of the thread on which the closest window handle was created.
BeginInvoke returns the results of the asynchronous execution in an interface IAsyncResult used as a return type.</docstr>
      </function>
      <function name="BeginInvoke">
        <docstr>Performs an asynchronous call to the method specified by either AProc or AFunc.
The AContext parameter specifies the context where the method executes in. This context corresponds to the main thread. In case of a Tcontrol descendant, it executes in the context of the thread on which the closest window handle was created.
BeginInvoke returns the results of the asynchronous execution in an interface IAsyncResult used as a return type.</docstr>
      </function>
      <function name="BeginInvoke">
        <docstr>Performs an asynchronous call to the method specified by either AProc or AFunc.
The AContext parameter specifies the context where the method executes in. This context corresponds to the main thread. In case of a Tcontrol descendant, it executes in the context of the thread on which the closest window handle was created.
BeginInvoke returns the results of the asynchronous execution in an interface IAsyncResult used as a return type.</docstr>
      </function>
      <function name="BeginInvoke">
        <docstr>Performs an asynchronous call to the method specified by either AProc or AFunc.
The AContext parameter specifies the context where the method executes in. This context corresponds to the main thread. In case of a Tcontrol descendant, it executes in the context of the thread on which the closest window handle was created.
BeginInvoke returns the results of the asynchronous execution in an interface IAsyncResult used as a return type.</docstr>
      </function>
      <function name="BeginInvoke">
        <docstr>Performs an asynchronous call to the method specified by either AProc or AFunc.
The AContext parameter specifies the context where the method executes in. This context corresponds to the main thread. In case of a Tcontrol descendant, it executes in the context of the thread on which the closest window handle was created.
BeginInvoke returns the results of the asynchronous execution in an interface IAsyncResult used as a return type.</docstr>
      </function>
      <procedure name="EndInvoke">
        <docstr>Blocks the caller until the specified ASyncResult completes.
Returns the result from the method that BeginInvoke asynchronously executes. This result is immediately returned after the given IAsyncResult finishes. 
EndInvoke raises any exception that may occur while the asynchronous method executes.</docstr>
      </procedure>
      <function name="EndInvoke">
        <docstr>Blocks the caller until the specified ASyncResult completes.
Returns the result from the method that BeginInvoke asynchronously executes. This result is immediately returned after the given IAsyncResult finishes. 
EndInvoke raises any exception that may occur while the asynchronous method executes.</docstr>
      </function>
      <function name="EndFunctionInvoke">
        <docstr>Blocks the caller until the specified ASyncResult completes.
Returns the result from the method that BeginInvoke asynchronously executes. This result is immediately returned after the given IAsyncResult finishes. The result type corresponds to a TObject class type.
EndInvoke raises any exception that may occur while the asynchronous method executes.</docstr>
      </function>
      <procedure name="DestroyComponents">
        <docstr>Destroys all owned components.
DestroyComponents iterates through the components owned by the component, removing each from the list of owned components and destroying it.
It is not necessary to call DestroyComponents directly. DestroyComponents is automatically called when the component is destroyed.</docstr>
      </procedure>
      <procedure name="Destroying">
        <docstr>Indicates that the component and its owned components are about to be destroyed.
Destroying sets the csDestroying flag in the ComponentState property. It then calls the Destroying method for each owned component so that its csDestroying flag is also set. If csDestroying is already set, Destroying does nothing.
It is not necessary to call Destroying directly. Destroying is automatically called when the component is destroyed.</docstr>
      </procedure>
      <function name="ExecuteAction">
        <docstr>Executes an action.
ExecuteAction executes an action for the component. Action is a TBasicAction or any descendant of TBasicAction. 
ExecuteAction first checks whether the provided action is compatible with the component and then executes the action. The return value is a Boolean. A value of True is returned if the action was executed; otherwise, False is returned. 
Derived classes can override this method to implement a distinct way of handling actions.</docstr>
      </function>
      <function name="FindComponent">
        <docstr>Indicates whether a given component is owned by the component.
FindComponent returns the component in the Components property array with the name that matches the string in the AName parameter. Use FindComponent to determine whether a given component is owned by another.
Component name matches are not case sensitive.</docstr>
      </function>
      <procedure name="FreeNotification">
        <docstr>Ensures that AComponent is notified that the component is going to be destroyed.
Use FreeNotification to register AComponent as a component that should be notified when the component is about to be destroyed. It is only necessary to register components this way when they are in a different form or have a different owner. For example, if AComponent is in another form and uses the component to implement a property, it must call FreeNotification so that its Notification method is called when the component is destroyed.
For components with the same owner, the Notification method is called automatically when an application explicitly frees the component. This notification is not sent out when components are freed implicitly, because the Owner is already being freed.</docstr>
      </procedure>
      <procedure name="RemoveFreeNotification">
        <docstr>Disables the destruction notification that was enabled by FreeNotification.
RemoveFreeNotification removes the component specified by the AComponent parameter from the internal list of objects to be notified that the component is about to be destroyed. AComponent is added to this list by a previous call to the FreeNotification method.
Most applications have no need to call RemoveFreeNotification. It is used by TComponent to detect loops where two components are notifying each other of their impending destruction.</docstr>
      </procedure>
      <procedure name="FreeOnRelease">
        <docstr>Frees the interface reference for components that were created from COM classes.
FreeOnRelease is called when an interface implemented by the component is released. FreeOnRelease is used internally and calls the corresponding interface method. It should not be necessary to call FreeOnRelease directly.</docstr>
      </procedure>
      <function name="GetEnumerator">
        <docstr>Returns a TComponent enumerator.
GetEnumerator returns a TComponentEnumerator reference, which enumerates the components contained within a specified containing component. 
To process all these subcomponents, call the TComponentEnumerator GetCurrent method within a While MoveNext do loop.</docstr>
      </function>
      <function name="GetParentComponent">
        <docstr>Returns the containing component.
GetParentComponent returns a reference to the component that contains the current component, or nil if there is no container. Use HasParent to determine whether a component has a containing component. 
For example, a button on a panel on a form returns the panel, the panel returns the form, and the form returns nil.</docstr>
      </function>
      <function name="GetNamePath">
        <docstr>Returns a string used by the Object Inspector.
GetNamePath is used to determine the text to display in the Object Inspector for the name of the object being edited. GetNamePath is introduced in TPersistent so descendants such as collections can appear in the Object Inspector. TComponent overrides GetNamePath to return the component&apos;s name. Do not call GetNamePath directly.</docstr>
      </function>
      <function name="HasParent">
        <docstr>Verifies whether the component has a parent.
Call HasParent to determine whether a specific component has a parent. 
Derived classes override this method to implement proper handling for parenting.
Use GetParentComponent to retrieve the component reference.</docstr>
      </function>
      <procedure name="InsertComponent">
        <docstr>Establishes the component as the owner of a specified component.
InsertComponent adds the component passed in the AComponent parameter to the end of the Components array property. The inserted component must have no name (no specified Name property value), or the name must be unique among all others in the Components list.
When the owning component is destroyed, AComponent is also destroyed.
Components are automatically inserted and removed when visually manipulating them in the form designer. Use InsertComponent when manually adding components to another Owner component&apos;s Components list.</docstr>
      </procedure>
      <procedure name="RemoveComponent">
        <docstr>Removes a specified component specified from the component&apos;s Components list.
Components are automatically inserted and removed when visually manipulating them in the form designer. Use RemoveComponent to programmatically delete the component specified by AComponent from its Owner component.</docstr>
      </procedure>
      <procedure name="SetSubComponent">
        <docstr>Identifies whether the component is a subcomponent.
Call SetSubComponent to indicate whether this component is a subcomponent. A subcomponent is a component whose Owner is a component other than the form or data module in which it resides. Unless such a component calls SetSubComponent with IsSubComponent set to True, its published properties will not be saved to the form file.
IsSubComponent indicates whether the component is a subcomponent (True) or not (False).
SetSubComponent is called at design time:

Either from the constructor of a component that always acts as a subcomponent. In this case, the component calls its own SetSubComponent method from the constructor with IsSubComponent set to True.
Or immediately after constructing an instance of the subcomponent. In this case, the Owner calls the SetSubComponent method of a component it has just instantiated, with IsSubComponent set to True.</docstr>
      </procedure>
      <function name="SafeCallException">
        <docstr>Handles exceptions in methods declared using the safecall calling convention.
SafeCallException handles exceptions in methods that use the safecall calling convention. Some classes that implement interfaces override this method to handle errors that might occur. TComponent calls the implementation of this method for the interface supported by the component, if it exists. If the component does not support interfaces, this method calls the SafeCallException method inherited from TObject, which returns E_UNEXPECTED. This is a default return value that is appropriate for classes that do not support any interfaces.</docstr>
      </function>
      <function name="UpdateAction">
        <docstr>Updates the state of an action.
UpdateAction is used to update the state of an action. Action is a TBasicAction or any descendant. 
UpdateAction first checks whether the provided action is compatible with the component and then updates it. The return value is a Boolean. A value of True is returned if the action was updated, and a value of False, otherwise. 
Derived classes can override this method to implement a distinct way of handling action updates.</docstr>
      </function>
      <function name="IsImplementorOf">
        <docstr>Indicates whether the component implements a specified interface.
Call IsImplementorOf to determine whether the component (or, if the component aggregates its interface with other components, whether the controlling component) supports the interface specified by I. IsImplementorOf is similar to the QueryInterface method, but it can handle a request for a nil (Delphi) or NULL (C++) interface, and it does not return an interface pointer.
The streaming system that loads and saves components uses IsImplementorOf to resolve property values that are interfaces.</docstr>
      </function>
      <function name="ReferenceInterface">
        <docstr>Establishes or removes internal links that cause this component to be notified when the implementer of a specified interface is destroyed.
Component writers use ReferenceInterface to ensure that properties whose values are interfaces are informed when the objects that implement those interfaces are destroyed. This notification must be in place for a property whose value is an interface to be saved with the component in a form file (that is, for such a property to persist as a published property).
I is an interface pointer that is the value of the published property of interest.
Operation indicates whether the notification link to the implementer of the interface should be established (opInsert) or removed (opRemove).
ReferenceInterface returns True if it is successful in establishing or removing the notification link. If ReferenceInterface returns False when called with Operation set to opInsert, the specified interface cannot be stored as the value of a published property.

Note: A result of False does not necessarily indicate an error, merely that the interface cannot be stored by the property streaming system. For example, ReferenceInterface returns False when the specified interface employs true reference counting, independent of component lifetimes.</docstr>
      </function>
      <property name="ComObject">
        <docstr>Specifies the interface reference implemented by the component.
Use ComObject to assign a COM interface implemented by a component to an interface reference. This property is used by components that support COM interfaces. 
If the component is not a wrapper for a COM component, trying to read ComObject causes TComponent to raise an EComponentError exception.</docstr>
      </property>
      <property name="ComponentCount">
        <docstr>Indicates the number of components owned by the component.
Use the ComponentCount property to determine the number of components owned by a component, for example, when iterating through the components list to perform an action on all owned components. The ComponentCount property equals the number of items in the components list. This value is one more than the highest Components index, because the first components index is 0.</docstr>
      </property>
      <property name="ComponentIndex">
        <docstr>Indicates the position of the component in its owner&apos;s Components property array.
Use ComponentIndex when iterating through the Components list of the component&apos;s owner to perform an action on owned components. It can be used in conjunction with ComponentCount. ComponentIndex is used internally for iterative assignment procedures. 

Note:  The first component in the list has a ComponentIndex value of 0, the second has a value of 1, and so on. Therefore, when using ComponentIndex with ComponentCount, note that ComponentCount is always 1 more than the highest Components index.</docstr>
      </property>
      <property name="ComponentState">
        <docstr>Describes the current state of the component, indicating when a component needs to avoid certain actions.
ComponentState is a set of constants defined in the TComponentState type.
Components use the ComponentState property to detect states in which certain kinds of actions are allowed or disallowed. For example, if a component needs to avoid certain behaviors at design time that it performs at run time, it can check for the csDesigning flag. 
ComponentState is read-only and its flags are set automatically when appropriate.</docstr>
      </property>
      <property name="ComponentStyle">
        <docstr>Governs the behavior of the component.
ComponentStyle governs how the component interacts with the streaming system and the Object Inspector. ComponentStyle is a read-only property. Typically, the value of the various component style flags are part of a component definition, specified in a component constructor. The one exception to this is the csSubComponent style, which can be set by calling the SetSubComponent method.</docstr>
      </property>
      <property name="DesignInfo">
        <docstr>Contains information used by the Form designer.
DesignInfo is used internally. Do not use this property in applications.</docstr>
      </property>
      <property name="Owner">
        <docstr>Indicates the component that is responsible for streaming and freeing this component.
Use Owner to find the owner of a component. The Owner of a component is responsible for two things:
The memory for the owned component is freed when its owner&apos;s memory is freed. This means that when a form is destroyed, all the components on the form are also destroyed.
The Owner is responsible for loading and saving the published properties of its owned controls.
By default, a form owns all components that are on it. In turn, the form is owned by the application. Thus, when the application shuts down and its memory is freed, the memory for all forms (and all their owned components) is also freed. When a form is loaded into memory, it loads all of the components that are on it.
The owner of a component is determined by the parameter passed to the constructor when the component is created. For components created in the form designer, the form is automatically assigned as the Owner.

Warning: If a component has an Owner other than a form or data module, it will not be saved or loaded with its Owner unless you identify it as a subcomponent. To identify a component as a subcomponent, call the SetSubComponent method.</docstr>
      </property>
      <property name="VCLComObject">
        <docstr>Represents information used internally by components that support COM.
VCLComObject is for internal use only.</docstr>
      </property>
      <property name="Observers">
        <docstr>Indicates the TObservers object added to the TComponent.
Observers is a read-only property that returns the TObservers added to the TComponent, in order to use the notifications provided by the observers either with LiveBindings or for the developers&apos; own purposes.</docstr>
      </property>
      <property name="Name">
        <docstr>Specifies the name of the component as referenced in code.
Use Name to change the name of a component to reflect its purpose in the current application. By default, the IDE assigns sequential names based on the type of the component, such as &apos;Button1&apos;, &apos;Button2&apos;, and so on.
Use Name to refer to the component in code.

Warning: Changing Name at run time causes any references to the old name to become undefined. Any subsequent code that uses the old name will cause an exception.</docstr>
      </property>
      <property name="Tag">
        <docstr>Stores a NativeInt integral value as a part of a component.
Tag has no predefined meaning. The Tag property can store any additional integer value for the convenience of developers. Often, Tag stores a pointer. A Tag value can be typecast to the appropriate pointer type. Notice that on 64-bit platforms, all  pointer types are 8 bytes in size, while on 32-bit platforms, pointer types are 4 bytes. These pointer sizes correspond to sizes of NativeInt integral values on 64-bit and 32-bit platforms.</docstr>
      </property>
    </members>
  </class>
  <class unit="System.Classes" name="TBasicAction">
    <docstr>TBasicAction is the ancestor class for all action objects.
TBasicAction introduces the fundamental behavior for an action. Descendants of TBasicAction add functionality for containment in an action list, for being categorized, and for specializing their behavior tailored to particular clients such as controls or menu items. Use TBasicAction if you want to create an action for an object that is neither a menu item nor a control.</docstr>
    <members>
      <procedure name="Change">
        <docstr>Generates an OnChange event.
Change is called automatically when the action&apos;s properties change. This method calls the OnChange event handler, if one is assigned.</docstr>
      </procedure>
      <procedure name="SetOnExecute">
        <docstr>Assigns an OnExecute event handler for the action and for all clients.
SetOnExecute is the property write method for the OnExecute event. 
In addition to assigning the specified Value event handler to the OnExecute event, SetOnExecute propagates the assignment of this event handler to all clients linked to the action and generates an OnChange event.</docstr>
      </procedure>
      <event name="OnChange">
        <docstr>Occurs when one of the action&apos;s properties changes.
Applications cannot use the protected OnChange event. It is used internally to manage the relationship between the properties of the action and the corresponding properties of the action&apos;s clients.
Component writers can use OnChange in descendent objects to respond when the action&apos;s properties change.</docstr>
      </event>
      <procedure name="Notification">
        <docstr>Responds when components are created or destroyed.
Do not call the Notification method in an application. Notification is called automatically when the component specified by AComponent is about to be inserted or removed, as specified by Operation. 
TBasicAction overrides the System.Classes.TComponent.Notification method. Notification checks whether the component specified by AComponent is the same as the component stored in the ActionComponent property and whether it is about to be freed. If so, Notification sets the ActionComponent property to nil (Delphi) or NULL (C++).</docstr>
      </procedure>
      <property name="ClientCount">
        <docstr>Stores the number of elements in the Clients list of action links associated with the action.</docstr>
      </property>
      <procedure name="RegisterChanges">
        <docstr>Associates the action with an action link.
RegisterChanges is called when the action and action link are connected, for example, when a new action link is set to an action. Value is the action link with which the action associates itself. The link is added to the action&apos;s client list.</docstr>
      </procedure>
      <procedure name="UnRegisterChanges">
        <docstr>Breaks the association between the action and the action link.
UnRegisterChanges is called when the action and the action link should no longer be associated. UnRegisterChanges is called, for example, in the action destructor or when the action link is unassociated from the action. Value is the action link with which the association is broken.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Instantiates and initializes a TBasicAction object.
Applications do not need to instantiate TBasicAction directly. Actions are created automatically when you choose New Action in the Action List editor.
If you want to create an action at run time, you should call the Create constructor of a FireMonkey action (FMX.ActnList.TAction) or VCL action (Vcl.ActnList.TAction), or any of their subclasses. The Create constructors assign a TActionList component to the ActionList property of the created action.
Create calls the inherited constructor and then creates a list of clients of the created action.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of an instance of a TBasicAction object.
You do not need to call the destructor for an action. An action is a component and is automatically destroyed by its owner, which was passed to the constructor when it is created. If you must destroy an action manually, call Free instead, which safely invokes the destructor.</docstr>
      </destructor>
      <function name="Suspended">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="HandlesTarget">
        <docstr>Introduces an interface for verifying that the type and state of a target component or control are appropriate for the action.
HandlesTarget does nothing in TBasicAction. HandlesTarget was introduced in TBasicAction so that descendants can override it to check the type and state of a target. HandlesTarget can verify any information about a target that is relevant for the action. HandlesTarget returns True if the target meets the specified criteria, False otherwise.</docstr>
      </function>
      <procedure name="UpdateTarget">
        <docstr>Introduces an interface for a method of notifying a client when the action updates itself.
UpdateTarget does nothing in TBasicAction. UpdateTarget was introduced in TBasicAction so that descendants can override it to correspondingly update a target when the action updates.</docstr>
      </procedure>
      <procedure name="ExecuteTarget">
        <docstr>Introduces an interface for invoking an action on a target client component or control.
ExecuteTarget does nothing in TBasicAction. ExecuteTarget was introduced in TBasicAction so that descendants can override it to initiate the action on the target. For example, an edit action that performs copying might copy the contents of an edit control to the clipboard.</docstr>
      </procedure>
      <function name="Execute">
        <docstr>Generates an OnExecute event.
Execute calls the OnExecute event handler, if one is assigned. Execute returns True if an event handler is called, False otherwise.</docstr>
      </function>
      <function name="Update">
        <docstr>Provides an opportunity to execute centralized code when an application is idle.
Update triggers the OnUpdate event handler. Update returns True if an event handler was found, False otherwise. When the application is idle, the OnUpdate event occurs for every action. This provides an opportunity for applications to execute centralized code for enabling and disabling, checking and unchecking, and so on.</docstr>
      </function>
      <property name="ActionComponent">
        <docstr>Stores the client component that caused this action to execute.
Use ActionComponent to discern which client component caused this action to execute. For example, examine ActionComponent from an OnExecute event handler if you need to know what user action triggered this action.
When the user clicks a client control, that client sets ActionComponent before calling the action&apos;s Execute method. After the action executes, the action resets ActionComponent to nil (Delphi) or NULL (C++).</docstr>
      </property>
      <event name="OnExecute">
        <docstr>Occurs when the execute event, of a client linked to the action, fires.
Write an OnExecute event handler when you want to respond when the user triggers the client object&apos;s default event (typically an OnClick event).
For most target clients, OnExecute is associated with the OnClick event. The Click method triggers the associated Action if EnableExecuteAction is True and the OnClick event handler is not assigned (or is equal to Action.OnExecute).
OnExecute is called in the Execute method. 
OnExecute also occurs when the user types the shortcut (or one of the secondary shortcuts) associated with the action or its client.

Warning:  If you assign an OnExecute event handler to a predefined action, the default behavior of that action will not occur.</docstr>
      </event>
      <event name="OnUpdate">
        <docstr>Occurs when the application is idle or when the action list updates.
Write an OnUpdate event handler to execute centralized code while an application is idle. For example, actions may want to update enabling and disabling, or checking and unchecking of client targets.</docstr>
      </event>
    </members>
  </class>
  <class unit="System.Classes" name="TProxySubrangeStream">
    <docstr>Helper class for reading/writing a segment of another stream.
        For example, it is used by TZipFile to provide access to a &quot;stored&quot; file.</docstr>
  </class>
  <class unit="Vcl.Controls" name="TControl">
    <docstr>TControl is the base class for all components that are visible at run time.
Controls are visual components, meaning the user can see them and possibly interact with them at run time. All controls have properties, methods, and events that describe aspects of their appearance, such as the position of the control, the cursor or hint associated with the control, methods to paint or move the control, and events that respond to user actions.
TControl has many protected properties and methods that are used or published by its descendants.</docstr>
    <members>
      <field name="FCurrentPPI">
        <docstr>Indicates current PPI value for the control</docstr>
      </field>
      <field name="FScaleFactor">
        <docstr>Indicates current scale factor for the control</docstr>
      </field>
      <function name="GetDesignDpi">
        <docstr>Obtains the design Dpi for the form where the control was designed.</docstr>
      </function>
      <function name="GetParentCurrentDpi">
        <docstr>Obtains the current Dpi for parent control, or the current control Dpi if there is no parent.</docstr>
      </function>
      <function name="GetCurrentPPI">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetDPIForDesigner">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="AsyncSchedule">
        <docstr>Schedules asynch method calls.
Vcl.Controls.TControl.AsyncSchedule inherits from System.Classes.TComponent.AsyncSchedule. All content below this line refers to System.Classes.TComponent.AsyncSchedule.
Schedules asynch method calls.
By default, AsyncSchedule uses Queue in order to queue the asynch method call with the main thread.
Override AsyncSchedule in descendant components in order to modify the management of the asynchronous scheduling.

 See Also
System.Classes.TComponent.BeginInvoke
System.Classes.TBaseAsyncResult
System.Classes.TBaseAsyncResult.Schedule</docstr>
      </procedure>
      <procedure name="ActionChange">
        <docstr>Responds when the action associated with the control changes.
ActionChange is called automatically when the action object specified by the Action property, or any of its properties, changes. By default, the control action link&apos;s OnChange event handler calls ActionChange.
ActionChange updates the control properties that correspond to properties of the associated action. These properties include the Caption, Enabled, Hint, and Visible properties and the OnClick event handler.
The Sender parameter is the action object that changed. 
The CheckDefaults parameter indicates whether the control&apos;s properties should all be updated or only those that have not been explicitly changed from their default values. When CheckDefaults is true, only those properties and event handlers that have not been changed from the default values are updated.</docstr>
      </procedure>
      <procedure name="AdjustSize">
        <docstr>Sets the size of the control as determined by the AutoSize property.
If the AutoSize property is true, AdjustSize is called automatically when the control needs to automatically resize itself to its contents. As implemented in TControl, AdjustSize calls SetBounds with the values of its Left, Top, Width, and Height properties. This call can result in a change of size if these values are altered in the control&apos;s OnCanResize or OnConstrainedResize event handlers, or if the control&apos;s OnResize event handler makes any final adjustments.
Descendent classes override AdjustSize to change the size of the control to adjust to its contents.
Other controls can call AdjustSize after changing the control&apos;s contents. Do not call AdjustSize in application code.</docstr>
      </procedure>
      <procedure name="AssignTo">
        <docstr>Overrides the inherited AssignTo function to enable assignments to TAction objects.
Do not call the protected AssignTo method in application code. The Assign method of a persistent object calls AssignTo if it is passed the control as a Source and the persistent object does not know how to copy the properties of the control. The Dest parameter is the persistent object that should have its properties copied from the control.
As implemented in TControl, AssignTo checks whether the Dest parameter is a TCustomAction object, and if so, assigns values to its Enabled, Hint, Caption, and Visible properties and its OnExecute event. This allows arbitrary controls to assign these to an associated action object.</docstr>
      </procedure>
      <procedure name="BeginAutoDrag">
        <docstr>Begins automatic drag.
BeginAutoDrag is called automatically when a user drags a control whose DragMode is dmAutomatic. Do not call BeginAutoDrag in application code.
As implemented in TControl, BeginAutoDrag calls BeginDrag, passing in the global Mouse variable&apos;s DragImmediate and DragThreshold properties.</docstr>
      </procedure>
      <function name="CanResize">
        <docstr>OnCanResize event dispatcher.
CanResize is called automatically when an attempt is made to resize the control, after any autosizing has occurred. The NewWidth and NewHeight arguments specify the attempted new values for the control&apos;s height and width. CanResize optionally adjusts the values of NewWidth and NewHeight, and returns true if the control can be resized to the returned values. CanResize returns false if the control cannot be resized.
CanResize generates an OnCanResize event. An OnCanResize event handler may change the values of NewHeight and NewWidth.</docstr>
      </function>
      <function name="CanAutoSize">
        <docstr>Indicates whether the control can resize itself automatically to accommodate its contents.
CanAutoSize is called automatically when the AutoSize property is true and an attempt is made to resize the control. It allows controls to implement the AutoSize property before the resize sequence that begins with the OnCanResize and OnConstrainedResize events and ends with the OnResize event.
When CanAutoSize is called, the NewWidth and NewHeight parameters indicate the proposed new dimensions of the control. CanAutoSize adjusts these values so that the control&apos;s size adjusts to its contents. If the adjustment results in values of NewWidth and NewHeight that differ from the control&apos;s current width and height, CanAutoSize returns true, indicating that the resize sequence should proceed. If, after adjustment, NewWidth and NewHeight equal Width and Height, CanAutoSize returns false, and the resize sequence is aborted.
As implemented in TControl, CanAutoSize always returns true without changing NewWidth or NewHeight. Override CanAutoSize to implement the AutoSize property for a particular control class&apos;s contents.</docstr>
      </function>
      <procedure name="Changed">
        <docstr>Sends a CM_CHANGED message to the control.
Call Changed after changing the properties of the control in a way that affects the properties of a parent object. Changed sends a CM_CHANGED message back to the control. If the control is a windowed control, this message is sent to the parent so that it can make any necessary adjustments.</docstr>
      </procedure>
      <procedure name="ChangeScale">
        <docstr>Rescaling event dispatcher.
ChangeScale is called automatically when an event requires that the control resize itself. Most often, this event is a call to the ScaleBy method of the control itself or the control&apos;s parent. This allows the control to adjust its own special properties, such as font sizes and display regions. 
ChangeScale parameters have the same meaning as for ScaleBy.

Note:  Because control sizes and coordinates are integers, scaling can result in round-off error. Repeated calls to ChangeScale can make the control gradually get smaller or slowly disappear from the form. Consider destroying and reloading the form after several rescalings.</docstr>
      </procedure>
      <procedure name="ChangeScale">
        <docstr>Rescaling event dispatcher.
ChangeScale is called automatically when an event requires that the control resize itself. Most often, this event is a call to the ScaleBy method of the control itself or the control&apos;s parent. This allows the control to adjust its own special properties, such as font sizes and display regions. 
ChangeScale parameters have the same meaning as for ScaleBy.

Note:  Because control sizes and coordinates are integers, scaling can result in round-off error. Repeated calls to ChangeScale can make the control gradually get smaller or slowly disappear from the form. Consider destroying and reloading the form after several rescalings.</docstr>
      </procedure>
      <procedure name="Click">
        <docstr>Respond to user click.
Click is called automatically when the user left-clicks the control. Component or application code can call Click to simulate a user mouse click. This is often done in menu actions and hotkey handlers.
As implemented in TControl, Click queries whether the OnClick event handler exists and is different from the OnExecute handler for the control&apos;s Action. If this is true, the OnClick event handler is called. If this is false, and the Action OnExecute event handler exists, the Action&apos;s Execute method is called. Override Click to provide additional behavior.</docstr>
      </procedure>
      <procedure name="ConstrainedResize">
        <docstr>Notify control of resize with constraints.
ConstrainedResize is called automatically when a control is resized and has nonzero Constraints. This allows the control to modify the constraints before they are applied.
As implemented in TControl, ConstrainedResize simply calls the OnConstrainedResize event handler.</docstr>
      </procedure>
      <function name="CalcCursorPos">
        <docstr>Gives the coordinates of the cursor, with respect to the origin of the control.
Use CalcCursorPos to obtain the current coordinates of the mouse cursor, with respect to the origin of the control.</docstr>
      </function>
      <procedure name="CreateTouchManager">
        <docstr>Instantiates a touch manager.
CreateTouchManager is called automatically in the constructor of the TControl class. By default, it instantiates a TTouchManager class. 
CreateTouchManager can be overridden in descendent classes of TControl to use another touch manager, usually a user-defined one.</docstr>
      </procedure>
      <procedure name="DblClick">
        <docstr>OnDblClick event dispatcher.
DblClick calls any event handler attached to the OnDblClick event. Override DblClick to provide other responses in addition to the inherited event-handler call when the user double-clicks the control.
The DblClick method is triggered by left mouse-button double-click message (WM_LBUTTONDBLCLK) from Windows.</docstr>
      </procedure>
      <procedure name="DefaultDockImage">
        <docstr>Handles the painting and erasing of a dock image.
The DrawDragDockImage and EraseDragDockImage methods call DefaultDockImage to paint or erase the drag image of a control while the user drags it in a drag-and-dock operation.
DragDockObject contains the drag-and-dock information for the control.
Erase specifies whether to draw or erase the image.</docstr>
      </procedure>
      <procedure name="DefineProperties">
        <docstr>Provides methods to read and write the IsControl property to a stream such as a form file.
DefineProperties is called automatically by the streaming system that loads and saves VCL components. It allows persistent objects to read and write properties that are not published. Published properties are loaded and stored automatically.
DefineProperties uses the methods of the filer passed as the Filer parameter to assign methods that can load and save the IsControl property.
Override DefineProperties to persist unpublished properties. Call the DefineBinaryProperty or DefineProperty method of the Filer parameter to assign methods that load or save property values.

Note:  When overriding this method, call the parent class&apos;s DefineProperties method first.</docstr>
      </procedure>
      <procedure name="DockTrackNoTarget">
        <docstr>Handles dragging of the control over an invalid docking target.
DockTrackNoTarget is called automatically when the control is dragged over an invalid docking target. It updates the docking rectangle of the TDragDockObject specified by Source to reflect the current mouse coordinates, as given by X and Y.</docstr>
      </procedure>
      <procedure name="DoContextPopup">
        <docstr>Is an OnContextPopup event dispatcher.
OnContextPopup calls any event handler attached to the OnContextPopup event. When creating a component that descends from TControl override OnContextPopup to provide other responses in addition to the inherited event-handler call when the user invokes the control&apos;s context menu.
MousePos indicates the position where the user right-clicked the control. If the user invoked the context menu using the keyboard, MousePos is (-1,-1).
Handled returns a Boolean value indicating whether the control should continue with its default response to the user action.</docstr>
      </procedure>
      <procedure name="DoEndDock">
        <docstr>Is an OnEndDock event dispatcher.
OnEndDock calls any event handler attached to the OnEndDock event. When creating a component that descends from TControl, override OnEndDock to provide other responses in addition to the inherited event-handler call when the user finishes a drag-and-dock operation.</docstr>
      </procedure>
      <procedure name="DoDock">
        <docstr>Docking event dispatcher.
DoDock is called automatically as part of the docking process. It updates the control&apos;s dimensions and causes it to repaint.
NewDockSite is the control&apos;s new dock site. This value can be nil (Delphi) or NULL (C++) or NullDockSite (a constant that indicates no dock site).
ARect specifies the control&apos;s new dimensions once it is docked to NewDockSite.</docstr>
      </procedure>
      <procedure name="DoStartDock">
        <docstr>Is an OnStartDockevent dispatcher.
DoStartDock calls any event handler attached to the OnStartDock event. When creating a component that descends from TControl, override DoStartDock to provide other responses in addition to the inherited event-handler call when the user starts a drag-and-dock operation.</docstr>
      </procedure>
      <function name="DoMouseWheel">
        <docstr>Processes mouse wheel motion.
DoMouseWheel is called automatically when the user rotates the mouse wheel.
The Shift parameter indicates the current state of the SHIFT, ALT, and CTRL keys.
The WheelDelta parameter indicates the distance the wheel was rotated. WheelDelta is positive if the mouse was rotated upward, negative if the mouse was rotated downward.
The MousePos parameter indicates the current position of the mouse pointer.
DoMouseWheel returns true if an event handler was found and indicated that it handled the event.
As implemented in TControl, DoMouseWheel first attempts to call the OnMouseWheel event handler. If this routine exists and succesfully handles the event, DoMouseWheel returns true. Otherwise, DoMouseWheel repeatedly calls DoMouseWheelDown or DoMouseWheelUp, depending on the direction the user turned the mouse wheel. These routines, in turn, call the OnMouseWheelUp or OnMouseWheelDown event handler.
Before the first call to DoMouseWheelDown or DoMouseWheelUp, DoMouseWheel adds WheelDelta to the WheelAccumulator property. After each call, DoMouseWheel adjusts WheelAccumulator towards zero; each adjustment is by an internal constant that defines the minimum meaningful wheel motion. When the absolute value of of WheelAccumulator drops below the value of this constant, DoMouseWheel exits, returning the value returned by the final call to DoMouseWheelDown or DoMouseWheelUp.</docstr>
      </function>
      <function name="DoMouseWheelDown">
        <docstr>Is an OnMouseWheelDown event dispatcher.
The DoMouseWheel method calls DoMouseWheelDown to generate an OnMouseWheelDown event.
The Shift parameter indicates the state of the SHIFT, ALT, and CTRL keys.
The MousePos parameter indicates the position of the mouse pointer.
DoMouseWheelDown returns true if an event handler indicates that it handled the message, and false otherwise.
Override DoMouseWheelDown to perform class-specific tasks in addition to calling the event handler when the mouse wheel is rotated downward.</docstr>
      </function>
      <function name="DoMouseWheelUp">
        <docstr>Is an OnMouseWheelUp event dispatcher.
The DoMouseWheel method calls DoMouseWheelUp to generate an OnMouseWheelUp event.
The Shift parameter indicates the state of the SHIFT, ALT, and CTRL keys.
The MousePos parameter indicates the position of the mouse pointer.
DoMouseWheelUp returns true if an event handler indicates that it handled the message, and false otherwise.
Override DoMouseWheelUp to perform class-specific tasks in addition to calling the event handler when the mouse wheel is rotated upward.</docstr>
      </function>
      <procedure name="DragCanceled">
        <docstr>Provides the interface for a method that responds to the cancellation of a drag.
DragCanceled is called automatically when a drag operation is canceled. As implemented in TControl, DragCanceled does nothing. When creating a component that descends from TControl, override DragCanceled to provide code that executes when a drag-and-drop or drag-and-dock operation is canceled.</docstr>
      </procedure>
      <procedure name="DragOver">
        <docstr>Is an OnDragOver event dispatcher.
Override DragOver to add additional code that executes before the OnDragOver event handler is called. 
DragOver sets the Accept parameter to true to indicate that the user can drop the dragged object on the control. It sets Accept to false to indicate that the user cannot drop the dragged object on the control.
The Source parameter is the object being dragged. 
The State parameter indicates how the dragged object is moving in relation to the control. X and Y indicate the current position of the mouse.</docstr>
      </procedure>
      <procedure name="DoEndDrag">
        <docstr>Is an OnEndDrag event dispatcher.
DoEndDrag calls any event handler attached to the OnEndDrag event. When creating a component that descends from TControl, override DoEndDrag to provide other responses in addition to the inherited event-handler call when the user drops an object or cancels a drag-and-drop operation.</docstr>
      </procedure>
      <procedure name="DoStartDrag">
        <docstr>Is an OnStartDrag event dispatcher.
DoStartDrag calls any event handler attached to the OnStartDrag event. When creating a component that descends from TControl, override DoStartDrag to provide other responses in addition to the inherited event-handler call when the user starts a drag-and-drop operation.</docstr>
      </procedure>
      <procedure name="DoGesture">
        <docstr>Processes the unhandled gesturing events.
DoGesture is run automatically for all gesturing events that were not handled by the user. DoGesture is run only if OnGesture is not set or if it did not handle the gesture event. 
Override DoGesture in descending classes to support default behavior for gesture events that were not handled by the user. In TControl, the DoGesture method simply returns and does no special processing.</docstr>
      </procedure>
      <procedure name="DoGetGestureOptions">
        <docstr>Returns the interactive gestures and their options.
DoGetGestureOptions is used internally to access the interactive gestures and their options associated with a TControl.</docstr>
      </procedure>
      <procedure name="DrawDragDockImage">
        <docstr>Draws the dock image for the control.
DrawDragDockImage is called automatically to draw the control (or, more typically, the drag rectangle) when the control is manipulated in drag-and-dock operations.
DrawDragDockImage calls DefaultDockImage to render the image.</docstr>
      </procedure>
      <procedure name="EraseDragDockImage">
        <docstr>Erases the dock image for the control.
DrawDragDockImage is called automatically to erase the control (or, more typically, the drag rectangle) when the control is manipulated in drag-and-dock operations.</docstr>
      </procedure>
      <function name="GetAction">
        <docstr>Returns the value of the Action property.
GetAction is a protected method in the TControl class and is used to obtain the current value of the Action property.</docstr>
      </function>
      <function name="GetActionLinkClass">
        <docstr>Returns the appropriate action link class that is associated with the control class.
GetActionLinkClass returns the appropriate class type for the action link used with a control. This class is used internally to create an action link object for the control when it has an associated action. The action link links the action to the control client. Each Action link class is designed to link specific properties and event handlers of the action to its client, based on the types of properties the client supports.
As implemented in TControl, GetActionLinkClass returns the TControlActionLink class type, which associates the ShowHint, Caption, Enabled, and Visible properties with the OnClick event handler. Descendants of TControl override this method to specify a descendant of TControlActionLink that handles their configuration of properties and events.</docstr>
      </function>
      <function name="GetClientOrigin">
        <docstr>Returns the screen coordinates of the upper-left corner of the control&apos;s client area.
Override GetClientOrigin to change how the ClientOrigin is calculated.
The GetClientOrigin method is the protected method for reading the ClientOrigin property. GetClientOrigin calculates the ClientOrigin by adding the control&apos;s Left and Top values to the ClientOrigin coordinates of its parent.</docstr>
      </function>
      <function name="GetClientRect">
        <docstr>Returns a rectangle defining the client area of the control.
Override GetClientRect to change how the client area is calculated.
The GetClientRect method is the protected method for reading the ClientRect property. GetClientRect returns a rectangle with the rectangle&apos;s Top and Left fields set to zero, and its Bottom and Right fields set to the control&apos;s ClientHeight and ClientWidth, respectively.</docstr>
      </function>
      <function name="GetDeviceContext">
        <docstr>Returns a device context for the control.
Call GetDeviceContext to obtain a device context and window handle. Override GetDeviceContext to change how the device context is obtained.
The window handle used by the control is returned in the WindowHandle parameter. GetDeviceContext returns the device context of this, the parent control&apos;s window.</docstr>
      </function>
      <function name="GetDockEdge">
        <docstr>Returns the edge on which another control should be docked when it is dragged over the control.
Use GetDockEdge to get the edge on which another control should be docked when it is dragged over the control.
MousePos is the position of the mouse.
GetDockEdge is called automatically during drag-and-dock operations involving the control.</docstr>
      </function>
      <function name="GetEnabled">
        <docstr>Returns the value of the Enabled property.
GetEnabled is the read implementation of the Enabled property.
Override GetEnabled and SetEnabled to change the implementation of the Enabled property. For example, a descendant of TControl might change the way the Enabled property interacts with an associated action.</docstr>
      </function>
      <function name="GetFloating">
        <docstr>Returns the value of the Floating property.
GetFloating is the implementation of the read-only Floating property. GetFloating returns true if the HostDockSite property is either nil (Delphi) or NULL (C++), or of type FloatingDockSiteClass.
Override this method to change the way a control determines if it is floating.</docstr>
      </function>
      <function name="GetFloatingDockSiteClass">
        <docstr>Returns the class used for the control when it is floating.
GetFloatingDockSiteClass is the read implementation of the FloatingDockSiteClass property. Override this method to change the implementation of FloatingDockSiteClass.</docstr>
      </function>
      <function name="GetPalette">
        <docstr>Returns the handle to a palette for use by the control.
As implemented in TControl, GetPalette returns a null handle, indicating that the control does not have a palette. Override GetPalette to implement derived objects that use a palette. Create a palette handle for the control by a call to the Windows API function CreatePalette. GetPalette should return the palette handle for the control.
Specifying the palette for a control tells the application that the control&apos;s palette needs to be realized and designates the palette to use for realization.
GetPalette is called only if the run-time video mode requires color palette support, for example, in 256-color mode.</docstr>
      </function>
      <function name="GetPopupMenu">
        <docstr>Returns the pop-up menu associated with the control.
Call GetPopupMenu to find the pop-up menu associated with the control. Override GetPopupMenu to change which pop-up menu is associated with the control or to specify different pop-up menus depending on the state of the control.
GetPopupMenu returns the value of the Popup property.</docstr>
      </function>
      <function name="GetDragMode">
        <docstr>Returns the value of the DragMode property.
GetDragMode is a protected method in the TControl class and is used to obtain the current value of the DragMode property.</docstr>
      </function>
      <function name="IsTouchPropertyStored">
        <docstr>Checks whether the associated touch manager stored any of the given options.
IsTouchPropertyStored is used internally by the VCL framework to check whether the associated touch manager component has stored the given options. Do not call IsTouchPropertyStored directly. IsTouchPropertyStored is used primarily to ensure that controls that do not require gesturing are not storing useless data in the DFMs or executables.</docstr>
      </function>
      <procedure name="Loaded">
        <docstr>Initializes the control after it is loaded from a stream.
Do not call Loaded. The VCL streaming system calls Loaded automatically after the control&apos;s form is loaded into memory so that the control can complete any initializations that depend on other objects in the form.
Loaded overrides the inherited method in order to initialize the control from its associated Action. To change the properties the control copies from its action, override the ActionChange method.</docstr>
      </procedure>
      <function name="MouseActivate">
        <docstr>Triggers a TMouseActivateEvent event.
Use MouseActivate to trigger a TMouseActivateEvent event with the given parameters. 
The following table explains the meaning of each parameter:





Parameter

Meaning



Button



The mouse button that is pressed.




Shift



The shift state while the mouse button is pressed.




X | Y



The current mouse coordinates.




HitTest



The hit test value obtained from the WM_NCHITTEST message.</docstr>
      </function>
      <procedure name="MouseDown">
        <docstr>OnMouseDown event dispatcher.
Override the protected MouseDown method to provide other responses in addition to calling the OnMouseDown event handler when the user presses the mouse button down while the cursor&apos;s hotspot is over the control.
The Button parameter determines which mouse button the user pressed. Shift indicates which shift keys (Shift, Ctrl, or Alt) were down when the user pressed the mouse button. X and Y are the pixel coordinates of the mouse pointer within the client area of the control.
A control calls MouseDown in response to any of the Windows mouse-down messages (WM_LBUTTONDOWN, WM_MBUTTONDOWN, WM_RBUTTONDOWN), decoding the message parameters into the shift-key state and position, which it passes in the Shift, X, and Y parameters, respectively. The value of the Button parameter indicates which mouse button was pressed down: left, right, or middle.</docstr>
      </procedure>
      <procedure name="MouseMove">
        <docstr>Responds to mouse moving over control area.
Override the protected MouseMove method to provide other responses in addition to calling the OnMouseMove event handler when the user moves the mouse.
A control calls MouseMove in response to any of the Windows mouse-move messages (WM_MOUSEMOVE), decoding the message parameters into the shift-key state and position, which it passes in the Shift, X, and Y parameters, respectively.
As the mouse cursor moves across a control, this method is called repeatedly. Each time it is called, it is with the new coordinates that reflect the continuous path of the mouse cursor across the screen real estate covered by the control&apos;s visual representation.</docstr>
      </procedure>
      <procedure name="MouseUp">
        <docstr>Is an OnMouseUp event dispatcher.
Override the protected MouseUp method to provide other responses in addition to calling the OnMouseUp event handler when the user releases a previously pressed mouse button while the cursor&apos;s hot spot is over the control.
A control calls MouseUp in response to any of the Windows mouse-up messages (WM_LBUTTONUP, WM_MBUTTONUP, WM_RBUTTONUP), decoding the message parameters into the shift-key state and position, which it passes in the Shift, X, and Y parameters, respectively. The value of the Button parameter indicates which mouse button was released: left, right, or middle.</docstr>
      </procedure>
      <procedure name="Notification">
        <docstr>Responds to notifications indicating that components are being created or destroyed.
Notification allows TControl to update its internal state if an associated component is removed. The internal state is updated if: 

The associated pop-up menu is destroyed.
The control docking site is destroyed.
The custom hint associated with the control is destroyed.
The associated gesture manager is destroyed.
Override the Notification method to respond to notifications indicating that other components are about to be destroyed or have just been created. Use the Notification method to update controls that rely on other objects. Data-aware objects override the Notification method to update themselves when their data source is removed. Some objects respond to notifications indicating that other objects of a specific type are being created. For example, the session component sets the Session property of new data-aware controls to itself when the AutoSessionName property is True. 
By default, components pass along the notification to their owned components, if any.</docstr>
      </procedure>
      <procedure name="PositionDockRect">
        <docstr>Positions the docking rectangle according to the current drag-and-dock state.
Use PositionDockRect to adjust the docking rectangle of the drag-and-dock object specified by DragDockObject. DragDockObject&apos;s DockRect property is updated to reflect the current drag-and-dock state. This updating process makes use of the UndockWidth, UndockHeight, LRDockWidth, or TBDockHeight property, as appropriate.</docstr>
      </procedure>
      <function name="PaletteChanged">
        <docstr>Responds to changes in the system&apos;s palette by realizing the control&apos;s palette.
Override PaletteChanged to change how the control responds to Windows notifications that the system palette is changing. TControl responds to these notifications by trying to realize the control&apos;s palette, if any, into the current device context. If the change in the system palette causes the actual value of the control&apos;s palette to change, PaletteChanged invalidates the control so that it can repaint with the new palette.
Windows paints the active window with a foreground palette, while other windows are forced to use background palettes. Background palettes are approximate matches to the colors specified by the control&apos;s logical palette, given the limitations imposed by implementing the foreground palette. Windows only allows a single foreground palette.
PaletteChanged allows the control to obtain a new realization of its palette when the system palette changes. When Foreground is true, the form has been activated and the control is specifying the new foreground palette. When Foreground is false, another application or form has changed the foreground palette, and controls that are sensitive to the available palette should realize new background palettes to best match their logical palettes.
If the control does not have a logical palette to be realized into the current device context, GetPalette returns a handle of 0, and PaletteChanged returns false, indicating that no palette was realized. If GetPalette returns the handle to a logical palette, PaletteChanged realizes this palette into the current device context, and returns true.

Note: PaletteChanged is called only when the run-time video mode requires palette support, such as for 256 color mode, but not 16 million color mode.</docstr>
      </function>
      <procedure name="ReadState">
        <docstr>Prepares the control for having its properties assigned values read from a stream.
ReadState is part of a sequence of calls used by the streaming system that loads and saves component state. It reads the values of all the control&apos;s published properties, stored data, and owned components from the reader object passed in Reader. 
Override ReadState to change the preparations the control makes as it readies itself to have its property values assigned from a stream. For example, a control might destroy temporary internal data structures or objects before new instances are loaded from the stream. Remember to include a call to the inherited class&apos;s method when overriding ReadState.
As implemented in TControl, ReadState assigns the Reader parameter&apos;s Parent property to the control&apos;s own Parent property before calling the inherited ReadState method of TComponent. Finally, ReadState synchronizes the Font, Color, and ShowHint properties with the parent control, as indicated by the ParentFont, ParentColor, and ParentShowHint properties, respectively.</docstr>
      </procedure>
      <procedure name="RequestAlign">
        <docstr>Instructs the parent of a control to reposition the control, enforcing its Align property.
Controls call RequestAlign internally when changes are made to the size or position of the control, so that they remain properly aligned within the parent control. Do not call RequestAlign in application code.</docstr>
      </procedure>
      <procedure name="Resize">
        <docstr>Respond to control resize.
Resize is called automatically immediately after the control&apos;s dimensions change. As implemented in TControl, Resize calls the control&apos;s OnResize event handler if it is assigned.</docstr>
      </procedure>
      <procedure name="ScaleConstraints">
        <docstr>Scales the values of the Constraints property to the given ratio.
Use ScaleConstraints to scale the values of the Constraints property to the given M/D ratio.</docstr>
      </procedure>
      <procedure name="ScaleMargins">
        <docstr>Scales the values of the Margins property to the given ratio.
Use ScaleMargins to scale the values of the Margins property to the given M/D ratio.</docstr>
      </procedure>
      <function name="DefaultScalingFlags">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="SendCancelMode">
        <docstr>Cancels the modal state of the control.
Call SendCancelMode to cancel the modal state of the control. Various controls implemented in the VCL support a model state where the user must respond to the control before interacting with any other object on the form. An example is the dropped-down state of a combo box when the drop-down list is showing. For these controls, specific user actions send a Windows message to the control to end the model state, such as a mouse click that closes up the drop-down list.
SendCancelMode allows an application to end the modal state of the control in the absence of a user action, or when implementing a new user interface response.</docstr>
      </procedure>
      <procedure name="SendDockNotification">
        <docstr>Sends a Windows message to the control&apos;s host dock site.
Use SendDockNotification to send a Windows message to the control&apos;s host dock site.
SendDockNotification is called automatically when the control&apos;s text or visibility changes.</docstr>
      </procedure>
      <procedure name="SetAutoSize">
        <docstr>Sets the value of the AutoSize property.
SetAutoSize is a protected method in the TControl class and is used to set the value of the AutoSize property.</docstr>
      </procedure>
      <procedure name="SetDragMode">
        <docstr>Sets the drag mode for the control.
SetDragMode is the protected write implementation for the DragMode property. Override SetDragMode to execute additional code when the value of the DragMode property changes.</docstr>
      </procedure>
      <procedure name="SetEnabled">
        <docstr>Sets the value of the Enabled property.
SetEnabled is the protected write implementation of the Enabled property. After changing the internal representation of the Enabled property, SetEnabled sends a Windows message back to the control so that it can respond to the change. When TControl receives this message, it invalidates the control so that its appearance reflects the change (for example, so that it appears grayed). Some descendants respond to this message in other ways (for example, windowed controls ensure that a disabled control does not have focus).
Override GetEnabled and SetEnabled to change the implementation of the Enabled property. For example, a descendant of TControl might change the way the Enabled property interacts with an associated action. When overriding SetEnabled, be sure to call the inherited method.</docstr>
      </procedure>
      <procedure name="SetName">
        <docstr>Sets the name of the control.
SetName is the protected write implementation of the Name property. TControl updates the Text or Caption property, if appropriate, after changing the value of Name.
Override SetName to execute additional code when the value of the Name property changes.</docstr>
      </procedure>
      <procedure name="SetParent">
        <docstr>Sets the parent of the control.
SetParent is the protected implementation of the Parent property. Override SetParent to execute additional code when the value of the Parent property changes.
The AParent parameter specifies the new parent of the control.
If the control already has a parent, SetParent removes the control from that parent&apos;s list of controls by calling the parent&apos;s RemoveControl method. If AParent is not nil (Delphi) or NULL (C++), SetParent calls its InsertControl method to add the control to its list of controls.
The TControl destructor calls SetParent(nil (Delphi) or NULL (C++)) to remove the control from its parent&apos;s control list before destroying the component.</docstr>
      </procedure>
      <procedure name="SetParentBiDiMode">
        <docstr>Specifies whether the control uses its parent&apos;s BiDiMode.
SetParentBiDiMode is the protected write implementation of the ParentBiDiMode property.</docstr>
      </procedure>
      <procedure name="SetBiDiMode">
        <docstr>Sets the control&apos;s bidirectional mode.
SetBiDiMode is the write implementation of the control&apos;s BiDiMode property. Override this method to change the implementation of BiDiMode.</docstr>
      </procedure>
      <procedure name="SetStyleElements">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="SetStyleName">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="SetZOrder">
        <docstr>Repositions the control in its parent&apos;s control list, thereby changing position onscreen.
Call SetZOrder to change the z-order of the control. To make the control the topmost control, specify the TopMost value as true. To make the control the bottommost, set TopMost to false.
After changing the order, SetZOrder invalidates the control to ensure repainting to reflect the new order.
The stacking order of windowed and non-windowed controls cannot be mingled. For example, if you put a memo, a windowed control on a form, and then put a label, a non-windowed control on top of it, the label disappears behind the memo. Windowed controls always stack on top of non-windowed controls. In this example, calling the SetZOrder method of the label or the memo has no effect; the label always remains behind the memo.</docstr>
      </procedure>
      <procedure name="SetCustomHint">
        <docstr>Sets the value of the CustomHint property.
SetCustomHint is a protected method in the TControl class and is used to set the value of the CustomHint property.</docstr>
      </procedure>
      <procedure name="UpdateExplicitBounds">
        <docstr>Attempts to update the values of the control&apos;s explicit bounds to those of its current bounds.
Use UpdateExplicitBounds to update the values of the control&apos;s explicit bounds to those of its current bounds. 
The update process succeeds as long as the options csAligning in ControlState and csReading in ComponentState are disabled.</docstr>
      </procedure>
      <procedure name="UpdateBoundsRect">
        <docstr>Changes the Top, Left, Width, and Height properties of the control, but does not update its screen image and bypasses all resize events.
UpdateBoundsRect is used internally by controls to stay synchronized with changes made by the underlying Windows screen object. UpdateBoundsRect updates the properties to match those passed in the rectangle as the R parameter.</docstr>
      </procedure>
      <procedure name="VisibleChanging">
        <docstr>Provides the interface for a method that responds to changes in the control&apos;s visibility.
VisibleChanging is called before the value of a control&apos;s Visible property changes. As implemented in TControl, it does nothing. Override VisibleChanging to respond to changes in the control&apos;s visibility. For example, if a control should not change its visibility, override VisibleChanging to raise an exception when an attempt is made to alter the control&apos;s visibility.</docstr>
      </procedure>
      <procedure name="WndProc">
        <docstr>Provides specific message responses for the control.
Override WndProc to change the initial Windows message handler for the control. The WindowProc property is initialized to WndProc.
WndProc implements the mouse behavior specified by the ControlStyle and DragMode properties, and updates the ControlState property. It passes any unhandled messages on to the Dispatch method.
When overriding WndProc to provide specialized responses to messages, be sure to call the inherited WndProc at the end to dispatch any unhandled messages.</docstr>
      </procedure>
      <procedure name="UpdateStyleElements">
        <docstr>Called when the StyleElements property changes.
Override the UpdateStyleElements method in a descendant class to provide customized behavior for the control when the value of the StyleElements property changes.</docstr>
      </procedure>
      <function name="DesignWndProc">
        <docstr>Processes the given message and returns some Boolean information based on the message&apos;s content.
DesignWndProc returns true if the csDesignInteractive option in ControlStyle is enabled and if either the right mouse button is pressed or the right mouse button is released. The true value is returned also when ControlStyle is enabled and when either the mouse has moved or the right mouse button is double-clicked.</docstr>
      </function>
      <function name="GetDragImages">
        <docstr>Returns the control&apos;s image list containing the image to be displayed while dragging.
Override GetDragImages to provide a custom image list for the control. As implemented in TControl, GetDragImages returns nil (Delphi) or NULL (C++).</docstr>
      </function>
      <function name="GetAllocatedWindowHandle">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <property name="ActionLink">
        <docstr>Contains the action link object associated with the control.
ActionLink handles the association between the control and the action specified by the Action property. The action link specifies which properties and events of the action object determine the values of the control&apos;s corresponding properties and events.
Most applications do not use the ActionLink property. Component writers can change this property in TControl descendants to be a custom descendant of TControl ActionLink that handles a desired configuration of properties and events.</docstr>
      </property>
      <property name="AutoSize">
        <docstr>Specifies whether the control sizes itself automatically to accommodate its contents.
Use AutoSize to specify whether the control sizes itself automatically. When AutoSize is True, the control resizes automatically when its contents change.
By default, AutoSize is False.</docstr>
      </property>
      <property name="Caption">
        <docstr>Specifies a text string that identifies the control to the user.
Use Caption to specify the text string that labels the control.
To underline a character in a Caption that labels a component, include an ampersand (&amp;) before the character. This type of character is called an accelerator character. The user can then select the component by pressing ALT while typing the underlined character. To display an ampersand character in the caption, use two ampersands (&amp;&amp;).

Notes:
Controls that display text use either the Caption property or the Text property to specify the text value. The property that is used depends on the type of control. In general, Caption is used for text that appears as a window title or label, while Text is used for text that appears as the content of a control.
For some controls, such as TButton, it is not possible to change the color of the Caption. If you want to change the color of a button caption, you should use an alternate button type such as TSpeedButton or TBitBtn instead of TButton. With either TSpeedButton or TBitBtn, you can change the color of the Caption property by using the Font property.
For TLinkLabel, an HTML tag is declared inside the Caption property either at run time or at design time.</docstr>
      </property>
      <property name="DesktopFont">
        <docstr>Specifies whether the control uses the Windows icon font when writing text.
Set DesktopFont to true to specify that the control should use the Windows icon font for its Font property. The Windows icon font is the value of the IconFont property of the global Screen variable. 
When DesktopFont is true, the control&apos;s Font property updates every time the Windows icon font changes. This font can be changed by setting the IconFont property of the global Screen variable, or by the actions of other programs. Setting the Font property from the IconFont property of the Screen object does not allow controls to dynamically respond in this manner when the Windows icon font changes.</docstr>
      </property>
      <property name="DragKind">
        <docstr>Specifies whether the control is being dragged normally or for docking.
Use DragKind to get or set whether the control participates in drag-and-drop operations or drag-and-dock operations.</docstr>
      </property>
      <property name="DragCursor">
        <docstr>Specifies the image used to represent the mouse pointer when the control is being dragged.
Use the DragCursor property to change the cursor image presented when the control is being dragged.

Note: To make a custom cursor available for the DragCursor property, see the Cursor property.</docstr>
      </property>
      <property name="DragMode">
        <docstr>Specifies how the control initiates drag-and-drop or drag-and-dock operations.
Use DragMode to control when the user can drag the control. Disable the drag-and-drop or drag-and-dock capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic. For more information about dmManual and dmAutomatic, see TDragMode.</docstr>
      </property>
      <property name="IsControl">
        <docstr>Specifies whether a form stores its form-specific properties to a stream.
Use IsControl to use a form as a complex control, rather than as a desktop form. IsControl affects the way the form gets saved. When IsControl is true, form-specific properties do not get saved with the form. When IsControl is false, the form-specific properties get saved along with the other properties.
IsControl permits you to use the forms designer to create complex controls by creating those controls as forms, placing and naming their contained controls, and attaching code to events. After saving the form, edit the form as text, and in the text version set IsControl to true. The next time the form is loaded and saved, only those form properties appropriate to use as a control are stored, not the properties specific to TForm. Next, edit the form file as text, changing the type of the component from TForm to the desired control type, such as TPanel.</docstr>
      </property>
      <property name="MouseCapture">
        <docstr>Specifies whether the control has &quot;captured&quot; mouse events.
Use MouseCapture to determine whether a control has captured the mouse. When a control captures the mouse, all subsequent mouse events go to that control until the user releases the mouse button.
A control captures the mouse when the user drags an item from it. In addition, if the control has the csCaptureMouse flag set in its ControlStyle property, it captures the mouse when the user presses the left mouse button over it, until the user releases the mouse button.</docstr>
      </property>
      <property name="ParentBiDiMode">
        <docstr>Specifies whether the control uses its parent&apos;s BiDiMode.
Use ParentBiDiMode to get or set whether the control uses its parent&apos;s BiDiMode. When ParentBiDiMode is true, the control&apos;s BiDiMode property is always equal to that of its parent. If ParentBiDiMode is false, the control uses its own BiDiMode property.
Set ParentBiDiMode to true for all controls in a form to ensure that the entire user interface adjusts to Middle Eastern locales in a uniform manner.
When the value of the control&apos;s BiDiMode property changes, ParentBiDiMode becomes false automatically.</docstr>
      </property>
      <property name="ParentColor">
        <docstr>Specifies where a control looks for its color information.
To have a control use the same color as its parent control, set ParentColor to True. If ParentColor is False, the control uses its own Color property.
Set ParentColor to True for all controls to ensure that all the controls on a form have a uniform appearance. For example, if ParentColor is True for all controls in a form, changing the background color of the form to gray causes all the controls on the form to also have a gray background.
When the value of a control&apos;s Color property changes, ParentColor becomes False automatically.</docstr>
      </property>
      <property name="ParentFont">
        <docstr>Specifies where a control looks for its font information.
To have a control use the same font as its parent control, set ParentFont to true. If ParentFont is false, the control uses its own Font property. Many controls default ParentFont to true so that all the controls in a form or other container present a uniform appearance. When the value of a control&apos;s Font property changes, ParentFont becomes false automatically.
When ParentFont is true for a form, the form uses the default font. Currently, the default font is Tahoma 8 pt.</docstr>
      </property>
      <property name="ParentShowHint">
        <docstr>Specifies where a control looks to find out if its Help Hint should be shown.
Use ParentShowHint to ensure that all the controls on a form either uniformly show their Help Hints or uniformly do not show them. 
If ParentShowHint is True, the control uses the ShowHint property value of its parent. If ParentShowHint is False, the control uses the value of its own ShowHint property.
To provide Help Hints only for selected controls on a form, set the ShowHint property for those controls that should have Help Hints to True, and ParentShowHint becomes False automatically.

Note:  Enable or disable all Help Hints for the entire application using the ShowHint property of the application object.</docstr>
      </property>
      <property name="PopupMenu">
        <docstr>Specifies the pop-up menu associated with the control.
Assign a value to PopupMenu to make a pop-up menu appear when the user selects the control and clicks the right mouse button. If the TPopupMenu&apos;s AutoPopup property is True, the pop-up menu appears automatically. If the menu&apos;s AutoPopup property is False, display the menu with a call to its Popup method from the control&apos;s OnContextPopup event handler.</docstr>
      </property>
      <property name="ScalingFlags">
        <docstr>Reflects which attributes of the control have been scaled.
ScalingFlags is an internal set of flags used primarily in scaling inherited forms and their controls. Applications should not use this property without a serious need. 
These are the flags and their meanings:





Flag

Meaning



sfLeft



Left side of control not yet scaled




sfTop



Top of control not yet scaled




sfWidth



Width of control not yet scaled




sfHeight



Height of control not yet scaled




sfFont



Font of control not yet scaled




sfDesignSize



Design-time dimensions of control not yet scaled</docstr>
      </property>
      <property name="Text">
        <docstr>Contains a text string associated with the control.
Use the Text property to read the Text of the control or to specify a new string for the Text value. By default, Text is the control name. For edit controls and memos, the Text appears within the control. For combo boxes, the Text is the content of the edit control portion of the combo box. 

Note:  Controls that display text use either the Caption property or the Text property to specify the text value. Which property is used depends on the type of control. In general, Caption is used for text that appears as a window title or label, while Text is used for text that appears as the content of a control.</docstr>
      </property>
      <property name="WheelAccumulator">
        <docstr>Accumulates mouse wheel rotations.
WheelAccumulator contains a value indicating the progress of event handlers in response to mouse wheel motion. See DoMouseWheel for more information.</docstr>
      </property>
      <property name="Color">
        <docstr>Specifies the background color of the control.
Use Color to read or change the background color of the control.
If a control&apos;s Vcl.Controls.TControl.ParentColor property is True, then changing the Color property of the control&apos;s parent automatically changes the Color property of the control. When the value of the Color property is changed, the control&apos;s ParentColor property is automatically set to False.
The Color of a TLabel is always the color of the background unless you set TLabel.Transparent to False.</docstr>
      </property>
      <property name="Font">
        <docstr>Specifies the attributes of text written on or in the control.
To change to a new font, specify a new TFont object. To modify a font, change the value of the Charset, Color, Height, Name , Pitch, Size, or Style of the TFont object.

Note: Changing the font color of the Caption is not supported for some controls (such as TButton). In most cases, there is an alternate control you can use whose Font property will change the color of the caption or text (such as TBitBtn or TSpeedButton).</docstr>
      </property>
      <property name="IScaling">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="WindowText">
        <docstr>Specifies the text string of the control.
Use WindowText to specify the text associated with the control. When setting WindowText, the control frees the memory associated with the previous value of WindowText before assigning a new value. Any memory associated with WindowText is freed when the control is destroyed. By default, WindowText is the same string as the Text property. Descendants of TControl can override the Text property to implement a different value.
For an edit box, the WindowText is the content of the control. For a combo box, the text string is the content of the edit box part of the combo box. For a button, the string is the button name. For all other controls, the string is the window title.</docstr>
      </property>
      <event name="OnCanResize">
        <docstr>Occurs when an attempt is made to resize the control.
Use OnCanResize to adjust the way a control is resized. If necessary, change the new width and height of the control in the OnCanResize event handler. The OnCanResize event handler also allows applications to indicate that the entire resize should be aborted.
If there is no OnCanResize event handler, or if the OnCanResize event handler indicates that the resize attempt can proceed, the OnCanResize event is followed immediately by an OnConstrainedResize event.
OnCanResize is an event handler of type Vcl.Controls.TCanResizeEvent.</docstr>
      </event>
      <event name="OnClick">
        <docstr>Occurs when the user clicks the control.
Use the OnClick event handler to respond when the user clicks the control. If the control has an associated action, and that action has an OnExecute method, the action&apos;s OnExecute method responds to click events unless it is superseded by an OnClick event handler.
Usually, OnClick occurs when the user presses and releases the left mouse button with the mouse pointer over the control. This event can also occur when:

The user selects an item in a grid, outline, list, or combo box by pressing an arrow key.
The user presses the SPACEBAR while a button or check box has focus.
The user presses ENTER when the active form has a default button (specified by the Default property).
The user presses ESC when the active form has a cancel button (specified by the Cancel property).
The user presses the accelerator key for a button or check box. For example, if the value of the Caption property of a check box is &apos;&amp;Bold&apos;, the B is underlined at run time and the OnClick event of the check box is triggered when the user presses Alt+B. However, focus does not move to the control in these instances.
The Checked property of a radio button is set to True.
The value of the Checked property of a check box is changed.
Note: When you change the value of the Checked property programmatically, the OnClick event of the check box control occurs. Do not modify the value of the Checked property in the event handler of the OnClick event, because that leads into a deadlock situation.
The Click method of a menu item is called.
For a form, an OnClick event occurs when the user clicks a disabled component or in a blank area of the form.
OnClick is an event handler of type TNotifyEvent.</docstr>
      </event>
      <event name="OnConstrainedResize">
        <docstr>Adjusts the resize constraints.
Use OnConstrainedResize to adjust a control&apos;s constraints when an attempt is made to resize it. Upon entry to the OnConstrainedResize event handler, the parameters of the event handler are set to the corresponding properties of the control&apos;s Constraints object. The event handler can adjust those values before they are applied to the new height and width that are being applied to the control. (The CanAutoSize method or an OnCanResize event handler may already have adjusted this new height and width).
On exit from the OnConstrainedResize event handler, the constraints are applied to the attempted new height and width. Once the constraints are applied, the control&apos;s height and width are changed. After the control&apos;s height and width change, an OnResize event occurs to allow any final adjustments or responses.

Note: The OnConstrainedResize handler is called immediately after the OnCanResize handler.
OnConstrainedResize is an event handler of type Vcl.Controls.TConstrainedResizeEvent.</docstr>
      </event>
      <event name="OnContextPopup">
        <docstr>Occurs when the user right-clicks the control or otherwise invokes the pop-up menu (such as using the keyboard).
The OnContextPopup event handler is called when the user utilizes the mouse or keyboard to request a pop-up menu. The OnContextPopup event is generated by a WM_CONTEXTMENU message, which is itself generated by the user clicking the right mouse button or by pressing SHIFT+F10 or the Applications key. 
This event is especially useful when the control does not have an associated pop-up menu (the PopupMenu property is not set) or if the AutoPopup property of the control&apos;s associated pop-up menu is False. However, the OnContextPopup can also be used to override the automatic context menu that appears when the control has an associated pop-up menu with an AutoPopup property of True. In this last case, if the event handler displays its own menu, it should set the Handled parameter to True to suppress the default context menu.
The handler&apos;s MousePos parameter indicates the position of the mouse, in client coordinates. If the event was not generated by a mouse click, MousePos is (-1,-1).

Note: Parent controls receive an OnContextPopup event before their child controls. In addition, for many child controls, the default window procedure causes the parent control to receive an OnContextPopup event after the child control. As a result, when parent controls do not set Handled to True in an OnContextPopup event handler, the event handler may be called multiple times for each context menu invocation.
OnContextPopup is an event handler of type Vcl.Controls.TContextPopupEvent.</docstr>
      </event>
      <event name="OnDblClick">
        <docstr>Occurs when the user double-clicks the left mouse button when the mouse pointer is over the control.
Use the OnDblClick event to respond to mouse double-clicks.
OnDblClick is an event handler of type System.Classes.TNotifyEvent.</docstr>
      </event>
      <event name="OnDragDrop">
        <docstr>Occurs when the user drops an object being dragged.
Use the OnDragDrop event handler to specify what happens when the user drops an object. The Source parameter of the OnDragDrop event is the object being dropped, and the Sender is the control on which the object is being dropped. The X and Y parameters are the coordinates of the mouse positioned over the control.
OnDragDrop is an event handler of type TDragDropEvent.</docstr>
      </event>
      <event name="OnDragOver">
        <docstr>Occurs when the user drags an object over a control.
Use an OnDragOver event to signal that the control can accept a dragged object so the user can drop or dock it.
Within the OnDragOver event handler, change the Accept parameter to False to reject the dragged object. Leave Accept as True to allow the user to drop or dock the dragged object on the control.
To change the shape of the cursor, indicating that the control can accept the dragged object, change the value of the DragCursor property for the control before the OnDragOver event occurs. 
The Source is the object being dragged, the Sender is the potential drop or dock site, and X and Y are screen coordinates in pixels. The State parameter specifies how the dragged object is moving over the control.

Note: Within the OnDragOver event handler, the Accept parameter defaults to True. However, if an OnDragOver event handler is not supplied, the control rejects the dragged object, as if the Accept parameter were changed to False.
OnDragOver is an event handler of type TDragOverEvent.</docstr>
      </event>
      <event name="OnEndDock">
        <docstr>Occurs when the dragging of an object ends, either by docking the object or by canceling the dragging.
Use OnEndDock to specify actions or special processing that happen when a drag-and-dock operation stops.</docstr>
      </event>
      <event name="OnEndDrag">
        <docstr>Occurs when the dragging of an object ends, either by dropping the object or by canceling the dragging.
Use the OnEndDrag event handler to specify any special processing that occurs when dragging stops. 
OnEndDrag is an event handler of type Vcl.Controls.TEndDragEvent.</docstr>
      </event>
      <event name="OnMouseActivate">
        <docstr>Occurs when the user presses a mouse button with the mouse pointer over a control and the parent form is not active.
Use the OnMouseActivate event handler to implement any special processing that should occur as a result of pressing a mouse button on a control when the parent top-level form is not active.
The event type is:

TMouseActivateEvent = procedure (Sender: TObject; Button: TMouseButton; ShiftState: TShiftState;
X, Y: Integer; HitTest: Integer; var MouseActivate: TMouseActivate) of object;

When you click a control and the parent top-level form is not active, this event fires on the control that the mouse cursor is over. MouseActivate is a protected virtual function in TControl. MouseActivate can be overridden in custom control descendants to provide special built-in processing of the OnMouseActivate events. If you leave the default value of MouseActivate as maDefault, the parent control fires the OnMouseActivate event and repeats the process all the way up to the top-level form. If no control in the chain sets the value of MouseActivate, the behavior is the same as if a control set TMouseActivate to maActivate. At any point, a control can set the value of TMouseActivate and the parent processing stops. 
Some controls set focus to themselves when they get a button down message so, in some cases, setting maNoActivate appears to have no effect. For instance, a TButton control sets focus to itself in the WM_LBUTTONDOWN message regardless of whether or not TMouseActivate is set to maNoActivate. In this case, setting maNoActivateAndEat will work because the top-level form is not activated and the WM_LBUTTONDOWN message is suppressed. 
The HitTest parameter is the hit test value obtained from the WM_NCHITTEST message. See Windows.pas for valid values and their meanings. In most cases this value will be HTCLIENT, which means that the user clicked in the client area of a control. However, in the case of a top-level form, this can take other values such as HTCAPTION or HTBOTTOM. This allows the code to decide which value to set for MouseActivate, based on the HitTest code. For example, the following code in the OnMouseActivate event handler for a TForm forces the user to click into a non-client area to activate the form: 

if HitTest = HTCLIENT then
MouseActivate := maNoActivateAndEat;

Even though this event is tied to how Windows processes WM_MOUSEACTIVATE, the actual handling of the message is done at the TControl level, which is the point in the VCL hierarchy where the control has no window handle. The OnMouseActivate event is then simulated because all the TControl descendants also have OnMouseDown, OnMouseMove, and OnMouseUp events. This information is applicable to both VCL Win32 and VCL.NET.</docstr>
      </event>
      <event name="OnMouseDown">
        <docstr>Occurs when the user presses a mouse button with the mouse pointer over a control.
Use the OnMouseDown event handler to implement any special processing that should occur as a result of pressing a mouse button.
The OnMouseDown event handler can respond to left, right, or center mouse button presses and shift key plus mouse-button combinations. Shift keys are the SHIFT, CTRL, and ALT keys. X and Y are the pixel coordinates of the mouse pointer in the client area of the Sender.
OnMouseDown is an event handler of type Vcl.Controls.TMouseEvent.</docstr>
      </event>
      <event name="OnMouseEnter">
        <docstr>Occurs when the user moves the mouse into a control.
Use the OnMouseEnter event handler to implement any special processing that should occur as a result of moving the mouse into a control when the parent top-level form is not active.
OnMouseEnter is an event handler of type System.Classes.TNotifyEvent.</docstr>
      </event>
      <event name="OnMouseLeave">
        <docstr>Occurs when the user moves the mouse outside of a control.
Use the OnMouseLeave event handler to implement any special processing that should occur as a result of moving the mouse outside of a control when the parent top-level form is not active.
OnMouseLeave is an event handler of type System.Classes.TNotifyEvent.</docstr>
      </event>
      <event name="OnMouseMove">
        <docstr>Occurs when the user moves the mouse pointer while the mouse pointer is over a control.
Use the OnMouseMove event handler to respond when the mouse pointer moves after the control has captured the mouse.
Use the Shift parameter of the OnMouseMove event handler to determine the state of the shift keys and mouse buttons. Shift keys are the SHIFT, CTRL, and ALT keys or shift key-mouse button combinations. X and Y are pixel coordinates of the new location of the mouse pointer in the client area of the Sender.
OnMouseMove is an event handler of type Vcl.Controls.TMouseMoveEvent.</docstr>
      </event>
      <event name="OnMouseUp">
        <docstr>Occurs when the user releases a mouse button that was pressed with the mouse pointer over a component.
Use an OnMouseUp event handler to implement special processing when the user releases a mouse button.
The OnMouseUp event handler can respond to left, right, or center mouse button presses and shift key plus mouse-button combinations. Shift keys are the SHIFT, CTRL, and ALT keys. X and Y are the pixel coordinates of the mouse pointer in the client area of the Sender.
OnMouseUp is an event handler of type Vcl.Controls.TMouseEvent.</docstr>
      </event>
      <event name="OnMouseWheel">
        <docstr>Occurs when the mouse wheel is rotated.
Write code in the OnMouseWheel event handler to respond to mouse wheel messages. If there is no OnMouseWheel event handler, or if the mouse wheel message is not handled in the OnMouseWheel event handler, then an OnMouseWheelUp or OnMouseWheelDown event occurs, depending on the direction the mouse wheel was rotated.
OnMouseWheel is an event handler of type Vcl.Controls.TMouseWheelEvent.</docstr>
      </event>
      <event name="OnMouseWheelDown">
        <docstr>Occurs when the mouse wheel is rotated downward.
Write code in the OnMouseWheelDown event handler to perform actions when the mouse wheel is rotated downward. OnMouseWheelDown occurs only if the message is not already handled in an OnMouseWheel event handler.
OnMouseWheelDown is an event handler of type Vcl.Controls.TMouseWheelUpDownEvent.</docstr>
      </event>
      <event name="OnMouseWheelUp">
        <docstr>Occurs when the mouse wheel is rotated upward.
Write code in the OnMouseWheelUp event handler to perform actions when the mouse wheel is rotated upward. OnMouseWheelUp occurs only if the message is not already handled in an OnMouseWheel event handler.
OnMouseWheelUp is an event handler of type Vcl.Controls.TMouseWheelUpDownEvent.</docstr>
      </event>
      <event name="OnResize">
        <docstr>Occurs immediately after the control is resized.
Use OnResize to make any final adjustments after a control is resized.
To modify the way a control responds when an attempt is made to resize it, use OnCanResize or OnConstrainedResize.

Note: Some controls call this event handler when the control is first created.
OnResize is an event handler of type System.Classes.TNotifyEvent.</docstr>
      </event>
      <event name="OnStartDock">
        <docstr>Occurs when the user begins to drag a control with a DragKind of dkDock.
Use the OnStartDock event handler to implement special processing when the user starts a drag-and-dock operation by dragging the control.
The OnStartDock event handler can create a TDragDockObjectEx object for the DragObject parameter to specify the appearance of the dragging rectangle and how the dragged control interacts with potential docking sites. If you return TDragDockObjectEx as the drag object, there is no need to call the Free method for the DragObject when dragging is over. If you use TDragDockObject, your application is responsible for freeing the drag object.
If the OnStartDock event handler sets the DragObject parameter to nil (Delphi) or NULL (C++), a TDragDockObject object is automatically created.

Note: This information applies to Win32 applications only.
OnStartDock is an event handler of type TStartDockEvent.</docstr>
      </event>
      <event name="OnStartDrag">
        <docstr>Occurs when the user begins to drag the control or an object it contains by left-clicking the control and holding the mouse button down.
Use the OnStartDrag event handler to implement special processing when the user starts to drag the control or an object it contains. OnStartDrag only occurs if DragKind is dkDrag.
Sender is the control that is about to be dragged, or that contains the object about to be dragged.
The OnStartDrag event handler can create a TDragControlObjectEx instance for the DragObject parameter to specify the drag cursor, or, optionally, a drag image list. If you create a TDragControlObjectEx instance, there is no need to call the Free method for the DragObject when dragging is over. If you create, instead, a TDragControlObject instance, your application is responsible for freeing the drag object instance.
If the OnStartDrag event handler sets the DragObject parameter to nil (Delphi) or NULL (C++), a TDragControlObject object is automatically created and dragging begins on the control itself.

Note: On some controls, such as TRichEdit, the underlying Windows control handles internal drag operations. For these controls, there are no OnStartDrag or OnEndDrag events for drag operations within the control.
OnStartDrag is an event handler of type TStartDragEvent.</docstr>
      </event>
      <constructor name="Create">
        <docstr>Creates an instance of TControl.
Calling Create constructs and initializes an instance of TControl. However, you should never attempt to instantiate a TControl. This class is intended solely as a base class from which other control classes descend and you should only call Create to instantiate one of these descendants.
Create calls the parent constructor and initializes the control. 
When overriding Create, always call the inherited Create method first, then proceed with the control&apos;s initialization. Remember to specify the override directive when overriding the Create method.

Note:  If a control&apos;s constructor allocates resources or memory, also override the destructor to free those resources.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys an instance of TControl.
Do not call Destroy directly in an application. Instead, call Free. Free verifies that the control is not nil, and only then calls Destroy.
Applications should only free controls explicitly when the constructor was called without assigning an owner to the control.
As the control is destroyed, it:

Frees the TFont object in its Font property.
Calls its inherited destructor.
Override Destroy to free any memory or resources allocated in the Create method. When declaring a Destroy method in a descendent control type, always add the override directive to the declaration and call the inherited Destroy as the last statement in the redeclared method.
When a control is created, Delphi automatically provides exception handling around the constructor call. The destructor is called if an exception escapes from the constructor. This means that the destructor code must be prepared to clean up a partially constructed instance. Check all data fields for zero before disposing of their contents.</docstr>
      </destructor>
      <procedure name="CheckNonMainThreadUsage">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="IsCustomStyleActive">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="IsLightStyleColor">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="ScaleForPPI">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="BeginDrag">
        <docstr>Starts the dragging of a control.
Call BeginDrag to start a drag operation. BeginDrag is called in application code only when the value of the control&apos;s DragMode is dmManual. If DragMode is dmAutomatic, BeginDrag is called automatically.
If the Immediate parameter is true, the mouse pointer changes to the value of the DragCursor property and dragging begins immediately. If Immediate is false, the mouse pointer does not change to the value of the DragCursor property and dragging does not begin until the user moves the mouse pointer the number of pixels specified by the Threshold parameter. If the caller passes a Threshold value less than 0 (such as the default value for this parameter), BeginDrag uses the DragThreshold property of the global Mouse variable.
Setting Immediate to false allows the control to accept mouse clicks without beginning a drag-and-drop or drag-and-dock operation.</docstr>
      </procedure>
      <procedure name="BringToFront">
        <docstr>Puts the control in front of all other controls in its parent control.
Call BringToFront to ensure that a form is visible or to reorder overlapping controls within a form.
Note that controls that wrap Windows screen objects (control classes descended from TWinControl) always &quot;stack&quot; above lightweight controls (control classes descended from TGraphicControl). BringToFront can force a lightweight control, such as a Shape, to stack above other lightweight controls, but wrapped controls, such as an Edit, will still stack above the Shape.
Without BringToFront, controls are stacked in the order they were placed on the form.</docstr>
      </procedure>
      <function name="ClientToScreen">
        <docstr>Translates a given point from client area coordinates to global screen coordinates.
Use ClientToScreen to convert a point whose coordinates are expressed locally to the control to the corresponding point in screen coordinates. In client area coordinates, (0, 0) corresponds to the upper-left corner of the control&apos;s client area. In screen coordinates, (0, 0) corresponds to the upper-left corner of the screen.
Use ScreenToClient along with ClientToScreen to convert from one control&apos;s coordinate system to another control&apos;s coordinate system. For example, 

P�:= TargetControl.ScreenToClient(SourceControl.ClientToScreen(P));

P = TargetControl-&gt;ScreenToClient(SourceControl-&gt;ClientToScreen(P));

converts P from coordinates in SourceControl to coordinates in TargetControl.</docstr>
      </function>
      <function name="ClientToScreen">
        <docstr>Translates a given point from client area coordinates to global screen coordinates.
Use ClientToScreen to convert a point whose coordinates are expressed locally to the control to the corresponding point in screen coordinates. In client area coordinates, (0, 0) corresponds to the upper-left corner of the control&apos;s client area. In screen coordinates, (0, 0) corresponds to the upper-left corner of the screen.
Use ScreenToClient along with ClientToScreen to convert from one control&apos;s coordinate system to another control&apos;s coordinate system. For example, 

P�:= TargetControl.ScreenToClient(SourceControl.ClientToScreen(P));

P = TargetControl-&gt;ScreenToClient(SourceControl-&gt;ClientToScreen(P));

converts P from coordinates in SourceControl to coordinates in TargetControl.</docstr>
      </function>
      <function name="ClientToParent">
        <docstr>Translates client coordinates to parent coordinates.
ClientToParent translates Point from the current control&apos;s coordinate system to AParent&apos;s coordinate system. AParent must be a control that can be found by iterating up the chain of Parent properties. If AParent is nil (Delphi) or NULL (C++), the control&apos;s immediate parent is used.
An EInvalidOperation exception is thrown if AParent is not an ancestor control or the Parent property is nil (Delphi) or NULL (C++).</docstr>
      </function>
      <procedure name="Dock">
        <docstr>Used internally to dock the control.
Do not call Dock in applications. It is called automatically to implement many of the details of docking the control to a dock site.
To dock the control programmatically, use ManualDock instead.
The NewDockSite parameter specifies the docking site to which the control is being docked. The ARect parameter indicates the new dimensions of the control when it is docked to NewDockSite.</docstr>
      </procedure>
      <function name="Dragging">
        <docstr>Indicates whether a control is being dragged.
Use Dragging to determine the drag state of the control. If Dragging returns true, the control is being dragged. If Dragging is false, the control is not being dragged.</docstr>
      </function>
      <procedure name="DragDrop">
        <docstr>Is an OnDragDrop event dispatcher.
When creating a component that descends from TControl, override DragDrop to add additional code that executes before the OnDragDrop event handler is called.
The Source parameter is the object that was dropped onto the control. The X and Y parameters are the mouse coordinates where the object was dropped.</docstr>
      </procedure>
      <function name="DrawTextBiDiModeFlags">
        <docstr>Returns the text flags that reflect the current setting of the BiDiMode property.
Call DrawTextBiDiModeFlags to obtain a value for the TextFlags property of a canvas when drawing the control&apos;s text or caption. The return value can also be used with the Windows API DrawText function.
Flags are the current text flags, unaltered by any bidirectional mode considerations.
DrawTextBiDiModeFlags adds or removes the DT_RIGHT or DT_RTLREADING flags based on the values returned from the UseRightToLeftAlignment and UseRightToLeftReading methods.</docstr>
      </function>
      <function name="DrawTextBiDiModeFlagsReadingOnly">
        <docstr>Returns the text flag to add that indicates whether the control&apos;s text should read from right to left.
Call DrawTextBiDiModeFlagsReadingOnly to determine whether the DT_RTLREADING flag should be added when calling the Windows API DrawText or when assigning the TextFlags property of a canvas.
DrawTextBiDiModeFlagsReadingOnly returns the DT_RTLREADING flag or 0, depending on the value returned from the UseRightToLeftReading method.
To obtain the text flags that indicate the bidirectional alignment as well as text direction for the control, use DrawTextBiDiModeFlags instead.</docstr>
      </function>
      <property name="Enabled">
        <docstr>Controls whether the control responds to mouse, keyboard, and timer events.
Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
To re-enable a control, set Enabled to True.

Note: This property applies to all TControl descendants.</docstr>
      </property>
      <procedure name="EndDrag">
        <docstr>Stops a control from being dragged any further.
Use EndDrag to stop a dragging operation that began with a call to the BeginDrag method.
If the Drop parameter is true, the control being dragged is dropped or docked. If the Drop parameter is false, the control is not dropped or docked and dragging is canceled.</docstr>
      </procedure>
      <function name="GetControlsAlignment">
        <docstr>Indicates how text is aligned within the control.
Use GetControlsAlignment to determine the alignment of the control. For controls that do not have an Alignment property, GetControlsAlignment returns taLeftJustify.

Note: GetControlsAlignment returns the alignment of text before it is altered by the BiDiMode property. To check whether the alignment should be reversed to reflect the BiDiMode property, call UseRightToLeftAlignment.</docstr>
      </function>
      <function name="GetParentComponent">
        <docstr>Returns the parent of the control.
GetParentComponent is called by the streaming system that loads and saves VCL components. The component returned by GetParentComponent is responsible for loading and saving the control when it is streamed in or out. As implemented in TControl, GetParentComponent returns the value of the Parent property.</docstr>
      </function>
      <function name="HasParent">
        <docstr>Indicates whether the control has a parent.
HasParent indicates whether the Parent property has been assigned a value. This method is used by the streaming system to determine whether the control has a parent that is responsible for writing it to a stream. As implemented in TControl, HasParent returns true if the Parent property is not nil (Delphi) or NULL (C++), and false otherwise.</docstr>
      </function>
      <procedure name="Hide">
        <docstr>Makes the control invisible.
Call Hide to hide a control. Hide sets the Visible property of the control to false.
Although a control that is hidden is not visible, its properties and methods are still available.</docstr>
      </procedure>
      <procedure name="InitiateAction">
        <docstr>Calls the action link&apos;s Update method if the control is associated with an action link.
When the application is idle, the library makes a series of calls to allow controls to update their associated actions so that they reflect the current properties of the controls. The first of these is to the InitiateAction method of the each form, followed by the InitiateAction methods of its visible menus and controls.
InitiateAction calls the action&apos;s update method indirectly (through its action link), which leads to a number of events, any of which may update the action and stop the update process:

First, the action list that contains the action receives an OnUpdate event.
If the action list does not handle the OnUpdate event, then the Application object receives an OnActionUpdate event.
If the OnActionUpdate event handler does not update the action, the action itself receives an OnUpdate event.
If that does not update the action, the active control&apos;s UpdateAction method is called.
Finally, if the action is still not updated, the active form&apos;s UpdateAction method is called.</docstr>
      </procedure>
      <procedure name="Invalidate">
        <docstr>Completely repaints the control.
Use Invalidate when the entire control needs to be repainted. When more than one region within the control needs repainting, Invalidate will cause the entire window to be repainted in a single pass, avoiding flicker caused by redundant repaints. There is no performance penalty for calling Invalidate multiple times before the control is actually repainted.</docstr>
      </procedure>
      <procedure name="MouseWheelHandler">
        <docstr>Dispatches messages received from a mouse wheel.
The WndProc method calls MouseWheelHandler when it receives a mouse wheel message. MouseWheelHandler checks whether the windowed control is embedded in a form, and if so, calls the form&apos;s MouseWheelHandler method. This allows the form to respond to mouse wheel messages before they are handled by individual controls. If the windowed control is not in a form, MouseWheelHandler passes the mouse wheel message to the Perform method, which generates an OnMouseWheel event, followed (if necessary) by an OnMouseWheelUp or OnMouseWheelDown event.</docstr>
      </procedure>
      <function name="IsRightToLeft">
        <docstr>Indicates whether the control should be reversed right to left.
Use IsRightToLeft to determine whether the control should be reversed in any way because it is running on a system with a Middle Eastern locale. IsRightToLeft is intended for component writers to ease the process of implementing the BiDiMode property.
IsRightToLeft returns true if the application is running on a Middle East-enabled version of Windows and the BiDiMode property indicates that the control should make any adjustments.</docstr>
      </function>
      <function name="ManualDock">
        <docstr>Docks the control.
Use ManualDock to dock the control programmatically. ManualDock undocks the control from its current dock site, then docks the control to its new dock site.
NewDockSite is the control&apos;s new dock site.
DropControl is the control in the new dock site, if any, on which to drop the control. For example, when docking to a page control, DropControl would be a tab sheet.
ControlSide specifies on which side of DropControl or NewDockSite (if DropControl is nil (Delphi) or NULL (C++)) the control should be docked. This value can be obtained by calling the dock site&apos;s GetDockEdge method.</docstr>
      </function>
      <function name="ManualFloat">
        <docstr>Undocks the control.
Use ManualFloat to undock the control programmatically.
ScreenPos is the rectangle in which the control is displayed when it starts floating.</docstr>
      </function>
      <function name="Perform">
        <docstr>Responds as if the control received a specified Windows message.
Call Perform to bypass the Windows message queue and send a message directly to the control&apos;s window procedure.
Perform fills a message record (of type TMessage) with the message ID passed in the Msg parameter, the message parameters passed in WParam and LParam, and a result field of zero. Perform then passes the message record to the WindowProc method for processing.</docstr>
      </function>
      <procedure name="Refresh">
        <docstr>Repaints the control on the screen.
Call the Refresh method to repaint the control immediately. Refresh calls the Repaint method. Use the Refresh and Repaint methods interchangeably.</docstr>
      </procedure>
      <procedure name="Repaint">
        <docstr>Forces the control to repaint its image on the screen.
Call Repaint to force the control to repaint its image immediately. If the ControlStyle property includes csOpaque, the control paints itself directly. Otherwise, the Repaint method calls the Invalidate method and then the Update method so that any visible portions of controls beneath the control will be repainted as well.</docstr>
      </procedure>
      <function name="ReplaceDockedControl">
        <docstr>Docks the control in the place where another control is already docked.
Call ReplaceDockedControl to replace a control that is already docked while moving that control to another dock site.
Control is the control whose place this control is taking.
NewDockSite is the new dock site for the control that is replaced.
DropControl is a control in the new dock site on which to drop the control that is replaced. For example, if NewDockSite were a page control, DropControl would be a tab sheet.
ControlSide specifies on which side of DropControl or NewDockSite (if DropControl is nil (Delphi) or NULL (C++)) the replaced control should be docked. This value can be obtained by calling the dock site&apos;s GetDockEdge method.
ReplaceDockedControl does the same thing as calling the ManualDock method of the control specified by the Control parameter (using the values of NewDockSite, DropControl, and ControlSide) in addition to calling ManualDock for the control whose method this is, docking it in the current position of the Control parameter. However, calling ReplaceDockedControl is more efficient, and prevents unnecessary flicker.</docstr>
      </function>
      <function name="ScreenToClient">
        <docstr>Converts the screen coordinates of a specified point on the screen to client coordinates.
Use ScreenToClient to convert a point in screen coordinates to local, or client area, coordinates. In client area coordinates (0, 0) corresponds to the upper-left corner of the control&apos;s client area. In screen coordinates (0, 0) corresponds to the upper-left corner of the screen.
Use ScreenToClient along with ClientToScreen to convert from one control&apos;s coordinate system to another control&apos;s coordinate system. For example, 



P := TargetControl.ScreenToClient(SourceControl.ClientToScreen(P));




P = TargetControl-&gt;ScreenToClient(SourceControl-&gt;ClientToScreen(P));



converts P from coordinates in SourceControl to coordinates in TargetControl.</docstr>
      </function>
      <function name="ScreenToClient">
        <docstr>Converts the screen coordinates of a specified point on the screen to client coordinates.
Use ScreenToClient to convert a point in screen coordinates to local, or client area, coordinates. In client area coordinates (0, 0) corresponds to the upper-left corner of the control&apos;s client area. In screen coordinates (0, 0) corresponds to the upper-left corner of the screen.
Use ScreenToClient along with ClientToScreen to convert from one control&apos;s coordinate system to another control&apos;s coordinate system. For example, 



P := TargetControl.ScreenToClient(SourceControl.ClientToScreen(P));




P = TargetControl-&gt;ScreenToClient(SourceControl-&gt;ClientToScreen(P));



converts P from coordinates in SourceControl to coordinates in TargetControl.</docstr>
      </function>
      <function name="ParentToClient">
        <docstr>Translate parent coordinates to client coordinates.
ParentToClient translates Point from the AParent&apos;s coordinate system to the current control&apos;s coordinate system. AParent must be a control that can be found by iterating up the chain of Parent properties. If AParent is nil (Delphi) or NULL (C++), the control&apos;s immediate parent is used.
An EInvalidOperation exception is thrown if AParent is not an ancestor control or the Parent property is nil (Delphi) or NULL (C++).</docstr>
      </function>
      <procedure name="SendToBack">
        <docstr>Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls.
Use SendToBack to change the order of overlapping controls or forms.
The order in which controls stack on top of each other (also called the Z order) depends on the order the controls are placed on the form. For example, if you put a label and an image on a form so that one is on top of the other, the one that was placed first on the form becomes the one on the bottom. Because both the label and the image are non-windowed controls, they &quot;stack&quot; as you would expect them to. Call the SendToBack method for the top object to move it below the other object.
The stacking order of two windowed controls is the same as the stacking of two non-windowed controls. For example, if you put a memo on a form, then put a check box on top of it, the check box remains on top. Calling SendToBack for the check box makes the memo appear on top.
The stacking order of windowed and non-windowed controls cannot be mingled. For example, if you put a memo, a windowed control on a form, and then put a label, a non-windowed control on top of it, the label disappears behind the memo. Windowed controls always stack on top of non-windowed controls. In this example, calling the SendToBack method of the memo does nothing, the label remains behind the memo.
If the control has the input focus when the SendToBack method executes, it loses the input focus.</docstr>
      </procedure>
      <procedure name="SetBounds">
        <docstr>Sets the Left, Top, Width, and Height properties all at once.
Use SetBounds to change all of the component&apos;s boundary properties at one time. The same effect can be achieved by setting the Left, Top, Width, and Height properties separately, but SetBounds changes all four properties at once ensuring that the control will not repaint between changes.
Specify the values for the Left, Top, Width, and Height properties as the value of the ALeft, ATop, AWidth, and AHeight parameters, respectively.
Calling SetBounds does not necessarily result in the Left, Top, Width, and Height properties changing to the specified values. Before the properties are changed, the AutoSize or Constraints property may limit the changes, and an OnCanResize (or OnConstrainedResize) event handler may change the new values. After the control&apos;s Left, Top, Width, and Height properties are changed, SetBounds generates an OnResize event.

Note:  Component writers can change the Left, Top, Width, and Height properties while bypassing all resize events and constraint or autosize logic by using the UpdateBoundsRect method instead.</docstr>
      </procedure>
      <procedure name="SetDesignVisible">
        <docstr>Makes a control visible at design time.
SetDesignVisible is used internally by Delphi during form design.</docstr>
      </procedure>
      <procedure name="SetParentComponent">
        <docstr>Sets the parent for the control.
Do not call the SetParentComponent method. It is used by the streaming system that loads and saves VCL components. SetParentComponent makes the component specified by the Value parameter the parent of the control.
SetParentComponent calls the SetParent method only if the component specified as the parent is a windowed control.</docstr>
      </procedure>
      <procedure name="Show">
        <docstr>Makes a control visible.
Use the Show method to make visible a control that was previously hidden. 
The Show method sets the control&apos;s Visible property to true and ensures that the parent control is also visible.</docstr>
      </procedure>
      <procedure name="Update">
        <docstr>Processes any pending paint messages immediately.
Call Update to force the control to be repainted before any more, possibly time-consuming, processing takes place. Use Update to provide immediate feedback to the user that cannot wait for the Windows paint message to arrive.
Update does not invalidate the control, but simply forces a repaint of any regions that have already been invalidated. Call Repaint instead to invalidate the control as well.</docstr>
      </procedure>
      <function name="UseRightToLeftAlignment">
        <docstr>Specifies whether the control&apos;s alignment should be reversed right-to-left.
Controls call UseRightToLeftAlignment when implementing the BiDiMode property. UseRightToLeftAlignment indicates whether the control&apos;s alignment should be reversed right-to-left. This information can be used when painting the control or when responding to mouse events.
UseRightToLeftAlignment returns True if the application is running on a system with a Middle Eastern locale and the BiDiMode property is bdRightToLeft. Otherwise, it returns False. Descendants override UseRightToLeftAlignment if alignment in Middle Eastern locales depends on other factors.</docstr>
      </function>
      <function name="UseRightToLeftReading">
        <docstr>Specifies whether the control is using a right-to-left reading order.
Controls call UseRightToLeftReading when implementing the BiDiMode property. UseRightToLeftReading indicates whether the control&apos;s text should read from right to left. This information can be used to determine which style flags to set for the control when it is created and which flags to set for drawing text.
UseRightToLeftReading returns true if the application is running on a system with a Middle Eastern locale and the BiDiMode property is not bdLeftToRight. UseRightToLeftReading returns false otherwise.</docstr>
      </function>
      <function name="UseRightToLeftScrollBar">
        <docstr>Specifies whether the vertical scroll bar appears on the left side of the control.
Controls call UseRightToLeftScrollBar when implementing the BiDiMode property. UseRightToLeftScrollBar returns true when the vertical scroll bar appears on the left side of the control, and false when it appears on the right side.
UseRightToLeftScrollBar returns true if the application is running on a system with a Middle Eastern locale and the BiDiMode property is bdRightToLeft or bdRightToLeftNoAlign.</docstr>
      </function>
      <procedure name="DefaultHandler">
        <docstr>Provides message handling for all messages that do not have specific handlers.
Override DefaultHandler to extend the default handling of messages. DefaultHandler is the final opportunity for component writers to handle messages to controls. The method referenced by WindowProc provides the first opportunity. Individual message methods such as Click provide additional opportunities.
DefaultHandler handles the messages Windows sends to manage the control&apos;s text: WM_GETTEXT, WM_SETTEXT, and WM_GETTEXTLENGTH.</docstr>
      </procedure>
      <function name="GetTextBuf">
        <docstr>Retrieves the control&apos;s text, copies it into a buffer, and returns the number of characters copied.
Call GetTextBuf to retrieve the text of a control into a fixed size buffer. The text copied is the value of the Text property. GetTextBuf returns the number of characters that were actually copied, which is either the length of the Text property, or BufSize - 1, whichever is smaller.
To find out how many characters the buffer needs to hold the entire text, call the GetTextLen method before allocating a buffer for GetTextBuf.

Note: GetTextBuf is available for compatibility with 16-bit code. Where backward compatibility is not an issue, use the Text property.
Note:  To obtain the control&apos;s text as an AnsiString, use the Text property instead.</docstr>
      </function>
      <function name="GetTextLen">
        <docstr>Returns the length of the control&apos;s text.
Call GetTextLen to find the length of the control&apos;s text. This is the size needed for a text buffer to be used by the GetTextBuf method.</docstr>
      </function>
      <function name="Perform">
        <docstr>Responds as if the control received a specified Windows message.
Call Perform to bypass the Windows message queue and send a message directly to the control&apos;s window procedure.
Perform fills a message record (of type TMessage) with the message ID passed in the Msg parameter, the message parameters passed in WParam and LParam, and a result field of zero. Perform then passes the message record to the WindowProc method for processing.</docstr>
      </function>
      <function name="Perform">
        <docstr>Responds as if the control received a specified Windows message.
Call Perform to bypass the Windows message queue and send a message directly to the control&apos;s window procedure.
Perform fills a message record (of type TMessage) with the message ID passed in the Msg parameter, the message parameters passed in WParam and LParam, and a result field of zero. Perform then passes the message record to the WindowProc method for processing.</docstr>
      </function>
      <procedure name="SetTextBuf">
        <docstr>Sets the text of the control.
Call the SetTextBuf method to set the text of the control to the text in the specified buffer.
The text is set to the text in the buffer pointed to by the Buffer parameter. Buffer must point to a null-terminated string. The SetTextBuf method sends the WM_SETTEXT and CM_TEXTCHANGED messages. Doing this in the tight execution of a function can result in the change not being seen until messages from the Windows message queue are processed after the function finishes executing. To interrupt a function&apos;s execution and process messages, use the ProcessMessages method of the Application object.

Note:  The SetTextBuf method is provided for backwards compatibility only. To set the text of a control now, assign a string value to the Text property.</docstr>
      </procedure>
      <function name="GetSystemMetrics">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetStyleName">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="ScaleValue">
        <docstr>The overloaded ScaleValue methods return a measure passed as parameter scaled by the current scale factor for the control (the value of the ScaleFactor read-only property).</docstr>
      </function>
      <function name="ScaleValue">
        <docstr>The overloaded ScaleValue methods return a measure passed as parameter scaled by the current scale factor for the control (the value of the ScaleFactor read-only property).</docstr>
      </function>
      <function name="ScaleValue">
        <docstr>The overloaded ScaleValue methods return a measure passed as parameter scaled by the current scale factor for the control (the value of the ScaleFactor read-only property).</docstr>
      </function>
      <function name="ScaleValue">
        <docstr>The overloaded ScaleValue methods return a measure passed as parameter scaled by the current scale factor for the control (the value of the ScaleFactor read-only property).</docstr>
      </function>
      <function name="ScaleValue">
        <docstr>The overloaded ScaleValue methods return a measure passed as parameter scaled by the current scale factor for the control (the value of the ScaleFactor read-only property).</docstr>
      </function>
      <function name="ScaleRectSize">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <property name="Action">
        <docstr>Specifies the action associated with the control.
Action is the action object that is associated with the control. Actions allow an application to centralize the response to user commands. When a control is associated with an action, the action determines the appropriate properties and events of the control (such as whether the control is enabled or how it responds to an OnClick event).
To create actions at design time, place an action list component on a form or data module. Double-click the action list to bring up the action list editor. Add actions in the editor using its context menu. Once the actions have been added using the Action List editor, they appear in the drop-down list for the Action property in the Object Inspector.</docstr>
      </property>
      <property name="Align">
        <docstr>Determines how the control aligns within its container (parent control).
Use Align to align a control to the top, bottom, left, or right of a form or panel and have it remain there even if the size of the form, panel, or component that contains the control changes. When the parent is resized, an aligned control also resizes so that it continues to span the top, bottom, left, or right edge of the parent.
For example, to use a panel component with various controls on it as a tool palette, change the panel&apos;s Align value to alLeft. The value of alLeft for the Align property of the panel guarantees that the tool palette remains on the left side of the form and always equals the client height of the form.
The default value of Align is alNone, which means a control remains where it is positioned on a form or panel.

Tip: If Align is set to alClient, the control fills the entire client area so that it is impossible to select the parent form by clicking it. In this case, select the parent by selecting the control on the form and pressing ESC, or by using the Object Inspector.
Any number of child components within a single parent can have the same Align value, in which case they stack up along the edge of the parent. The child controls stack up in z-order. To adjust the order in which the controls stack up, drag the controls into their desired positions.

Note: To cause a control to maintain a specified relationship with an edge of its parent, but not necessarily lie along one edge of the parent, use the Anchors property instead.</docstr>
      </property>
      <property name="Anchors">
        <docstr>Specifies how the control is anchored to its parent.
Use Anchors to ensure that a control maintains its current position relative to an edge of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored.
If a control is anchored to opposite edges of its parent, the control stretches when its parent is resized. For example, if a control has its Anchors property set to [akLeft, akRight], the control stretches when the width of its parent changes.
Anchors is enforced only when the parent is resized. Thus, for example, if a control is anchored to opposite edges of a form at design time and the form is created in a maximized state, the control is not stretched because the form is not resized after the control is created.

Note: If a control should maintain contact with three edges of its parent (hugging one side of the parent and stretching the length of that side), use the Align property instead. Unlike Anchors, Align allows controls to adjust to changes in the size of other aligned sibling controls as well as changes to the parent&apos;s size.</docstr>
      </property>
      <property name="BiDiMode">
        <docstr>Specifies the bidirectional mode for the control.
Use BiDiMode to enable the control to adjust its appearance and behavior automatically when the application runs in a locale that reads from right to left instead of left to right. The bidirectional mode controls the reading order for the text, the placement of the vertical scroll bar, and whether the alignment is changed.
Alignment does not change for controls that are known to contain number, date, time, or currency values. For example, with data-aware controls, the alignment does not change for the following field types: ftSmallint, ftInteger, ftWord, ftFloat, ftCurrency, ftBCD, ftDate, ftTime, ftDateTime, ftAutoInc.</docstr>
      </property>
      <property name="BoundsRect">
        <docstr>Specifies the bounding rectangle of the control, expressed in the coordinate system of the parent control.
Use BoundsRect as a quick way to obtain the pixel locations of all corners of the control all at once.
For example, the statement



R := Control.BoundsRect;




R = Control-&gt;BoundsRect;



corresponds to



R.Left := Control.Left;
R.Top := Control.Top;
R.Right := Control.Left + Control.Width;
R.Bottom := Control.Top + Control.Height;




R.Left = Control-&gt;Left;
R.Top = Control-&gt;Top;
R.Right = Control-&gt;Left + Control-&gt;Width;
R.Bottom = Control-&gt;Top + Control-&gt;Height;



The origin of the pixel coordinate system is in the upper-left corner of the parent window.

Note:  A point is considered within the control&apos;s bounds rectangle if it lies on the left or top side but not if it lies on the right or bottom side. That is, to be inside the bounds rectangle, the x-coordinate must be greater than or equal to BoundsRect.Left and less than BoundsRect.Right, and the y-coordinate must be greater than or equal to BoundsRect.Top and less than BoundsRect.Bottom.</docstr>
      </property>
      <property name="ClientHeight">
        <docstr>Specifies the height of the control&apos;s client area in pixels.
Use ClientHeight to read or change the height of the control&apos;s client area.
For TControl, ClientHeight is the same as Height. Derived classes may implement a ClientHeight property that differs from Height. For example, the ClientHeight of a form is the value of the Height property minus the height of the title bar, resize border, and scroll bars.</docstr>
      </property>
      <property name="ClientOrigin">
        <docstr>Specifies the screen coordinates (in pixels) of the upper-left corner of a control&apos;s client area.
Read ClientOrigin to locate the upper-left corner of the control&apos;s client area. ClientOrigin returns X and Y coordinates as a TPoint type, where X specifies the horizontal coordinate of the point and Y specifies the vertical coordinate. 
The screen coordinates of a control that is descended from TControl and not TWinControl are the screen coordinates of the control&apos;s parent added to its Left and Top properties. If the control doesn&apos;t have a parent, an EInvalidOperation exception is raised when ClientOrigin is read.</docstr>
      </property>
      <property name="ClientRect">
        <docstr>Specifies the size of a control&apos;s client area in pixels.
Read ClientRect to find out the size of the client area of a control. ClientRect returns a rectangle with its Top and Left fields set to zero, and its Bottom and Right fields set to the control&apos;s Height and Width, respectively. ClientRect is equivalent to Rect(0, 0, ClientWidth, ClientHeight). 
A point is considered within the control&apos;s client rectangle if it lies on the left or top side but not if it lies on the right or bottom side. That is, to be inside the client rectangle, the X-coordinate must be greater than or equal to ClientRect.Left and less than ClientRect.Right, and the Y-coordinate must be greater than or equal to ClientRect.Top and less than ClientRect.Bottom. 

Note: ClientRect is the size of the physical client area of the control, not its logical client area. If the control supports scrolling, the ClientRect is not the entire scrolling range, but only the region that is available at any given time.</docstr>
      </property>
      <property name="ClientWidth">
        <docstr>Specifies the horizontal size of the control&apos;s client area in pixels.
Use ClientWidth to read or change the width of the control&apos;s client area. ClientWidth is equivalent to ClientRect.Right.
For TControl, ClientWidth is the same as Width. Derived classes may implement a ClientWidth property that differs from Width. For example, the ClientWidth of a form is the value of the Width property minus the width of the resize border and scroll bars.</docstr>
      </property>
      <property name="Constraints">
        <docstr>Specifies the size constraints for the control.
Use Constraints to specify the minimum and maximum width and height of the control. When Constraints contains maximum or minimum values, the control cannot be resized to violate those constraints. 

Note: Constraints apply to the height of the form. However, the height of the form depends on how large Windows makes the title bar. For example, Windows XP uses much larger title bars than other windowing systems. To work around this, note the ClientHeight when you design your form and set the constraints in the FormCreate event. In the following example, ClientHeight is represented by x: Constraints.MinHeight�:= x + Height - ClientHeight.
Warning: Do not set up constraints that conflict with the value of the Align or Anchors property. When these properties conflict, the response of the control to resize attempts is not well-defined.</docstr>
      </property>
      <property name="ControlState">
        <docstr>Specifies the current state of a control at run time.
Read ControlState to find out various conditions that affect the control such as whether it has been clicked or needs alignment. ControlState reflects transient conditions of an instance of the control, as opposed to attributes of the control class as a whole. ControlState consists of a set of flags drawn from the following values: 





Flag

Meaning



csLButtonDown



The left mouse button was clicked and not yet released. This is set for all mouse-down events.




csClicked



The same as csLButtonDown, but only set if ControlStyle contains csClickEvents, meaning that mouse-down events are interpreted as clicks.




csPalette



The system palette has changed and the control or one of its descendants has not finished adjusting by realizing its palette.




csReadingState



The control is reading its state from a stream.




csAlignmentNeeded



The control needs to realign itself when alignment is re-enabled.




csFocusing



The application is processing messages intended to give the control focus. This does not guarantee the control will receive focus, but prevents recursive calls.




csCreating



The control and/or its owner and subcontrols are being created. This flag clears when all have finished creating.




csPaintCopy



The control is being replicated, meaning a copy of the control is being painted. The ControlStyle flag csReplicatable must be set for this state to occur.




csCustomPaint



The control is processing custom paint messages.




csDestroyingHandle



The control&apos;s window is being destroyed.




csDocking



The control is being docked.




The flags in ControlState are specific to controls, and augment the state flags in the ComponentState property.
ControlState is primarily used by component writers in the implementation of components derived from TControl.</docstr>
      </property>
      <property name="ControlStyle">
        <docstr>Determines style characteristics of the control.
Use ControlStyle to determine various attributes of the control, such as whether the control can capture the mouse or has a fixed size. The ControlStyle property contains a set of style flags indicating these attributes. The following table lists the flags and their meanings:





Flag

Meaning



csAcceptsControls



The control becomes the parent of any controls dropped on it at design time.




csCaptureMouse



The control captures mouse events when it is clicked.




csDesignInteractive



The control maps right mouse button clicks at design time into left mouse button clicks to manipulate the control.




csClickEvents



The control can receive and respond to mouse clicks. Some controls may not inherit this attribute, for example, TButton.




csFramed



The control has a 3D frame.




csSetCaption



The control&apos;s Caption should match the Name if it has not been explicitly set to something else.




csOpaque



The control completely fills its client rectangle.




csDoubleClicks



The control can receive and respond to double-click messages. Otherwise, map double-clicks into clicks.




csFixedWidth



The width of the control does not vary or scale.




csFixedHeight



The height of the control does not vary or scale.




csNoDesignVisible



The control is not visible at design time.




csReplicatable



The control can be copied using the PaintTo method to draw its image to an arbitrary canvas.




csNoStdEvents



Standard events such as mouse, key, and click events are ignored. This flag allows an application to run faster when there is no need to respond to these events.




csDisplayDragImage



If a control that has an associated drag image list is dragged across a control with this setting, then the image list is used to enhance the drag cursor while the cursor is over it. Otherwise, the drag cursor is used on its own.




csReflector



The control responds to Windows dialog messages, focus messages, or size change messages. Use this setting if the control can be used as an ActiveX control, so that it receives notification of these events.




csActionClient



The control is linked to an action object. This flag is set when the Action property is set, and cleared if the Action property is cleared.




csMenuEvents



The control responds to system menu commands.




ControlStyle describes all controls instantiated from a given class. ControlStyle should not be modified at run time, except in the constructor. The ControlState property records transient conditions.
The TControl constructor initializes ControlStyle to the set of csCaptureMouse, csClickEvents, csSetCaption, and csDoubleClicks.
ControlStyle is primarily used by component writers when implementing components derived from TControl.</docstr>
      </property>
      <property name="CurrentPPI">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="DockOrientation">
        <docstr>DockOrientation specifies how the control is docked relative to other controls docked in the same parent.
Use DockOrientation to determine the position of the control relative to other controls docked to the same parent. Docking zones can be arranged from left to right or from top to bottom.</docstr>
      </property>
      <property name="ExplicitLeft">
        <docstr>Specifies the explicit horizontal pixel coordinate of the left edge of a component relative to its parent.
ExplicitLeft is a read-only property used internally by Delphi. Use Left in applications to allow read and write access.</docstr>
      </property>
      <property name="ExplicitTop">
        <docstr>Specifies the explicit vertical pixel coordinate of the top edge of a component relative to its parent.
ExplicitTop is a read-only property used internally by Delphi. Use Top in applications to allow read and write access.</docstr>
      </property>
      <property name="ExplicitWidth">
        <docstr>Specifies the explicit horizontal size of the control in pixels.
ExplicitWidth is a read-only property used internally by Delphi. Use Width in applications to allow read and write access.</docstr>
      </property>
      <property name="ExplicitHeight">
        <docstr>Specifies the explicit vertical size of the control in pixels.
ExplicitHeight is a read-only property used internally by Delphi. Use Height in applications to allow read and write access.</docstr>
      </property>
      <property name="Floating">
        <docstr>Specifies whether the control is floating.
Read Floating to determine whether a dockable control appears in a floating window, rather than docked to a parent control.

Note:  Use Floating rather than the Parent property to determine whether a control is free-floating. Floating controls may have a non-nil (Delphi) or NULL (C++) parent if the FloatingDockSiteClass property specifies a floating window type.</docstr>
      </property>
      <property name="FloatingDockSiteClass">
        <docstr>Specifies the class of the temporary control that hosts the control when it is floating.
Use FloatingDockSiteClass to specify the class that houses the control when it is floating. This class must be a descendant of TWinControl. By default, it is TCustomDockForm. When the control is undocked, a temporary control of this type is created and the control is docked to that control. When the control is docked to another control, the temporary floating dock site is freed.
If the control can float as a stand-alone window, FloatingDockSiteClass is nil (Delphi) or NULL (C++).</docstr>
      </property>
      <property name="HostDockSite">
        <docstr>Specifies the control in which the control is docked.
Read HostDockSite to access the windowed control to which the control is docked. If the control is floating, HostDockSite is a temporary control of type FloatingDockSiteClass, or (if there is no floating dock site class) nil (Delphi) or NULL (C++).
Most applications should use the ManualDock method rather than setting HostDockSite. Setting HostDockSite automatically undocks the control from its previous host (if any) and docks it to the specified control, but does not adjust the control&apos;s position and alignment and bypasses the standard docking events.
For dock clients, the value of HostDockSite is the same as the value of Parent. For controls that are not docking clients, HostDockSite is nil (Delphi) or NULL (C++), while Parent specifies the containing control.</docstr>
      </property>
      <property name="LRDockWidth">
        <docstr>Specifies the width of the control when it is docked horizontally.
Read LRDockWidth to get the width of the control from the last time it was docked horizontally. Set LRDockWidth to indicate the width the control should have the next time it is docked horizontally.
LRDockWidth allows a control to &quot;remember&quot; its docked size even when its width changes because it is undocked or docked with a vertical orientation.</docstr>
      </property>
      <property name="ScaleFactor">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="ShowHint">
        <docstr>ShowHint specifies whether to show the Help Hint when the mouse pointer moves over the control.
ShowHint determines whether the Help Hint appears for the control. The Help Hint is the value of the TControl.Hint property. The Help Hint appears in a box just beneath the control when the mouse pointer moves over the control. 
To enable Help Hints for a particular control, two conditions must be satisfied:

The application&apos;s ShowHint property must be True.
Either the control&apos;s own ShowHint property must be True, or the control&apos;s ParentShowHint property must be True and its parent&apos;s ShowHint property must be True.
For example, imagine a check box within a group box. If the ShowHint property of the group box is True and the ParentShowHint property of the check box is True, but the ShowHint property of the check box is False, the check box still displays its Help Hint.
Changing the ShowHint value automatically sets the ParentShowHint property to False.</docstr>
      </property>
      <property name="TBDockHeight">
        <docstr>Specifies the height of the control when it is docked vertically.
Read TBDockHeight to get the height of the control from the last time it was docked vertically. Set TBDockHeight to indicate the height the control should have the next time it is docked vertically.
TBDockHeight allows a control to &quot;remember&quot; its docked size even when its height changes because it is undocked or docked with a horizontal orientation.</docstr>
      </property>
      <property name="Touch">
        <docstr>Specifies the touch manager component associated with the control.
Use the Touch property to access gesturing options associated with a control. Touch specifies a class of type TTouchManager. 
Touch is used to: 

Associate a TGestureManager.
(TGestureManager manages all the gestures that can be used by the control.)
Select the standard, interactive, or custom gestures to associate with the control.
(You can also connect each gesture to an action; see Assigning Actions to Gestures.)
Specify a set of options for interactive or tablet gestures.</docstr>
      </property>
      <property name="UndockHeight">
        <docstr>Specifies the height of the control when it is floating.
Read UndockHeight to get the height of the control from the last time it was floating. Set UndockHeight to indicate the height the control should have the next time it is undocked.
UndockHeight allows a control to &quot;remember&quot; its floating size even when its height changes because it is docked.</docstr>
      </property>
      <property name="UndockWidth">
        <docstr>Specifies the width of the control when it is floating.
Read UndockWidth to get the width of the control from the last time it was floating. Set UndockWidth to indicate the width the control should have the next time it is undocked.
UndockWidth allows a control to &quot;remember&quot; its floating size even when its width changes because it is docked.</docstr>
      </property>
      <property name="Visible">
        <docstr>Specifies whether the component appears onscreen.
Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible.
Calling the Show method sets the control&apos;s Visible property to True. Calling the Hide method sets it to False.
For TCustomForm descendants, the Show and ShowModal methods set Visible to True and bring the form to the front of all open windows.
For TTabSheet descendants, Visible does not control the visibility of the control at run time. For more information, see the description of the TabVisible property.</docstr>
      </property>
      <event name="WindowProc">
        <docstr>Points to the window procedure that responds to messages sent to the control.
Use the WindowProc property to temporarily replace or subclass the window procedure of the control. Component writers that are customizing the window procedure for a descendent class should override the WndProc method instead.
Before assigning a new value to WindowProc, store the original value. WindowProc is initially set to the WndProc method, so if the value has not been changed since then, the original value need not be stored. Within the procedure that is used as the new value for WindowProc, pass any unhandled messages to the original procedure that was the value of WindowProc. After completing any specialized message handling, restore the value of WindowProc to the original procedure.</docstr>
      </event>
      <property name="Parent">
        <docstr>Specifies the parent of the control.
Use the Parent property to get or set the parent of the control. The parent of a control is the control that contains it. For example, if an application includes three radio buttons in a group box, the group box is the parent of the three radio buttons, and the radio buttons are the child controls of the group box.
To serve as a parent, a control must be an instance of a TWinControl descendant.
When creating a new control at run time, assign a Parent property value for the new control. Usually, this is a form, panel, group box, or a control that is designed to contain another. Changing the parent of a control moves the control onscreen so that it is displayed within the new parent. When the parent control moves, the child moves with the parent.
Some controls (such as ActiveX controls) are contained in native windows rather than in a parent VCL control. For these controls, the value of Parent is nil (Delphi) or NULL (C++) and the ParentWindow property specifies the window.

Note:  The Parent property declared in TControl is similar to the Owner property declared in TComponent, in that the Parent of a control frees the control just as the Owner of a component frees that component. However, the Parent of a control is always a windowed control that visually contains the control, and is responsible for writing the control to a stream when the form is saved. The Owner of a component is the component that was passed as a parameter in the constructor and, if assigned, initiates the process of saving all objects (including the control and its parent) when the form is saved.</docstr>
      </property>
      <property name="StyleElements">
        <docstr>Specifies the style elements that are used by the control.
Use StyleElements to customize the style of the control. If a custom style is enabled, you can enable or disable style elements in the control.
StyleElements is a set of values that specify which elements of the current style are to be applied to this control. By default, all the elements of the style are enabled.</docstr>
      </property>
      <property name="StyleName">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <event name="OnGesture">
        <docstr>Occurs when you perform a gesture associated with this control.
Write an event handler for OnGesture to perform custom processing for gesture events. OnGesture is fired on controls that subscribed for specific gestures using the TTouchManager class. If your code did process the gesture event, do not forget to set the Handled parameter to True so that the event is not propagated further.
If no event handler is associated with the control, the default DoGesture method is executed performing its own processing for the event. 
OnGesture is an event handler of type Vcl.Controls.TGestureEvent.</docstr>
      </event>
      <property name="RaiseOnNonMainThreadUsage">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="AlignWithMargins">
        <docstr>Specifies whether a control should be constrained by margins.
If AlignWithMargins is true, use the Margins property of the control to govern the spacing relative to other controls that are aligned with this one. The controls are not allowed to be any closer than the spacing specified in Margins. This spacing is maintained as controls are moved when the parent control resizes. 
AlignWithMargins is true if the style csAlignWithMargins, a TControlStyle type, is in the control&apos;s ControlStyle property, and false otherwise.</docstr>
      </property>
      <property name="Left">
        <docstr>Specifies the horizontal coordinate of the left edge of a component relative to its parent.
Use the Left property to determine where the left side of the control begins or to reposition the left side of the control.
If the control is contained in another control, the Left and Top properties are relative to the parent control. If the control is contained directly by the form, the property values are relative to the form. For forms, the value of the Left property is relative to the screen in pixels.</docstr>
      </property>
      <property name="Top">
        <docstr>Specifies the Y coordinate of the upper-left corner of a control, relative to its parent or containing control in pixels.
Use Top to locate the top of the control or reposition the control to a different Y coordinate. The Top property, like the Left property, is the position of the control relative to its container. Thus, if a control is contained in a TPanel, the Left and Top properties are relative to the panel. If the control is contained directly by the form, it is relative to the form. For forms, the value of the Top property is relative to the screen in pixels.</docstr>
      </property>
      <property name="Width">
        <docstr>Specifies the horizontal size of the control or form in pixels.
Use the Width property to read or change the width of the control.

Note:  For tab sheet controls, changing this property at run time has no effect.</docstr>
      </property>
      <property name="Height">
        <docstr>Specifies the vertical size of the control in pixels.
Use the Height property to read or change the height of the control.</docstr>
      </property>
      <property name="Cursor">
        <docstr>Specifies the image used to represent the mouse pointer when it passes into the region covered by the control.
Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. The value of Cursor is the index of the cursor in the list of cursors maintained by the global variable, Screen. In addition to the built-in cursors provided by TScreen, applications can add custom cursors to the list.</docstr>
      </property>
      <property name="Hint">
        <docstr>Hint contains the text string that appears when the user moves the mouse over the control.
Use the Hint property to provide a string of Help text either as a Help Hint or as Help text on a particular location, such as a status bar. 
A Help Hint is a box containing Help text that appears for a control when the user moves the mouse pointer over the control and pauses momentarily. 
To set up Help Hints

Specify the Hint property of each control for which a Help Hint should appear.
Set the ShowHint property of each appropriate control to True, or set the ParentShowHint property of all controls to True and set the ShowHint property of the form to True.
At run time, set the value of the application&apos;s ShowHint property to True.
To show the Hint on a status bar or another location, use the OnHint event handler of the application. The application&apos;s OnHint event occurs when the mouse pointer moves over the control.
Specify a hint to be used for both a Help Hint box and by an OnHint event handler by specifying values separated by a | (pipe) character.
For example,

Edit1.Hint := &apos;Name|Enter Name in the edit box|1&apos;;

Edit1-&gt;Hint = &quot;Name|Enter Name in the edit box|1&quot;;

Here:

The Name part is the short hint and appears at the top of the Help Hint box.
Enter full name in the edit box is the long hint and appears below the short hint. It can be extracted using the GetLongHint function for use in an OnHint event handler.
1 is an optional image index in an image list in the Images property of the control and specifies the index of the image to appear in the hint.
If Hint contains only one value, the entire string is used as a Help Hint and returned by the GetLongHint and GetShortHint functions. If a control has no Hint value specified, but its parent control does, the control uses the value of the parent control (as long as the control&apos;s ShowHint property is True). 

Note: If the application&apos;s ShowHint property is False, the Help Hint does not appear, but the OnHint event handler is still called.</docstr>
      </property>
      <property name="HelpType">
        <docstr>Specifies whether the control&apos;s context-sensitive Help topic is identified by a context ID or by keyword.
Set HelpType to specify whether the control identifies its context-sensitive Help topic by a context ID or by keyword:

When HelpType is htContext, the HelpContext property value identifies the control&apos;s Help topic.
When HelpType is htKeyword, the HelpKeyword property value identifies the control&apos;s Help topic.
To use the Help, insert in the uses clause of your application the Vcl.HtmlHelpViewer or another unit that provides an interface to the external Help viewer to use. For C++, you need to include the HTMLHelpViewer.hpp header file.</docstr>
      </property>
      <property name="HelpKeyword">
        <docstr>The HelpKeyword property contains the keyword string that identifies the Help topic for the control.
To enable the keyword-based context-sensitive Help for a control, set Vcl.Controls.TControl.HelpType to htKeyword and set HelpKeyword to a keyword string.
No keyword (zero-length string, the default) means that no Help topic is provided for the control. 
To use the Help, insert in the uses clause of your application the Vcl.HtmlHelpViewer or other unit that provides an interface to the external Help viewer to use. For C++, you need to include the HTMLHelpViewer.hpp header file.</docstr>
      </property>
      <property name="HelpContext">
        <docstr>The HelpContext property contains the numeric context ID that identifies the Help topic for the control.
In case of a .chm help file, you must map symbolic Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
To enable Context ID-based context-sensitive Help for a control, set Vcl.Controls.TControl.HelpType to htContext and set HelpContext to a numeric topic ID. 
A topic ID of 0 (default) means that no Help topic is provided for the control. 
To use the Help, insert in the uses clause of your application the Vcl.HtmlHelpViewer or another unit that provides an interface to the external Help viewer to use. For C++, you need to include the HTMLHelpViewer.hpp header file.</docstr>
      </property>
      <property name="Margins">
        <docstr>Specifies the margins of the control.
Use the Margins property to set the margins of the control.
If AlignWithMargins is true, then the Margins property of the control governs the spacing relative to other controls that are aligned with this one. The controls are not allowed to be closer than the spacing specified in Margins. 

Note:  The Margins you set for the control have effect only when AlignWithMargins is set to true and Align is not set to alNone.</docstr>
      </property>
      <property name="CustomHint">
        <docstr>CustomHint is a custom hint for the control.
CustomHint is a TCustomHint instance for a control to specify the appearance of the control&apos;s hint.</docstr>
      </property>
      <property name="ParentCustomHint">
        <docstr>Specifies where a control looks for its custom hint.
To have a control use the same hint customization information as its parent control, set ParentCustomHint to true.
If ParentCustomHint is false, the control uses its own CustomHint property. 
Set ParentCustomHint to true for all controls to ensure that all the controls on a form display their hint messages alike.
When the value of a control&apos;s CustomHint property changes, ParentCustomHint becomes false automatically.</docstr>
      </property>
    </members>
  </class>
  <class unit="Vcl.Controls" name="TWinControl">
    <docstr>TWinControl is the base class for all controls that are wrappers for Microsoft Windows screen objects.
TWinControl provides the common functionality for all controls that act as wrappers for Microsoft Windows screen objects (&quot;windows&quot;). Controls that are wrap underlying windows have the following features:

The control can incorporate the functionality of an underlying window. For example, if the underlying screen object is a text editor, the control can incorporate the editor ability to manage and display a text buffer.
The control can receive user input focus. The focused control can handle keyboard input events. Some controls change their appearance when they have the focus. For example, button controls typically indicate the focus by drawing a rectangle around the caption.
The control can serve as a container for other controls, referred to as child controls. This relationship is signified by the child&apos;s Parent property. Container controls provide important services to their children, including display services for controls that do not implement their own canvases. Examples of container controls include forms, panels, and toolbars.
Controls based on TWinControl can display standard screen objects provided by Microsoft Windows, or customized screen objects developed by the VCL programmer.
Descendants of TWinControl include abstract base classes that support most kinds of user interface objects. The most significant descendant is TCustomControl, which provides code to implement a canvas and handle paint messages. Other important abstract descendants include TScrollingWinControl, TButtonControl, TCustomComboBox, TCustomEdit, and TCustomListBox. When defining new control classes, consider these descendants before deriving directly from TWinControl.
Every TWinControl object has a Handle property which provides the window handle for the underlying Microsoft Windows screen object. Use the Handle property to bypass the VCL API and directly access the underlying window.</docstr>
    <members>
      <field name="FAsyncList">
        <docstr>Internal list of pending Asynchronous method calls for this Win control and child TControl instances.</docstr>
      </field>
      <procedure name="InvokeAsyncCalls">
        <docstr>Processes pending asynchronous method calls listed in FAsyncList.
The Handle of the control calls InvokeAsyncCalls as a result of a specific message that the  Handle retrieves.

Note: InvokeAsyncCalls synchronizes the access to FAsyncList. It prohibits other threads from accessing it until the calling one calls Exit.</docstr>
      </procedure>
      <procedure name="UpdateStyleElements">
        <docstr>Called when the StyleElements property changes.
Vcl.Controls.TWinControl.UpdateStyleElements inherits from Vcl.Controls.TControl.UpdateStyleElements. All content below this line refers to Vcl.Controls.TControl.UpdateStyleElements.
Called when the StyleElements property changes.
Override the UpdateStyleElements method in a descendant class to provide customized behavior for the control when the value of the StyleElements property changes.</docstr>
      </procedure>
      <procedure name="AsyncSchedule">
        <docstr>Schedules asynch method calls.
Vcl.Controls.TWinControl.AsyncSchedule inherits from System.Classes.TComponent.AsyncSchedule. All content below this line refers to System.Classes.TComponent.AsyncSchedule.
Schedules asynch method calls.
By default, AsyncSchedule uses Queue in order to queue the asynch method call with the main thread.
Override AsyncSchedule in descendant components in order to modify the management of the asynchronous scheduling.

 See Also
System.Classes.TComponent.BeginInvoke
System.Classes.TBaseAsyncResult
System.Classes.TBaseAsyncResult.Schedule</docstr>
      </procedure>
      <procedure name="ActionChange">
        <docstr>Updates the control to reflect changes in its associated action.
ActionChange is called automatically when the associated action changes. It updates the control to reflect the action&apos;s current Caption, Enabled, Hint, Visible, and HelpContext properties and its OnClick event handler.
The Sender parameter is the associated action. The CheckDefaults parameter specifies whether properties and event handlers should be changed if they differ from the default values. When CheckDefaults is true, properties and event handlers are only changed when the current values are the default values (that is, when the values have not been previously changed). When CheckDefaults is false, properties and event handlers are changed, regardless of their current values.</docstr>
      </procedure>
      <procedure name="AddBiDiModeExStyle">
        <docstr>Sets control&apos;s window style according to its bi-directional support.
The CreateParams method calls AddBiDiModeExStyle to update the control&apos;s style flags (passed as the ExStyle parameter) according the control&apos;s bi-directional support. AddBiDiModeExStyle uses the UseRightToLeftReading, UseRightToLeftScrollBar, UseRightToLeftAlignment, and GetControlsAlignment methods to determine the current bi-directional support.</docstr>
      </procedure>
      <procedure name="AssignTo">
        <docstr>Copies the properties of the windowed control to another object.
Do not call the protected AssignTo method. Instead, applications call the Assign method to copy the properties of another object. If the object&apos;s Assign method does not include the ability to copy from the source object, the Assign method calls the source object&apos;s protected AssignTo method, to copy the source objects properties to the object specified by the Dest parameter. This allows objects to expand the abilities of another object&apos;s Assign method to copy from additional sources.
The AssignTo method implemented in TWinControl copies the Caption, Enabled, Hint, Visible, and HelpContext properties and the OnClick event handler to a TCustomAction object.</docstr>
      </procedure>
      <procedure name="AdjustClientRect">
        <docstr>Provides the interface that adjusts the ClientRect property for idiosyncrasies of the window.
AdjustClientRect is called internally when the control needs accurate information on where to place child controls within the client area. As implemented in TWinControl, AdjustClientRect does nothing. Override this method in descendants such as TTabControl where the ClientRect property is not the same as the region in which child objects can appear.</docstr>
      </procedure>
      <procedure name="AdjustSize">
        <docstr>Adjusts the control&apos;s size according to its contents and constraints.
If the AutoSize property is true, AdjustSize is called automatically when the control needs to automatically resize itself to its contents. As implemented in TWinControl, AdjustSize calls SetBounds with the values of its Left, Top, Width, and Height properties. This call can result in a change of size if these values are altered in the control&apos;s OnCanResize or OnConstrainedResize event handlers, or if the control&apos;s OnResize event handler makes any final adjustments.
Descendant classes override AdjustSize to change the size of the control to adjust to its contents.
Component writers may call AdjustSize when making changes to a control&apos;s contents.</docstr>
      </procedure>
      <procedure name="AlignControls">
        <docstr>Aligns any controls for which the control is the parent within a specified area of the control.
Use AlignControls to align all controls within an area of a form, panel, group box, scroll box, or any container control. Specify the area in which to align the controls as the value of the Rect parameter.
AlignControls uses the Align property value for each child control to determine how to align it. The AControl parameter can be nil (Delphi) or NULL (C++). If you specify a control in AControl, that control takes precedence in alignment over other, similarly-aligned controls.</docstr>
      </procedure>
      <procedure name="ArrangeControl">
        <docstr>Aligns the given control with the specified alignment options.
ArrangeControl is a protected method used internally by AlignControls to align each control, with the specified alignment options. 
To be more specific, ArrangeControl aligns the control given by AControl, with the alignment options specified through the parameters ParentSize, AAlign, AAlignInfo, Rect, and UpdateAnchorOrigin. The meaning of these parameters is summarized in the following table.





Parameter

Meaning



ParentSize



The size of the parent control within which AControl is aligned.




AAlign



Determines how AControl aligns within its parent control.




AAlignInfo



Describes the alignment details of AControl within its parent.




Rect



The rectangular area inside the parent control in which to align AControl.




UpdateAnchorOrigin



Specifies whether to update the anchor origin of AControl, following the alignment.</docstr>
      </procedure>
      <function name="CanAutoSize">
        <docstr>Indicates how the control can be resized.
CanAutoSize is called automatically when the AutoSize property is true and an attempt is made to resize the control. It allows controls to implement the AutoSize property before the resize sequence that begins with the OnCanResize and OnConstrainedResize events and ends with the OnResize event.
When CanAutoSize is called, the NewWidth and NewHeight parameters indicate the proposed new dimensions of the control. CanAutoSize adjusts these values so that the control&apos;s size adjusts to its contents. If the adjustment results in values of NewWidth and NewHeight that differ from the control&apos;s current width and height, CanAutoSize returns true, indicating that the resize sequence should proceed. If, after adjustment, NewWidth and NewHeight equal Width and Height, CanAutoSize returns false, and the resize sequence is aborted.
As implemented in TWinControl, CanAutoSize returns true, adjusting NewWidth and NewHeight so that all the control&apos;s children fit.</docstr>
      </function>
      <function name="CanResize">
        <docstr>Indicates how the control can respond to a resize attempt.
CanResize is called automatically when an attempt is made to resize the control. The NewWidth and NewHeight parameters specify the attempted new values for the control&apos;s height and width. CanResize returns true if the control can be resized to the returned values of NewWidth and NewHeight. CanResize returns false if the control can&apos;t be resized.
CanResize generates an OnCanResize event. An OnCanResize event handler may change the values of NewHeight and NewWidth.</docstr>
      </function>
      <procedure name="ChangeScale">
        <docstr>Resize and reposition children and self.
ChangeScale rescales the control in the same manner as the ChangeScale method in TControl. If the control contains any children, their ChangeScale methods are called before the parent itself is rescaled.
To rescale the control&apos;s children without rescaling the control itself, use ScaleControls. To rescale the control without repositioning, use ScaleBy.</docstr>
      </procedure>
      <procedure name="ConstrainedResize">
        <docstr>Generates an OnConstrainedResize event.
ConstrainedResize is called automatically as part of a control&apos;s resize sequence. It generates an OnConstrainedResize event, passing in the MinWidth, MinHeight, MaxWidth, and MaxHeight parameters, which can be altered by the event handler before they are applied to the attempted resize.</docstr>
      </procedure>
      <procedure name="ControlsAligned">
        <docstr>ControlsAligned automatically executes after a call to AlignControls.
Implement ControlsAligned in descendant classes to display a notification, after aligning the controls by a call to AlignControls. 

Note:  As a member of the TWinControl class, ControlsAligned has no effect.</docstr>
      </procedure>
      <function name="CreateDockManager">
        <docstr>Creates the dock manager for the control.
CreateDockManager is called automatically during drag-and-dock operations when the UseDockManager property is true. CreateDockManager creates the object that implements the DockManager property.
Override CreateDockManager to create a custom dock manager for the control.</docstr>
      </function>
      <procedure name="CreateHandle">
        <docstr>Creates underlying screen object.
CreateHandle creates the Microsoft Windows screen object that underlies the control. if it does not already exist. The new window handle becomes the value of the Handle property.
CreateHandle creates or locates the parent control&apos;s window before it creates a window for the control itself.

Note:  If the Parent property is nil (Delphi) or NULL (C++), CreateHandle raises an exception.</docstr>
      </procedure>
      <procedure name="CreateParams">
        <docstr>Initializes a window-creation parameter data structure.
The CreateWnd method calls CreateParams to initialize the parameters it passes to CreateWindowHandle. Override CreateParams to customize the way a control creates its Windows representation. When overriding CreateParams, always call the inherited method first to set the default values, then make any desired adjustments.
CreateParams fills in the parameter that is passed as the value of the Params parameter. This data structure holds information needed when telling Windows to create a window handle. The fields of a TCreateParams record become the parameters to a call to the CreateWindowEx API function.
TWinControl implements CreateParams by setting all the fields of Params to generic base values. A number of the standard controls override CreateParams to change one or more of the default values in Params.</docstr>
      </procedure>
      <procedure name="CreateWindowHandle">
        <docstr>Creates a Windows control to represent the control.
The CreateWnd method calls CreateWindowHandle to create the window for a control. CreateWindowHandle creates the window by calling the CreateWindowEx API function, passing parameters from the record passed in the Params parameter. Once the window is created, its handle is available as the Handle property.</docstr>
      </procedure>
      <procedure name="CreateWnd">
        <docstr>Creates the underlying window.
CreateWnd is called automatically when the control is first created or when the underlying screen object must be destroyed and recreated to reflect property changes. Override CreateWnd to pass additional initialization messages to the screen object when it is created.</docstr>
      </procedure>
      <function name="CustomAlignInsertBefore">
        <docstr>Returns placement order of custom-aligned child control.
CustomAlignInsertBefore determines the order in which custom-aligned child controls are placed. The control calls CustomAlignInsertBefore once for each pair of child controls with an Align property of alCustom. CustomAlignInsertBefore returns true if C2 should be presented before C1, and false otherwise.
Once the custom-aligned child controls are sorted, their specific positions are determined by calls to CustomAlignPosition. 
CustomAlignInsertBefore triggers the OnAlignInsertBefore event. If this event is defined, CustomAlignInsertBefore returns the value returned by OnAlignInsertBefore. Defining this event allows users to define the order of control alignment without overriding CustomAlignInsertBefore.
As implemented in TWinControl, CustomAlignInsertBefore returns false if OnAlignInsertBefore is not implemented, so the controls are placed in the order they appear in the Controls property.</docstr>
      </function>
      <procedure name="CustomAlignPosition">
        <docstr>Returns aligned position of custom-aligned child control.
CustomAlignPosition determines the specific position of custom-aligned child controls. CustomAlignPosition is called once for each child control with an Align property of alCustom, in an order previously determined by calls to CustomAlignInsertBefore.
CustomAlignPosition triggers the OnAlignPosition event. If this event is defined, CustomAlignPosition uses the alignment parameters it obtains from OnAlignPosition. Defining this event allows users to set the alignment parameters without overriding CustomAlignPosition.
These are the parameters:





Control

The child control being placed.



NewLeft | NewTop | NewWidth | NewHeight



Location and size of child control, as determined by container&apos;s size and the Anchors TControl_Anchors constraints for the control. CustomAlignPosition can modify these values to reposition the control.




AlignRect



The client area in which the control is aligned. CustomAlignPosition can modify this value.




AlignInfo



Alignment information in a TAlignInfo.




As implemented in TWinControl, CustomAlignPosition does nothing.</docstr>
      </procedure>
      <procedure name="DefineProperties">
        <docstr>Provides methods to read and write the IsControl property to a stream such as a form file.
Vcl.Controls.TWinControl.DefineProperties inherits from Vcl.Controls.TControl.DefineProperties. All content below this line refers to Vcl.Controls.TControl.DefineProperties.
Provides methods to read and write the IsControl property to a stream such as a form file.
DefineProperties is called automatically by the streaming system that loads and saves VCL components. It allows persistent objects to read and write properties that are not published. Published properties are loaded and stored automatically.
DefineProperties uses the methods of the filer passed as the Filer parameter to assign methods that can load and save the IsControl property.
Override DefineProperties to persist unpublished properties. Call the DefineBinaryProperty or DefineProperty method of the Filer parameter to assign methods that load or save property values.

Note:  When overriding this method, call the parent class&apos;s DefineProperties method first.</docstr>
      </procedure>
      <procedure name="DestroyHandle">
        <docstr>Destroys the control&apos;s window without destroying the control.
Call DestroyHandle to dispose of the window, but leave the control intact. The control can later recreate the window if needed. DestroyHandle is the converse operation to CreateHandle. Applications should call the high-level CreateHandle and DestroyHandle methods, rather than the lower-level methods of CreateWnd and DestroyWnd, whenever possible.
If the control has TWinControl objects as child controls, DestroyHandle calls each of their DestroyHandle methods before calling DestroyWnd to destroy its own handle.</docstr>
      </procedure>
      <procedure name="DestroyWindowHandle">
        <docstr>Destroys the window created in the CreateWindowHandle method.
Call DestroyWindowHandle to dispose of the window for the control.
TWinControl&apos;s Destroy method calls DestroyWindowHandle to destroy any window associated with a windowed control before destroying the object. The DestroyWnd method also calls DestroyWindowHandle.</docstr>
      </procedure>
      <procedure name="DestroyWnd">
        <docstr>Destroys the control&apos;s window.
DestroyWnd is called when the control needs to replace its window. For example, changing properties that are implemented by window parameter settings require the control to be destroyed and then recreated using the CreateWnd method. 
Before the window is destroyed, DestroyWnd saves a copy of the control&apos;s text in memory, frees any device contexts, and finally calls DestroyWindowHandle. When the window is recreated, the stored copy of the control&apos;s text is assigned to the new window.</docstr>
      </procedure>
      <procedure name="DoAddDockClient">
        <docstr>Performs actions when a control is docked to the windowed control.
DoAddDockClient is called automatically when a client control is docked to the windowed control. As implemented in TWinControl, DoAddDockClient sets the client&apos;s Parent property to the control.
Client is the control that has been docked.
ARect describes the boundaries of the region where Client has been docked.
Override DoAddDockClient to perform actions when a control is docked to the windowed control.

Note: DoAddDockClient is called in response to a message sent by the DockDrop method, before the OnDockDrop event.</docstr>
      </procedure>
      <procedure name="DockOver">
        <docstr>Responds when a docking client is dragged over the windowed control.
DockOver is called automatically for dock sites when a dockable object is dragged over them. As implemented in TWinControl, DockOver positions the docking rectangle and then calls DoDockOver to generate an OnDockOver event.
Override DockOver to perform additional actions when another control is dragged over the control.
DockOver is called only if DockSite is true.</docstr>
      </procedure>
      <function name="DockReplaceDockClient">
        <docstr>Invalidates the first dock site in the list of child controls.
Currently, DockReplaceDockClient always returns False and has no effect as a member of the TWinControl class. 
Implement DockReplaceDockClient in descendant classes in order to manually replace Client with ReplacementClient. Also, manually dock Client to NewDockSite on the control specified by DropControl and using the alignment options given in ControlSide.</docstr>
      </function>
      <procedure name="DoDockOver">
        <docstr>Generates an OnDockOver event.
DoDockOver is called by the DockOver method to generate an OnDockOver event when the user drags a dockable control over the windowed control. Override this method to perform some other action or to suppress the event.</docstr>
      </procedure>
      <procedure name="DoEnter">
        <docstr>Respond to receiving input focus.
DoEnter is called automatically when the control receives the input focus. As implemented in TWinControl, DoEnter calls the OnEnter event handler, if defined.
Descendant classes that override DoEnter should always call the inherited method.</docstr>
      </procedure>
      <procedure name="DoExit">
        <docstr>Responds to losing input focus.
DoExit is called automatically when the control loses the input focus. As implemented in TWinControl, DoExit calls the OnExit event handler, if defined.
Descendant classes that override DoExit should always call the inherited method.</docstr>
      </procedure>
      <procedure name="DoFlipChildren">
        <docstr>Flips the control&apos;s children.
The FlipChildren method calls DoFlipChildren to reverse the positions of child controls. DoFlipChildren moves the control&apos;s children to opposite positions on the control; that is, children on the left side of the control are moved to the right side of the control and vice versa.
Override FlipChildren to control how the control&apos;s children are flipped.

Note: DoFlipChildren is a protected helper method for the public FlipChildren method. Unlike FlipChildren, DoFlipChildren does not adjust the alignment of controls that are aligned to one of the edges of the windowed control.</docstr>
      </procedure>
      <function name="DoWritePixelsPerInch">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="DoKeyDown">
        <docstr>Performs some preprocessing before generating an OnKeyDown event.
The return value from DoKeyDown determines if the control should continue processing key-down messages passed in the Message parameter. A return value of true indicates that the key-down occurrence has been handled completely, and no further processing is needed. A return value of false indicates that the application should continue passing the key-down message through the inherited processing.
DoKeyDown checks whether the KeyPreview property of the parent form is true; if so, it allows the form to preemptively process key-down messages before they are handled by the windowed control. If the form does not handle the message, DoKeyDown translates the message parameters into the appropriate types and calls KeyDown, which in turn calls the OnKeyDown event handler, if any.</docstr>
      </function>
      <function name="DoKeyPress">
        <docstr>Performs some preprocessing before generating an OnKeyPress event.
The return value from DoKeyPress determines whether the control should continue processing the key-press message passed in the Message parameter. A return value of true indicates that the key-press occurrence has been handled completely, and no further processing is needed. A return value of false indicates that the application should continue passing the key-press message through the inherited processing.
DoKeyPress checks whether the KeyPreview property of the parent form is true, and if so, allows the form to preemptively process key-press messages before they are handled by the windowed control. If the form does not handle the message, DoKeyPress translates the message parameters into the appropriate types and calls KeyPress, which in turn calls the OnKeyPress event handler, if any.</docstr>
      </function>
      <function name="DoKeyUp">
        <docstr>Performs some preprocessing before generating an OnKeyUp event.
The return value from DoKeyUp determines whether the control should continue processing the key-up message passed in the Message parameter. A return value of true indicates that the key-up occurrence has been handled completely, and no further processing is needed. A return value of false indicates that the application should continue passing the key-up message through the inherited processing.
DoKeyUp checks whether the KeyPreview property of the parent form is true, and if so, allows the form to preemptively process key-up messages before they are handled by the windowed control. If the form does not handle the message, DoKeyUp translates the message parameters into the appropriate types and calls KeyUp, which in turn calls the OnKeyUp event handler, if any.</docstr>
      </function>
      <function name="DoHandleStyleMessage">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="DoRemoveDockClient">
        <docstr>Responds when a control is undocked from the windowed control.
DoRemoveDockClient is called automatically when a client control is undocked from the windowed control. As implemented in TWinControl, DoRemoveDockClient does nothing.
Client is the control that has been undocked.
Override DoRemoveDockClient to perform any necessary adjustments when a control is undocked from the windowed control.

Note: DoRemoveDockClient occurs at the end of the undocking process. To make changes when undocking starts, override the DoUnDock method instead.</docstr>
      </procedure>
      <function name="DoUnDock">
        <docstr>Undocks a control that is currently docked to the windowed control.
DoUnDock is called automatically when a control is undocked from the windowed control. It handles all necessary changes to the windowed control to accomplish the undocking. These are
1.Generates an OnUnDock event.
2.If there is no OnUnDock event handler, or if the event handler indicates that the client can be undocked, it removes the client from the DockClients property list.
The NewTarget parameter indicates the new host to which the undocked control is moving.
The Client parameter indicates the control to be undocked from the windowed control.
DoUnDock returns true if the client is successfully undocked, false if the undocking attempt was blocked by an OnUnDock event handler.
Override DoUnDock to change the way controls are undocked from the windowed control.

Note: DoUnDock occurs at the start of the undocking process. To handle changes when undocking is complete, override the DoRemoveDockClient method instead.</docstr>
      </function>
      <function name="FindNextControl">
        <docstr>Returns the control&apos;s next child in the tab order after the specified control.
Call FindNextControl to find the next child control in the tab order after CurControl. If CurControl is not a child of the control, FindNextControl returns the first child control in the tab order.
The GoForward parameter controls the direction of the search. If GoForward is true, FindNextControl searches forward through the child controls in tab order. If Go Forward is false, FindNextControl searches backward through the controls.
The CheckTabStop and CheckParent parameters control whether FindNextControl performs certain checks on the controls it finds. If CheckTabStop is true, the returned control must have its TabStop property set to true. If CheckParent is true, the returned control&apos;s Parent property must indicate the parent control.
FindNextControl calls the GetTabOrderList method to build its list of possible &quot;next&quot; controls.</docstr>
      </function>
      <procedure name="FixupTabList">
        <docstr>Sorts the child controls by their tab order.
Applications should not call FixupTabList directly. The ReadState method calls FixupTabList to initialize the tab order list based on the TabOrder properties of the child controls being read from a stream.</docstr>
      </procedure>
      <function name="GetActionLinkClass">
        <docstr>Returns the associated action link class.
GetActionLinkClass returns the appropriate class type for the action link used with a control. This class is used internally to create an action link object for the control when it has an associated action. The action link links the action to the control client. Each Action link class is designed to link specific properties and event handlers of the action to its client, based on the types of properties the client supports.
As implemented in TWinControl, GetActionLinkClass returns the TWinControlActionLink class type, which associates the HelpContext, ShowHint, Caption, Enabled and Visible properties and the OnClick event handler. Descendants of TWinControl override this method to specify a descendant of TControlActionLink that handles their configuration of properties and events.</docstr>
      </function>
      <function name="GetClientOrigin">
        <docstr>Returns the value of the ClientOrigin property.
GetClientOrigin is the protected implementation of the ClientOrigin property.
GetClientOrigin returns a point indicating the position of the top-left corner of the control in screen coordinates.</docstr>
      </function>
      <function name="GetClientRect">
        <docstr>Returns the value of the ClientRect property.
GetClientRect is the protected implementation of the ClientRect property. GetClientRect returns a rectangle with the rectangle&apos;s Top and Left fields set to zero, and its Bottom and Right fields set to the control&apos;s ClientHeight and ClientWidth, respectively.</docstr>
      </function>
      <function name="GetDPIForDesigner">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetControlExtents">
        <docstr>Returns the smallest rectangle in which all the control&apos;s children fit.
Call GetControlExtents to determine the smallest rectangle in which all the control&apos;s children fit. Windowed controls call GetControlExtents when implementing the AutoSize property.</docstr>
      </function>
      <function name="GetDeviceContext">
        <docstr>Provides access to a device context for the control.
Call GetDeviceContext to obtain a handle to a device context for the control.
GetDeviceContext calls the Windows API function GetDC, passing the windowed control&apos;s Handle property. It returns the window&apos;s handle in the WindowHandle parameter and the HDC as the return value. If the call is unsuccessful, the EOutOfResources exception is raised.</docstr>
      </function>
      <function name="GetParentHandle">
        <docstr>Returns the window handle for the window of the control&apos;s parent.
Use the handle returned by GetParentHandle as a parameter to Windows API function calls that need the window handle for the parent window of the control. If the Parent property is not nil (Delphi) or NULL (C++), GetParentHandle returns the Handle property of the parent control. If the Parent property is nil (Delphi) or NULL (C++), GetParentHandle returns the value of ParentWindow.</docstr>
      </function>
      <procedure name="GetSiteInfo">
        <docstr>Generates an OnGetSiteInfo event.
GetSiteInfo is called automatically during drag-and-dock operations to initialize a TDragDockObject with information about where a dragged object can be docked, if at all.
Client is a potential docking client.
InfluenceRect returns the area in which the client would be docked.
MousePos is the current mouse position.
CanDock returns whether the client can dock to the windowed control.
As implemented in TWinControl, GetSiteInfo generates an influence rectangle equal to BoundsRect expanded by 10 pixels on every side, and then calls the OnGetSiteInfo event handler.</docstr>
      </procedure>
      <function name="GetTopParentHandle">
        <docstr>Returns the window handle of the first window not associated with a VCL control that contains the windowed control.
Use GetTopParentHandle to access the handle of the window that is hosting the windowed control. GetTopParentHandle walks up the containers of the windowed control until it finds a control whose Parent property is nil (Delphi) or NULL (C++). If that topmost parent is contained in a non-VCL window (its ParentWindow is nonzero), GetTopParentHandle returns the non-VCL window. If the windowed control is not contained in a non-VCL window, GetTopParentHandle returns the windowed control&apos;s own window handle.</docstr>
      </function>
      <procedure name="InvalidateDockHostSite">
        <docstr>Invalidates the first dock site that appears in the list of child controls.
Call InvalidateDockHostSite to invalidate the first dock site that appears in the list of child controls.</docstr>
      </procedure>
      <function name="IsControlMouseMsg">
        <docstr>Indicates whether a specified mouse message is directed to one of the windowed control&apos;s child controls.
Call IsControlMouseMsg to find out if a mouse message is directed to one of the control&apos;s child controls. Specify the mouse message as the value of the Message parameter.
Windows takes care of sending messages to windowed child controls, but for nonwindowed child controls, Windows sends the messages to the parent control, which must then determine which, if any, of its child controls should receive the message.
The WndProc method of a windowed control calls IsControlMouseMsg to process all mouse message sent to the windowed control.</docstr>
      </function>
      <function name="IsControlActivateMsg">
        <docstr>Indicates whether a specified mouse activation message is directed to the given child control.
Call IsControlActivateMsg to find out whether a mouse activation message is directed to the child control given by the Control parameter. Specify the mouse activation message as the value of the Message parameter.
The WndProc method of a windowed control calls IsControlActivateMsg to process all mouse activation messages sent to the windowed control.</docstr>
      </function>
      <function name="IsQualifyingSite">
        <docstr>Checks whether the control is docked inside another control or has at least two docked controls.
IsQualifyingSite is a protected method that returns true if either the given Client control is docked inside another control, or there are at least two controls docked inside Client.</docstr>
      </function>
      <procedure name="KeyDown">
        <docstr>Responds to key press events.
When a windowed control receives a key-down message (WM_KEYDOWN) from Windows, its message handler calls the DoKeyDown method. If DoKeyDown determines that the control should, in fact, process the character, it calls KeyDown, passing the key code and shift-key state in the Key and Shift parameters, respectively.
KeyDown calls any event handler attached to the OnKeyDown event. Override KeyDown to provide other responses in addition to the event handler call.
The Key parameter is the key on the keyboard. For nonalphanumeric keys, you must use WinAPI virtual key codes to determine the key pressed. For more information see Representing Keys and Shortcuts.
The Shift parameter indicates whether the SHIFT, ALT, or CTRL keys are combined with the keystroke.
Either KeyDown or the OnKeyDown event handler it calls can suppress further processing of a key by setting the Key parameter to zero.</docstr>
      </procedure>
      <procedure name="KeyUp">
        <docstr>Respond to released key.
When a windowed control receives a key-up message (WM_KEYUP) from Windows, its message handler calls the DoKeyUp method. If DoKeyUp determines that the control should, in fact, process the character, it calls KeyUp, passing the key code and shift-key state to KeyUp in the Key and Shift parameters, respectively.
KeyUp calls any event handler attached to the OnKeyUp event. Override KeyUp to provide other responses in addition to the event-handler call.
Either KeyUp or the OnKeyUp event handler it calls can suppress further processing of a key by setting the Key parameter to zero.
The Key parameter is the key on the keyboard. For non-alphanumeric keys, use WinAPI virtual key codes to determine the key pressed. For more information, see Representing Keys and Shortcuts.
The Shift parameter indicates whether the Shift, Alt, or Ctrl keys are combined with the keystroke.</docstr>
      </procedure>
      <procedure name="KeyPress">
        <docstr>Responds to keyboard input.
When a windowed control receives a key-press message (WM_CHAR) from Windows, its message handler calls the DoKeyPress method. If DoKeyPress determines that the control should, in fact, process the character, it calls KeyPress, passing the key code in the Key parameter.
KeyPress calls any event handler attached to the OnKeyPress event. Override KeyPress to provide other responses in addition to the event handler call.
Either KeyPress or the OnKeyPress event handler it calls can suppress further processing of a character by setting the Key parameter to zero.

Note: The Key parameter is the character represented by the key that is pressed, not a Windows virtual key code.</docstr>
      </procedure>
      <procedure name="MainWndProc">
        <docstr>Receives Windows messages for the control.
MainWndProc is the window procedure for the control that is associated with the control&apos;s window when it is created. When Windows sends a message to the control&apos;s window, MainWndProc receives it.
MainWndProc does not process or dispatch the messages itself, but rather calls the method specified by WindowProc to do that. MainWndProc provides an exception-handling block around WindowProc, ensuring that if any unhandled exceptions occur during the processing of a message, the application&apos;s HandleException method will handle them.</docstr>
      </procedure>
      <procedure name="Notification">
        <docstr>Responds to notifications indicating that components are being created or destroyed.
Vcl.Controls.TWinControl.Notification inherits from Vcl.Controls.TControl.Notification. All content below this line refers to Vcl.Controls.TControl.Notification.
Responds to notifications indicating that components are being created or destroyed.
Notification allows TControl to update its internal state if an associated component is removed. The internal state is updated if: 

The associated pop-up menu is destroyed.
The control docking site is destroyed.
The custom hint associated with the control is destroyed.
The associated gesture manager is destroyed.
Override the Notification method to respond to notifications indicating that other components are about to be destroyed or have just been created. Use the Notification method to update controls that rely on other objects. Data-aware objects override the Notification method to update themselves when their data source is removed. Some objects respond to notifications indicating that other objects of a specific type are being created. For example, the session component sets the Session property of new data-aware controls to itself when the AutoSessionName property is True. 
By default, components pass along the notification to their owned components, if any.</docstr>
      </procedure>
      <procedure name="NotifyControls">
        <docstr>Sends a message to all the child controls.
NotifyControls sends a message with the message ID passed in the Msg parameter to all the controls in the windowed control&apos;s Controls array property. NotifyControls is used to update all the controls in a form of such occurrences as changes in the parent color or font. 
NotifyControls constructs a generic message record, filling its message ID field with the value of Msg and setting its parameter and result fields to zeros, then calls the Broadcast method to send the message to all the child controls.</docstr>
      </procedure>
      <procedure name="PaintControls">
        <docstr>Paints each of the child controls in a windowed control using the specified device context.
Call PaintControls to paint all the child controls of this control. Pass the device context as the value of the DC parameter. The First parameter indicates the starting point in the windowed control&apos;s child-control list to paint. If First is nil (Delphi) or NULL (C++) or does not indicate one of the child controls, PaintControls paints all the child controls.
The Repaint method calls PaintControls for the control&apos;s parent, passing the control in First to repaint the control and any controls it might intersect. PaintHandler also calls PaintControls after calling PaintWindow.</docstr>
      </procedure>
      <procedure name="PaintHandler">
        <docstr>Responds to WM_PAINT messages.
PaintHandler is called automatically when the control receives a WM_PAINT message. It calls the BeginPaint and EndPaint API functions, and between them paints the control&apos;s background by calling PaintWindow and any child controls by calling PaintControls.</docstr>
      </procedure>
      <procedure name="PaintWindow">
        <docstr>Renders the image of a windowed control.
Call PaintWindow to repaint the control. PaintWindow sends a WM_PAINT message to the windowed control&apos;s DefaultHandler method, setting the message record&apos;s WParam field to the value passed in DC and the other parameter and result fields to zeros.</docstr>
      </procedure>
      <function name="PaletteChanged">
        <docstr>Responds to changes in the system&apos;s palette by realizing the control&apos;s palette and the palette for each child control.
PaletteChanged is called automatically when the Windows system palette changes. TWinControl responds to these notifications by trying to realize the windowed control&apos;s palette, if any, into the current device context, and then passing on the PaletteChanged notification to each of the child controls in turn. If the change in the system palette causes the actual value of the control&apos;s palette to change, PaletteChanged will invalidate the control so that it can repaint with the new palette.
Windows paints the active window with a foreground palette, while other windows are forced to use background palettes. Background palettes are approximate matches to the colors specified by the control&apos;s logical palette, given the limitations imposed by implementing the foreground palette. Windows only allows a single foreground palette.
PaletteChanged allows the control to obtain a new realization of its palette when the system palette changes. When Foreground is true, the form has been activated and the control is specifying the new foreground palette. When Foreground is false, another application or form has changed the foreground palette, and controls that are sensitive to the available palette should realize new background palettes to best match their logical palettes.
If the control does not have a logical palette to be realized into the current device context, GetPalette will return a handle of 0, and PaletteChanged will not try to realize a palette for the windowed control. Instead, it simply passes the notification on to the child controls. If the windowed control or any of its child controls realize a palette into the current device context in response to PaletteChanged, this method returns true.
Override PaletteChanged to change the way in which controls are given an opportunity to realize a new palette when the Windows system palette changes. For example, override PaletteChanged to change the order in which child controls realize their palettes, giving a particular control the foreground palette when the form is activated, or to pass palette change notification to custom controls implemented outside of the VCL, such as in DLLs.
Override GetPalette instead to affect whether the windowed control actually has a palette to realize, or to change the value of the control&apos;s logical palette.

Note: PaletteChanged is called only when the run-time video mode requires palette support, such as for 256 color mode, but not 16 million color mode.</docstr>
      </function>
      <procedure name="ReadState">
        <docstr>Prepares the control for having its properties assigned values from a stream.
Override ReadState to change the preparations the control makes as it readies itself to have its property values assigned from a stream. For example, a control might destroy temporary internal data structures or objects before new instances are loaded from the stream. Be sure to include a call to the inherited method when overriding ReadState.
As implemented in TWinControl, ReadState disables control alignment until all the child controls have been read from the stream, calls the inherited ReadState method, and re-enables the alignment of all the controls. The method then builds the tab order list of controls and synchronizes its visibility with that of its parent control.</docstr>
      </procedure>
      <procedure name="RecreateWnd">
        <docstr>Recreate underlying Windows screen object.
Call RecreateWnd to recreate the control from scratch. RecreateWnd destroys the underlying Windows screen object. The next time the Handle property is referenced (when the object is repainted, for example), a new Windows screen object is created. Some changes in control properties are not implemented until this re-creation occurs.</docstr>
      </procedure>
      <procedure name="ReloadDockedControl">
        <docstr>Reloads a docked control.
Use ReloadDockedControl to obtain a reference to control given its name. The AControlName parameter is the name of the child control. The corresponding control is returned as the AControl parameter. ReloadDockedControl can only locate a control if it has the same Owner as the windowed control.
The dock manager calls ReloadDockedControl to obtain a control reference that it then docks to the windowed control.</docstr>
      </procedure>
      <procedure name="ResetIme">
        <docstr>Restores the input method editor (IME) that was active when the application started.
For controls that specify the ImeName property, call ResetIme to revert to the IME that was active when the application started. If the IME was deactivated by setting the ImeMode property to imDisable, ResetIme restarts the default IME.
Applications cannot call ResetIme. ResetIme is called automatically when the control loses input focus. It is exposed as a protected method so descendant objects can restore the default IME at other times.</docstr>
      </procedure>
      <procedure name="ResetIme">
        <docstr>Restores the input method editor (IME) that was active when the application started.
For controls that specify the ImeName property, call ResetIme to revert to the IME that was active when the application started. If the IME was deactivated by setting the ImeMode property to imDisable, ResetIme restarts the default IME.
Applications cannot call ResetIme. ResetIme is called automatically when the control loses input focus. It is exposed as a protected method so descendant objects can restore the default IME at other times.</docstr>
      </procedure>
      <function name="ResetImeComposition">
        <docstr>Directs the composition window of the input method editor (IME) to perform a specific action.
Call ResetImeComposition to direct what the composition window does with the input typed by the user. The composition window is the window displayed by the IME that provides feedback to the user about what keystrokes have been typed, and how they are converted into asian characters. 
The Action parameter indicates what the composition window should do with its current contents. Action can have one of the following values:





Value

Meaning



CPS_CANCEL



Clear the composition string and set the status to no composition string.




CPS_COMPLETE



Set the composition string as the result string.




CPS_CONVERT



Convert the composition string.




CPS_REVERT



Cancel the current composition string and revert to the unconverted string.




ResetImeComposition returns true if the composition window performs the requested action.</docstr>
      </function>
      <procedure name="RequestAlign">
        <docstr>Instructs the parent of a control to reposition the control, enforcing its Align property.
Vcl.Controls.TWinControl.RequestAlign inherits from Vcl.Controls.TControl.RequestAlign. All content below this line refers to Vcl.Controls.TControl.RequestAlign.
Instructs the parent of a control to reposition the control, enforcing its Align property.
Controls call RequestAlign internally when changes are made to the size or position of the control, so that they remain properly aligned within the parent control. Do not call RequestAlign in application code.</docstr>
      </procedure>
      <procedure name="ScaleControlsForDpi">
        <docstr>Scales all the contained controls to the NewPPI value.</docstr>
      </procedure>
      <function name="GetCurrentPPIScreen">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetPixelsPerInch">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="SetPixelsPerInch">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="ScaleControls">
        <docstr>Rescale child controls only.
Call ScaleControls to rescale only the children of the control, while leaving the control itself the same size. The parameters have the same meaning as in the ScaleBy method.</docstr>
      </procedure>
      <procedure name="ScalePadding">
        <docstr>Scales the control padding to the given ratio.
Call ScalePadding to scale the padding coordinates of the control to the given M/D ratio.</docstr>
      </procedure>
      <procedure name="SelectFirst">
        <docstr>Locates first selectable child control.
Call SelectFirst to find the first child that can be selected within the control&apos;s tab order. SelectFirst calls the FindNextControl method, passing nil (Delphi) or NULL (C++) as the current control. Once the first selectable control is found, SelectFirst makes the control the active control on the form.</docstr>
      </procedure>
      <procedure name="SelectNext">
        <docstr>Moves the input focus from the current child control to the next one in the tab order.
Call SelectNext to move the child control focus. SelectNext selects the first child that follows or precedes CurControl in the tab order and that meets the criteria specified in the other parameters.
The GoForward parameter controls the direction of the search. If GoForward is true, FindNextControl searches forward through the child controls in tab order. If GoForward is false, SelectNext searches backward through the controls. The search wraps past the end of the collection back to CurControl.
The CheckTabStop parameter controls whether the control SelectNext finds must be a tab stop. If CheckTabStop is true, the returned control must have its TabStop property set to true, or the search for the next control continues.
If a child control matches the search criteria, that control obtains the focus. If no such child control is found, the focus remains unchanged.</docstr>
      </procedure>
      <procedure name="SetChildOrder">
        <docstr>Changes the order in which the child component appears in the list of child components returned by the GetChildren method.
Use SetChildOrder when you want to change the order in which child objects are streamed in. Specify the child component whose order you want to change as the value of the Child parameter. Indicate the position you want the component to be in as the value of the Order parameter.
When SetChildOrder is called, items previously below the child&apos;s old position move up, and those below the new position move down.</docstr>
      </procedure>
      <procedure name="SetIme">
        <docstr>Activates an input method editor (IME) using the values specified by the ImeMode and ImeName properties.
Applications cannot call SetIme. SetIme is called automatically when the control receives input focus. It is exposed as a protected method so that descendant objects can cause the ImeMode and ImeName properties to take effect at other times.</docstr>
      </procedure>
      <procedure name="SetIme">
        <docstr>Activates an input method editor (IME) using the values specified by the ImeMode and ImeName properties.
Applications cannot call SetIme. SetIme is called automatically when the control receives input focus. It is exposed as a protected method so that descendant objects can cause the ImeMode and ImeName properties to take effect at other times.</docstr>
      </procedure>
      <function name="SetImeCompositionWindow">
        <docstr>Sets the position and font of the composition window.
Call SetImeComposition to change the position or font of the composition window. The composition window is the window displayed by the input method editor (IME) that provides feedback to the user about what keystrokes have been typed, and how they are converted into asian characters.
The Font parameter describes the font that the composition window should use. Setting the Font parameter to nil (Delphi) or NULL (C++) repositions the composition window without changing the font. XPos and YPos specify the desired global coordinates for the composition window.
SetImeCompositionWindow returns true if the font and position are successfully assigned.</docstr>
      </function>
      <procedure name="SetParent">
        <docstr>Sets the parent of the control.
Vcl.Controls.TWinControl.SetParent inherits from Vcl.Controls.TControl.SetParent. All content below this line refers to Vcl.Controls.TControl.SetParent.
Sets the parent of the control.
SetParent is the protected implementation of the Parent property. Override SetParent to execute additional code when the value of the Parent property changes.
The AParent parameter specifies the new parent of the control.
If the control already has a parent, SetParent removes the control from that parent&apos;s list of controls by calling the parent&apos;s RemoveControl method. If AParent is not nil (Delphi) or NULL (C++), SetParent calls its InsertControl method to add the control to its list of controls.
The TControl destructor calls SetParent(nil (Delphi) or NULL (C++)) to remove the control from its parent&apos;s control list before destroying the component.</docstr>
      </procedure>
      <procedure name="SetParentBackground">
        <docstr>Sets the ParentBackground property.
SetParentBackground is a protected method that sets the value of ParentBackground.</docstr>
      </procedure>
      <procedure name="SetParentDoubleBuffered">
        <docstr>Sets the ParentBackground property.
SetParentDoubleBuffered is a protected method that sets the value of ParentDoubleBuffered.</docstr>
      </procedure>
      <procedure name="SetZOrder">
        <docstr>Moves the control to the top or bottom of the parent control&apos;s (or screen&apos;s) list of TWinControl controls.
Use SetZOrder to rearrange overlapping controls within a parent control or (if the control has no parent) overlapping windows on the screen. If the TopMost parameter is true, the control becomes the top control; otherwise, it becomes the bottom control. 
TWinControl controls always stack on top of other controls, regardless of the Z order.
After changing the order, SetZOrder invalidates the control to ensure repainting to reflect the new order.</docstr>
      </procedure>
      <procedure name="ShowControl">
        <docstr>Ensures that a specified child control is visible.
Call ShowControl to display a child control. Specify the control you want to ensure will be visible as the value of the AControl parameter.
As implemented in TWinControl, ShowControl simply calls the ShowControl method of the control&apos;s parent. Derived objects override ShowControl to perform whatever actions are necessary to allow the indicated child object to be visible. Possible actions include scrolling the particular child object into view, or changing to the appropriate notebook page.</docstr>
      </procedure>
      <procedure name="UpdateBounds">
        <docstr>Updates the bounds of the control.
UpdateBounds is a protected method that updates the bounds of the control.</docstr>
      </procedure>
      <procedure name="UpdateControlOriginalParentSize">
        <docstr>Updates the original size of the parent control.
UpdateControlOriginalParentSize is a protected method that updates the original size of the parent control. It is used internally to update the anchor rules of the control.</docstr>
      </procedure>
      <procedure name="UpdateRecreatingFlag">
        <docstr>Toggles the csRecreating flag in the ControlState property.
Switches on or off the csRecreating flag in the ControlState property, if the Recreating parameter is True or False, correspondingly.
If the control has any children, then the UpdateRecreatingFlag method is applied to all the children, using the same Recreating parameter.</docstr>
      </procedure>
      <procedure name="UpdateTIPStatus">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="UpdateUIState">
        <docstr>Updates form User Interface State as needed
UpdateUIState is called in component code to ensure that the User Interface State is consistently updated. User Interface State determinates whether keyboard accelerators and focus indicators are hidden or shown. A control should call UpdateUIState whenever it receives a keyboard event that might invalidate the User Interface State. CharCode is the virtual key code of the keyboard event.</docstr>
      </procedure>
      <procedure name="WndProc">
        <docstr>Provides specific message responses for the control.
Override WndProc to change the initial Windows message handler for the control. The WindowProc property is initialized to point to the WndProc method.
WndProc for TWinControl overrides the inherited method to define responses for focus, mouse, and keyboard messages. It sends all others to its inherited WndProc.
When overriding WndProc to provide specialized responses to messages, call the inherited WndProc at the end to dispatch any unhandled messages.</docstr>
      </procedure>
      <procedure name="CreateSubClass">
        <docstr>Creates a windowed control derived from an existing Windows window class.
Call CreateSubClass in the CreateParams method of a subclassed control, after calling the inherited CreateParams. Specify the parameter record as the value of the Params parameter. CreateSubClass allows VCL controls to create registered Windows controls.</docstr>
      </procedure>
      <procedure name="RemoveWindowProps">
        <docstr>Removes the ControlAtom and WindowAtom properties of the control.
Call RemoveWindowProps to remove the ControlAtom and WindowAtom properties of the control.</docstr>
      </procedure>
      <function name="GetAllocatedWindowHandle">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <property name="AlignControlList">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="BevelEdges">
        <docstr>Specifies which edges of the control are beveled.
Use BevelEdges to get or set which edges of the control are beveled. The BevelInner, BevelOuter, and BevelKind properties determine the appearance of the specified edges.</docstr>
      </property>
      <property name="BevelInner">
        <docstr>Specifies the cut of the inner bevel.
Use BevelInner to specify whether the inner bevel has a raised, lowered, or flat look. 
The inner bevel appears immediately inside the outer bevel. If there is no outer bevel (BevelOuter is bvNone), the inner bevel appears immediately inside the border.</docstr>
      </property>
      <property name="BevelOuter">
        <docstr>Specifies the cut of the outer bevel.
Use BevelOuter to specify whether the outer bevel has a raised, lowered, or flat look.
The outer bevel appears immediately inside the border and outside the inner bevel.</docstr>
      </property>
      <property name="BevelKind">
        <docstr>Specifies the control&apos;s bevel style.
Use BevelKind to modify the appearance of a bevel. BevelKind influences how sharply the bevel stands out.
BevelKind, in combination with BevelWidth and the cut of the bevel specified by BevelInner or BevelOuter, can create a variety of effects. Experiment with various combinations to get the look you want.</docstr>
      </property>
      <property name="BevelWidth">
        <docstr>Specifies the width of the inner and outer bevels.
Use BevelWidth to specify the width, in pixels, of the inner and outer bevels.</docstr>
      </property>
      <property name="BorderWidth">
        <docstr>Specifies the width of the control&apos;s border.
Use BorderWidth to get or set the width of the control&apos;s border. Graphics or text drawn by the control is clipped to the area within the border.</docstr>
      </property>
      <property name="Ctl3D">
        <docstr>Determines whether a control has a three-dimensional (3-D) or two-dimensional look.
Ctl3D is provided for backward compatibility. It is not used by 32-bit versions of Windows or NT4.0 and later, with the exception of Windows XP Home, where it is used on occasion.
On earlier platforms, Ctl3D controlled whether the control had a flat or beveled appearance.


Note RAD Studio no longer supports Windows Vista or earlier.</docstr>
      </property>
      <property name="ImeMode">
        <docstr>Determines the behavior of the input method editor (IME).
Set ImeMode to configure the way an IME processes user keystrokes. An IME is a front-end input processor for Asian language characters. The IME hooks all keyboard input, converts it to Asian characters in a conversion window, and sends the converted characters or strings on to the application. 
ImeMode allows a control to influence the type of conversion performed by the IME so that it is appropriate for the input expected by the control. For example, a control that only accepts numeric input might specify an ImeMode of imClose, as no conversion is necessary for numeric input.

Note:  The value of ImeMode only takes effect when the control receives focus. To change the value of ImeMode when the control already has input focus, call the SetIme method.</docstr>
      </property>
      <property name="ImeName">
        <docstr>Specifies the input method editor (IME) to use for converting keyboard input to Asian language characters.
Set ImeName to specify which IME to use for converting keystrokes. An IME is a front-end input processor for Asian language characters. The IME hooks all keyboard input, converts it to Asian characters in a conversion window, and sends the converted characters or strings on to the application.
ImeName must specify one of the IMEs that has been installed through the Windows control panel. The property inspector provides a drop-down list of all currently installed IMEs on the system. At runtime, applications can obtain a list of currently installed IMEs from the global Screen variable.
If ImeName specifies an unavailable IME, the IME that was active when the application started is used instead. No exception is generated.

Note:  The value of ImeName only takes effect when the control receives focus. To change the value of ImeName after the control has input focus, call the SetIme method.</docstr>
      </property>
      <property name="ParentBackground">
        <docstr>Determines whether the control uses its parent&apos;s theme background.
If ParentBackground is True, the control uses the parent&apos;s theme background to draw its own background. 
If  ParentBackground is False, the control uses its own properties, such as Color, to draw its background.
ParentBackground has no effect unless XP themes are enabled.</docstr>
      </property>
      <property name="ParentCtl3D">
        <docstr>Determines where a component looks to determine whether it should have a three-dimensional look.
ParentCtl3D is provided for backwards compatibility. It has no effect on 32-bit versions of Windows or NT 4.0 and later.
ParentCtl3D determines whether the control uses its parent&apos;s Ctl3D property.</docstr>
      </property>
      <property name="TipMode">
        <docstr>TipMode indicates whether TabTip (onscreen keyboard equivalent) opens or closes when the control receives focus or if it receives a gesture. 
For example, in controls derived from TButtonControl the default mode is tipClose, so TabTip is instructed to disappear when the control receives focus or a gesture. The default for controls derived from TCustomEdit is tipOpen.

Note: The above applies only to devices that have touch screen support</docstr>
      </property>
      <property name="DefWndProc">
        <docstr>Specifies the default window procedure for the windowed control.
Windowed controls use the Windows API function CallWindowProc with DefWndProc to invoke the standard Windows message handling for a window message. Using DefWndProc instead of the WndProc method bypasses any message processing introduced by the WndProc method.
DefWndProc fills the role for windowed controls that DefaultHandler fills for all objects. The DefaultHandler for TWinControl uses DefWndProc to pass messages to Windows for processing.
For windowed controls, DefWndProc is initially set to the window procedure of the window class specified in the Params parameter in the CreateParams method. Change DefWndProc to subclass the window class of a windowed control.</docstr>
      </property>
      <property name="WindowHandle">
        <docstr>Provides access to a window handle for the control.
The WindowHandle property provides access to the same window handle as the Handle property, but WindowHandle is protected, and therefore only accessible to code inside the control.
The advantage to using WindowHandle is that it can be written to, while the Handle property is read-only. Use WindowHandle when implementing methods that need to change the value of the control&apos;s window handle. Unlike the Handle property, reading the value of WindowHandle doesn&apos;t automatically create a valid handle. Reading WindowHandle can return a zero value.</docstr>
      </property>
      <event name="OnAlignInsertBefore">
        <docstr>Occurs when an object with custom alignment is aligned.
OnAlignInsertBefore occurs for each pair of child controls with an Align property of alCustom.
It can determine the order in which custom-aligned child controls are placed. OnAlignInsertBefore returns true if C2 should be presented before C1, and false otherwise. It holds a TAlignInsertBeforeEvent type.
CustomAlignInsertBefore triggers the OnAlignInsertBefore event. If this event is defined, CustomAlignInsertBefore returns the value returned by OnAlignInsertBefore. Defining this event allows users to define the order of control alignment without overriding CustomAlignInsertBefore.</docstr>
      </event>
      <event name="OnAlignPosition">
        <docstr>Occurs when an object with custom alignment is aligned.
OnAlignPosition occurs when child controls with an Align property of alCustom are aligned.
CustomAlignPosition triggers the OnAlignPosition event. If this event is defined, CustomAlignPosition uses the alignment parameters it obtains from OnAlignPosition. Defining this event allows users to set the alignment parameters without overriding CustomAlignPosition. It holds a TAlignPositionEvent type.
These are the parameters:





Parameter

Meaning



NewLeft | NewTop | NewWidth | NewHeight



Location and size of child control, as determined by container&apos;s size and the Anchors TControl_Anchors constraints for the control. OnAlignPosition can modify these values to reposition the control.




AlignRect



The client area in which the control is aligned. OnAlignPosition can modify this value.




AlignInfo



Alignment information in a TAlignInfo.




As implemented in TWinControl, OnAlignPosition does nothing.</docstr>
      </event>
      <event name="OnDockDrop">
        <docstr>Occurs when another control is docked to the control.
Write code in the OnDockDrop event to perform actions when another control is docked on the control.
OnDockDrop can only occur if DockSite is true.
OnDockDrop is an event handler of type Vcl.Controls.TDockDropEvent.</docstr>
      </event>
      <event name="OnDockOver">
        <docstr>Occurs when another control is dragged over the control.
Write code in the OnDockOver event to indicate whether a dockable control that is dragged over the windowed control can be accepted as a dock client. OnDockOver occurs after the TDragDockObject has been initialized by an OnGetSiteInfo event.
OnDockOver occurs only if DockSite is true.</docstr>
      </event>
      <event name="OnEnter">
        <docstr>Occurs when a control receives the input focus.
Use the OnEnter event handler to cause any special processing to occur when a control becomes active.
The OnEnter event does not occur when switching between forms or between another application and the application that includes the control.
When switching between controls in separate container controls such as the TPanel and the TGroupBox controls, an OnEnter event occurs for the container before the OnEnter event of the contained control.
Similarly, an OnExit event of the container occurs after the OnExit event of the control in a container when focus moves to another control outside the container.
For example, consider a form with an OK button and a group box that contains three radio buttons, where focus is currently on the OK button. When the user clicks one of the radio buttons, an OnExit event of the button occurs, followed by an OnEnter event on the group box, and finally an OnEnter event on the radio button that was clicked. If the user then clicks on the OK button, an OnExit event for the radio button occurs followed by an OnExit event for the group box, and then the button&apos;s OnEnter event occurs.
OnEnter is an event handler of type System.Classes.TNotifyEvent.</docstr>
      </event>
      <event name="OnExit">
        <docstr>Occurs when the input focus shifts away from one control to another.
Use the OnExit event handler to provide special processing when the control ceases to be active. 
The OnExit event does not occur when switching between forms or between another application and your application.
When switching between controls in separate container controls such as the TPanel and the TGroupBox controls, an OnExit event occurs for the control inside the container before the OnExit event of the container.
Similarly, an OnEnter event of the container occurs before the OnEnter event of the control in a container when the focus moves to a control inside a container.
For example, consider a form with an OK button and a group box that contains three radio buttons, where the focus is currently on the OK button. When the user clicks one of the radio buttons, an OnExit event on the button occurs, followed by an OnEnter event on the group box, and finally an OnEnter event on the radio button that was clicked. If the user then clicks the OK button, an OnExit event for the radio button occurs followed by an OnExit event for the group box, and then the button&apos;s OnEnter event occurs.

Note: In some control classes, the ActiveControl property updates before the OnExit event occurs.
OnExit is an event handler of type TNotifyEvent.</docstr>
      </event>
      <event name="OnGetSiteInfo">
        <docstr>Returns the control&apos;s docking information.
Write code in the OnGetSiteInfo event handler to initialize a TDragDockObject with information about where a dragged object can be docked, if at all. OnGetSiteInfo occurs before the OnDockOver event.
OnGetSiteInfo occurs only if DockSite is true.
OnGetSiteInfo is an event handler of type Vcl.Controls.TGetSiteInfoEvent.  See TGetSiteInfoEvent for a description of the parameters.</docstr>
      </event>
      <event name="OnKeyDown">
        <docstr>Occurs when a user presses any key while the control has focus.
Use the OnKeyDown event handler to specify special processing to occur when a key is pressed. The OnKeyDown handler can respond to keyboard keys, including function keys and keys combined with the SHIFT, ALT, and CTRL keys, and pressed mouse buttons.

Note: TCheckBox does not fire OnKeyDown events for arrow keys.
OnKeyDown is an event handler of type Vcl.Controls.TKeyEvent.  See TKeyEvent for a description of the parameters.
An application gets Windows WM_KEYDOWN messages for all keys when the user presses a key. These messages indirectly fire the OnKeyDown event. Setting the Key parameter to #0 prevents any further processing of this message. But for keys that generate characters Windows also produces WM_CHAR. At the time your OnKeyDown event fires, the WM_CHAR message for the key will already be in the message queue. Setting Key to #0 does not stop it from being delivered, so it fires the OnKeyPress event. If you set the Key to #0, OnKeyPress will be prevented from being fired only for keys that do not have chars. For keys that represent characters, OnKeyPress will continue to be fired. 
This method of organizing key processing has advantages. Code that only deals with characters, including control characters like #13 for carriage return, #3 for CTRL-C, and so on, should go into the OnKeyPress event. Code that deals with keys that do not generate characters should be put into the OnKeyDown event.</docstr>
      </event>
      <event name="OnKeyPress">
        <docstr>Occurs when a key is pressed.
Use the OnKeyPress event handler to make something happen as a result of a single character key press. 
The Key parameter in the OnKeyPress event handler is of type Char; therefore, the OnKeyPress event registers the ASCII character of the key pressed. Keys that do not correspond to an ASCII Char value (SHIFT or F1, for example) do not generate an OnKeyPress event. Key combinations (such as SHIFT+A) generate only one OnKeyPress event (for this example, SHIFT+A results in a Key value of &quot;A&quot; if Caps Lock is off). To respond to non-ASCII keys or key combinations, use the OnKeyDown or OnKeyUp event handler. 
An application gets Windows WM_KEYDOWN messages for all keys when the user presses a key. These messages indirectly fire the OnKeyDown event. Setting the Key parameter to #0 prevents any further processing of this message. But for keys that generate characters Windows also produces WM_CHAR. At the time your OnKeyDown event fires, the WM_CHAR message for the key will already be in the message queue. Setting Key to #0 does not stop it from being delivered, so it fires the OnKeyPress event. If you set the Key to #0, OnKeyPress will be prevented from being fired only for keys that do not have chars. For keys that represent characters, OnKeyPress will continue to be fired. 
This method of organizing key processing has advantages. Code that only deals with characters, including control characters like #13 for carriage return, #3 for CTROL-C, and so on, should go into the OnKeyPress event. Code that deals with keys that do not generate characters should be put into the OnKeyDown event. 
OnKeyPress is an event handler of type Vcl.Controls.TKeyPressEvent.</docstr>
      </event>
      <event name="OnKeyUp">
        <docstr>Occurs when the user releases a key that was pressed.
Use the OnKeyUp event handler to provide special processing that occurs when a key is released. The OnKeyUp handler can respond to all keyboard keys, keys that represent characters, function keys, and keys combined with the SHIFT, ALT, and CTRL keys.
If Key is set to #0, any further processing of the OnKeyUp event will be prevented. 
OnKeyUp is an event handler of type Vcl.Controls.TKeyEvent.  See TKeyEvent for a description of the parameters.</docstr>
      </event>
      <event name="OnUnDock">
        <docstr>Occurs when the application tries to undock a control that is docked to the windowed control.
Write an OnUnDock event handler to adjust the windowed control when a dock client is undocked. The OnUnDock event handler can make any necessary adjustments, or it can block the undock attempt by setting the Allow parameter to false.
OnUnDock is an event handler of type Vcl.Controls.TUnDockEvent.</docstr>
      </event>
      <constructor name="Create">
        <docstr>Creates an instance of TWinControl.
Call Create to construct and initialize a new control and insert the newly-constructed control into its owner, as specified by the AOwner parameter. Create inserts the control in the owner by calling the owner&apos;s InsertComponent method. 
Most controls override Create to initialize their unique properties. Objects that override the Create method must always call the inherited Create method first, and then proceed with the component-specific initialization. Specify the override directive when overriding the Create method.
If a component&apos;s Create method allocates resources or memory, override the Destroy method to free those resources.</docstr>
      </constructor>
      <function name="CreateParentedControl">
        <docstr>Creates and initializes a control as the child of a specified non-VCL window.
Call CreateParentedControl to embed a new control in a non-VCL parent. 
CreateParentedControl allocates memory for a new instance of the same class as the control (Delphi) or is the class specified by the vmt parameter (C++), sets its ParentWindow property to ParentWindow, and calls the constructor, passing in nil (Delphi) or NULL (C++) for the Owner parameter. CreateParentedControl returns the newly created control.
CreateParentedControl has the same purpose as CreateParented, but is a simple class function instead of a constructor. Unlike CreateParented, CreateParentedControl can be called from C++ code.</docstr>
      </function>
      <destructor name="Destroy">
        <docstr>Destroys an instance of TWinControl.
Do not call Destroy directly in an application. Instead, call Free. Free verifies that the TWinControl reference is not nil, and only then calls Destroy.</docstr>
      </destructor>
      <procedure name="ScaleForPPI">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Broadcast">
        <docstr>Sends a message to each of the child controls.
Use Broadcast when you want to send the same message to each of the child controls contained within the windowed control. Specify the message to be passed as the value of the Message parameter.</docstr>
      </procedure>
      <function name="CanFocus">
        <docstr>Indicates whether a control can receive focus.
Call CanFocus to find out if the control can receive input from the user.
CanFocus returns true if both the control and its parent(s) have their Visible and Enabled properties set to true. If any of the Visible and Enabled properties of the control or the controls in which it is contained are not true, then CanFocus returns false.</docstr>
      </function>
      <function name="ContainsControl">
        <docstr>Indicates whether a specified control exists within the control.
Use ContainsControl to find out if a particular control exists within this control. ContainsControl returns true if the specified value of the Control parameter is a child control of this control. The Control parameter need not be an immediate child (in the Controls property), but may be contained in a child of the control, or in a child of a child of the control, for indefinitely many levels deep.
If the method returns false, the specified control is not within the control.</docstr>
      </function>
      <function name="ControlAtPos">
        <docstr>Returns the child control located at a specified position within the control.
Use ControlAtPos to determine which child control is at the specified location within the control. ControlAtPos returns an immediate child of the control; that is, one of the entries of the Controls property, that has this control for its Parent property.
Specify the position in client coordinates as the value of the Pos parameter. Pos can be anywhere within the boundaries of the child control, not just the upper left corner.
The AllowDisabled parameter determines whether the search for controls includes disabled controls.
The AllowWinControls parameter determines whether descendants of TWinControl are considered when looking for the child control.
If there is no control that matches the AllowDisabled and AllowWinControls parameters at the specified position, ControlAtPos returns nil (Delphi) or NULL (C++).</docstr>
      </function>
      <procedure name="DefaultHandler">
        <docstr>Provides message handling for all messages that the control does not fully process by itself.
Override DefaultHandler to change the default message handling for the control. The Message parameter can be cast to a TMessage type, to obtain the WParam, LParam, and Result of the message. If the Result of the message is non-zero, the message has already been handled. Set the Result field to a non-zero value to prevent further processing of the message by the inherited method.

Note:  In Delphi code, calling inherited in a message-handling method results in a call to the ancestor&apos;s DefaultHandler method unless that ancestor specifies an explicit handler for the message. 
TWinControl overrides the TControl DefaultHandler method to handle messages for all its descendant types. DefaultHandler passes any otherwise-unhandled messages to the control&apos;s window procedure using the CallWindowProc API function.</docstr>
      </procedure>
      <procedure name="DisableAlign">
        <docstr>Disables the realignment of child controls.
Call DisableAlign to temporarily prevent child controls from realigning. For example, while performing multiple manipulations of controls, such as reading from a form file or scaling, performance improves if child controls are not realigned until all manipulations are complete. The EnableAlign method restores normal child realignment.
Every call to DisableAlign must be followed by a matching call to EnableAlign. If an exception could be raised after the call to DisableAlign, use an exception block to ensure that EnableAlign will always be called.
DisableAlign/EnableAlign call sequences can be nested. An internal counter records the level of nesting. As long as the counter is positive, realignment is disabled and the AlignDisabled property returns true. Once the counter returns to zero, realignment is enabled and AlignDisabled returns false.</docstr>
      </procedure>
      <property name="DockClientCount">
        <docstr>Specifies the number of controls that are docked on the windowed control.
Use DockClientCount to get the number of controls that are docked to the windowed control. This value can be used as an upper bound when iterating through the DockClients property.

Note:  The DockClients property can contain controls that are not visible. To get the number of docked clients that are visible, use the VisibleDockClientCount property instead.</docstr>
      </property>
      <procedure name="DockDrop">
        <docstr>Generates an OnDockDrop event.
DockDrop is called automatically when a control is docked to the windowed control. It instructs the control that is being dropped to prepare for the dock operation and then generates an OnDockDrop event.
Although you can override DockDrop to perform actions in addition to the generated OnDockDrop event, typically descendant classes override the DoAddDockClient method instead. This is because DoAddDockClient is called by the client after it has performed its own preparations, but before the OnDockDrop event.
DockDrop is called only if DockSite is True.</docstr>
      </procedure>
      <property name="DockSite">
        <docstr>Specifies whether the control can be the target of drag-and-dock operations.
Set DockSite to true to allow other controls to be docked to this windowed control.

Code Examples
Docking (Delphi)
Docking (C++)</docstr>
      </property>
      <property name="DockManager">
        <docstr>Specifies the control&apos;s docking manager interface.
Use DockManager to specify the control&apos;s docking manager. The docking manager handles the layout of docking zones (where controls are docked) and any painting associated with docking zones.
If you set DockSite and UseDockManager to true, but do not assign a value to DockManager, the windowed control generates a default docking manager, using the global DefaultDockTreeClass variable.</docstr>
      </property>
      <property name="DoubleBuffered">
        <docstr>Determines whether the control&apos;s image is rendered directly to the window or painted to an in-memory bitmap first.
When DoubleBuffered is false, the windowed control paints itself directly to the window. When DoubleBuffered is true, the windowed control paints itself to an in-memory bitmap that is then used to paint the window. Double buffering reduces the amount of flicker when the control repaints, but is more memory intensive.
When a windowed control is a dock site and has an associated dock manager, it must be double-buffered.

Note:  Some controls, such as TRichEdit, can&apos;t paint themselves into a bitmap. For such controls, DoubleBuffered must be set to false.</docstr>
      </property>
      <procedure name="EnableAlign">
        <docstr>Decrements the reference count incremented by the DisableAlign method, eventually realigning the child controls.
Call EnableAlign to allow child controls within the control to realign again after they were prevented from realigning by a call to DisableAlign. 
Each time the DisableAlign method is called, it increments a reference count. Each time EnableAlign is called, it decrements the same reference count. When the reference count reaches zero, EnableAlign calls the Realign method to perform any pending realignments.
Be sure to pair each call to DisableAlign with a call to EnableAlign. If an exception could be raised after the call to DisableAlign, use an exception block to ensure that the corresponding call to EnableAlign is executed.</docstr>
      </procedure>
      <function name="FindChildControl">
        <docstr>Returns a child control given its name.
Call FindChildControl to locate a specified child control. FindChildControl searches the control&apos;s children and returns the control with the specified name. If no child controls match the specified name, FindChildControl returns nil (Delphi) or NULL (C++).

Note: FindChildControl only locates immediate children of the control. It can&apos;t find a control that is a child of one of the control&apos;s children.</docstr>
      </function>
      <procedure name="FlipChildren">
        <docstr>Reverses the positions of child controls.
Call FlipChildren to flip the control&apos;s children; that is, to move children on the left side of the control to the right side and vice versa. FlipChildren reverses the position of all child controls and adjusts their Align properties, if necessary, to enforce the new position.
AllLevels specifies whether FlipChildren should be called recursively on the control&apos;s children.
FlipChildren can be used to reverse the layout of an application when it is running in Middle Eastern locales where users read from right to left instead of left to right: Call UseRightToLeftAlignment to determine whether the BiDiMode property dictates a reversal of alignment based on the system locale.

Note: FlipChildren does the same thing as the Flip Children command on the control&apos;s context menu in the IDE.</docstr>
      </procedure>
      <function name="Focused">
        <docstr>Determines whether the control has input focus.
Use the Focused method to see if the control is the active control. When Focused returns true, the control has the input focus. If Focused returns false, the user cannot interact with the control.</docstr>
      </function>
      <procedure name="GetChildren">
        <docstr>Calls a specified method for each child of the control.
GetChildren is called by the streaming system that loads and saves components. Applications seldom need to call this routine.
GetChildren executes the callback specified by the Proc parameter for every child control listed by the Controls property that lists the Root parameter as its Owner.
Override GetChildren to limit or augment which child controls are saved with the control. When overriding GetChildren, call the procedure passed as the Proc parameter for every child control that should be saved. The Root parameter indicates the component (usually a form) that owns the control.</docstr>
      </procedure>
      <procedure name="GetTabControlList">
        <docstr>Builds a list of owned controls.
Call GetTabControlList to construct a list of child controls.
GetTabControlList iterates through the control&apos;s internal tab order list, adding each of the child controls to List. The result is a list of all the owned controls in TabOrder.</docstr>
      </procedure>
      <procedure name="GetTabOrderList">
        <docstr>Builds a list of controls in tab order.
Call GetTabOrderList to construct a list of child controls in tab order.
GetTabOrderList iterates through the control&apos;s internal tab order list, adding each of the child controls to List, including any controls contained in those controls. The result is a list of all the controls and their owned controls, in tab order.
The FindNextControl method calls GetTabOrderList to build a complete list of the controls that FindNextControl uses to locate the next control in the tab order.</docstr>
      </procedure>
      <function name="HandleAllocated">
        <docstr>Reports whether a screen object handle exists for the control.
Query HandleAllocated to find out if the control&apos;s underlying screen object has been generated.
If the screen object exists, HandleAllocated returns true. If the screen object does not exist, HandleAllocated returns false. Testing the Handle property of a control directly causes the window to be created if it does not already exist. Call the HandleAllocated method to determine whether a window exists without creating one as a side effect.</docstr>
      </function>
      <procedure name="HandleNeeded">
        <docstr>Creates a screen object for the control if it doesn&apos;t already exist.
Call HandleNeeded to create a screen object for the control.
If the screen object does not exist, HandleNeeded calls the CreateHandle method for the parent of the control before it creates a screen object for this control.</docstr>
      </procedure>
      <procedure name="InsertControl">
        <docstr>Inserts a control into the Controls array property.
Applications should not need to call InsertControl directly. Child controls are automatically inserted and removed when added or deleted at design time. At run time, use the Parent property of the child control to insert it in the Controls array. If the child control is already the child of another control, setting the Parent property ensures that the child is removed from the Controls of the original parent.
InsertControl makes the inserted control a child, and the containing control the parent. The AControl parameter is the child control that is inserted into the Controls array.</docstr>
      </procedure>
      <procedure name="Invalidate">
        <docstr>Schedules a control repaint.
Invalidate informs a control that its entire surface needs to be repainted. Calling Invalidate can prevent flicker caused by a series of partial repaints. There is no performance penalty for calling Invalidate multiple times before the control is actually repainted.
The actual repaint does not occur until the control is updated. To force an immediate repaint, call Repaint instead.</docstr>
      </procedure>
      <procedure name="PaintTo">
        <docstr>Draws the windowed control to a device context.
Call PaintTo to draw the control on a device context. Specify the device context as the value of the DC parameter and specify the X and Y coordinates on the device context where the top-left corner of the windowed control is to be drawn. PaintTo first erases the background of the device context and then paints the control.
PaintTo is useful for drawing an image of the control into a bitmap DC.

Warning:  When using PaintTo to draw on a canvas, you must lock the canvas first (and unlock it after the call to PaintTo. If you do not lock the canvas, Windows calls that occur while the control is painting can cause the canvas to lose its handle.</docstr>
      </procedure>
      <procedure name="PaintTo">
        <docstr>Draws the windowed control to a device context.
Call PaintTo to draw the control on a device context. Specify the device context as the value of the DC parameter and specify the X and Y coordinates on the device context where the top-left corner of the windowed control is to be drawn. PaintTo first erases the background of the device context and then paints the control.
PaintTo is useful for drawing an image of the control into a bitmap DC.

Warning:  When using PaintTo to draw on a canvas, you must lock the canvas first (and unlock it after the call to PaintTo. If you do not lock the canvas, Windows calls that occur while the control is painting can cause the canvas to lose its handle.</docstr>
      </procedure>
      <property name="PixelsPerInch">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <function name="PreProcessMessage">
        <docstr>Returns False, no matter the value of Msg.
As a member of the TWinControl class, PreProcessMessage always returns False, no matter the value of Msg.

Note:  When overriding PreProcessMessage in descendant classes, we recommend to implement it such that it returns True if Msg is a preprocess message, and False otherwise.</docstr>
      </function>
      <procedure name="RemoveControl">
        <docstr>Removes a specified control from the Controls array.
RemoveControl removes a child control from the Controls property. After calling RemoveControl, the control is no longer the parent of the child specified by the AControl parameter. 
Applications should not call RemoveControl directly. Child controls are automatically inserted and removed when added or deleted at design time. At runtime, use the Parent property of the child control to remove it from the Controls array.</docstr>
      </procedure>
      <procedure name="Realign">
        <docstr>Forces the control to realign children.
The EnableAlign method calls Realign when the reference count reaches zero. It adjusts the size and position of any child controls according to their Align properties.
If all of the child controls have their Align properties set to alNone, Realign has no effect.</docstr>
      </procedure>
      <procedure name="Repaint">
        <docstr>Repaints the entire control.
Call Repaint to repaint the control.
As implemented in TWinControl, Repaint calls the Invalidate method and then the Update method to repaint the control.</docstr>
      </procedure>
      <procedure name="ScaleBy">
        <docstr>Rescale control and its children.
ScaleBy resizes a control without moving its upper left corner. This is similar to changing the Height and Width properties, but the control also attempts to rescale and rearrange any child controls to maintain their relative size and placement.
The M and D parameters define a multiplier and divisor by which to scale the control. For example, to make a control 75% of its original size, specify the value of M as 75, and the value of D as 100. Any pair of values that has the same ratio has the same effect. Thus M = 3 and D = 4 also makes the control 75% of its previous size.
To rescale the control&apos;s children without rescaling the control itself, use ScaleControls.</docstr>
      </procedure>
      <procedure name="ScrollBy">
        <docstr>Scroll control contents.
Call ScrollBy to scroll the contents within the control. While ScrollBy can be used for any TWinControl, it makes the most sense to use it for descendants of TScrollingWinControl.
Applications seldom need to call the ScrollBy method unless they implement their own scrolling interface rather than relying on a scroll bar.
The DeltaX parameter is the change in pixels along the X axis. A positive DeltaX value scrolls the contents to the right; a negative value scrolls the contents to the left. The DeltaY parameter is the change in pixels along the Y axis. A positive DeltaY value scrolls the contents down; a negative value scrolls the contents up.</docstr>
      </procedure>
      <procedure name="SetBounds">
        <docstr>Sets the windowed control&apos;s boundary properties all at once.
Use SetBounds to change all of the control&apos;s boundary properties at once. The same effect can be achieved by setting the Left, Top, Width, and Height properties separately. By setting all four properties at once, SetBounds ensures that the control will not repaint between changes
Specify the values for the Left, Top, Width, and Height properties as the value of the ALeft, ATop, AWidth, and AHeight parameters, respectively.</docstr>
      </procedure>
      <procedure name="SetDesignVisible">
        <docstr>Makes a control visible at design time.
Vcl.Controls.TWinControl.SetDesignVisible inherits from Vcl.Controls.TControl.SetDesignVisible. All content below this line refers to Vcl.Controls.TControl.SetDesignVisible.
Makes a control visible at design time.
SetDesignVisible is used internally by Delphi during form design.</docstr>
      </procedure>
      <procedure name="SetFocus">
        <docstr>Gives the input focus to the control.
Use SetFocus to change input focus to the control. When a control has focus, it receives keyboard events.</docstr>
      </procedure>
      <procedure name="Update">
        <docstr>Forces the control to update.
Update repaints any part of the control surface that is out of date. Normally, updates occur automatically, but an Update call may be necessary before lengthy processing that might interfere with automatic updates. Calling Update unnecessarily can increase overhead and cause screen flicker.
Update only repaints areas of the control the have been determined to be out of date. To force immediate repainting of the entire control, call the Repaint method. To notify a control that it is out of date (without forcing an immediate repaint), call the Invalidate method.</docstr>
      </procedure>
      <procedure name="UpdateControlState">
        <docstr>Respond to state change.
UpdateControlState is called automatically when any display change occurs that might affect the internal state of the control.
As implemented in TWinControl, UpdateControlState climbs the chain of parent controls to verify that each control in the chain has Showing equal to true. If this is the case, UpdateControlState makes sure that the Showing property is accurate for this control and for all its descendants. Descendant classes can extend this behavior.</docstr>
      </procedure>
      <procedure name="LockDrawing">
        <docstr>Call LockDrawing method to prevent changes in that control from being redrawn. To resume redrawing call UnlockDrawing method. If to recreate a window handle after a LockDrawing call, the control will remain locked until the corresponding UnlockDrawing call. 
LockDrawing / UnlockDrawing calls may be nested.</docstr>
      </procedure>
      <procedure name="UnlockDrawing">
        <docstr>Call UnlockDrawing method to allow changes in that control to be redrawn. 
LockDrawing / UnlockDrawing calls may be nested.</docstr>
      </procedure>
      <property name="AlignDisabled">
        <docstr>Indicates child control realignment disabled.
AlignDisabled returns true if child control realignment has been temporarily disabled by a call to DisableAlign.</docstr>
      </property>
      <property name="MouseInClient">
        <docstr>Indicates whether the mouse pointer is currently in the client area of the control.
Use MouseInClient to check whether the mouse pointer is currently located in the client area of the control. MouseInClient is also used internally to fire the OnMouseEnter and OnMouseLeave events.</docstr>
      </property>
      <property name="VisibleDockClientCount">
        <docstr>Specifies the number of visible controls that are docked on the windowed control.
Use VisibleDockClientCount to determine the number of controls in the DockClients list that have a Visible property value of true. This value is less than or equal to the value of DockClientCount.</docstr>
      </property>
      <property name="Brush">
        <docstr>Determines the color and pattern used for painting the background of the control.
The Brush property accesses the TBrush object that determines pattern and color for the control background. Brush is a read-only property, but an application can manipulate the TBrush object by setting its properties or by using its Assign method.</docstr>
      </property>
      <property name="ControlCount">
        <docstr>Returns the number of child controls.
Read ControlCount when iterating over all the children of this control. The children of the control are listed in the Controls property array.
ControlCount is a read-only property.

Note:  The value of ControlCount is always 1 greater than the highest Controls index, because the first Controls index is 0.</docstr>
      </property>
      <property name="Handle">
        <docstr>Provides access to the underlying Windows screen object for the control.
The Handle property returns the window handle for the underlying Microsoft Windows screen object. Use the Handle property to bypass the VCL API and directly access the underlying window.
Do not refer to the Handle property during component creation or streaming. The underlying window does not exist until the first time the Handle property is referenced. When this occurs, the HandleNeeded method is called automatically.
Handle is a read-only property.

Note: On Win64, the size of HANDLE types has changed to 64-bits --except for OLE_HANDLE, which is now a 32bit Long even in Win64. This means that you need to change any code that assumed OLE_HANDLE and other HANDLE types are interchangeable. See also http://stackoverflow.com/questions/401812/what-is-the-proper-way-to-cast-from-an-ole-handle-to-an-hicon.</docstr>
      </property>
      <property name="Padding">
        <docstr>Specifies the padding of a control.
Use Padding to specify the padding of a control. This value is an instance of the class TPadding.</docstr>
      </property>
      <property name="ParentDoubleBuffered">
        <docstr>ParentDoubleBuffered defers the DoubleBuffered property of this component to the value of the parent&apos;s DoubleBuffered property.
ParentDoubleBuffered is a boolean indicating that the DoubleBuffered property of this component is overridden by the value of the parent&apos;s DoubleBuffered property.</docstr>
      </property>
      <property name="ParentWindow">
        <docstr>Reference to parent&apos;s underlying control.
ParentWindow refers to the window handle that underlies the parent control. To designate a non-VCL control as a parent, assign that control&apos;s handle to ParentWindow. This assignment causes the control to be moved into the parent&apos;s screen area. Setting ParentWindow has no effect if Parent is not nil (Delphi) or NULL (C++).
TActiveXControl objects use ParentWindow to insert a control in an ActiveX container window. ParentWindow is set automatically when a control is constructed with a call to CreateParented (Delphi) or the appropriate overloaded constructor (C++).
Use ParentWindow with windowed controls that are packaged in a DLL. This allows references to the control by applications based on other applications.</docstr>
      </property>
      <property name="Showing">
        <docstr>Indicates whether the control is showing on the screen.
Showing is used internally to optimize the allocation of Windows resources. Use Showing to determine when you must allocate resources that are required when the control is visible. When Showing is false, the control is not visible and you can delay the allocation of resources.
If the Visible properties of a component and all the parents in its parent hierarchy are true, Showing is guaranteed to be true. If one of the parents containing the control has a Visible property value of false, Showing may be either true or false.
Showing is a read-only property.</docstr>
      </property>
      <property name="IsDrawingLocked">
        <docstr>IsDrawingLocked property returns True when redrawing for this control is locked.  It is True when the number of LockDrawing calls is less than UnlockDrawing calls for this control.</docstr>
      </property>
      <property name="RedrawDisabled">
        <docstr>RedrawDisabled property returns True when redrawing for this control is locked.  It is similar to IsDrawingLocked, but uses Win32 API to determine when a Win32 window redrawing is disabled. 
For example, when a parent control redrawing is locked using LockDrawing, then IsDrawingLocked returns True for parent control and False for child control. RedrawDisabled returns True for both parent and child controls.</docstr>
      </property>
      <property name="TabOrder">
        <docstr>Indicates the position of the control in its parent&apos;s tab order.
TabOrder is the order in which child windows are visited when the user presses the Tab key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
Each control has a unique tab-order value within its parent. If you change the TabOrder property value of one control to be the same as the value of a second control, the TabOrder value for all the other controls changes. For example, suppose a control is sixth in the tab order. If you change the control&apos;s TabOrder property value to 3 (making the control fourth in the tab order), the control that was originally fourth in the tab order now becomes fifth, and the control that was fifth becomes sixth.
Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that assures the control is the last in the tab order.

Note: TabOrder is meaningful only if the TabStop property is True and if the control has a parent. (The TabOrder property of a form is not used unless the form is the child of another form.) A control with a TabOrder of -1 has no parent, and therefore cannot be reached by pressing the Tab key. To remove a parented control from the Tab order, set its TabStop property to False.</docstr>
      </property>
      <property name="TabStop">
        <docstr>Determines whether the user can tab to a control.
Use the TabStop to allow or disallow access to the control using the Tab key.
If TabStop is True, the control is in the tab order. If TabStop is False, the control is not in the tab order and the user cannot press the TAB key to move to the control. 

Note: TabStop is not meaningful for a form unless the form assigns another form to be its parent.</docstr>
      </property>
      <property name="UseDockManager">
        <docstr>Specifies whether the docking manager is used in drag-and-dock operations.
Use UseDockManager to get or set whether a docking manager is used in drag-and-dock operations. 
The docking manager handles the positioning of docked controls and any painting of docking zones around those controls. If you do not use a docking manager, docked controls are aligned to the windowed control based on the closest edge to where they are released. When you do not use a docking manager, there is no region for a user to grab to automatically undock a docked control.</docstr>
      </property>
    </members>
  </class>
  <class unit="Vcl.Controls" name="TCustomControl">
    <docstr>Base class for controls that wrap Windows screen objects but perform their own rendering.
In most descendants of TWinControl, the job of drawing the control&apos;s surface belongs to the underlying Windows screen object. If a control has visible features that cannot be rendered by a Windows screen object, it requires access to a canvas object so it can do its own drawing.
TCustomControl is one of two base classes for controls that draw their own surfaces. Because TCustomControl is descended from TWinControl, instances of its descendants can receive focus and serve as containers.
Classes of controls that perform their own screen rendering and do not need the features of TWinControl should be descendants of TGraphicControl instead of TCustomControl. TGraphicControl objects can render themselves with less overhead, because they do not have underlying Windows screen objects.
TCustomControl objects have a Paint method, which is called whenever the control needs to render its image. Custom controls paint themselves using the Canvas property.</docstr>
    <members>
      <procedure name="Paint">
        <docstr>Renders the image of a custom control.
The Paint method for TCustomControl does nothing other than provide the interface for a method that responds to WM_PAINT messages. Paint is called by the PaintWindow method, after that method has supplied the Canvas with the handle to a device context. When creating a custom control, always override Paint to draw the image of the control.

Tip:  To determine which portions of the control&apos;s canvas need to be repainted when Paint is called, use the ClipRect property of the canvas.</docstr>
      </procedure>
      <procedure name="PaintWindow">
        <docstr>Renders the image of the control on a specified device context.
PaintWindow is called automatically when a custom control receives a WM_PAINT message. PaintWindow assigns the device context specified by the DC parameter to the custom control&apos;s canvas, calls the Paint method, and finally removes the device context. Override PaintWindow to provide additional responses to the WM_PAINT message. To draw the image of the control, override the Paint method instead.</docstr>
      </procedure>
      <property name="Canvas">
        <docstr>Specifies the TCanvas object that presents a drawing surface for the control.
Use the properties of the TCanvas object to draw or paint on the surface of the control. Canvas encapsulates a Windows device context, providing all the tools and methods needed for drawing and painting.
Canvas is a protected property that is usually redeclared as public in descendants of TCustomControl.</docstr>
      </property>
      <constructor name="Create">
        <docstr>Creates an instance of TCustomControl.
Calling Create constructs and initializes an instance of TCustomControl. However, you should never attempt to instantiate a TCustomControl. This class is intended solely as a base class from which other control classes descend and you should only call Create to instantiate one of these descendants. Controls placed on forms at design time are created automatically.
After calling the inherited constructor, Create initializes the control and also a TCanvas object for its Canvas property.
When overriding Create, always call the inherited Create method first, then proceed with the control&apos;s initialization. Remember to specify the override directive when overriding the Create method.

Note: If a component&apos;s constructor allocates resources or memory, also override the destructor to free those resources.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys an instance of TCustomControl.
Do not call Destroy directly in an application. Instead, call Free. Free verifies that the control is not nil, and only then calls Destroy. 
Applications should only free controls explicitly when the constructor was called without assigning an owner to the control.
As the control is destroyed, it destroys the TCanvas object in its Canvas property. 
Override Destroy to free any memory or resources allocated in the Create method. When declaring a Destroy method in a descendent control type, always add the override directive to the declaration and call the inherited Destroy as the last statement in the redeclared method. 
When a control is created, Delphi automatically provides exception handling around the constructor call. The destructor is called if an exception escapes from the constructor. This means that the destructor code must be prepared to clean up a partially constructed instance. Check all data fields for zero before disposing of their contents.</docstr>
      </destructor>
    </members>
  </class>
  <class unit="Data.Bind.Components" name="TContainedBindComponent">
    <docstr>Base class for all common binding components descending from it.
TContainedBindComponent is an abstract class that is the base class for TCommonBindComponent.</docstr>
    <members>
      <function name="GetBindingsList">
        <docstr>Protected getter method for the BindingsList property.</docstr>
      </function>
      <procedure name="ReadState">
        <docstr>Reads the state of this component.
ReadState is used internally in the component streaming system. It is not necessary to call it directly.
ReadState expects a TReader object, which is used for reading the state of the component.</docstr>
      </procedure>
      <function name="GetControlComponent">
        <docstr>Protected getter method for the ControlComponent property.</docstr>
      </function>
      <procedure name="SetControlComponent">
        <docstr>Protected setter method for the ControlComponent property.</docstr>
      </procedure>
      <procedure name="CheckControlComponent">
        <docstr>Verifies whether the control component is assigned.
If the ControlComponent is nil, then CheckControlComponent raises an exception.</docstr>
      </procedure>
      <function name="GetDisplayName">
        <docstr>Protected getter implementation for the DisplayName property.</docstr>
      </function>
      <function name="Designing">
        <docstr>Returns whether this component is in design mode.</docstr>
      </function>
      <function name="Loading">
        <docstr>Returns whether this component is in loading mode.</docstr>
      </function>
      <procedure name="DoReactivate">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Creates an instance of the TContainedBindComponent class.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys an instance of the TContainedBindComponent class.</docstr>
      </destructor>
      <function name="CanSetControlComponent">
        <docstr>Returns whether the control component can be set a given value.
As implemented in TContainedBindComponent, CanSetControlComponent always returns True, but in descendants it actually returns whether the given Value (that is itself a TComponent) can be assigned to the control component.</docstr>
      </function>
      <function name="GetParentComponent">
        <docstr>Returns the containing component.
GetParentComponent returns a reference to the component that contains the current component, or nil if there is no container. Use HasParent to determine whether a component has a containing component.</docstr>
      </function>
      <function name="HasParent">
        <docstr>Verifies whether the contained binding component has a parent.
HasParent returns True if the contained binding component has a parent, False otherwise.</docstr>
      </function>
      <procedure name="SetParentComponent">
        <docstr>Sets the parent component of this component.
SetParentComponent is used internally in the component streaming system. It is not necessary to call it directly.</docstr>
      </procedure>
      <property name="BindingsList">
        <docstr>Specifies a list that holds the binding expressions.</docstr>
      </property>
      <property name="Index">
        <docstr>Returns the index of this component in the bindings list.</docstr>
      </property>
      <property name="ControlComponent">
        <docstr>Specifies the component that will be bound to the source component, by means of LiveBindings.</docstr>
      </property>
      <property name="DisplayName">
        <docstr>Returns a string containing the name of this component.</docstr>
      </property>
      <property name="Category">
        <docstr>Specifies a category for this component.
For example, for a binding expression called BindExpressionForm121, of type TBindExpression, the following code:

  ShowMessage(BindExpressionForm121.Category);

shows the following message: Binding Expressions.</docstr>
      </property>
    </members>
  </class>
  <class unit="Data.Bind.Components" name="TCustomBindingsList">
    <docstr>Represents the base class for the binding list.
The TCustomBindingsList class implements a list of binding expressions, output converters, method scopes, and other binding list-related functionality.</docstr>
    <members>
      <procedure name="AddBindComp">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="RemoveBindComp">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Notification">
        <docstr>Forwards notification messages to all owned components.
Data.Bind.Components.TCustomBindingsList.Notification inherits from System.Classes.TComponent.Notification. All content below this line refers to System.Classes.TComponent.Notification.
Forwards notification messages to all owned components.
Do not call the Notification method in an application. Notification is called automatically when the component specified by AComponent is about to be inserted or removed, as specified by Operation. By default, components pass along the notification to their owned components, if any.
A component can, if needed, act on the notification that a component is being inserted or removed. For example, if a component has object fields or properties that contain references to other components, it can check the notifications of component removals and invalidate those references as needed.

Note: Notification is not called for components that are freed implicitly (because their Owner is freed).</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Data.Bind.Components.TCustomBindingsList.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of the component and its owned components.
Data.Bind.Components.TCustomBindingsList.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
Disposes of the component and its owned components.
Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
To destroy a form, call its Release method. Release waits for all the form&apos;s event handlers and the event handlers of the form&apos;s components to finish executing before destroying the form.

Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates.</docstr>
      </destructor>
      <function name="GetMethodsScope">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetOutputConverter">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="Notify">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="GetChildren">
        <docstr>Enumerates all child components.
Data.Bind.Components.TCustomBindingsList.GetChildren inherits from System.Classes.TComponent.GetChildren. All content below this line refers to System.Classes.TComponent.GetChildren.
Enumerates all child components.
GetChildren is used internally in the component streaming system. It is not necessary to call it directly. 
GetChildren expects a TGetChildProc routine that receives all enumerated components. 
Root represents the owner of the components that will be enumerated.
This method does nothing in TComponent and is expected to be overridden in descendants.</docstr>
      </procedure>
      <property name="Methods">
        <docstr>Specifies a list of available methods. For more information about these methods, read the LiveBindings Methods topic.</docstr>
      </property>
      <property name="OutputConverters">
        <docstr>Specifies a list of available output converters. For more information about output converters, read the LiveBindings Output Converters help topic.</docstr>
      </property>
      <function name="GetEnumerator">
        <docstr>Returns a TComponent enumerator.
Data.Bind.Components.TCustomBindingsList.GetEnumerator inherits from System.Classes.TComponent.GetEnumerator. All content below this line refers to System.Classes.TComponent.GetEnumerator.
Returns a TComponent enumerator.
GetEnumerator returns a TComponentEnumerator reference, which enumerates the components contained within a specified containing component. 
To process all these subcomponents, call the TComponentEnumerator GetCurrent method within a While MoveNext do loop.</docstr>
      </function>
      <property name="BindCompCount">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="UseAppManager">
        <docstr>Specifies whether the bindings list uses the global application manager for managed bindings.</docstr>
      </property>
      <property name="PromptDeleteUnused">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="DependencyList">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
    </members>
  </class>
  <class unit="Data.Bind.Components" name="TDependencyList">
    <docstr>List of dependencies on components and properties</docstr>
  </class>
  <class unit="Data.Bind.Components" name="TDependency">
    <docstr>Describe the component/property that a binding component depends upon</docstr>
  </class>
  <class unit="Data.Bind.Components" name="TBindingsList">
    <docstr>Implements the bindings list component. TBindingsList is built on the TCustomBindingsList component and publishes additional properties that can be accessed from within the Object Inspector.</docstr>
  </class>
  <class unit="Data.Bind.Components" name="TCustomBindControlValue">
    <docstr>Update component properties with a control is modified by user input</docstr>
  </class>
  <class unit="Data.Bind.Components" name="TBindControlValue">
    <docstr>Update component properties with a control is modified by user input</docstr>
  </class>
  <class unit="Data.Bind.Components" name="TEvalEnumeratorToEditor">
    <docstr>Evaluate an assignment from a data source to an editor.  May use a shortcut or expression engine.</docstr>
    <members>
      <property name="Source">
        <docstr>Enumerator of data source records, such as records in a dataset.</docstr>
      </property>
      <property name="SourceMemberName">
        <docstr>Data source member name, such as a FieldName.</docstr>
      </property>
      <property name="Editor">
        <docstr>Editor for a list, such as a FMX TListView.</docstr>
      </property>
      <property name="EditorMemberName">
        <docstr>Member name for a list, such as &quot;Text&quot;.</docstr>
      </property>
      <property name="UseEvalShortcuts">
        <docstr>Indicate whether the assignment can be evaluated without expression engine.</docstr>
      </property>
      <property name="Expression">
        <docstr>Expression engine description of assignment.</docstr>
      </property>
      <event name="OnEvalError">
        <docstr>Event to execute when the expression engine raises an exception</docstr>
      </event>
      <property name="Custom">
        <docstr>Indicate whether the expression has been customized.  A customized expression must
           be evaluated with expression engine, rather than by shortcut.</docstr>
      </property>
    </members>
  </class>
  <class unit="Data.Bind.Components" name="TEvalEnumerator">
    <docstr>Evaluate an value from a data source.  May use a shortcut or expression engine.</docstr>
    <members>
      <property name="Source">
        <docstr>Enumerator of data source records, such as records in a dataset.</docstr>
      </property>
      <property name="SourceMemberName">
        <docstr>Data source member name, such as a FieldName.</docstr>
      </property>
      <property name="UseEvalShortcuts">
        <docstr>Indicate whether the assignment can be evaluated without expression engine.</docstr>
      </property>
      <property name="Expression">
        <docstr>Expression engine description of expression to evaluate.</docstr>
      </property>
      <event name="OnEvalError">
        <docstr>Event to call when the expression engine raises an exception</docstr>
      </event>
      <property name="Custom">
        <docstr>Indicate whether the expression has been customized.  A customized
           expression must be evaluated with expression engine, rather than as a shortcut</docstr>
      </property>
    </members>
  </class>
  <class unit="Data.Bind.Components" name="TCustomBindGridList">
    <docstr></docstr>
    <members>
      <procedure name="FillHeaderRecord">
        <docstr>Evaluate expressions to fill a break header</docstr>
      </procedure>
    </members>
  </class>
  <class unit="Data.Bind.Components" name="TBindComponentDelegate">
    <docstr>Is a binding component that wraps one or more other binding components.</docstr>
    <members>
      <procedure name="Reactivate">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GetActive">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="GenerateExpressions">
        <docstr>Automatically generates the bindings expressions for the quick binding component this delegate wraps onto. For more information regarding the quick binding components, please refer to the New LiveBinding topic, the Quick Binding Components Reference section.</docstr>
      </procedure>
      <procedure name="ClearGeneratedExpressions">
        <docstr>Clears all the generated bindings expressions, at once, for the quick binding component this delegate wraps onto. For more information regarding the quick binding components, please refer to the New LiveBinding topic, the Quick Binding Components Reference section.</docstr>
      </procedure>
      <procedure name="Activated">
        <docstr>Informs the wrapper binding component that a delegate (or contained) binding component has been activated.</docstr>
      </procedure>
      <function name="CanActivate">
        <docstr>Lets the wrapper binding component indicate whether a delegate (or contained) binding component may be activated.
The CanActivate method returns True if the delegate (or contained) binding component can be activated, False otherwise.</docstr>
      </function>
      <function name="RequiresControlHandler">
        <docstr>Used internally for observing purposes.</docstr>
      </function>
      <function name="GetSourceScopes">
        <docstr>Returns an array of scopes for the source component.</docstr>
      </function>
      <procedure name="MemberRenaming">
        <docstr>Used for renaming a member of this binding component.
MemberRenaming is used for renaming component members. The old member name is given through the ACurMemberName parameter, while the new member name is given through the ANewMemberName parameter.</docstr>
      </procedure>
      <function name="GetUseEvalShortcuts">
        <docstr>Returns True if this binding component delegate supports evaluation shortcuts or False otherwise.
Subclasses of TBindComponentDelegate that support evaluation shortcuts must reimplement GetUseEvalShortcuts to return True.</docstr>
      </function>
      <function name="GetDelegates">
        <docstr>Gets the delegate (or contained) binding components that this wrapper binding component uses to execute expressions and respond to user input.</docstr>
      </function>
      <event name="OnAssigningValue">
        <docstr>Event that occurs as an expression is evaluated and is assigning to a value of an object member. Event handlers can intercede in the assignment operation.</docstr>
      </event>
      <event name="OnAssignedValue">
        <docstr>Event that occurs after an expression has been evaluated and has assigned a value to an object member.</docstr>
      </event>
      <event name="OnEvalError">
        <docstr>Event that occurs when an exception is raised while evaluating an expression, such as a conversion error. Event handlers can intercede and raise a different exception.</docstr>
      </event>
      <event name="OnActivating">
        <docstr>Event that occurs when activating the binding expressions of this delegate wrapper.</docstr>
      </event>
      <event name="OnActivated">
        <docstr>Event that occurs when the binding expressions of this delegate wrapper have been activated.</docstr>
      </event>
    </members>
  </class>
  <class unit="Data.Bind.Components" name="TLinkControlDelegate">
    <docstr>Is a binding component that wraps another binding component and references a control.
The TLinkControlDelegate class implements a binding component that wraps another binding component and references a control.
For more information regarding the delegates, please refer to the New LiveBinding topic, the Quick Binding Components Reference section.</docstr>
    <members>
      <function name="GetControlComponent">
        <docstr>Protected getter method for the ControlComponent property.</docstr>
      </function>
      <procedure name="SetControlComponent">
        <docstr>Protected setter method for the ControlComponent property.</docstr>
      </procedure>
      <function name="GetControlComponentMemberName">
        <docstr>Returns a string containing the name of the control component member. When a control member is specified, expressions execute against the member rather than against the control component.</docstr>
      </function>
      <procedure name="SetActive">
        <docstr>Activates or deactivates the bind control value of this link delegate wrapper.</docstr>
      </procedure>
      <procedure name="BindActivate">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="CanSetControlComponent">
        <docstr>Returns whether the given parameter can be used as the control component of this binding component.
CanSetControlComponent returns whether the given Value (that is itself a TComponent) can be used as the control component of this binding component.</docstr>
      </function>
    </members>
  </class>
  <class unit="Data.Bind.Components" name="TLinkControlToFieldDelegate">
    <docstr>Is a binding component that wraps another binding component and references a control, data source, and field.
The TLinkControlToFieldDelegate class implements a binding component that wraps another binding component and references a control, a data source, and a field.
For more information regarding the delegates, please refer to the New LiveBinding topic, the Quick Binding Components Reference section.</docstr>
    <members>
      <procedure name="SetDataSource">
        <docstr>Protected setter implementation for the DataSource property.</docstr>
      </procedure>
      <function name="GetDataSource">
        <docstr>Protected getter implementation for the DataSource property.</docstr>
      </function>
      <procedure name="SetSourceMember">
        <docstr>Protected setter implementation for the FieldName property defined in subclasses.
Both TCustomLinkControlToField and TCustomLinkListControlToField use SetSourceMember as the setter implementation.</docstr>
      </procedure>
      <function name="GetSourceMember">
        <docstr>Protected getter implementation for the FieldName property defined in subclasses.
Both TCustomLinkControlToField and TCustomLinkListControlToField use GetSourceMember as the getter implementation.</docstr>
      </function>
      <function name="GetDisplaysMultipleSourceMembers">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <property name="DataSource">
        <docstr>Specifies a TBaseLinkingBindSource object to which this delegate component links.
Use DataSource to determine or set the TBaseLinkingBindSource object that connects to a specific dataset.</docstr>
      </property>
    </members>
  </class>
  <class unit="Data.Bind.Components" name="TCustomLinkControlToField">
    <docstr>Represents the base class for linking a control to a field.
The TCustomLinkControlToField class implements the functionality for linking a control to a field in a data source.

Tip: If the direction is bidirectional, then the control must support the IEditLinkObserver interface.</docstr>
    <members>
      <procedure name="Reactivate">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="AllowBidirectional">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="CheckAllowBidirectional">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="Notification">
        <docstr>Forwards notification messages to all owned components.
Data.Bind.Components.TCustomLinkControlToField.Notification inherits from System.Classes.TComponent.Notification. All content below this line refers to System.Classes.TComponent.Notification.
Forwards notification messages to all owned components.
Do not call the Notification method in an application. Notification is called automatically when the component specified by AComponent is about to be inserted or removed, as specified by Operation. By default, components pass along the notification to their owned components, if any.
A component can, if needed, act on the notification that a component is being inserted or removed. For example, if a component has object fields or properties that contain references to other components, it can check the notifications of component removals and invalidate those references as needed.

Note: Notification is not called for components that are freed implicitly (because their Owner is freed).</docstr>
      </procedure>
      <function name="GetSourceScopes">
        <docstr>Returns an array of scopes for the source component.
Data.Bind.Components.TCustomLinkControlToField.GetSourceScopes inherits from Data.Bind.Components.TBindComponentDelegate.GetSourceScopes. All content below this line refers to Data.Bind.Components.TBindComponentDelegate.GetSourceScopes.
Returns an array of scopes for the source component.</docstr>
      </function>
      <procedure name="MemberRenaming">
        <docstr>Used for renaming a member of this binding component.
Data.Bind.Components.TCustomLinkControlToField.MemberRenaming inherits from Data.Bind.Components.TBindComponentDelegate.MemberRenaming. All content below this line refers to Data.Bind.Components.TBindComponentDelegate.MemberRenaming.
Used for renaming a member of this binding component.
MemberRenaming is used for renaming component members. The old member name is given through the ACurMemberName parameter, while the new member name is given through the ANewMemberName parameter.</docstr>
      </procedure>
      <procedure name="SetAutoActivate">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GetControlExpression">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="SetActive">
        <docstr>Activates or deactivates the bind control value of this link delegate wrapper.
Data.Bind.Components.TCustomLinkControlToField.SetActive inherits from Data.Bind.Components.TLinkControlDelegate.SetActive. All content below this line refers to Data.Bind.Components.TLinkControlDelegate.SetActive.
Activates or deactivates the bind control value of this link delegate wrapper.</docstr>
      </procedure>
      <function name="GetActive">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="CanActivate">
        <docstr>Lets the wrapper binding component indicate whether a delegate (or contained) binding component may be activated.
Data.Bind.Components.TCustomLinkControlToField.CanActivate inherits from Data.Bind.Components.TBindComponentDelegate.CanActivate. All content below this line refers to Data.Bind.Components.TBindComponentDelegate.CanActivate.
Lets the wrapper binding component indicate whether a delegate (or contained) binding component may be activated.
The CanActivate method returns True if the delegate (or contained) binding component can be activated, False otherwise.</docstr>
      </function>
      <procedure name="ClearGeneratedExpressions">
        <docstr>Clears all the generated bindings expressions, at once, for the quick binding component this delegate wraps onto.
Data.Bind.Components.TCustomLinkControlToField.ClearGeneratedExpressions inherits from Data.Bind.Components.TBindComponentDelegate.ClearGeneratedExpressions. All content below this line refers to Data.Bind.Components.TBindComponentDelegate.ClearGeneratedExpressions.
Clears all the generated bindings expressions, at once, for the quick binding component this delegate wraps onto. For more information regarding the quick binding components, please refer to the New LiveBinding topic, the Quick Binding Components Reference section.</docstr>
      </procedure>
      <function name="RequiresControlHandler">
        <docstr>Used internally for observing purposes.
Data.Bind.Components.TCustomLinkControlToField.RequiresControlHandler inherits from Data.Bind.Components.TBindComponentDelegate.RequiresControlHandler. All content below this line refers to Data.Bind.Components.TBindComponentDelegate.RequiresControlHandler.
Used internally for observing purposes.</docstr>
      </function>
      <procedure name="Loaded">
        <docstr>Initializes the component after the form file has been read into memory.
Data.Bind.Components.TCustomLinkControlToField.Loaded inherits from System.Classes.TComponent.Loaded. All content below this line refers to System.Classes.TComponent.Loaded.
Initializes the component after the form file has been read into memory.
Do not call the protected Loaded method. The streaming system calls this method after it loads the component&apos;s form from a stream.
When the streaming system loads a form or data module from its form file, it first constructs the form component by calling its constructor, then reads its property values from the form file. After reading all the property values for all the components, the streaming system calls the Loaded methods of each component in the order the components were created. This gives the components a chance to initialize any data that depends on the values of other components or other parts of itself.

Note:  All references to sibling components are resolved by the time Loaded is called. Loaded is the first place that sibling pointers can be used after being streamed in.
As implemented in TComponent, Loaded clears the csLoading flag in the ComponentState property, indicating that the component is no longer loading.

Warning: Loaded may be called multiple times on inherited forms. It is called every time a level of inheritance is streamed in. Do not allocate memory in an overridden Loaded method without first checking that the memory has not been allocated in a previous call.</docstr>
      </procedure>
      <function name="GetUseEvalShortcuts">
        <docstr>Setter of UseEvalShortcuts.</docstr>
      </function>
      <constructor name="Create">
        <docstr>Creates an instance of the TContainedBindComponent class.
Data.Bind.Components.TCustomLinkControlToField.Create inherits from Data.Bind.Components.TContainedBindComponent.Create. All content below this line refers to Data.Bind.Components.TContainedBindComponent.Create.
Creates an instance of the TContainedBindComponent class.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys an instance of the TContainedBindComponent class.
Data.Bind.Components.TCustomLinkControlToField.Destroy inherits from Data.Bind.Components.TContainedBindComponent.Destroy. All content below this line refers to Data.Bind.Components.TContainedBindComponent.Destroy.
Destroys an instance of the TContainedBindComponent class.</docstr>
      </destructor>
      <procedure name="ClearExpressionProperties">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GetDelegates">
        <docstr>Gets the delegate (or contained) binding components that this wrapper binding component uses to execute expressions and respond to user input.
Data.Bind.Components.TCustomLinkControlToField.GetDelegates inherits from Data.Bind.Components.TBindComponentDelegate.GetDelegates. All content below this line refers to Data.Bind.Components.TBindComponentDelegate.GetDelegates.
Gets the delegate (or contained) binding components that this wrapper binding component uses to execute expressions and respond to user input.</docstr>
      </function>
      <property name="Binding">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="FieldName">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="AutoActivate">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="Active">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="Direction">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <procedure name="GenerateExpressions">
        <docstr>Automatically generates the bindings expressions for the quick binding component this delegate wraps onto.
Data.Bind.Components.TCustomLinkControlToField.GenerateExpressions inherits from Data.Bind.Components.TBindComponentDelegate.GenerateExpressions. All content below this line refers to Data.Bind.Components.TBindComponentDelegate.GenerateExpressions.
Automatically generates the bindings expressions for the quick binding component this delegate wraps onto. For more information regarding the quick binding components, please refer to the New LiveBinding topic, the Quick Binding Components Reference section.</docstr>
      </procedure>
      <property name="Control">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="ControlMemberName">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="Track">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="CustomFormat">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="CustomParse">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="LookupDataSource">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="LookupKeyFieldName">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="LookupValueFieldName">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="UseEvalShortcuts">
        <docstr>Determines whether this binding component delegate uses evaluation shortcuts (True) or not (False).</docstr>
      </property>
    </members>
  </class>
  <class unit="Data.Bind.Components" name="TLinkControlToField">
    <docstr>Links a list control to a field.
The TLinkListControlToField class extends TCustomLinkListControlToField with published properties.

Tip: If the direction is bidirectional, then the control must support the IEditLinkObserver interface.</docstr>
  </class>
  <class unit="Data.Bind.Components" name="TLinkFillControlToField">
    <docstr>Link a control to a field, fill the control with possible values</docstr>
  </class>
  <class unit="Data.Bind.Components" name="TCustomLinkListControlToField">
    <docstr>Represents the base class for linking a list control to a field.
The TCustomLinkListControlToField class implements the functionality for linking a list control, such as TListBox, to a field.

Tip: If the direction is bidirectional, then the control must support the IEditLinkObserver interface.</docstr>
    <members>
      <procedure name="Reactivate">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GetActive">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="SetActive">
        <docstr>Activates or deactivates the bind control value of this link delegate wrapper.
Data.Bind.Components.TCustomLinkListControlToField.SetActive inherits from Data.Bind.Components.TLinkControlDelegate.SetActive. All content below this line refers to Data.Bind.Components.TLinkControlDelegate.SetActive.
Activates or deactivates the bind control value of this link delegate wrapper.</docstr>
      </procedure>
      <function name="GetControlComponentMemberName">
        <docstr>Returns a string containing the name of the control component member.
Data.Bind.Components.TCustomLinkListControlToField.GetControlComponentMemberName inherits from Data.Bind.Components.TLinkControlDelegate.GetControlComponentMemberName. All content below this line refers to Data.Bind.Components.TLinkControlDelegate.GetControlComponentMemberName.
Returns a string containing the name of the control component member. When a control member is specified, expressions execute against the member rather than against the control component.</docstr>
      </function>
      <function name="CanActivate">
        <docstr>Lets the wrapper binding component indicate whether a delegate (or contained) binding component may be activated.
Data.Bind.Components.TCustomLinkListControlToField.CanActivate inherits from Data.Bind.Components.TBindComponentDelegate.CanActivate. All content below this line refers to Data.Bind.Components.TBindComponentDelegate.CanActivate.
Lets the wrapper binding component indicate whether a delegate (or contained) binding component may be activated.
The CanActivate method returns True if the delegate (or contained) binding component can be activated, False otherwise.</docstr>
      </function>
      <procedure name="ClearGeneratedExpressions">
        <docstr>Clears all the generated bindings expressions, at once, for the quick binding component this delegate wraps onto.
Data.Bind.Components.TCustomLinkListControlToField.ClearGeneratedExpressions inherits from Data.Bind.Components.TBindComponentDelegate.ClearGeneratedExpressions. All content below this line refers to Data.Bind.Components.TBindComponentDelegate.ClearGeneratedExpressions.
Clears all the generated bindings expressions, at once, for the quick binding component this delegate wraps onto. For more information regarding the quick binding components, please refer to the New LiveBinding topic, the Quick Binding Components Reference section.</docstr>
      </procedure>
      <function name="RequiresControlHandler">
        <docstr>Used internally for observing purposes.
Data.Bind.Components.TCustomLinkListControlToField.RequiresControlHandler inherits from Data.Bind.Components.TBindComponentDelegate.RequiresControlHandler. All content below this line refers to Data.Bind.Components.TBindComponentDelegate.RequiresControlHandler.
Used internally for observing purposes.</docstr>
      </function>
      <procedure name="Loaded">
        <docstr>Initializes the component after the form file has been read into memory.
Data.Bind.Components.TCustomLinkListControlToField.Loaded inherits from System.Classes.TComponent.Loaded. All content below this line refers to System.Classes.TComponent.Loaded.
Initializes the component after the form file has been read into memory.
Do not call the protected Loaded method. The streaming system calls this method after it loads the component&apos;s form from a stream.
When the streaming system loads a form or data module from its form file, it first constructs the form component by calling its constructor, then reads its property values from the form file. After reading all the property values for all the components, the streaming system calls the Loaded methods of each component in the order the components were created. This gives the components a chance to initialize any data that depends on the values of other components or other parts of itself.

Note:  All references to sibling components are resolved by the time Loaded is called. Loaded is the first place that sibling pointers can be used after being streamed in.
As implemented in TComponent, Loaded clears the csLoading flag in the ComponentState property, indicating that the component is no longer loading.

Warning: Loaded may be called multiple times on inherited forms. It is called every time a level of inheritance is streamed in. Do not allocate memory in an overridden Loaded method without first checking that the memory has not been allocated in a previous call.</docstr>
      </procedure>
      <function name="GetDisplaysMultipleSourceMembers">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetControlEditorName">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="SetFieldName">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DefineProperties">
        <docstr>Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
Data.Bind.Components.TCustomLinkListControlToField.DefineProperties inherits from System.Classes.TComponent.DefineProperties. All content below this line refers to System.Classes.TComponent.DefineProperties.
Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
TComponent overrides the DefineProperties method defined in TPersistent to define &quot;fake&quot; Top and Left properties. These are defined so that components that are not controls can be manipulated at design time. However, the Top and Left properties are hidden, that is, they are not published, because only controls appear at run time.
DefineProperties is virtual; descendent classes can override it. When overriding DefineProperties, be aware that the Ancestor property of Filer might be set, and that this property can determine whether or not it is appropriate to write properties.
DefineProperties is called automatically as part of the component streaming system; do not call it directly.</docstr>
      </procedure>
      <function name="GetUseEvalShortcuts">
        <docstr>Setter of UseEvalShortcuts.</docstr>
      </function>
      <constructor name="Create">
        <docstr>Creates an instance of the TContainedBindComponent class.
Data.Bind.Components.TCustomLinkListControlToField.Create inherits from Data.Bind.Components.TContainedBindComponent.Create. All content below this line refers to Data.Bind.Components.TContainedBindComponent.Create.
Creates an instance of the TContainedBindComponent class.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys an instance of the TContainedBindComponent class.
Data.Bind.Components.TCustomLinkListControlToField.Destroy inherits from Data.Bind.Components.TContainedBindComponent.Destroy. All content below this line refers to Data.Bind.Components.TContainedBindComponent.Destroy.
Destroys an instance of the TContainedBindComponent class.</docstr>
      </destructor>
      <procedure name="ClearExpressionProperties">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="FillList">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GetDelegates">
        <docstr>Gets the delegate (or contained) binding components that this wrapper binding component uses to execute expressions and respond to user input.
Data.Bind.Components.TCustomLinkListControlToField.GetDelegates inherits from Data.Bind.Components.TBindComponentDelegate.GetDelegates. All content below this line refers to Data.Bind.Components.TBindComponentDelegate.GetDelegates.
Gets the delegate (or contained) binding components that this wrapper binding component uses to execute expressions and respond to user input.</docstr>
      </function>
      <property name="BindLink">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="FieldName">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="AutoActivate">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="Active">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="Direction">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="BufferCount">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="AutoBufferCount">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <procedure name="GenerateExpressions">
        <docstr>Automatically generates the bindings expressions for the quick binding component this delegate wraps onto.
Data.Bind.Components.TCustomLinkListControlToField.GenerateExpressions inherits from Data.Bind.Components.TBindComponentDelegate.GenerateExpressions. All content below this line refers to Data.Bind.Components.TBindComponentDelegate.GenerateExpressions.
Automatically generates the bindings expressions for the quick binding component this delegate wraps onto. For more information regarding the quick binding components, please refer to the New LiveBinding topic, the Quick Binding Components Reference section.</docstr>
      </procedure>
      <property name="Control">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="ControlMemberName">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="CustomFormat">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="CustomParse">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="FillExpressions">
        <docstr>Specifies additional optional expressions to use when filling the list control. Use this collection when multiple expressions are needed to fill an item in the list.
For instance, you can use FillExpressions in order to populate a FireMonkey list box item Text and Detail properties. Use the FillDisplayCustomFormat and FillDisplayCustomFormat properties in order to fill the Text property and add an item to the FillExpressions collection, for the Detail property.</docstr>
      </property>
      <property name="ListItemStyle">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="FillHeaderExpressions">
        <docstr>Specifies a collection of expressions to fill a list header. This property is optional.</docstr>
      </property>
      <property name="FillBreakFieldName">
        <docstr>Specifies the field used to determine a break. This property is optional.</docstr>
      </property>
      <property name="FillBreakCustomFormat">
        <docstr>Specifies a custom expression that is used with the field defined by the FillBreakFieldName property. For instance, the expression StrCopy(%s, 0, 1); causes a break when the first character of the field is different. This property is optional.</docstr>
      </property>
      <property name="FillHeaderFieldName">
        <docstr>Specifies the field to display in the list header. If FillBreakFieldName and FillBreakCustomFormat are blank, then the value determined using FillHeaderFieldName and FillBreakCustomFormat controls breaks. This is the only required field to cause breaking.</docstr>
      </property>
      <property name="FillHeaderCustomFormat">
        <docstr>Specifies a custom expression that is used with the field defined by the FillHeaderFieldName property. For instance, the expression StrCopy(%s, 0, 1); displays the first character of the field in the header. This property is optional.</docstr>
      </property>
      <property name="FillBreakGroups">
        <docstr>Specifies a collection of break value ranges. The break value falls within an item in this collection. The display value associated with the item is displayed in the header. This property is optional.</docstr>
      </property>
      <event name="OnFillingListItem">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </event>
      <event name="OnFilledListItem">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </event>
      <event name="OnFillingList">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </event>
      <event name="OnFilledList">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </event>
      <property name="UseEvalShortcuts">
        <docstr>Determines whether this binding component delegate uses evaluation shortcuts (True) or not (False).</docstr>
      </property>
    </members>
  </class>
  <class unit="Data.Bind.Components" name="TLinkListControlToField">
    <docstr>Links a list control to a field.
The TLinkListControlToField class extends TCustomLinkListControlToField with published properties.

Tip: If the direction is bidirectional, then the control must support the IEditLinkObserver interface.</docstr>
  </class>
  <class unit="Data.Bind.Components" name="TLinkPropertyToFieldDelegate">
    <docstr>Is a binding component that wraps another binding component and references a component property, data source, and field name.
The TLinkPropertyToFieldDelegate class implements a binding component that wraps another binding component and references a component property, a data source, and a field name.
For more information regarding the delegates, please refer to the New LiveBinding topic, the Quick Binding Components Reference section.</docstr>
    <members>
      <procedure name="SetDataSource">
        <docstr>Protected setter implementation for the DataSource property.</docstr>
      </procedure>
      <function name="GetDataSource">
        <docstr>Protected getter implementation for the DataSource property.</docstr>
      </function>
      <procedure name="SetSourceMember">
        <docstr>Protected setter implementation for the FieldName property.</docstr>
      </procedure>
      <function name="GetSourceMember">
        <docstr>Protected getter implementation for the FieldName property.</docstr>
      </function>
      <function name="GetControlComponent">
        <docstr>Protected getter implementation for the Component property.</docstr>
      </function>
      <procedure name="SetControlComponent">
        <docstr>Protected setter implementation for the Component property.</docstr>
      </procedure>
      <procedure name="SetComponentProperty">
        <docstr>Protected setter implementation for the ComponentProperty property.</docstr>
      </procedure>
      <procedure name="SetActive">
        <docstr>Protected setter implementation for the Active property.</docstr>
      </procedure>
      <procedure name="BindActivate">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <property name="DataSource">
        <docstr>Specifies a TDataSource object to which this delegate component links.
Use DataSource to determine or set the TDataSource object that connects to a specific dataset.</docstr>
      </property>
      <property name="Component">
        <docstr>Specifies the component that this wrapping binding component references.</docstr>
      </property>
      <property name="ComponentProperty">
        <docstr>Specifies the name of the property of the component that this wrapping binding component references.</docstr>
      </property>
      <property name="FieldName">
        <docstr>Specifies the field name that this wrapping binding component references.</docstr>
      </property>
    </members>
  </class>
  <class unit="Data.Bind.Components" name="TCustomLinkPropertyToField">
    <docstr>Represents the base class for linking a property of a component to a field.
The TCustomLinkPropertyToField class implements the functionality for linking a property of a component to a field.

Tip: The user input to this component is not monitored using an observer.</docstr>
    <members>
      <procedure name="Reactivate">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GetActive">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="SetActive">
        <docstr>Protected setter implementation for the Active property.
Data.Bind.Components.TCustomLinkPropertyToField.SetActive inherits from Data.Bind.Components.TLinkPropertyToFieldDelegate.SetActive. All content below this line refers to Data.Bind.Components.TLinkPropertyToFieldDelegate.SetActive.
Protected setter implementation for the Active property.</docstr>
      </procedure>
      <procedure name="Notification">
        <docstr>Forwards notification messages to all owned components.
Data.Bind.Components.TCustomLinkPropertyToField.Notification inherits from System.Classes.TComponent.Notification. All content below this line refers to System.Classes.TComponent.Notification.
Forwards notification messages to all owned components.
Do not call the Notification method in an application. Notification is called automatically when the component specified by AComponent is about to be inserted or removed, as specified by Operation. By default, components pass along the notification to their owned components, if any.
A component can, if needed, act on the notification that a component is being inserted or removed. For example, if a component has object fields or properties that contain references to other components, it can check the notifications of component removals and invalidate those references as needed.

Note: Notification is not called for components that are freed implicitly (because their Owner is freed).</docstr>
      </procedure>
      <function name="GetSourceScopes">
        <docstr>Returns an array of scopes for the source component.
Data.Bind.Components.TCustomLinkPropertyToField.GetSourceScopes inherits from Data.Bind.Components.TBindComponentDelegate.GetSourceScopes. All content below this line refers to Data.Bind.Components.TBindComponentDelegate.GetSourceScopes.
Returns an array of scopes for the source component.</docstr>
      </function>
      <procedure name="MemberRenaming">
        <docstr>Used for renaming a member of this binding component.
Data.Bind.Components.TCustomLinkPropertyToField.MemberRenaming inherits from Data.Bind.Components.TBindComponentDelegate.MemberRenaming. All content below this line refers to Data.Bind.Components.TBindComponentDelegate.MemberRenaming.
Used for renaming a member of this binding component.
MemberRenaming is used for renaming component members. The old member name is given through the ACurMemberName parameter, while the new member name is given through the ANewMemberName parameter.</docstr>
      </procedure>
      <function name="GetDelegates">
        <docstr>Gets the delegate (or contained) binding components that this wrapper binding component uses to execute expressions and respond to user input.
Data.Bind.Components.TCustomLinkPropertyToField.GetDelegates inherits from Data.Bind.Components.TBindComponentDelegate.GetDelegates. All content below this line refers to Data.Bind.Components.TBindComponentDelegate.GetDelegates.
Gets the delegate (or contained) binding components that this wrapper binding component uses to execute expressions and respond to user input.</docstr>
      </function>
      <function name="CanActivate">
        <docstr>Lets the wrapper binding component indicate whether a delegate (or contained) binding component may be activated.
Data.Bind.Components.TCustomLinkPropertyToField.CanActivate inherits from Data.Bind.Components.TBindComponentDelegate.CanActivate. All content below this line refers to Data.Bind.Components.TBindComponentDelegate.CanActivate.
Lets the wrapper binding component indicate whether a delegate (or contained) binding component may be activated.
The CanActivate method returns True if the delegate (or contained) binding component can be activated, False otherwise.</docstr>
      </function>
      <procedure name="ClearGeneratedExpressions">
        <docstr>Clears all the generated bindings expressions, at once, for the quick binding component this delegate wraps onto.
Data.Bind.Components.TCustomLinkPropertyToField.ClearGeneratedExpressions inherits from Data.Bind.Components.TBindComponentDelegate.ClearGeneratedExpressions. All content below this line refers to Data.Bind.Components.TBindComponentDelegate.ClearGeneratedExpressions.
Clears all the generated bindings expressions, at once, for the quick binding component this delegate wraps onto. For more information regarding the quick binding components, please refer to the New LiveBinding topic, the Quick Binding Components Reference section.</docstr>
      </procedure>
      <function name="RequiresControlHandler">
        <docstr>Used internally for observing purposes.
Data.Bind.Components.TCustomLinkPropertyToField.RequiresControlHandler inherits from Data.Bind.Components.TBindComponentDelegate.RequiresControlHandler. All content below this line refers to Data.Bind.Components.TBindComponentDelegate.RequiresControlHandler.
Used internally for observing purposes.</docstr>
      </function>
      <procedure name="Loaded">
        <docstr>Initializes the component after the form file has been read into memory.
Data.Bind.Components.TCustomLinkPropertyToField.Loaded inherits from System.Classes.TComponent.Loaded. All content below this line refers to System.Classes.TComponent.Loaded.
Initializes the component after the form file has been read into memory.
Do not call the protected Loaded method. The streaming system calls this method after it loads the component&apos;s form from a stream.
When the streaming system loads a form or data module from its form file, it first constructs the form component by calling its constructor, then reads its property values from the form file. After reading all the property values for all the components, the streaming system calls the Loaded methods of each component in the order the components were created. This gives the components a chance to initialize any data that depends on the values of other components or other parts of itself.

Note:  All references to sibling components are resolved by the time Loaded is called. Loaded is the first place that sibling pointers can be used after being streamed in.
As implemented in TComponent, Loaded clears the csLoading flag in the ComponentState property, indicating that the component is no longer loading.

Warning: Loaded may be called multiple times on inherited forms. It is called every time a level of inheritance is streamed in. Do not allocate memory in an overridden Loaded method without first checking that the memory has not been allocated in a previous call.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Creates an instance of the TContainedBindComponent class.
Data.Bind.Components.TCustomLinkPropertyToField.Create inherits from Data.Bind.Components.TContainedBindComponent.Create. All content below this line refers to Data.Bind.Components.TContainedBindComponent.Create.
Creates an instance of the TContainedBindComponent class.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys an instance of the TContainedBindComponent class.
Data.Bind.Components.TCustomLinkPropertyToField.Destroy inherits from Data.Bind.Components.TContainedBindComponent.Destroy. All content below this line refers to Data.Bind.Components.TContainedBindComponent.Destroy.
Destroys an instance of the TContainedBindComponent class.</docstr>
      </destructor>
      <property name="BindLink">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="AutoActivate">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="Active">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="CustomFormat">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <procedure name="GenerateExpressions">
        <docstr>Automatically generates the bindings expressions for the quick binding component this delegate wraps onto.
Data.Bind.Components.TCustomLinkPropertyToField.GenerateExpressions inherits from Data.Bind.Components.TBindComponentDelegate.GenerateExpressions. All content below this line refers to Data.Bind.Components.TBindComponentDelegate.GenerateExpressions.
Automatically generates the bindings expressions for the quick binding component this delegate wraps onto. For more information regarding the quick binding components, please refer to the New LiveBinding topic, the Quick Binding Components Reference section.</docstr>
      </procedure>
      <property name="LookupDataSource">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="LookupKeyFieldName">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="LookupValueFieldName">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
    </members>
  </class>
  <class unit="Data.Bind.Components" name="TLinkPropertyToField">
    <docstr>Links the property of a component to a field.
The TLinkPropertyToField class extends TCustomLinkPropertyToField with published properties.

Tip: The user input to this component is not monitored using an observer.</docstr>
  </class>
  <class unit="Data.Bind.Components" name="TCustomLinkControlToProperty">
    <docstr>Binds a value of a control to a component property</docstr>
  </class>
  <class unit="Data.Bind.Components" name="TLinkControlToProperty">
    <docstr>Binds a value of a control to a component property</docstr>
  </class>
  <class unit="Data.Bind.Components" name="TCustomLinkFillControlToProperty">
    <docstr>Binds a value of a control to a component property</docstr>
  </class>
  <class unit="Data.Bind.Components" name="TLinkFillControlToProperty">
    <docstr>Binds a value of a control to a component property, fill the control with possible values</docstr>
  </class>
  <class unit="Data.Bind.Components" name="TBaseBindScopeComponent">
    <docstr>Base class for the binding scope component. TBaseBindScopeComponent is the ancestor for the TCustomBindScope component. TBaseBindScopeComponent provides functionality for adding scope mappings, getting scope members and values, returning the scope itself or the scope of a member. It also provides properties for accessing the binding expressions in this scope and the scope mappings.</docstr>
    <members>
      <procedure name="SetScopeMappings">
        <docstr>Protected setter implementation for the ScopeMappings property.</docstr>
      </procedure>
      <function name="AddScopeMappings">
        <docstr>Adds the given scope mapping to the ScopeMappings list. The scope mapping to be added is given through the AScope parameter.</docstr>
      </function>
      <function name="GetMember">
        <docstr>Returns the member for the given member name.
The GetMember method returns the scope member, as a TObject, for the member name given through the AMemberName parameter. This member is later used in the generated bindings expressions.

Tip: This member object or its properties may be referenced by bindings expressions.</docstr>
      </function>
      <function name="GetValue">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetScope">
        <docstr>Returns the binding scope for this source component.
The GetScope method returns the binding scope for this source component. This binding scope allows expressions to access properties and methods of the source component, as opposed to GetMemberScope, which allows expressions to access properties and methods of a member of the source component, such as a field.</docstr>
      </function>
      <function name="GetMemberScope">
        <docstr>Returns the binding scope for the given member name.
The GetMemberScope method returns the binding scope for the member name given through the AMemberName parameter.</docstr>
      </function>
      <function name="GetScopeObject">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="PosLockEnter">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="PosLockLeave">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GetPosLock">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="AddExpression">
        <docstr>Adds the given bind component to the Expressions list. The binding component is given through the AExpression parameter.</docstr>
      </procedure>
      <procedure name="RemoveExpression">
        <docstr>Removes the given binding component from the Expressions list. The binding component to be removed is given through the AExpression parameter.</docstr>
      </procedure>
      <procedure name="Notification">
        <docstr>Forwards notification messages to all owned components.
Data.Bind.Components.TBaseBindScopeComponent.Notification inherits from System.Classes.TComponent.Notification. All content below this line refers to System.Classes.TComponent.Notification.
Forwards notification messages to all owned components.
Do not call the Notification method in an application. Notification is called automatically when the component specified by AComponent is about to be inserted or removed, as specified by Operation. By default, components pass along the notification to their owned components, if any.
A component can, if needed, act on the notification that a component is being inserted or removed. For example, if a component has object fields or properties that contain references to other components, it can check the notifications of component removals and invalidate those references as needed.

Note: Notification is not called for components that are freed implicitly (because their Owner is freed).</docstr>
      </procedure>
      <procedure name="ActivateExpressions">
        <docstr>Activates or deactivates all the binding expressions of this binding scope component at once.
The ActivateExpressions method activates or deactivates, depending on the value of the AValue parameter, all the binding expressions contained by this binding scope component at once.

Tip: If one or more of the binding expressions does not support one of the IBindLink, IBindPosition, or IBindActivate interfaces, then ActivateExpressions does nothing for that particular binding expression.</docstr>
      </procedure>
      <property name="Expressions">
        <docstr>Specifies a list of binding components that are using this source component.</docstr>
      </property>
      <property name="ScopeMappings">
        <docstr>Specifies an owned collection of scope mappings.
The ScopeMappings property specifies an owned collection whose elements are scope mappings. ScopeMappings are used to add name/value pairs that can be referenced by expressions that reference this source component.</docstr>
      </property>
      <constructor name="Create">
        <docstr>Allocates memory and constructs a safely initialized instance of a component.
Data.Bind.Components.TBaseBindScopeComponent.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
Allocates memory and constructs a safely initialized instance of a component.
All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:

Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.

Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component&apos;s Create constructor.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of the component and its owned components.
Data.Bind.Components.TBaseBindScopeComponent.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
Disposes of the component and its owned components.
Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
To destroy a form, call its Release method. Release waits for all the form&apos;s event handlers and the event handlers of the form&apos;s components to finish executing before destroying the form.

Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates.</docstr>
      </destructor>
    </members>
  </class>
  <class unit="Data.Bind.Components" name="TBaseLinkingBindSource">
    <docstr>Base class for scope with supports linking</docstr>
  </class>
  <class unit="Data.Bind.Components" name="TEvalShortcutEnumeratorToEditor">
    <docstr>Base class for evaluator shortcuts, that assign a value from data source to an editor</docstr>
    <members>
      <procedure name="Evaluate">
        <docstr>Evaluate expression to assign a value from a data source to an editor</docstr>
      </procedure>
    </members>
  </class>
  <class unit="Data.Bind.Components" name="TEvalShortcutEnumerator">
    <docstr>Base class for evaluator shortcuts that retrieve a value from a data source</docstr>
    <members>
      <function name="Evaluate">
        <docstr>Evaluate an expression to retrieve a value from a data source</docstr>
      </function>
    </members>
  </class>
  <class unit="Data.Bind.Components" name="TEvalShortcutFactory">
    <docstr>Base class for a factory of shortcut evaluators</docstr>
    <members>
      <function name="Supports">
        <docstr>Provide an evaluator for assigning from data source to editor</docstr>
      </function>
      <function name="Supports">
        <docstr>Indicate whether this factory can provide an evaluator for assigning from data source to editor</docstr>
      </function>
      <function name="Supports">
        <docstr>Provide an evaluator for retrieving a value from a data source</docstr>
      </function>
      <function name="Supports">
        <docstr>Indicate whether this factory can provide an evaluator for retrieving a value from  a data source to editor</docstr>
      </function>
    </members>
  </class>
  <class unit="Data.Bind.Components" name="TEvalShortcutFactories">
    <docstr>Singleton class for registering factories of shortcut evaluators, and instantiating shortcut evaluators</docstr>
    <members>
      <function name="Supports">
        <docstr>Provide an evaluator for assigning from data source to editor</docstr>
      </function>
      <function name="Supports">
        <docstr>Indicate whether a factory can provide an evaluator for assigning from data source to editor</docstr>
      </function>
      <function name="Supports">
        <docstr>Provide an evaluator for retrieving a value from a data source</docstr>
      </function>
      <function name="Supports">
        <docstr>Indicate whether a factory can provide an evaluator for assigning from  a data source to editor</docstr>
      </function>
      <procedure name="Register">
        <docstr>Register an evaluator shortcut factory</docstr>
      </procedure>
      <procedure name="Unregister">
        <docstr>Unregister an evaluator shortcut factory</docstr>
      </procedure>
      <property name="Instance">
        <docstr>Singleton instance property.  Use this property to access instance methods.</docstr>
      </property>
    </members>
  </class>
  <class unit="Vcl.Dialogs" name="TOpenDialog">
    <docstr>TOpenDialog displays a file-selection dialog.
TOpenDialog displays a modal Windows dialog box for selecting and opening files. The dialog does not appear at runtime until it is activated by a call to the Execute method. When the user clicks Open, the dialog closes and the selected file or files are stored in the Files property.</docstr>
    <members>
      <function name="CanClose">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="DoCanClose">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="DoSelectionChange">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoFolderChange">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoTypeChange">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoIncludeItem">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DefineProperties">
        <docstr>Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
Vcl.Dialogs.TOpenDialog.DefineProperties inherits from System.Classes.TComponent.DefineProperties. All content below this line refers to System.Classes.TComponent.DefineProperties.
Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
TComponent overrides the DefineProperties method defined in TPersistent to define &quot;fake&quot; Top and Left properties. These are defined so that components that are not controls can be manipulated at design time. However, the Top and Left properties are hidden, that is, they are not published, because only controls appear at run time.
DefineProperties is virtual; descendent classes can override it. When overriding DefineProperties, be aware that the Ancestor property of Filer might be set, and that this property can determine whether or not it is appropriate to write properties.
DefineProperties is called automatically as part of the component streaming system; do not call it directly.</docstr>
      </procedure>
      <procedure name="GetFileNames">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GetHandle">
        <docstr>Returns the value for the inherited Handle property.
The GetHandle protected function gets the value for the Handle property.</docstr>
      </function>
      <function name="GetStaticRect">
        <docstr>Returns the coordinates of the reserved area of the dialog box.
GetStaticRect is provided for components that descend from TOpenDialog and require the placement of new controls alongside the standard ones inherited from the parent class. For Explorer-style dialogs, GetStaticRect returns the size and location of the standard controls within the dialog. For older versions of Windows, or if ofOldStyleDialog is enabled in Options, GetStaticRect returns the client dimensions of the entire dialog box.</docstr>
      </function>
      <procedure name="WndProc">
        <docstr>Responds to Windows messages sent to the dialog.
Vcl.Dialogs.TOpenDialog.WndProc inherits from Vcl.Dialogs.TCommonDialog.WndProc. All content below this line refers to Vcl.Dialogs.TCommonDialog.WndProc.
Responds to Windows messages sent to the dialog.
WndProc is the main window procedure for the dialog. As implemented in TCommonDialog, it simply calls the Dispatch method, where any message handlers respond to messages before the DefaultHandler method sends them on to the Windows message handler.
Override WndProc to subclass the dialog&apos;s window procedure. To add additional message processing without interfering with the existing message handling of the dialog, override MessageHook instead.</docstr>
      </procedure>
      <function name="DoExecute">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="DoExecute">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <constructor name="Create">
        <docstr>Creates and initializes a TOpenDialog instance.
Create generates a TOpenDialog instance, but the new dialog does not appear on the form at runtime until the Execute method is called.
AOwner is the component that is responsible for freeing the TOpenDialog instance. It becomes the value of the Owner property.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys the TOpenDialog and frees its memory.
Do not call Destroy directly in an application. Call Free instead. Free verifies that the TOpenDialog reference is not nil before calling Destroy.</docstr>
      </destructor>
      <function name="Execute">
        <docstr>Displays the file-selection dialog.
Execute opens the file-selection dialog, returning true when the user selects a file and clicks Open. If the user clicks Cancel, Execute returns false.
The code signatures of Execute that appear above are actually overrides of the Execute overloads in the base class Vcl.Dialogs.TCommonDialog.Execute.  There is one more overload of Execute for Delphi that appears in the inherited members from TCommonDialog, and this overload takes no input parameters.
The ParentWnd parameter is a window handle of type HWND MSDN.  If none is provided, the current form handle is used, accessed from  Vcl.Forms.TApplication.ActiveFormHandle in the global variable Vcl.Forms.Application.

 // Delphi:
 if OpenDialog1.Execute then
   Memo1.Lines.LoadFromFile(OpenDialog1.FileName)
 else
   Memo1.Lines.Clear;

 // C++:
 if (OpenDialog1-&gt;Execute())
   Memo1-&gt;Lines-&gt;LoadFromFile(OpenDialog1-&gt;FileName);
 else
   Memo1-&gt;Lines-&gt;Clear();</docstr>
      </function>
      <property name="FileEditStyle">
        <docstr>Determines the style of the file-selection dialog. (Obsolete.)
FileEditStyle is maintained for compatibility with older versions of the VCL. It has no effect.</docstr>
      </property>
      <property name="Files">
        <docstr>List of selected file names.
Files is a string list that contains each selected file name with its full directory path. (To let users select multiple file names, set the ofAllowMultiSelect flag in Options.) Use properties and methods for string lists to traverse this list of files and read individual items.
The example below assigns the list of files in Files to the Items property of a TListBox component.



ListBox1.Items.Assign(OpenDialog1.Files);




ListBox1-&gt;Items-&gt;Assign(OpenDialog1-&gt;Files);</docstr>
      </property>
      <property name="HistoryList">
        <docstr>Maintains a list of previously selected files. (Obsolete.)
HistoryList is maintained for compatibility with older versions of TOpenDialog. It is not used.</docstr>
      </property>
      <property name="DefaultExt">
        <docstr>Specifies a default file extension.
DefaultExt specifies a file extension that is appended automatically to the selected file name, unless the selected file name already includes a registered extension. If the user selects a file name with an extension that is unregistered, DefaultExt is appended to the unregistered extension.
Extensions longer than three characters are not supported. Do not include the period (.) that divides the file name and its extension.

Code Examples
SavePictureDialog (Delphi)
TApplicationIcon (Delphi)
SavePictureDialog (C++)
TApplicationIcon (C++)</docstr>
      </property>
      <property name="FileName">
        <docstr>Indicates the name and directory path of the last file selected.
The FileName property returns the name and complete directory path of the most recently selected file. The value of FileName is the same as the first item in the Files property.
To make a file name appear by default in the dialog&apos;s edit box, assign a value to FileName in the Object Inspector or in program code. Programmatic changes to FileName have no effect while the dialog is active.

if OpenDialog1.Execute then
  Memo1.Lines.LoadFromFile(OpenDialog1.FileName)
else
  Memo1.Lines.Clear;

if (OpenDialog1-&gt;Execute())
  Memo1-&gt;Lines-&gt;LoadFromFile(OpenDialog1-&gt;FileName);
else
  Memo1-&gt;Clear();</docstr>
      </property>
      <property name="Filter">
        <docstr>Determines the file masks (filters) available in the dialog.
The file-selection dialog includes a drop-down list of file types under the edit box. When the user picks a file type from the list, only files of the selected type are displayed in the dialog.
To configure file masks at design time, click on the ellipsis marks (...) to the right of the Filter property in the Object Inspector. This opens the Filter editor. In the left column of the Filter editor, under Filter Name, type a brief description of each file type that will be available at runtime. In the right column, under Filter, type the file mask corresponding to each description. For example, the description &quot;Text files&quot; might appear to the left of the mask &quot;*.txt&quot;, and the description &quot;Pascal source files&quot; might appear to the left of the mask &quot;*.pas&quot;. Since the description appears in the drop-down list at runtime, it is often helpful to show the mask explicitly in the description (for example, &quot;Text files (*.txt)&quot;).
To create file masks in program code, assign a value to the Filter property that consists of a description and a mask separated by a vertical bar (pipe) character. Do not include spaces around the vertical bar. For example,



OpenDialog1.Filter := &apos;Text files (*.txt)|*.TXT&apos;;




OpenDialog1-&gt;Filter = &quot;Text files (*.txt)|*.TXT&quot;;



Multiple filters should be separated by vertical bars. For example,



OpenDialog1.Filter := &apos;Text files (*.txt)|*.TXT|Pascal files (*.pas)|*.PAS&apos;;




OpenDialog1-&gt;Filter = &quot;Text files (*.txt)|*.TXT|Pascal files (*.pas)|*.PAS&quot;;



To include multiple masks in a single filter, separate the masks with semicolons. This works both in the Object Inspector and in program code. For example,



OpenDialog1.Filter := &apos;Pascal files|*.PAS;*.DPK;*.DPR&apos;;




OpenDialog1-&gt;Filter = &quot;Pascal files|*.PAS;*.DPK;*.DPR&quot;;



If no value is assigned to Filter, the dialog displays all file types.</docstr>
      </property>
      <property name="FilterIndex">
        <docstr>Determines which filter is selected by default when the dialog opens.
FilterIndex determines which of the file types in Filter is selected by default when the dialog opens. Set FilterIndex to 1 to choose the first file type in the list as the default, or set FilterIndex to 2 to choose the second file type as the default, and so forth. If the value of FilterIndex is out or range, the first file type listed in Filter is the default.</docstr>
      </property>
      <property name="InitialDir">
        <docstr>Determines the current directory when the dialog opens.
InitialDir determines the default directory displayed in the file-selection dialog when it opens. For example, to point the dialog at the WINDOWS\SYSTEM directory, set the value of InitialDir to C:\WINDOWS\SYSTEM.
If no value is assigned to InitialDir, or if the specified directory does not exist, the initial directory is controlled by the global ForceCurrentDirectory variable. If ForceCurrentDirectory is true, the dialog opens with the current working directory displayed. Otherwise, the dialog opens with either the current working directory or the My Documents directory, depending on the version of Windows.</docstr>
      </property>
      <property name="Options">
        <docstr>Determines the appearance and behavior of the file-selection dialog.
Use the Options property to customize the appearance and functionality of the dialog.</docstr>
      </property>
      <property name="OptionsEx">
        <docstr>Augments the Options property with additional flags that determine the appearance and behavior of the file-selection dialog.
Use the OptionsEx property to further customize the file open dialog beyond the options covered by the Options property.</docstr>
      </property>
      <property name="Title">
        <docstr>Specifies the text in the dialog&apos;s title bar.
Use Title to specify the text that appears in the file-selection dialog&apos;s title bar. If no value is assigned to Title, the dialog has the title &quot;Open&quot;.

Code Examples
TOpenDialogTitle (Delphi)
TOpenDialogTitle (C++)</docstr>
      </property>
      <event name="OnCanClose">
        <docstr>Occurs when the user tries to close the dialog without canceling.
Write an OnCanClose event handler to provide custom validation of the value of FileName. File selection dialogs provide a number of built-in validations, such as checking for invalid characters, prompting for confirmation before overwriting, checking whether a file or path exists, and so on. These validations can be specified using the Options property. However, applications can provide additional validation of file names in an OnCanClose event handler. 
Set the CanClose parameter to false to prevent the dialog from closing. The OnCanClose event handler is responsible for telling the user why the dialog doesn&apos;t close.

Note: OnCanClose does not occur under Windows NT 3.51 unless the new shell is installed.</docstr>
      </event>
      <event name="OnFolderChange">
        <docstr>Occurs when a directory is opened or closed from the dialog.
The OnFolderChange event occurs when the user changes the directory whose contents are displayed in the dialog. This can happen when the user double-clicks a directory, clicks the Up arrow, or uses the list box at the top of the dialog to navigate through the directory structure. 
To obtain the path of the currently selected directory, use the ExtractFilePath routine on the FileName property of the Sender.</docstr>
      </event>
      <event name="OnSelectionChange">
        <docstr>Occurs when file names displayed in the dialog are changed.
The OnSelectionChange event occurs when the user does something to change the list displayed in the dialog. This can include opening the file-selection dialog box, highlighting a file or directory, selecting a new filter, selecting a new directory, or creating a new folder. 
The newly selected files can be obtained by reading the value of the FileName or Files properties. The latter property should be consulted if the ofMultiSelect option is included in the dialog&apos;s Options.</docstr>
      </event>
      <event name="OnTypeChange">
        <docstr>Occurs when the file types displayed in the dialog are changed.
The OnTypeChange event occurs when the user selects a new filter from the Files of Type list box at the bottom of the dialog.</docstr>
      </event>
      <event name="OnIncludeItem">
        <docstr>Occurs before the dialog adds a file to the file list box.
Write an OnIncludeItem event handler to programmatically filter the items that appear in the shell folder&apos;s item list. 
This event does not occur unless the Options property includes ofEnableIncludeNotify.</docstr>
      </event>
    </members>
  </class>
  <class unit="Vcl.Dialogs" name="TSaveDialog">
    <docstr>TSaveDialog displays a &quot;Save As&quot; dialog for saving files.
TSaveDialog displays a modal Windows dialog box for selecting file names and saving files. The dialog does not appear at runtime until it is activated by a call to the Execute method. When the user clicks Save, the dialog closes and the selected file name is stored in the FileName property.</docstr>
    <members>
      <function name="Execute">
        <docstr>Displays the Save As dialog box.
Execute opens the Save As dialog, returning true when the user selects a file name and clicks Save. If the user cancels the save operation, Execute returns a false value.
The code signatures of Execute that appear above are actually overrides of the Execute overloads in the base class Vcl.Dialogs.TCommonDialog.Execute.  There is one more overload of Execute for Delphi that appears in the inherited members from TCommonDialog, and this overload takes no input parameters.
The ParentWnd parameter is a window handle of type HWND MSDN.  If none is provided, the current form handle is used, accessed from  
Vcl.Forms.TApplication.ActiveFormHandle in the global variable Vcl.Forms.Application.

 // Delphi:
 if SaveDialog1.Execute then
   Memo1.Lines.SaveToFile(SaveDialog1.FileName);

 // C++:
 if (SaveDialog1-&gt;Execute())
   Memo1-&gt;Lines-&gt;SaveToFile(SaveDialog1-&gt;FileName);</docstr>
      </function>
    </members>
  </class>
  <class unit="Vcl.Dialogs" name="TFileOpenDialog">
    <docstr>Class for Vista and newer Windows operating systems style file open dialogs.
This class extends TCustomFileOpenDialog. It allows creating Microsoft Windows Vista (or newer Windows operating systems) style file open dialogs CLSID_FileOpenDialog and implements the IFileOpenDialog interface.</docstr>
  </class>
  <class unit="Vcl.Menus" name="TMenuItem">
    <docstr>TMenuItem describes the properties of an item in a menu.
Use TMenuItem to specify the appearance and behavior of an item in a menu. Each TMainMenu or TPopupMenu component can contain multiple menu items. When a menu is defined at design time, the Menu Designer automatically creates menu item objects for each command on the menu.
The Caption property can be used to define an accelerator key to the menu item of a TMainMenu.</docstr>
    <members>
      <procedure name="ActionChange">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="AdvancedDrawItem">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="AssignTo">
        <docstr>Copies the properties of an object to a destination object.
Vcl.Menus.TMenuItem.AssignTo inherits from System.Classes.TPersistent.AssignTo. All content below this line refers to System.Classes.TPersistent.AssignTo.
Copies the properties of an object to a destination object.
Override the AssignTo method to extend the functionality of the Assign method of destination objects so that they handle newly created object classes. When defining a new object class, override the Assign method for every existing object class that should be able to copy its properties to the new class. Override the AssignTo method for every existing class to which the new class can copy.
The Assign method of TPersistent calls AssignTo if the descendant object does not succeed in copying the properties of a source object. The AssignTo method defined by TPersistent raises an EConvertError exception. 
For example, given the following code in which A and B are instance variables:

A.Assign(B); {Delphi}

A-&gt;Assign(B); // C++

if A knows how to handle B, then it does so and returns. If A doesn&apos;t know how to handle B&apos;s type, execution will trickle to the TPersistent version of Assign, which calls:

B.AssignTo(A); {Delphi}

B-&gt;AssignTo(A); // C++

If B knows how to copy to A, the assignment succeeds. Otherwise, TPersistent raises an exception.</docstr>
      </procedure>
      <procedure name="DefineProperties">
        <docstr>Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
Vcl.Menus.TMenuItem.DefineProperties inherits from System.Classes.TComponent.DefineProperties. All content below this line refers to System.Classes.TComponent.DefineProperties.
Designates methods for storing an object&apos;s unpublished data on a stream such as a form file.
TComponent overrides the DefineProperties method defined in TPersistent to define &quot;fake&quot; Top and Left properties. These are defined so that components that are not controls can be manipulated at design time. However, the Top and Left properties are hidden, that is, they are not published, because only controls appear at run time.
DefineProperties is virtual; descendent classes can override it. When overriding DefineProperties, be aware that the Ancestor property of Filer might be set, and that this property can determine whether or not it is appropriate to write properties.
DefineProperties is called automatically as part of the component streaming system; do not call it directly.</docstr>
      </procedure>
      <procedure name="DoDrawText">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DrawItem">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GetActionLinkClass">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetHandle">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetCount">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetItem">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetMenuIndex">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetAutoHotkeys">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetAutoLineReduction">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="InsertNewLine">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="MeasureItem">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="MenuChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Loaded">
        <docstr>Initializes the component after the form file has been read into memory.
Vcl.Menus.TMenuItem.Loaded inherits from System.Classes.TComponent.Loaded. All content below this line refers to System.Classes.TComponent.Loaded.
Initializes the component after the form file has been read into memory.
Do not call the protected Loaded method. The streaming system calls this method after it loads the component&apos;s form from a stream.
When the streaming system loads a form or data module from its form file, it first constructs the form component by calling its constructor, then reads its property values from the form file. After reading all the property values for all the components, the streaming system calls the Loaded methods of each component in the order the components were created. This gives the components a chance to initialize any data that depends on the values of other components or other parts of itself.

Note:  All references to sibling components are resolved by the time Loaded is called. Loaded is the first place that sibling pointers can be used after being streamed in.
As implemented in TComponent, Loaded clears the csLoading flag in the ComponentState property, indicating that the component is no longer loading.

Warning: Loaded may be called multiple times on inherited forms. It is called every time a level of inheritance is streamed in. Do not allocate memory in an overridden Loaded method without first checking that the memory has not been allocated in a previous call.</docstr>
      </procedure>
      <procedure name="Notification">
        <docstr>Forwards notification messages to all owned components.
Vcl.Menus.TMenuItem.Notification inherits from System.Classes.TComponent.Notification. All content below this line refers to System.Classes.TComponent.Notification.
Forwards notification messages to all owned components.
Do not call the Notification method in an application. Notification is called automatically when the component specified by AComponent is about to be inserted or removed, as specified by Operation. By default, components pass along the notification to their owned components, if any.
A component can, if needed, act on the notification that a component is being inserted or removed. For example, if a component has object fields or properties that contain references to other components, it can check the notifications of component removals and invalidate those references as needed.

Note: Notification is not called for components that are freed implicitly (because their Owner is freed).</docstr>
      </procedure>
      <procedure name="SetBreak">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="SetCaption">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="SetChecked">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="SetChildOrder">
        <docstr>Sets the visual ordering of a child control.
Vcl.Menus.TMenuItem.SetChildOrder inherits from System.Classes.TComponent.SetChildOrder. All content below this line refers to System.Classes.TComponent.SetChildOrder.
Sets the visual ordering of a child control.
SetChildOrder is used internally in the component streaming system. It is not necessary to call it directly. 
Derived classes override this method to actually implement the ordering. TWinControl uses this ordering information to Z-align the controls.</docstr>
      </procedure>
      <procedure name="SetDefault">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="SetEnabled">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="SetGroupIndex">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="SetImageIndex">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="SetImageName">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="SetMenuIndex">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="SetRadioItem">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="SetShortCut">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="SetVisible">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="UpdateItems">
        <docstr>Iterates through all the menu items of this menu item and updates them.
UpdateItems is called whenever the image list attached to the menu is changed or when OwnerDraw is changed.</docstr>
      </procedure>
      <procedure name="CheckImageIndex">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <property name="ActionLink">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="Merged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <constructor name="Create">
        <docstr>Creates an instance of TMenuItem.
Use Create to create a menu item at runtime. Menu items defined at design time using the Menu designer are created automatically.
AOwner is the component that is responsible for freeing the menu item. It becomes the value of the Owner property.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys an instance of TMenuItem.
Do not call Destroy directly in an application. Instead, call Free. Free verifies that the TMenuItem reference is not nil, and only then calls Destroy.</docstr>
      </destructor>
      <procedure name="InitiateAction">
        <docstr>Calls the action link&apos;s Update method if the menu item is associated with an action link.
InitiateAction calls the action link, if there is one for the menu item, to update the association between the action and the menu item.</docstr>
      </procedure>
      <procedure name="Insert">
        <docstr>Inserts a menu item into a specified position in the Items array.
Use Insert to insert a new menu item to the dropdown menu for this menu item. If this menu item is the value of the Items property of a main menu or pop-up menu, Insert inserts an item into that menu. Specify the new menu item to add as the value of the Item parameter, and the position in the Items array as the value of the Index parameter.</docstr>
      </procedure>
      <procedure name="Delete">
        <docstr>Removes a menu item from the Items property array.
Call Delete to remove a menu item and all its submenus from a menu. The Index parameter is the index of the item to be deleted, where 0 specifies the first item in the menu, 1 specifies the second item, and so on.
Delete does not free the removed item&apos;s memory. To remove an item from the menu and free its memory, call the Free method in the item you want to remove.
To temporarily hide a menu item, without deleting it, use the Visible property.</docstr>
      </procedure>
      <procedure name="Clear">
        <docstr>Removes and frees all menu items listed in the Items property.
Use Clear to free all the items listed in the Items property array.</docstr>
      </procedure>
      <procedure name="Click">
        <docstr>Simulates a mouse click.
Click generates an OnClick event, as if the user had clicked the menu item. Unlike a real mouse click, Click does not generate a WM_COMMAND message to the window associated with the menu.
Component writers can override click to provide a different response when the user selects the menu item.</docstr>
      </procedure>
      <function name="Find">
        <docstr>Locates a menu item in the Items property array given its caption.
Use Find to locate the menu item in the Items property array with the caption specified by the ACaption parameter. Find ignores accelerator characters when comparing item captions to the ACaption parameter.
Find returns the first menu item in the Items property array with the specified caption. If no item is found, Find returns nil (Delphi) or NULL (C++).</docstr>
      </function>
      <function name="IndexOf">
        <docstr>Returns the position of a menu item within the Items array.
Call IndexOf to locate a menu item in the submenu headed by this menu item. IndexOf returns 0 for the first menu item, 1 for the second menu item, and so on. If the menu item is not in the submenu, IndexOf returns -1.

Note: IndexOf may not correspond to the position of the item in the menu the user sees if the menu includes some items that are not visible.</docstr>
      </function>
      <function name="IsLine">
        <docstr>Indicates whether the menu item represents a separator bar.
Call IsLine to determine whether the menu item is a separator bar. IsLine checks the Caption of the menu item and returns true if the value of Caption is &apos;-&apos;. Menu items with this Caption appear as separator bars.</docstr>
      </function>
      <procedure name="GetChildren">
        <docstr>Enumerates all child components.
Vcl.Menus.TMenuItem.GetChildren inherits from System.Classes.TComponent.GetChildren. All content below this line refers to System.Classes.TComponent.GetChildren.
Enumerates all child components.
GetChildren is used internally in the component streaming system. It is not necessary to call it directly. 
GetChildren expects a TGetChildProc routine that receives all enumerated components. 
Root represents the owner of the components that will be enumerated.
This method does nothing in TComponent and is expected to be overridden in descendants.</docstr>
      </procedure>
      <function name="GetEnumerator">
        <docstr>Returns a TComponent enumerator.
Vcl.Menus.TMenuItem.GetEnumerator inherits from System.Classes.TComponent.GetEnumerator. All content below this line refers to System.Classes.TComponent.GetEnumerator.
Returns a TComponent enumerator.
GetEnumerator returns a TComponentEnumerator reference, which enumerates the components contained within a specified containing component. 
To process all these subcomponents, call the TComponentEnumerator GetCurrent method within a While MoveNext do loop.</docstr>
      </function>
      <function name="GetImageList">
        <docstr>Returns the Image list that supplies an image for the menu item.
Use GetImageList to access the list of images that contains the image for this menu item. The ImageIndex property identifies a specific image from the list that GetImageList returns.
GetImageList first checks the Parent of this menu item for a SubMenuImages property. If the parent menu item does not maintain a list of images, it checks that menu item&apos;s parent, and so on until reaching a top-level menu item (a menu item where Parent is not set). If none of the parent menu items has a SubMenuImages property, GetImageList checks the top-level menu for an Images property.
GetImageList returns the first image list it finds. If it doesn&apos;t find an image list, GetImageList returns nil (Delphi) or NULL (C++).</docstr>
      </function>
      <function name="GetParentComponent">
        <docstr>Returns the parent component of the menu item.
GetParentComponent is called by the streaming system that loads and saves components. It ensures that objects are loaded and saved with their parent objects. GetParentComponent is overridden in descendant classes to return the appropriate parent for their particular type of component. TMenuItem overrides it to identify its associated menu, if it has one, as its parent.</docstr>
      </function>
      <function name="GetParentMenu">
        <docstr>Returns the main menu of which the menu item is part.
GetParentMenu returns the menu that contains the menu item.</docstr>
      </function>
      <function name="HasParent">
        <docstr>Indicates that the menu item has a parent that is responsible for loading and saving its data.
TMenuItem overrides HasParent to return true, indicating that menu items have a parent. Applications seldom call the HasParent method. It is used by the streaming system that loads and saves forms to determine when another object is responsible for writing a component to a stream.</docstr>
      </function>
      <function name="NewTopLine">
        <docstr>Inserts a separator bar at the beginning of the Items property array.
Use NewTopLine to insert a separator bar at the beginning of the items property array. This is useful when building up submenus dynamically at runtime.
NewTopLine returns the index of the newly inserted separator item in the Items property array.

Tip:  When inserting separator bars at runtime, it is a good idea to set AutoLineReduction to true so that superfluous separators can be automatically removed.</docstr>
      </function>
      <function name="NewBottomLine">
        <docstr>Inserts a separator bar at the end of the Items property array.
Use NewBottomLine to insert a separator bar at the end of the items property array. This is useful when building up submenus dynamically at runtime.
NewBottomLine returns the index of the newly inserted separator item in the Items property array.

Tip:  When inserting separator bars at runtime, it is a good idea to set AutoLineReduction to true so that superfluous separators can be automatically removed.</docstr>
      </function>
      <function name="InsertNewLineBefore">
        <docstr>Inserts a separator bar before a specified item from the Items property array.
Use InsertNewLineBefore to insert a separator bar before the menu item specified by AItem. If AItem is not an item in the Items property array, InsertNewLineBefore raises an exception.
InsertNewLineBefore returns the index of the newly inserted separator item in the Items property array.

Tip:  When inserting separator bars at runtime, it is a good idea to set AutoLineReduction to true so that superfluous separators can be automatically removed.</docstr>
      </function>
      <function name="InsertNewLineAfter">
        <docstr>Inserts a separator bar after a specified item from the Items property array.
Use InsertNewLineAfter to insert a separator bar after the menu item specified by AItem. If AItem is not an item in the Items property array, InsertNewLineAfter raises an exception.
InsertNewLineAfter returns the index of the newly inserted separator item in the Items property array.

Tip:  When inserting separator bars at runtime, it is a good idea to set AutoLineReduction to true so that superfluous separators can be automatically removed.</docstr>
      </function>
      <procedure name="Add">
        <docstr>Adds one or more menu items to the end of the Items property array.
Use Add to add new menu items to the dropdown menu for this menu item. If this menu item is the value of the Items property of a main menu or pop-up menu, Add adds the items to the end of the menu. 
Specify a single new menu item to add as the value of the Item parameter, or an array of new menu items as the value of the AItems parameter. AItems_Size is the index of the last item in the AItems array (one less than the number of items).</docstr>
      </procedure>
      <procedure name="Add">
        <docstr>Adds one or more menu items to the end of the Items property array.
Use Add to add new menu items to the dropdown menu for this menu item. If this menu item is the value of the Items property of a main menu or pop-up menu, Add adds the items to the end of the menu. 
Specify a single new menu item to add as the value of the Item parameter, or an array of new menu items as the value of the AItems parameter. AItems_Size is the index of the last item in the AItems array (one less than the number of items).</docstr>
      </procedure>
      <procedure name="Remove">
        <docstr>Removes a menu item from the Items property array
Call Remove to remove a menu item and all its submenus from a menu. The Item parameter is the item to be removed. If Item is not a menu item in the Items array, Remove raises an exception.
Remove does not free the item&apos;s memory. To remove an item from the menu and free its memory, call the Free method in the item you want to remove.
To temporarily hide a menu item, without deleting it, use the Visible property.</docstr>
      </procedure>
      <function name="RethinkHotkeys">
        <docstr>Adjusts the captions of subitems so that every item has an accelerator and there are no duplicate accelerator keys.
Call RethinkHotkeys to adjust the accelerator keys for the items in the Items property and in any submenu of those items. RethinkHotkeys checks for items that do not have an accelerator key or that have duplicate accelerator keys. It then replaces any duplicate accelerators with unique characters and adds accelerator keys to items that don&apos;t have them. RethinkHotkeys gives first priority to existing accelerator key mappings, but may change them if necessary to ensure uniqueness.
RethinkHotkeys lets a menu adjust the accelerator keys when the AutoHotkeys property is false. For any menu or submenu that has AutoHotkeys set to true, this adjustment occurs automatically.
RethinkHotkeys returns true if RethinkHotkeys changed the Caption property of any menu items, false otherwise.</docstr>
      </function>
      <function name="RethinkLines">
        <docstr>Removes superfluous separator lines from the Items property array.
Call RethinkLines to remove superfluous separators from the items in the Items property and in any submenu of those items. RethinkLines removes separators that appear at the very beginning or end of a submenu and separators that immediately follow another separator.
RethinkLines lets a menu remove superfluous separators when the AutoLineReduction property is false. For any menu or submenu that has AutoLineReduction set to true, this adjustment occurs automatically.
RethinkLines returns true if RethinkLines removed any menu items, false otherwise.</docstr>
      </function>
      <procedure name="SetParentComponent">
        <docstr>Sets the parent component.
Vcl.Menus.TMenuItem.SetParentComponent inherits from System.Classes.TComponent.SetParentComponent. All content below this line refers to System.Classes.TComponent.SetParentComponent.
Sets the parent component.
SetParentComponent is used internally in the component streaming system. It is not necessary to call it directly. 
Derived classes override this method to implement proper handling for parenting.</docstr>
      </procedure>
      <property name="Command">
        <docstr>Specifies the Windows Command ID associated with the menu item.
Use Command in an application that directly handles WM_COMMAND messages. When the user selects the menu item, Windows sends a WM_COMMAND to the window associated with the menu. The ItemID of the message contains the value of the Command property of the menu item that was selected.</docstr>
      </property>
      <property name="Handle">
        <docstr>Indicates the Windows menu handle of the drop-down menu associated with the menu item.
Use Handle when calling a Windows API function that requires a menu handle. Handle is only valid if the Count property is greater than 0.</docstr>
      </property>
      <property name="Count">
        <docstr>Indicates the number of subitems of the menu item.
Read Count to determine the number of subitems listed in the Items property array. When the user clicks on a menu item that has subitems, a dropdown menu appears which displays those subitems. Each subitem can, in turn, contain additional subitems. The Count property counts only the immediate subitems of the menu item.</docstr>
      </property>
      <property name="MenuIndex">
        <docstr>Indicates the index of the menu item within its parent menu.
Use MenuIndex to locate the menu item in the Items property of its parent menu item. Changing this value moves the menu item within its menu.

Note: MenuIndex may not correspond to the position of the item in the menu the user sees. The menu can include items that are not visible.</docstr>
      </property>
      <property name="Parent">
        <docstr>Identifies the parent menu item of this menu item.
Read Parent to determine the menu item that represents the dropdown menu that contains this menu item. If the menu item is a top level menu item in a main menu or pop-up menu, Parent is the value of that menu&apos;s Items property.</docstr>
      </property>
      <property name="Action">
        <docstr>Designates the action associated with the menu item.
Action designates the action object that is associated with the menu item. Actions can be associated with a menu item by using the action list editor at design-time. Actions are a way of centralizing user responses to commands.</docstr>
      </property>
      <property name="AutoCheck">
        <docstr>Indicates whether the menu item&apos;s checked state toggles automatically when the item is clicked.
When AutoCheck is true, then every time the menu item is clicked, the value of the Checked property toggles automatically before the OnClick event occurs. When AutoCheck is false, the application must explicitly set the value of the Checked property (for example, in an OnClick event handler).</docstr>
      </property>
      <property name="AutoHotkeys">
        <docstr>Determines whether the accelerator keys for submenu items can be reset automatically.
Set AutoHotkeys to indicate whether the accelerator keys for the items in the Items property can be reset if necessary to ensure that every menu item has an accelerator key and no two items have the same accelerator key. This ensures that menu items added dynamically at runtime can have accelerator keys that do not introduce conflicts. TMenuItem tries to preserve all existing accelerator key mappings when adjusting the accelerator keys, but may be forced to change some in order to ensure that every item has a unique accelerator.
Before the menu is displayed, it checks and adjusts the accelerator key mappings if AutoHotkeys is maAutomatic or if AutoHotkeys is maParent and the parent menu item adjusts accelerator key mappings. Otherwise, the menu does not alter the items listed in the Items property, but may adjust the accelerator keys for submenus, depending on the AutoHotkeys property of the menu item that is the parent of the submenu.

Note:  When AutoHotkeys disallows automatic adjustment of accelerator keys, an application can still adjust the menu items by calling the RethinkHotkeys method. AutoHotkeys merely controls whether this adjustment occurs automatically.</docstr>
      </property>
      <property name="AutoLineReduction">
        <docstr>Determines whether redundant separator bars are automatically removed from the submenu.
Set AutoLineReduction to indicate whether the menu item should automatically ensure that the submenu defined by its Items property does not start or end with a separator bar and that two separator bars do not appear next to each other. This ensures that menus built dynamically at run time do not have separator bars in undesired positions.
Before the menu is displayed, the menu item removes superfluous separator bars if AutoLineReduction is maAutomatic or AutoLineReduction is maParent and the parent menu item removes superfluous separator bars. Otherwise, the menu item does not remove separators from the Items property, but may remove superfluous separators from submenus, depending on the AutoLineReduction property of the menu item that is the parent of the submenu.

Note: When AutoLineReduction disallows automatic removal of separator bars, an application can still remove superfluous separators by calling the RethinkLines method. AutoLineReduction merely controls whether this adjustment occurs automatically.</docstr>
      </property>
      <property name="Bitmap">
        <docstr>Designates a bitmap that is drawn for the menu item.
Use Bitmap to provide a custom image that appears next to the caption in the menu item. On owner-draw menus, Bitmap can be used from an OnDrawItem event handler to represent the entire menu item or a portion of the menu item.

Note:  If the ImageIndex property is set and the parent menu has a non-nil (Delphi) or NULL (C++) Images property, the image identified by ImageIndex is used instead of Bitmap.</docstr>
      </property>
      <property name="Break">
        <docstr>Determines whether the menu item starts a new column in the menu.
Set Break to break a long menu into columns at the item described by this menu item. The value of Break indicates whether the menu is broken into columns, and if so, whether a bar appears between the columns of the parent menu.
The default is mbNone (no breaking into columns).</docstr>
      </property>
      <property name="Caption">
        <docstr>Specifies the text of the menu item.
Set Caption to the string the user sees for this item in the menu. To underline a character in a string, include an ampersand (&amp;) before the character. This type of character is called an accelerator character. If Caption includes an accelerator character, the user can select the menu item by pressing Alt while typing the underlined character.

Tip:  To automatically assign or adjust the accelerator characters in menu item captions, use the RethinkHotkeys method.
Use the Caption property to identify the menu item as a line that separates the menu into parts. Specify a hyphen character (-) as the value of Caption for the menu item to indicate that the menu item is a separator. To separate the menu into multiple columns, use the Break property instead.

Note:  This property is not stored with the menu item if it is supplied by a TAction object.</docstr>
      </property>
      <property name="Checked">
        <docstr>Specifies whether a check mark should appear beside the Caption.
Use Checked to allow a menu item to work like a check box. If Checked is true, the menu item appears checked. If Checked is false, the menu item remains unchecked.

Note:  This property is not stored with the menu item if it is supplied by a TAction object.</docstr>
      </property>
      <property name="SubMenuImages">
        <docstr>Lists the images that can appear beside individual items in a submenu of this menu item.
Use SubMenuImages to supply a set of images that can appear beside items listed in the Items property. Individual menu items set their ImageIndex property to indicate which image in the list appears to the left of the menu item caption.

Tip:  If the application uses action lists, this property can be the value of the command list&apos;s Images property. This way, menu items and buttons that do the same thing can display the same image.</docstr>
      </property>
      <property name="Default">
        <docstr>Specifies whether the menu item is invoked when the parent item is double clicked.
Set Default to specify whether a menu item is the default item in a submenu. Default menu items are executed when the parent item is double-clicked, allowing users to avoid navigating the submenus that contain them. 
The default item appears in boldface. A submenu can have only one default item. If the Items list of the parent menu item already contains a default menu item, setting the Default property to true sets the Default property of the previous default item to false.</docstr>
      </property>
      <property name="Enabled">
        <docstr>Specifies whether the menu item is enabled.
Use Enabled to enable or disable a menu item. If Enabled is true, the Click method is called when the user selects the item with the mouse. If Enabled is false, the menu item appears dimmed and the user cannot select it. However, calling the Click method works even when Enabled is false.

Note:  This property is not stored with the menu item if it is supplied by a TAction object.</docstr>
      </property>
      <property name="GroupIndex">
        <docstr>Identifies the logical group to which the menu item belongs.
Use GroupIndex to control how menus are merged. In applications that contain multiple forms, items from the menus of secondary forms can be merged into the application&apos;s main menu as those forms become active. MDI applications always merge the menus of child windows with the main menu of the parent window. 
By default, all menu items in a menu bar (main menu) have the same GroupIndex value. To use GroupIndex to merge menus, set the GroupIndex value of each successive menu item to a value equal to or greater than that of the previous menu item. 
When a menu item in a menu bar that is merged into the application&apos;s main menu has the same GroupIndex value as a menu item in the main menu, the menu item in the application&apos;s main menu is replaced by the corresponding menu item. If multiple menu items in the application&apos;s main menu have the same GroupIndex value, they can be replaced only by separate menu items from the other form&apos;s menu that also have repeated GroupIndex values. Thus, the first main menu item with a given value is replaced by the first item in the second form with that value, the second item in the main form is replaced by the second item in the second form, and so on. 
When a menu item in a menu bar that is merged into the application&apos;s main menu has a GroupIndex that falls between the GroupIndex values of two adjacent items on the application&apos;s main menu, that menu item is inserted between the two adjacent items. If the item&apos;s GroupIndex value is greater than all other GroupIndex values in the application&apos;s main menu, the item appears at the end of the main menu. If the GroupIndex value is less than all other GroupIndex values in the application&apos;s main menu, the menu item appears at the beginning of the main menu bar. 
When an object created by an OLE 2.0 server application is activated, the server can try to merge its menus with the menus of the container application. The GroupIndex property is used to replace up to three main menu items with items from the server, in the manner described above. The server application uses the following predefined GroupIndex values to locate menu items to replace:





Group

Index

Description



Edit



1



Server menu items for editing the active OLE object




View



3



Server menu items for modifying the view of the OLE object.




Help



5



Server menu items for accessing the server&apos;s online Help.





Note:  See the documentation for the OLE server for information about whether it attempts menu merge during in-place activation.
GroupIndex can also be used to define groups of menu items that act like radio buttons. To allow menu items to behave like radio buttons, set the RadioItem property to all menu items in the group to true, and assign each menu item the same value of GroupIndex. Checking any menu item in the group will then uncheck the others.</docstr>
      </property>
      <property name="HelpContext">
        <docstr>Specifies the help context ID associated with the menu item.
Use HelpContext to associate the menu item with a screen in the Help system of the application. Each screen in the Help system should have a unique context ID. When a menu item is selected using the keyboard, pressing F1 displays a Help screen. Which Help screen appears depends on the value of the HelpContext property.

Note:  This property is not stored with the menu item if it is supplied by a TAction object.</docstr>
      </property>
      <property name="Hint">
        <docstr>Specifies the text string that can appear when the user moves the mouse pointer over a menu item.
Set Hint to a string that provides more information about the meaning of the menu item than the Caption. The hint text appears in the Status Bar when the user pauses with the mouse over the menu item if Help Hints are enabled (that is, if the Form&apos;s and the Application&apos;s ShowHint properties are True). It is also available for the code in the application&apos;s OnHint event handler.
The value of Hint can specify both a short value for the Help Hint window and a longer string to be used by the OnHint event handler. To provide both a short and a long hint, set Hint to the short string, followed by a vertical bar (|), followed by the long string. 

Note: This property is not stored with the menu item if it is supplied by a TAction object.</docstr>
      </property>
      <property name="ImageIndex">
        <docstr>Indicates which image maintained by the parent menu appears next to the menu item.
Set ImageIndex to designate an image that should appear next to the caption when the menu item is drawn. On top-level menu items, ImageIndex specifies a zero-offset index into the Images property of the parent menu (TMenu or TPopupMenu). On submenu items, ImageIndex is the zero-offset index into the parent item&apos;s SubMenuImages property.
If the parent menu or item does not maintain a list of images, use the Bitmap property to provide an image for a single menu item. However, any image specified by ImageIndex takes precedence over the Bitmap property. Bitmap is only used when ImageIndex has a negative value or the parent&apos;s Images or SubMenuImages property is nil (Delphi) or NULL (C++).

Note:  This property is not stored with the menu item if it is supplied by a TAction object.</docstr>
      </property>
      <property name="ImageName">
        <docstr>Displays the name of linked items from the Image Collection.</docstr>
      </property>
      <property name="RadioItem">
        <docstr>Specifies whether the menu item is mutually exclusive with other menu items in its group.
Use RadioItem to make the menu item behave like a radio button with a group of other menu items. The group of menu items is the set of all menu items in a pop-up or drop-down menu that have the same value of GroupIndex. When RadioItem is true, only one menu item in the group that contains the menu item can be checked at a time. The single selected menu item in the group is indicated by a round dot next to the Caption.

Note: RadioItem does not automatically select the item when the user clicks it at runtime: you must still explicitly set the Checked property to true in response to the OnClick event. RadioItem simply changes the appearance of the Checked state (from a check mark to a round dot) and automatically unchecks other menu items in the same group when you set the Checked property to true.
RadioItem does not work for the top-level items in a main menu.

Note:  Under Windows NT 3.51, the round dot indicator only appears if the &quot;new shell&quot; has been installed.</docstr>
      </property>
      <property name="ShortCut">
        <docstr>Shortcut that opens the menu item.
The string representation of this shortcut appears to the right of the menu item in the menu.

Note: ShortCut is not stored with the menu item if it is supplied by an action.</docstr>
      </property>
      <property name="Visible">
        <docstr>Specifies whether the menu item appears in the menu.
Use Visible to prevent the user from seeing an item in the menu. For example, remove menu items that do not apply to the current component of a pop-up menu in an OnPopup event handler.
If Visible is true, the menu item appears. If Visible is false, the menu item is hidden.

Note:  This property is not stored with the menu item if it is supplied by a TAction object.</docstr>
      </property>
      <event name="OnClick">
        <docstr>Occurs when the user clicks menu item.
Write an OnClick event handler to implement the desired behavior for when the user selects the menu item. An advantage of using the OnClick event handler over directly handling WM_COMMAND messages sent when the user selects the menu item, is that only the OnClick event occurs when the Click method is called.

Note:  This event handler is not stored with the menu item if it is supplied by a TAction object.</docstr>
      </event>
      <event name="OnDrawItem">
        <docstr>Occurs when an owner-draw menu needs to be drawn.
Write an OnDrawItem event handler to render the image of a menu item in an owner-draw menu. In the event handler, use the Bitmap property or the ImageIndex property to access a bitmap that represents the menu item.

Note: OnDrawItem will only occur if the parent menu&apos;s OwnerDraw property is true or the parent menu&apos;s Images property has been set.
Tip:  For more precise information about the menu item&apos;s state, use the OnAdvancedDrawItem event instead.</docstr>
      </event>
      <event name="OnAdvancedDrawItem">
        <docstr>Occurs when an owner-draw menu needs to be drawn.
Write an OnAdvancedDrawItem event handler to render the image of a menu item in an owner-draw menu. 
In the event handler, use the Bitmap property or the ImageIndex property to access a bitmap that represents the menu item.

Note: OnAdvancedDrawItem will only occur if the parent menu&apos;s OwnerDraw property is true or the parent menu&apos;s Images property has been set.</docstr>
      </event>
      <event name="OnMeasureItem">
        <docstr>Occurs on owner-draw menu items to determine menu item size before the menu is drawn.
Write an OnMeasureItem event handler to indicate the size of owner-draw menu items. If the menu item is using a bitmap image, the event handler can use the Bitmap property or the ImageIndex property to access the bitmap to determine its size.

Note: OnMeasureItem will only occur if the parent menu&apos;s OwnerDraw property is true or the parent menu&apos;s Images property has been set.</docstr>
      </event>
    </members>
  </class>
  <class unit="Vcl.Menus" name="TMenu">
    <docstr>TMenu is the base type for menu components such as TMainMenu and TPopupMenu.
Use TMenu as a base class when defining a component that represents a collection of menu items. TMenu introduces properties and methods to create a Windows menu that represents a set of menu items, dispatch commands associated with those menu items, and locate the help context id for any of those menu items.</docstr>
    <members>
      <procedure name="AdjustBiDiBehavior">
        <docstr>Applies the BiDiMode property to the menu when the Windows control is created.
AdjustBiDiBehavior is called automatically when the Windows control for the menu is created. It ensures that the BiDiMode property is properly reflected in the menu if the application is running in a Middle Eastern locale.</docstr>
      </procedure>
      <procedure name="DoChange">
        <docstr>Generates an OnChange event.
DoChange is called automatically when the properties of any menu items change. The Source parameter specifies the menu item (if any) that changed. The Rebuild parameter indicates whether the change requires the menu to regenerate its items.</docstr>
      </procedure>
      <procedure name="DoBiDiModeChanged">
        <docstr>Updates the menu when the BiDiMode property changes.
Do not call DoBiDiModeChanged. It is called automatically when the menu&apos;s BiDiMode property changes to update the menu to reflect the current setting.</docstr>
      </procedure>
      <function name="GetHandle">
        <docstr>Returns the value of the Handle property.
GetHandle is the protected implementation of the Handle property. Override this method to change the implementation of the handle property. For example, TMainMenu overrides GetHandle to adjust for menus added by embedded OLE objects.</docstr>
      </function>
      <function name="IsOwnerDraw">
        <docstr>Indicates whether menu items can contain more than simple captions.
IsOwnerDraw returns true when the OwnerDraw property is true or the Images property is not nil (Delphi) or NULL (C++). This is used internally to determine how the menu should be painted.</docstr>
      </function>
      <procedure name="Loaded">
        <docstr>Calls the DoChange method when the menu is first loaded into memory.
Loaded is called automatically immediately after the menu is loaded into memory. It calls the DoChange method to allow any necessary fixup.</docstr>
      </procedure>
      <procedure name="MenuChanged">
        <docstr>Responds when the menu changes.
MenuChanged is called automatically when changes occur that affect the structure of the menu. The Sender parameter indicates the object that originates the change. Its value can be nil (Delphi) or NULL (C++). Source indicates which menu item is affected. Rebuild indicates whether the menu must be rebuilt to reflect the change (for example when items are added or deleted).
MenuChanged calls the DoChange method, which generates an OnChange event.

Note:  Changes that affect individual items rather than the menu as a whole trigger the UpdateItems method instead of MenuChanged. For example, when the Images property changes, UpdateItems is called rather than MenuChanged.</docstr>
      </procedure>
      <procedure name="Notification">
        <docstr>Responds when components are added or deleted.
TMenu overrides the inherited method to set the Images property to nil (Delphi) or NULL (C++) if the ImageList is deleted.</docstr>
      </procedure>
      <procedure name="SetChildOrder">
        <docstr>Ensures that the menu item indexes reflect the order in which they are loaded and saved.
SetChildOrder is called automatically when menus are loaded into memory. The Child parameter specifies the child object that was just loaded. The Order parameter specifies the order in which it was loaded. SetChildOrder assigns the MenuIndex for each child to match the order in which the items are loaded.</docstr>
      </procedure>
      <procedure name="UpdateItems">
        <docstr>Causes all menu items to update themselves.
UpdateItems is called automatically when changes occur that must be reflected by individual menu items. Changes that affect the menu as a whole trigger the MenuChanged method instead.</docstr>
      </procedure>
      <function name="DoGetMenuString">
        <docstr>Returns the caption for an item in the menu.
DoGetMenuString is used internally to obtain menu item captions, given the Windows menu handle. The Menu parameter indicates the menu&apos;s handle. The ItemID parameter specifies the menu item whose caption is desired. If the Flag parameter is MF_BYCOMMAND, ItemID is the Command property of the menu item. If Flag is MF_BYPOSITION, ItemID is the 0-based index of the menu item. The caption is returned in a buffer pointed to by the Str parameter. MaxCount indicates the size of that buffer.
Unlike the Windows API function GetMenuString, DoGetMenuString returns the correct caption for owner-draw menu items.</docstr>
      </function>
      <event name="OnChange">
        <docstr>Occurs when the menu changes.
Write an OnChange event handler to respond to changes in the menu&apos;s structure. OnChange occurs when the menu is loaded into memory, and in response to property changes that affect the menu&apos;s structure.</docstr>
      </event>
      <constructor name="Create">
        <docstr>Creates an instance of TMenu.
Call Create to create a menu at runtime. Menus placed on forms at design time are created automatically. Create calls the inherited Create method, then sets the initial values for the menu component, including creating an Items property.
The AOwner parameter indicates the component (usually a form) that is responsible for managing the memory associated with the menu.</docstr>
      </constructor>
      <function name="CreateMenuItem">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <destructor name="Destroy">
        <docstr>Destroys the menu component.
Do not call Destroy directly in an application. Instead, call Free. Free verifies that the TMenu reference is not nil, and only then calls Destroy. Destroy frees the Items property, and then calls the inherited Destroy method.</docstr>
      </destructor>
      <function name="DispatchCommand">
        <docstr>Calls the Click method of the menu item with the specified value as its Command property.
Call DispatchCommand to simulate a click on the menu item associated with a command ID. If DispatchCommand locates a menu item that matches the command ID, it calls the Click method for that menu item and returns true. If there is no such item, DispatchCommand returns false.</docstr>
      </function>
      <function name="DispatchPopup">
        <docstr>Dispatches a pop-up menu command.
Call DispatchPopup to simulate a click on the menu item associated with the pop-up menu handle. If DispatchPopup locates a menu item that matches the pop-up menu handle, it calls the Click method for that menu item and returns true. If there is no such item, DispatchPopup returns false.</docstr>
      </function>
      <function name="FindItem">
        <docstr>Locates and returns a menu item.
Call FindItem to locate a menu item in the menu or one of its submenus. The menu item is identified by either a pop-up menu handle, command ID, or menu shortcut value. The Kind parameter specifies how the menu item is to be identified.</docstr>
      </function>
      <procedure name="GetChildren">
        <docstr>Executes a callback for child menu items.
GetChildren is called automatically by the streaming system so that child menu items are saved and read with their parent menu.</docstr>
      </procedure>
      <function name="GetHelpContext">
        <docstr>Returns the help context ID associated with a menu item.
Call GetHelpContext to obtain the ID for context-sensitive help on a particular menu item. Identify the menu item as the item that matches the Value property. If ByCommand is true, Value is the Command property of the TMenuItem. If ByCommand is false, Value is the Handle property.</docstr>
      </function>
      <property name="Images">
        <docstr>Lists the images that can appear beside individual menu items.
Use Images to hold the set of images that can appear beside menu items in the menu. Individual menu items set their ImageIndex property to indicate which image in the list appears to the left of the menu item caption.
Images in the list should be 16x16.

Tip:  If the application uses action lists, this property should be the value of the action list&apos;s Images property. This way, menu items and buttons that do the same thing can display the same image.</docstr>
      </property>
      <function name="IsRightToLeft">
        <docstr>Indicates whether menu items read from right to left.
Call IsRightToLeft to determine the layout of main menu items. IsRightToLeft returns true if the application is running on a system with a Middle Eastern locale and the BiDiMode property is not bdLeftToRight.</docstr>
      </function>
      <function name="IsShortCut">
        <docstr>Dispatches a key message if it represents a shortcut key for an item in the menu.
Call IsShortCut when processing a KeyDown message to identify shortcut keys and trigger the appropriate menu action. IsShortCut decodes the key message passed in the Message parameter. It then encodes the state of the Shift, Control, and Alt keys with the value of the character that was typed to obtain the ShortCut property of a menu item. If IsShortCut locates a menu item associated with the shortcut key combination, it calls the item&apos;s Click method and returns true. If no item in the menu has a shortcut corresponding to the message, IsShortCut returns false.</docstr>
      </function>
      <procedure name="ParentBiDiModeChanged">
        <docstr>Ensures that the menu&apos;s layout follows the current settings of the BiDiMode and ParentBiDiMode properties.
ParentBiDiMode changed is called when the menu&apos;s BiDiMode property must be updated to reflect the bi-directional mode of its associated control.</docstr>
      </procedure>
      <procedure name="ParentBiDiModeChanged">
        <docstr>Ensures that the menu&apos;s layout follows the current settings of the BiDiMode and ParentBiDiMode properties.
ParentBiDiMode changed is called when the menu&apos;s BiDiMode property must be updated to reflect the bi-directional mode of its associated control.</docstr>
      </procedure>
      <procedure name="ProcessMenuChar">
        <docstr>Responds to keyboard input for the menu.
ProcessMenuChar handles keyboard messages from Windows. It checks whether the character typed is an accelerator character from one of the menu&apos;s items. If so, ProcessMenuChar executes the menu item (or, if the item is disabled, selects it). If the key is not an accelerator, ProcessMenuChar checks for captions that begin with the character. If there is only one, it is treated like an accelerator. Otherwise, the first item beginning with that character is selected.
When calling ProcessMenuChar programmatically, the User, MenuFlag, and Menu fields of Message parameter must be supplied.</docstr>
      </procedure>
      <property name="AutoHotkeys">
        <docstr>Determines whether the accelerator keys for menu items can be reset automatically.
Set AutoHotkeys to indicate whether the menu should automatically ensure that accelerator keys for its items are reset if necessary so that every menu item has an accelerator key and no two items have the same accelerator key. This ensures that menu items added dynamically at runtime can have accelerator keys that do not introduce conflicts. TMenu tries to preserve all existing accelerator key mappings when adjusting the accelerator keys, but may be forced to change some in order to ensure that every item has a unique accelerator.
Before the menu is displayed, the menu checks and adjusts the accelerator key mappings if AutoHotkeys is maAutomatic. When AutoHotkeys is maManual, the menu does not alter the top-level menu items, but may adjust the accelerator keys for submenus, depending on the AutoHotkeys property of the menu item that is the parent of the submenu.
When AutoHotkeys is maManual, an application can still adjust the menu items by calling the Items property&apos;s RethinkHotkeys method. AutoHotkeys merely controls whether this adjustment occurs automatically.

Note:  The AutoHotkeys property of a menu is linked to the AutoHotkeys property of the TMenuItems object that implements its Items property. Setting one sets the other.</docstr>
      </property>
      <property name="AutoLineReduction">
        <docstr>Determines whether redundant separator bars are automatically removed from the menu.
Set AutoLineReduction to indicate whether the menu should automatically ensure that the menu does not start or end with a separator bar and that two separator bars do not appear next to each other. This ensures that menus built dynamically at runtime do not have separator bars in undesired positions.
Before the menu is displayed, it removes superfluous separator bars when AutoLineReduction is maAutomatic. When AutoLineReduction is maManual, the menu does not remove separators from the top-level menu items, but may remove superfluous separators from submenus, depending on the AutoLineReduction property of the menu item that is the parent of the submenu.
When AutoLineReduction is maManual, an application can still remove superfluous separators by calling the Items property&apos;s RethinkLines method. AutoLineReduction merely determines whether this adjustment occurs automatically.

Note:  The AutoLineReduction property of a menu is linked to the AutoLineReduction property of the TMenuItems object that implements its Items property. Setting one sets the other.</docstr>
      </property>
      <property name="BiDiMode">
        <docstr>Determines the layout of the menu in Middle East locales.
Set BiDiMode to control the layout of menu items. BiDiMode controls whether the menu items read from left to right or right to left.</docstr>
      </property>
      <property name="Handle">
        <docstr>Provides access to the Windows menu handle for the menu.
Use Handle to call a Windows API function that requires a menu handle. Handle is the handle for the menu that contains only the items described by the Items property.</docstr>
      </property>
      <property name="OwnerDraw">
        <docstr>Specifies whether the menu items are drawn by the application.
Set OwnerDraw to true to indicate that the application will draw menu items in an OnDrawItem event handler. When OwnerDraw is true, menu items receive an OnMeasureItem and an OnDrawItem event when they need to be rendered on screen.
Set OwnerDraw to false to accept the default drawing. When OwnerDraw is false, menu items display the caption with an optional image to the left (If the Images and ImageIndex properties are set).
Owner-draw menus are useful for displaying the value that appears when selecting a menu item. For example, in a menu that allows users to choose a color, an owner-draw menu could display rectangles drawn in the designated color, rather than color names.</docstr>
      </property>
      <property name="ParentBiDiMode">
        <docstr>Indicates whether the BiDiMode property is inherited from the control that uses the menu.
By default, ParentBiDiMode is true, indicating that the layout of menu items follows the BiDiMode setting of the associated form or control. Change ParentBiDiMode to false to override the default BiDiMode setting and control the menu&apos;s layout independently.</docstr>
      </property>
      <property name="WindowHandle">
        <docstr>Provides access to the handle of the window that uses the menu.
Read WindowHandle to get the window handle of the control that receives WM_COMMAND messages when the user clicks on an item in the menu. When menu items are selected, use this handle in an OnClick event handler to send messages to the control that uses the menu or to make Windows API calls that affect the control. 
Set WindowHandle to associate the menu with a control.</docstr>
      </property>
      <property name="Items">
        <docstr>Describes the elements of the menu.
Use Items to access information about the elements in the menu. Items is a single TMenuItem object that describes the elements of the menu in its own Items property.

Note:  Because Items is the default property of TMenuItem, the Items property of TMenu can be treated as an indexed array of menu items that describe the individual items in the menu. That is, instead of writing
Note:  FirstItem�:= Menu1.Items.Items[0];
Note:  you can use
Note:  FirstItem�:= Menu1.Items[0];
Set the Items property at design time by clicking on the Items property in the Property Inspector. The Menu Designer automatically inserts a menu item. As each menu item is entered, outlined regions appear at the possible locations of additional menu items. Click in those regions to specify additional menu items. At runtime, create a TMenuItem that describes the elements of the menu programmatically, and set the Items property of the menu.</docstr>
      </property>
    </members>
  </class>
  <class unit="Vcl.Menus" name="TMainMenu">
    <docstr>TMainMenu encapsulates a menu bar and its accompanying drop-down menus for a form.
Use TMainMenu to provide the main menu for a form. To begin designing a menu, add a main menu to a form, and double-click the component. 
TMainMenu introduces properties and methods for merging the drop-down menus of the main menu with the main menu of another form.
TMainMenu introduces properties and methods for assisting in the menu negotiation process of an OLE container.

Tip:  To create a menu that users can configure at runtime, use the TActionMainMenuBar component with an action manager instead.</docstr>
    <members>
      <procedure name="MenuChanged">
        <docstr>Responds when the menu changes.
Vcl.Menus.TMainMenu.MenuChanged inherits from Vcl.Menus.TMenu.MenuChanged. All content below this line refers to Vcl.Menus.TMenu.MenuChanged.
Responds when the menu changes.
MenuChanged is called automatically when changes occur that affect the structure of the menu. The Sender parameter indicates the object that originates the change. Its value can be nil (Delphi) or NULL (C++). Source indicates which menu item is affected. Rebuild indicates whether the menu must be rebuilt to reflect the change (for example when items are added or deleted).
MenuChanged calls the DoChange method, which generates an OnChange event.

Note:  Changes that affect individual items rather than the menu as a whole trigger the UpdateItems method instead of MenuChanged. For example, when the Images property changes, UpdateItems is called rather than MenuChanged.</docstr>
      </procedure>
      <function name="GetHandle">
        <docstr>Returns the value of the Handle property.
Vcl.Menus.TMainMenu.GetHandle inherits from Vcl.Menus.TMenu.GetHandle. All content below this line refers to Vcl.Menus.TMenu.GetHandle.
Returns the value of the Handle property.
GetHandle is the protected implementation of the Handle property. Override this method to change the implementation of the handle property. For example, TMainMenu overrides GetHandle to adjust for menus added by embedded OLE objects.</docstr>
      </function>
      <procedure name="Merge">
        <docstr>Combines the main menu of one form with the main menu of another in non-MDI applications.
Call Merge to merge another main menu with this one. Specify the menu you want merged with this menu as the Menu parameter.
For example, to use the main menu of the first form in an application as the main menu for the application, call Merge to merge the main menu of any additional forms in the application with the main menu of the first form. 
Depending on the value of the GroupIndex property of menu items on the main menu, the merged menu items can replace menu items on the menu bar, or insert menu items into the menu bar. See GroupIndex for information on how to do these things.
To merge and unmerge main menus automatically when other forms are displayed, change the value of the AutoMerge property to true on all forms whose menus should be merged in.</docstr>
      </procedure>
      <procedure name="Unmerge">
        <docstr>Reverses the merging of two menus in a non-MDI application.
Call Unmerge to remove items from another main menu that were added using the Merge method. The Menu parameter is the merged menu whose items should be removed from the main menu.</docstr>
      </procedure>
      <procedure name="PopulateOle2Menu">
        <docstr>Populates an OLE menu with items from the main menu.
Call PopulateOle2Menu to merge the menu items with GroupIndex values specified by the Groups parameter into the menu that uses the SharedMenu handle. PopulateOle2Menu appends all menu items in the specified groups to the menu, and increments the corresponding entries in the Widths array for every menu item appended. PopulateOle2Menu is used by OLE containers when merging menus.

Note: PopulateOle2Menu populates the menu specified by the SharedMenu parameter but does not set this as the OLE menu associated with the menu.</docstr>
      </procedure>
      <procedure name="GetOle2AcceleratorTable">
        <docstr>Returns the main menu&apos;s accelerator table.
Call GetOle2AcceleratorTable to obtain a handle to an accelerator table for all menu items with a GroupIndex value that appears in the Groups parameter. The AccelTable parameter is set to the accelerator table handle, and the AccelCount is set to the number of entries in the table. GetOle2AcceleratorTable is used by OLE containers when merging menus.</docstr>
      </procedure>
      <procedure name="SetOle2MenuHandle">
        <docstr>Associates the handle for an OLE menu with the main menu.
Call SetOle2MenuHandle to temporarily replace the menu of a form with the menu represented by the Handle parameter. To restore the original menu, call SetOle2MenuHandle with the Handle parameter set to 0. SetOle2MenuHandle allows an OLE container to use menu items provided by an OLE server.</docstr>
      </procedure>
      <property name="AutoMerge">
        <docstr>Determines if the main menus of secondary forms merge with the main menu of the main form in non-MDI applications at runtime.
To merge a form&apos;s menus with the main menu in the main form, set the AutoMerge property of each main menu you want merged to true. Make sure that the AutoMerge property of the main menu of the main form (the one other menus are merged into) remains false. How menus merge depends on the value of the GroupIndex property for each menu item.
If the application is an MDI application (the FormStyle properties are set so the main form is a parent form and subsequent forms are child forms), menu merging occurs automatically without using the AutoMerge property.</docstr>
      </property>
    </members>
  </class>
  <class unit="Vcl.Menus" name="TPopupMenu">
    <docstr>TPopupMenu encapsulates the properties, methods, and events of a pop-up menu.
Use TPopupMenu to define the pop-up menu that appears when the user clicks on a control with the right mouse button. To make a pop-up menu available, assign the TPopupMenu object to the control&apos;s PopupMenu property.

Tip:  To create a popup menu that users can configure at runtime, use the TStandardMenuPopup component with an action manager instead.
Note:  If the popup menu&apos;s ParentBiDiMode is true, the popup menu&apos;s BiDiMode is set to the BiDiMode of the control that activates it. If a control cannot be found, the BiDiMode is set to the value of the Application object&apos;s BiDiMode. The popup menu&apos;s BiDiMode affects all of its menu items.</docstr>
    <members>
      <function name="UseRightToLeftAlignment">
        <docstr>Specifies whether the control&apos;s alignment is in a right-to-left mode.
Call UseRightToLeftAlignment to determine whether the control&apos;s alignment is in a right-to-left mode. This information can be used when painting the control or when responding to mouse events.
UseRightToLeftAlignment returns the setting from the control that activated the popup. If the popup was not activated by a control, UseRightToLeftAlignment returns the setting used in the global Application object.</docstr>
      </function>
      <procedure name="DoClose">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoPopup">
        <docstr>Generates an OnPopup event.
DoPopup is called automatically just before the pop-up menu appears to generate an OnPopup event. Override DoPopup in a descendant class to change the event.</docstr>
      </procedure>
      <procedure name="SetPopupPoint">
        <docstr>Used to set starting point coordinates.
SetPopupPoint is used internally to set the coordinates of the point where the pop-up menu will appear.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Creates an instance of TPopupMenu.
Call Create to create to create a pop-up menu at runtime. Pop-up menus placed in forms or data modules at design time are created automatically.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys an instance of TPopupMenu.
Do not call Destroy directly in an application. Instead, call Free. Free verifies that the TPopupMenu reference is not nil, and only then calls Destroy.</docstr>
      </destructor>
      <procedure name="CloseMenu">
        <docstr>Closes the pop-up menu onscreen.
Call CloseMenu to close the pop-up menu.</docstr>
      </procedure>
      <procedure name="Popup">
        <docstr>Displays the pop-up menu onscreen.
Call Popup to bring up the pop-up menu. The menu appears at the screen coordinates indicated by the values (in pixels) of X and Y.</docstr>
      </procedure>
      <property name="PopupComponent">
        <docstr>Indicates the component that last displayed the popup menu in response to a right mouse click.
Read PopupComponent to determine which control is currently using the popup menu. In applications where multiple controls share the same pop-up menu, use PopupComponent to determine which of them displayed the menu.
Set PopupComponent to associate a control with the menu before calling the Popup method programmatically to bring up the pop-up menu.</docstr>
      </property>
      <property name="PopupPoint">
        <docstr>Indicates the location where the pop-up menu appears.
This public property is used internally to locate the popup menu. Its value is set by the Popup method.</docstr>
      </property>
      <property name="Alignment">
        <docstr>Determines where the pop-up menu appears when the user clicks the right mouse button.
Set Alignment to control the placement of the popup menu. Alignment controls whether the menu appears to the left of the mouse, to the right of the mouse, or centered over the mouse.
By default, the menu appears with its top left corner under the mouse (paLeft).</docstr>
      </property>
      <property name="AutoPopup">
        <docstr>Determines whether the pop-up menu appears automatically when the user clicks the right mouse button.
Set AutoPopup to true to cause the pop-up menu to appear automatically when the user clicks the right mouse button on a control that has the pop-up menu specified as its PopupMenu property. The application key present on keyboards specifically designed for 32-bit Windows will also show this menu when pressed.
Set AutoPopup to false if the appearance of the pop-up menu should be controlled programmatically. To display a pop-up menu when AutoPopup is false, use the Popup method.</docstr>
      </property>
      <property name="HelpContext">
        <docstr>Specifies a context ID for the entire pop-up menu.
Use HelpContext to associate a help screen with the entire pop-up menu. Each screen in the Help system should have a unique context ID. When a component is selected in the application, pressing F1 displays the Help screen associated with the value of HelpContext.
To associate a help screen with the individual items in the pop-up menu, use the HelpContext property of the associated TMenuItem objects.</docstr>
      </property>
      <property name="MenuAnimation">
        <docstr>Specifies how the menu appears when it is first displayed.
Use MenuAnimation to specify how the popup menu appears on the screen. The menu can simply appear as a whole, or can slide into view like a window shade being drawn from any edge.

Note: MenuAnimation only has an effect when running on Windows 98, NT 5.0, or later.</docstr>
      </property>
      <property name="TrackButton">
        <docstr>Specifies which mouse button activates the popup menu when it is associated with a toolbar button.
Use TrackButton to specify which mouse button activates the popup menu when it is associated with a toolbar button.</docstr>
      </property>
      <event name="OnClose">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </event>
      <event name="OnPopup">
        <docstr>Occurs just before the pop-up menu appears.
Write an OnPopup event handler to take specific action just before the pop-up menu appears. For example, use an OnPopup event handler to set the Checked, Enabled, or Visible property of individual items in the menu so that they are appropriate to the PopupComponent.</docstr>
      </event>
    </members>
  </class>
  <class unit="Vcl.Themes" name="TCustomStyleServices">
    <docstr>TCustomStyleServices is a class that provides access to style functionality.
Use the methods and properties of TCustomStyleServices to get information about a style or to perform painting of custom controls. 
Do not instantiate TCustomStyleServices; instead, call the StyleServices function to access the methods and properties of TCustomStyleServices.</docstr>
    <members>
      <procedure name="DoOnThemeChange">
        <docstr>Triggers the OnThemeChange event. 
DoOnThemeChange calls the user-supplied OnThemeChange event, if it exists; otherwise nothing happens.</docstr>
      </procedure>
      <function name="GetFlags">
        <docstr>Returns the flags set for the current style.
Call GetFlags to obtain the flags that are set for the current style. 
GetFlags is the read implementation for the Flags property.</docstr>
      </function>
      <constructor name="Create">
        <docstr>Constructs an object and initializes its data before the object is first used.
Vcl.Themes.TCustomStyleServices.Create inherits from System.TObject.Create. All content below this line refers to System.TObject.Create.
Constructs an object and initializes its data before the object is first used.
Create constructs an object. The purpose, size, and behavior of objects differ greatly. The Create constructor defined by TObject allocates memory but does not initialize data. 
Descendant objects usually define a constructor that creates the particular kind of object and initializes its data.

Note: If an exception escapes from a constructor, the object&apos;s destructor is called to clean up the failed instance.</docstr>
      </constructor>
      <procedure name="ApplyThemeChange">
        <docstr>Resets the application theme.
ApplyThemeChange is called automatically by the TApplication object whenever the operating system theme is changed. 

Note: ApplyThemeChange is used internally by the VCL and should not be called manually by applications.</docstr>
      </procedure>
      <function name="ColorToRGB">
        <docstr>Gets the color reference for a specified TColor.
Use ColorToRGB to convert the Color parameter to its RGB representation.
If Details is not nil, the function returns the system color that is defined for Color under the current style. For example, if Color is clBtnFace, the function returns the system color defined for the button face in the current style, as a TColorRef value.</docstr>
      </function>
      <function name="ColorToRGB">
        <docstr>Gets the color reference for a specified TColor.
Use ColorToRGB to convert the Color parameter to its RGB representation.
If Details is not nil, the function returns the system color that is defined for Color under the current style. For example, if Color is clBtnFace, the function returns the system color defined for the button face in the current style, as a TColorRef value.</docstr>
      </function>
      <function name="DrawEdge">
        <docstr>Draws the edge or edges of the rectangle that contains the element in the current style.
Call DrawEdge to draw one or more edges of the given element.
Edge indicates the types of inner and outer edges and Flags specifies the types of borders.

Note: The first overload of this method is deprecated; use the second overload instead.</docstr>
      </function>
      <function name="DrawEdge">
        <docstr>Draws the edge or edges of the rectangle that contains the element in the current style.
Call DrawEdge to draw one or more edges of the given element.
Edge indicates the types of inner and outer edges and Flags specifies the types of borders.

Note: The first overload of this method is deprecated; use the second overload instead.</docstr>
      </function>
      <function name="DrawElement">
        <docstr>Draws the specified element.
Call DrawElement to draw the element specified by Details, using the current style.  
R is the rectangle where the element is drawn and ClipRect is a clipping rectangle.</docstr>
      </function>
      <function name="DrawElement">
        <docstr>Draws the specified element.
Call DrawElement to draw the element specified by Details, using the current style.  
R is the rectangle where the element is drawn and ClipRect is a clipping rectangle.</docstr>
      </function>
      <function name="DrawIcon">
        <docstr>Draws an icon over the given element.
Call DrawIcon to draw the image that resides at the Index index in the image list specified by Images. The icon is drawn in the rectangle specified by R, over the element indicated by Details.</docstr>
      </function>
      <function name="DrawParentBackground">
        <docstr>Draws the background of the given user interface element&apos;s parent.
Call DrawParentBackground to draw the background of a user interface element&apos;s parent, using the current style.
If OnlyIfTransparent is True, the drawing is performed only if the element is transparent in the current style. Bounds represents the area to be drawn.</docstr>
      </function>
      <function name="DrawParentBackground">
        <docstr>Draws the background of the given user interface element&apos;s parent.
Call DrawParentBackground to draw the background of a user interface element&apos;s parent, using the current style.
If OnlyIfTransparent is True, the drawing is performed only if the element is transparent in the current style. Bounds represents the area to be drawn.</docstr>
      </function>
      <function name="DrawParentBackground">
        <docstr>Draws the background of the given user interface element&apos;s parent.
Call DrawParentBackground to draw the background of a user interface element&apos;s parent, using the current style.
If OnlyIfTransparent is True, the drawing is performed only if the element is transparent in the current style. Bounds represents the area to be drawn.</docstr>
      </function>
      <function name="DrawText">
        <docstr>Draws text over an element, using the current style.
Call DrawText to draw the S string in the rectangle specified by R. The S string has the format and additional options indicated by the Flags and Options parameters. The drawing is performed with the settings of the current style.

Note: The first overload of this function is deprecated. Use the following two overloads that use TTextFormat to specify the text formatting.</docstr>
      </function>
      <function name="DrawText">
        <docstr>Draws text over an element, using the current style.
Call DrawText to draw the S string in the rectangle specified by R. The S string has the format and additional options indicated by the Flags and Options parameters. The drawing is performed with the settings of the current style.

Note: The first overload of this function is deprecated. Use the following two overloads that use TTextFormat to specify the text formatting.</docstr>
      </function>
      <function name="DrawText">
        <docstr>Draws text over an element, using the current style.
Call DrawText to draw the S string in the rectangle specified by R. The S string has the format and additional options indicated by the Flags and Options parameters. The drawing is performed with the settings of the current style.

Note: The first overload of this function is deprecated. Use the following two overloads that use TTextFormat to specify the text formatting.</docstr>
      </function>
      <function name="GetElementContentRect">
        <docstr>Gets the background rectangle of the content area of the element.
Call GetElementContentRect to retrieve the rectangle that contains the background area of a control, when styles are enabled. 
Details represents the user interface element from which the information is being retrieved.</docstr>
      </function>
      <function name="GetElementColor">
        <docstr>Determines the color of the element specified by Details.
GetElementColor determines the color value used for the property determined by ElementColor.</docstr>
      </function>
      <function name="GetElementMargins">
        <docstr>Determines the margins of the element in the current style.
Call GetElementMargins to retrieve the margins of the control specified by Details.</docstr>
      </function>
      <function name="GetElementMargins">
        <docstr>Determines the margins of the element in the current style.
Call GetElementMargins to retrieve the margins of the control specified by Details.</docstr>
      </function>
      <function name="GetElementRegion">
        <docstr>Determines the region of the element in the current style.
Call GetElementRegion to obtain the region of the element, bounded by the given rectangle.</docstr>
      </function>
      <function name="GetElementRegion">
        <docstr>Determines the region of the element in the current style.
Call GetElementRegion to obtain the region of the element, bounded by the given rectangle.</docstr>
      </function>
      <function name="GetElementSize">
        <docstr>Determines the size for the specified part of a control.
Call GetElementSize to obtain the size of the rectangle that contains the part of the control specified by Details.
ElementSize represents the type of size to be returned: minimum, actual, or stretch.</docstr>
      </function>
      <function name="GetElementSize">
        <docstr>Determines the size for the specified part of a control.
Call GetElementSize to obtain the size of the rectangle that contains the part of the control specified by Details.
ElementSize represents the type of size to be returned: minimum, actual, or stretch.</docstr>
      </function>
      <function name="GetStyleColor">
        <docstr>Returns the color defined in the style for the element specified by Color.
Use GetStyleColor to obtain the color defined for a certain control.
For example, if Color is scButtonPressed, GetStyleColor returns the color assigned for the button when it is pressed.
The style colors give you access to the colors used for controls in the current style. There are two categories of style colors. The first category includes colors used for control parts that are rendered directly from an image. In this case, the style color offers you a way to access the color of that image and is purely informational. The second category includes the colors used for controls that are rendered from code at run time (Panel, ListBox, Grid, and so on).</docstr>
      </function>
      <function name="GetStyleFontColor">
        <docstr>Returns the font color for the element specified by Font.
Call GetStyleFontColor to obtain the font color defined in the current style for a specific part and state of a control.
For example, if Font is sfEditBoxDisabled, GetStyleFontColor returns the color of the text in an edit box, when the edit box is disabled.</docstr>
      </function>
      <function name="GetSystemColor">
        <docstr>Returns the system color defined in the current style.
The current style has a set of colors defined for system color constants that resemble the style colors. For instance, you can call GetSystemColor with clBtnFace to obtain the styled color of a button face.</docstr>
      </function>
      <function name="GetTextExtent">
        <docstr>Returns the rectangle that contains the given text, drawn in the current style.
Call GetTextExtent to obtain the rectangle required to draw the given text with the specified formatting in the current style.</docstr>
      </function>
      <function name="GetTextExtent">
        <docstr>Returns the rectangle that contains the given text, drawn in the current style.
Call GetTextExtent to obtain the rectangle required to draw the given text with the specified formatting in the current style.</docstr>
      </function>
      <function name="HasElementFixedPosition">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="HasTransparentParts">
        <docstr>Determines whether the given element has transparent parts.
Call HasTransparentParts to check whether the element specified by Details has transparent parts in the current style.</docstr>
      </function>
      <function name="LoadFromFile">
        <docstr>Loads a style from the specified file.
Call LoadFromFile to load a style from the specified file.</docstr>
      </function>
      <procedure name="PaintBorder">
        <docstr>Draws the border of a control.
Call PaintBorder to draw the border of a control using the current style.</docstr>
      </procedure>
      <procedure name="SaveToFile">
        <docstr>Saves the current style settings to the specified file.
Call SaveToFile to save the current style in the specified filename.</docstr>
      </procedure>
      <function name="IsValidStyle">
        <docstr>Checks whether the provided style is a valid style.
Call IsValidStyle to verify whether the style specified by Stream is a valid style.</docstr>
      </function>
      <function name="IsValidStyle">
        <docstr>Checks whether the provided style is a valid style.
Call IsValidStyle to verify whether the style specified by Stream is a valid style.</docstr>
      </function>
      <property name="Available">
        <docstr>Determines whether the operating system supports styles.
Use Available to check whether the operating system supports styles.</docstr>
      </property>
      <property name="Enabled">
        <docstr>Determines whether styles are enabled for the current application.
Use Enabled to check whether the current application has styles enabled.</docstr>
      </property>
      <property name="DesigningState">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="Flags">
        <docstr>Returns the flags set for the current style.
Use Flags to obtain the flags that are set for the current style.</docstr>
      </property>
      <property name="IsSystemStyle">
        <docstr>Determines whether the current style is a system style.
IsSystemStyle returns True if the current style is a default operating system style, and False if it is a custom style.</docstr>
      </property>
      <property name="Name">
        <docstr>Returns the name of the current style.
Use Name to obtain a string that represents the name of the current style. This is the same name you can use with StyleManager.SetStyle to activate the style.</docstr>
      </property>
      <event name="OnThemeChange">
        <docstr>Occurs when the operating system theme changes.
Use the OnThemeChange event to implement custom processing that should occur whenever the operating system theme changes.</docstr>
      </event>
    </members>
  </class>
  <class unit="Vcl.Themes" name="TSysControl">
    <docstr></docstr>
    <members>
      <property name="ClientHeight">
        <docstr>Get client height of the system control</docstr>
      </property>
      <property name="ClientWidth">
        <docstr>Get client width of the system control</docstr>
      </property>
    </members>
  </class>
  <class unit="Vcl.Themes" name="TSysStyleHook">
    <docstr></docstr>
    <members>
      <property name="HookedDirectly">
        <docstr>special property to use CallDefaultProc method</docstr>
      </property>
    </members>
  </class>
  <class unit="Vcl.Themes" name="TStyleManager">
    <docstr>Handles styles-related operations.
Use TStyleManager to:

Register and unregister style classes.
Set the active style.
Load styles from files or resources.
Retrieve styles and their descriptors.
Replace and retrieve the style engine.</docstr>
    <members>
      <function name="GetStyle">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetDesigningState">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="CheckSysClassName">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="HandleMessage">
        <docstr>Handles a message from a control.
HandleMessage sends the message received from a control to the style engine.



Parameter

Meaning


Control

The component that passes the message.


Message

The message that is passed to the engine.


DefWndProc

The default window procedure to be called for the message.</docstr>
      </function>
      <procedure name="Initialize">
        <docstr>Initializes data about styles and style engines.

Note: This function is reserved for internal use only. Do not call it directly.</docstr>
      </procedure>
      <function name="IsValidStyle">
        <docstr>Checks whether a file represents a valid style.
IsValidStyle returns True if the file specified by FileName is recognized as a valid style.
The second overload of IsValidStyle returns, in addition, information about the style.



Parameter

Meaning


FileName

The file name to be verified whether it represents a valid style.


StyleInfo

A record that contains the information about the style.</docstr>
      </function>
      <function name="IsValidStyle">
        <docstr>Checks whether a file represents a valid style.
IsValidStyle returns True if the file specified by FileName is recognized as a valid style.
The second overload of IsValidStyle returns, in addition, information about the style.



Parameter

Meaning


FileName

The file name to be verified whether it represents a valid style.


StyleInfo

A record that contains the information about the style.</docstr>
      </function>
      <function name="IsCustomStyleAvailable">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="IsSystemStyleDefault">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="LoadFromFile">
        <docstr>Loads a style from the specified file.
Note that LoadFromFile does not automatically switch to the loaded style. To do that, call the SetStyle method.</docstr>
      </function>
      <function name="LoadDesigningStyle">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="LoadDesigningStyles">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="LoadFromResource">
        <docstr>Loads a style from the specified resource.
Note that LoadFromResource does not automatically switch to the loaded style. To do that, call the SetStyle method.




Parameter

Meaning


Instance

The instance handle of the loaded resource.


ResourceName

The string associated with the resource.


ResType

A string that identifies the type of resource.</docstr>
      </function>
      <function name="LoadFromResource">
        <docstr>Loads a style from the specified resource.
Note that LoadFromResource does not automatically switch to the loaded style. To do that, call the SetStyle method.




Parameter

Meaning


Instance

The instance handle of the loaded resource.


ResourceName

The string associated with the resource.


ResType

A string that identifies the type of resource.</docstr>
      </function>
      <procedure name="Notification">
        <docstr>Notifies the style engine of an event that occured.



Parameter

Meaning


Operation

The action that is performed.


Data

The data on which the operation is executed.</docstr>
      </procedure>
      <procedure name="RegisterStyle">
        <docstr>Registers the instance of a style specified by the Style parameter.</docstr>
      </procedure>
      <procedure name="RegisterStyleClass">
        <docstr>Registers a style class with extension, description, and resource type.



Parameter

Meaning


Extension

A string that specifies the extension used with the style files.


Description

A string that specifies a description of the style.


ResourceType

A string associated with the resource type.


StyleClass

Specifies the style class to be registered.</docstr>
      </procedure>
      <procedure name="RegisterStyleClass">
        <docstr>Registers a style class with extension, description, and resource type.



Parameter

Meaning


Extension

A string that specifies the extension used with the style files.


Description

A string that specifies a description of the style.


ResourceType

A string associated with the resource type.


StyleClass

Specifies the style class to be registered.</docstr>
      </procedure>
      <procedure name="RemoveDesigningStyle">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="SetStyle">
        <docstr>Sets the active style by name, instance, or handle.



Parameter

Meaning


Name

The name of the style to be set as the active style.


Style

A style instance to be set as the active style.


Handle

The handle of the style to be set as the active style, as returned by the LoadFromFile or LoadFromResource method.</docstr>
      </procedure>
      <procedure name="SetStyle">
        <docstr>Sets the active style by name, instance, or handle.



Parameter

Meaning


Name

The name of the style to be set as the active style.


Style

A style instance to be set as the active style.


Handle

The handle of the style to be set as the active style, as returned by the LoadFromFile or LoadFromResource method.</docstr>
      </procedure>
      <procedure name="SetStyle">
        <docstr>Sets the active style by name, instance, or handle.



Parameter

Meaning


Name

The name of the style to be set as the active style.


Style

A style instance to be set as the active style.


Handle

The handle of the style to be set as the active style, as returned by the LoadFromFile or LoadFromResource method.</docstr>
      </procedure>
      <procedure name="SetDesigningStyle">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="SetDesigningStyle">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="TryLoadFromResource">
        <docstr>Loads a style from a resource without raising an exception.
TryLoadFromResource returns True if the style was successfully loaded, or False otherwise. 



Parameter

Meaning


Instance

The instance handle of the loaded resource.


ResourceName

The string associated with the resource.


ResType

A string that identifies the type of resource.


Handle

The handle of the loaded style.</docstr>
      </function>
      <function name="TrySetStyle">
        <docstr>Sets the style specified by name as the active style, without raising an exception.
TrySetStyle returns True if the style was successfully set as the active style, and False otherwise.



Parameter

Meaning


Name

A string that specifies the name of the style to be set as active.


ShowErrorDialog

Specifies whether an error dialog box is shown if the style cannot be set as the active style.</docstr>
      </function>
      <function name="TrySetDesigningStyle">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="ResetDesigningStyles">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="UnInitialize">
        <docstr>Uninitializes data about styles and style engines.

Note: This function is reserved for internal use only. Do not call it directly.</docstr>
      </procedure>
      <procedure name="UnRegisterStyle">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="UnRegisterStyleClass">
        <docstr>Unregisters a style class specified by the StyleClass parameter.</docstr>
      </procedure>
      <procedure name="UnRegisterStyleEngine">
        <docstr>Unregisters the style engine specified by the AEngineClass parameter.</docstr>
      </procedure>
      <property name="AutoDiscoverStyleResources">
        <docstr>Specifies whether the style manager should automatically load all styles of registered types or not. By default, AutoDiscoverStyleResources is set to True. Set it to False if you want to turn off automatic discovery.</docstr>
      </property>
      <property name="ActiveStyle">
        <docstr>Returns the current style that is set for the application.</docstr>
      </property>
      <property name="ActiveDesigningStyle">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="DesigningStyleNames">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="Enabled">
        <docstr>Specifies whether the style engine is enabled. Enabled returns True if the style engine is active, and False otherwise.</docstr>
      </property>
      <property name="Engine">
        <docstr>Returns an instance of the current style engine.</docstr>
      </property>
      <property name="EngineClass">
        <docstr>Use it to get or set the reference to the style engine class.</docstr>
      </property>
      <property name="Flags">
        <docstr>Returns the flags of the active style.</docstr>
      </property>
      <property name="IsCustomStyleActive">
        <docstr>Indicates whether the active style is a custom style. IsCustomStyleActive returns True if the active style is a custom style, and False if the active style is a system style.</docstr>
      </property>
      <property name="IsCustomDesigningStyleActive">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="StyleClassDescriptors">
        <docstr>Returns an array with the descriptors of all the registered style classes.</docstr>
      </property>
      <property name="StyleNames">
        <docstr>Returns an array with the names of all the registered style classes.</docstr>
      </property>
      <property name="SystemStyle">
        <docstr>Returns the native system style, for example, the Windows theme.</docstr>
      </property>
      <property name="SystemStyleName">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="FormBorderStyle">
        <docstr>Specifies the type of border to use for the forms in the application. 
Use the FormBorderStyle property to specify whether to use the system&apos;s border or the current style&apos;s border for the forms in the current application.
By default, the border of the current style is used.</docstr>
      </property>
      <property name="AnimationOnControls">
        <docstr>Enables the animation effect in controls when custom styles are used.
Set the AnimationOnControls property to True to enable the fade effect in controls when the mouse enters or leaves the area of the control.
By default, the value of AnimationOnControls is set to False.</docstr>
      </property>
      <property name="DialogsStyleName">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="SystemHooks">
        <docstr>The  SystemHooks property allows displaying styled menus, common dialogs and tooltips. 
When a style is applied to the VCL application using the  TStyleManager, the following values show styled menus, common dialogs and tooltips, according to the set style.
The property includes these values by default:

shMenus shows styled menus.
shDialogs shows styled common dialogs. (Only for Seattle version and superior).
shToolTips shows tool tips. (Only for Seattle version and superior).
To enable / disable a system hook, just add or remove the value from the enumerated property.
For example:

Use a  TCheckBox to show a styled dialog.
Use the  OnClick event from a  Button to execute a  TOpenDialog component.
Note: Find the Common Dialog components under the Dialogs category of the  Tool Palette.

For Delphi:

procedure TForm1.CheckBox1Click(Sender: TObject);
begin
 if CheckBox1.Checked then
   //When checking the checkbox, the value is added to the property and common dialog ares styled.
   TStyleManager.SystemHooks := TStyleManager.SystemHooks + [shDialogs] 
 else
   //When unchecking the checkbox, the value is removed from the property and the style does not apply to common dialogs.
   TStyleManager.SystemHooks := TStyleManager.SystemHooks - [shDialogs] 
end;

procedure TForm2.Button2Click(Sender: TObject);
begin
  OpenDialog1.Execute; //Opens the dialog.
end;



For C++:

void __fastcall TForm1::CheckBox1Click(TObject *Sender)
{
if (CheckBox1-&gt;Checked) {
  //One possible way to add the value.
  TStyleManager::SystemHooks = TStyleManager::SystemHooks + (TStyleManager::TSystemHooks() &lt;&lt; TStyleManager::TSystemHook::shDialogs); 
  //Another possible way to add the value.
  StyleManager::SystemHooks = TStyleManager::SystemHooks &lt;&lt; TStyleManager::TSystemHook::shDialogs; } 
else {
  //One possible way to remove the value.
  TStyleManager::SystemHooks = TStyleManager::SystemHooks - (TStyleManager::TSystemHooks() &lt;&lt; TStyleManager::TSystemHook::shDialogs);
  //Another possible way to add the value.
  TStyleManager::SystemHooks = TStyleManager::SystemHooks &gt;&gt; TStyleManager::TSystemHook::shDialogs; }
}

void __fastcall TForm1::Button1Click(TObject *Sender)
{
  OpenDialog1-&gt;Execute(); //Opens the dialog.
}</docstr>
      </property>
      <property name="UseSystemStyleAsDefault">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="UseSystemStyleAsDefaultDesigning">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="UseParentPaintBuffers">
        <docstr>Eliminates flickering in VCL Style Forms.
Set it to TRUE in project sources for the following scenarios:

TPanel bevel and caption.
TGraphicControl subtypes, such as TSplitter, TLabel or TImage, on TPanels.
TListBox when you move the horizontal splitter above.
PageControl for the horizontal scroll buttons.
Note: The TListBox does not flicker when resizing the window.</docstr>
      </property>
      <property name="UseDesigningStyles">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
    </members>
  </class>
  <class unit="Vcl.NumberBox" name="TNumberBoxSpinButtonOptions">
    <docstr>Defines spin button properties and behavior</docstr>
    <members>
      <property name="ArrowWidth">
        <docstr>Defines width of arrow
           if value is 0 then arrow has width, which adjusts automatically</docstr>
      </property>
      <property name="ButtonWidth">
        <docstr>Defines width of button</docstr>
      </property>
      <property name="Placement">
        <docstr>Defines placement of spin button</docstr>
      </property>
      <property name="ArrowColor">
        <docstr>Defines arrow color for normal state</docstr>
      </property>
      <property name="ArrowHotColor">
        <docstr>Defines arrow color for hot state</docstr>
      </property>
      <property name="ArrowPressedColor">
        <docstr>Defines arrow color for pressed state</docstr>
      </property>
      <property name="ArrowDisabledColor">
        <docstr>Defines arrow color for disabled state</docstr>
      </property>
      <property name="RepeatTimerInterval">
        <docstr>Defines timer inerval to repeat click of the button</docstr>
      </property>
      <property name="ShowInlineDividers">
        <docstr>Defines visiblity of dividers if Placement is nbspInline</docstr>
      </property>
    </members>
  </class>
  <class unit="Vcl.NumberBox" name="TCustomNumberBox">
    <docstr>TCustomEdit is the base class from which all edit-box and memo controls are derived.
Vcl.NumberBox.TCustomNumberBox inherits from Vcl.StdCtrls.TCustomEdit. All content below this line refers to Vcl.StdCtrls.TCustomEdit.
TCustomEdit is the base class from which all edit-box and memo controls are derived.
TCustomEdit encapsulates the behavior common to all components for editing text by introducing methods and properties that provide:
Basic text editing functions such as selecting text, modifying selected text, and case conversions.
Ability to respond to changes in the contents of the text.
Access control of the text for making it read-only or introducing a password character to hide the actual value.
Do not create instances of TCustomEdit. Use TCustomEdit as a base class when declaring control objects that permit the user to enter or modify text. Properties and methods of TCustomEdit provide basic behavior that descendant classes inherit as well as behavior that components can override to customize their behavior.</docstr>
    <members>
      <procedure name="DrawButtons">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GetDisplayText">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="DrawDisplayText">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoButtonClick">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="ChangeScale">
        <docstr>Resize and reposition children and self.
Vcl.NumberBox.TCustomNumberBox.ChangeScale inherits from Vcl.Controls.TWinControl.ChangeScale. All content below this line refers to Vcl.Controls.TWinControl.ChangeScale.
Resize and reposition children and self.
ChangeScale rescales the control in the same manner as the ChangeScale method in TControl. If the control contains any children, their ChangeScale methods are called before the parent itself is rescaled.
To rescale the control&apos;s children without rescaling the control itself, use ScaleControls. To rescale the control without repositioning, use ScaleBy.</docstr>
      </procedure>
      <procedure name="KeyDown">
        <docstr>Responds to key press events.
Vcl.NumberBox.TCustomNumberBox.KeyDown inherits from Vcl.Controls.TWinControl.KeyDown. All content below this line refers to Vcl.Controls.TWinControl.KeyDown.
Responds to key press events.
When a windowed control receives a key-down message (WM_KEYDOWN) from Windows, its message handler calls the DoKeyDown method. If DoKeyDown determines that the control should, in fact, process the character, it calls KeyDown, passing the key code and shift-key state in the Key and Shift parameters, respectively.
KeyDown calls any event handler attached to the OnKeyDown event. Override KeyDown to provide other responses in addition to the event handler call.
The Key parameter is the key on the keyboard. For nonalphanumeric keys, you must use WinAPI virtual key codes to determine the key pressed. For more information see Representing Keys and Shortcuts.
The Shift parameter indicates whether the SHIFT, ALT, or CTRL keys are combined with the keystroke.
Either KeyDown or the OnKeyDown event handler it calls can suppress further processing of a key by setting the Key parameter to zero.</docstr>
      </procedure>
      <procedure name="KeyPress">
        <docstr>Responds to keyboard input.
Vcl.NumberBox.TCustomNumberBox.KeyPress inherits from Vcl.Controls.TWinControl.KeyPress. All content below this line refers to Vcl.Controls.TWinControl.KeyPress.
Responds to keyboard input.
When a windowed control receives a key-press message (WM_CHAR) from Windows, its message handler calls the DoKeyPress method. If DoKeyPress determines that the control should, in fact, process the character, it calls KeyPress, passing the key code in the Key parameter.
KeyPress calls any event handler attached to the OnKeyPress event. Override KeyPress to provide other responses in addition to the event handler call.
Either KeyPress or the OnKeyPress event handler it calls can suppress further processing of a character by setting the Key parameter to zero.

Note: The Key parameter is the character represented by the key that is pressed, not a Windows virtual key code.</docstr>
      </procedure>
      <function name="IsValidChar">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="IsNumericText">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="IsNumericText">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="GetValidCharSet">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="DoChangeValue">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="EvaluateExpression">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Change">
        <docstr>Generates an OnChange event.
Vcl.NumberBox.TCustomNumberBox.Change inherits from Vcl.StdCtrls.TCustomEdit.Change. All content below this line refers to Vcl.StdCtrls.TCustomEdit.Change.
Generates an OnChange event.
Applications do not call the Change method directly. It is triggered automatically by Windows events. Change is exposed as a protected method so that derived classes can make additional responses when the text changes beyond invoking the OnChange event handler. If Derived classes that override the Change method do not call the inherited method, the OnChange event handler will not be called.</docstr>
      </procedure>
      <procedure name="Loaded">
        <docstr>Initializes the control after it is loaded from a stream.
Vcl.NumberBox.TCustomNumberBox.Loaded inherits from Vcl.Controls.TControl.Loaded. All content below this line refers to Vcl.Controls.TControl.Loaded.
Initializes the control after it is loaded from a stream.
Do not call Loaded. The VCL streaming system calls Loaded automatically after the control&apos;s form is loaded into memory so that the control can complete any initializations that depend on other objects in the form.
Loaded overrides the inherited method in order to initialize the control from its associated Action. To change the properties the control copies from its action, override the ActionChange method.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Creates an instance of TCustomEdit.
Vcl.NumberBox.TCustomNumberBox.Create inherits from Vcl.StdCtrls.TCustomEdit.Create. All content below this line refers to Vcl.StdCtrls.TCustomEdit.Create.
Creates an instance of TCustomEdit.
Call Create to create and initialize an instance of TCustomEdit.
AOwner is another component, typically the form, that is responsible for freeing the edit control. It becomes the value of the Owner property.
Derived objects that override the Create method should call the inherited Create before performing any additional initialization.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys an instance of TWinControl.
Vcl.NumberBox.TCustomNumberBox.Destroy inherits from Vcl.Controls.TWinControl.Destroy. All content below this line refers to Vcl.Controls.TWinControl.Destroy.
Destroys an instance of TWinControl.
Do not call Destroy directly in an application. Instead, call Free. Free verifies that the TWinControl reference is not nil, and only then calls Destroy.</docstr>
      </destructor>
      <property name="Mode">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="Value">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="ValueInt">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="ValueFloat">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="ValueCurrency">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="CurrencyString">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="CurrencyFormat">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="DisplayFormat">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="MinValue">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="MaxValue">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="Decimal">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="SmallStep">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="LargeStep">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="AcceptExpressions">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="SpinButtonOptions">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="UseNaNValue">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="UseMouseWheel">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="UseUpDownKeys">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="Wrap">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="NegativeValueColor">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <event name="OnChangeValue">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </event>
      <event name="OnEvaluateExpression">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </event>
      <event name="OnValidateChar">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </event>
    </members>
  </class>
  <class unit="Vcl.NumberBox" name="TNumberBox">
    <docstr>TNumberBox is a numeric input control that supports the input of integer numbers, floating point numbers with a given set of decimal digits and proper formatting, and currency values.</docstr>
  </class>
  <class unit="Vcl.Graphics" name="TCanvas">
    <docstr>TCanvas provides an abstract drawing space for objects that must render their own images.
Use TCanvas as a drawing surface for objects that draw an image of themselves. Standard window controls such as edit controls or list boxes do not require a canvas, as they are drawn by the system. 
TCanvas provides properties, events, and methods that assist in creating an image by:

Specifying the type of brush, pen, and font to use.
Drawing and filling a variety of shapes and lines.
Writing text.
Rendering graphic images.
Enabling a response to changes in the current image.
TCanvas has two descendants, TControlCanvas and TMetafileCanvas, which assist in drawing images of controls and in creating metafile images for objects.</docstr>
    <members>
      <function name="GetCanvasOrientation">
        <docstr>Represents the getter method for the CanvasOrientation property.
GetCanvasOrientation is called each time the value of the CanvasOrientation is read.</docstr>
      </function>
      <function name="GetClipRect">
        <docstr>Represents the getter method for the ClipRect property.
GetClipRect is called each time the value of ClipRect is read.</docstr>
      </function>
      <function name="GetPenPos">
        <docstr>Represents the getter method for the PenPos property.
GetPenPos is called each time the value of PenPos is read.</docstr>
      </function>
      <function name="GetPixel">
        <docstr>Represents the getter method for the Pixels property.
GetPixel is called each time the color of a pixel in the Pixels property is read.</docstr>
      </function>
      <function name="GetHandle">
        <docstr>Represents the getter method for the Handle property.
GetHandle is called each time the value of the Handle property is read. GetHandle uses the RequiredState method to make sure that the canvas has a valid handle allocated.</docstr>
      </function>
      <procedure name="SetBrush">
        <docstr>Represents the setter method for the Brush property.
SetBrush is called each time the value of the Brush property is changed.</docstr>
      </procedure>
      <procedure name="SetFont">
        <docstr>Represents the setter method for the Font property.
SetFont is called each time the value of the Font property is changed.</docstr>
      </procedure>
      <procedure name="SetHandle">
        <docstr>Represents the setter method for the Handle property.
SetHandle is called each time the value of the Handle property is changed. SetHandle makes sure to deallocate all associated graphical objects before changing the handle.</docstr>
      </procedure>
      <procedure name="SetPen">
        <docstr>Represents the setter method for the Pen property.
SetPen is called each time the value of the Pen property is changed.</docstr>
      </procedure>
      <procedure name="SetPenPos">
        <docstr>Represents the setter method for the PenPos property.
SetPenPos is called each time the value of the PenPos property is changed.</docstr>
      </procedure>
      <procedure name="SetPixel">
        <docstr>Represents the setter method for the Pixels property.
SetPixel is called each time the color of a pixel in the Pixels property is changed.</docstr>
      </procedure>
      <procedure name="CreateHandle">
        <docstr>Allocates a new handle for the canvas.
CreateHandle is called automatically by the canvas when a handle is required. In TCanvas, CreateHandle simply returns without allocating a handle. CreateHandle is supposed to be overridden in descending classes, which, in certain conditions, allocate handles. 
For example, TControlCanvas returns the HDC (Windows Device Context handle) for the control the canvas is associated to.</docstr>
      </procedure>
      <procedure name="RequiredState">
        <docstr>Changes the current state of the canvas to meet the given requirements.
RequiredState ensures that a canvas meets a set of given requirements. If the requirements are not met, the canvas initializes its internal structures so that the requirements are met after the call to RequiredState is completed. 
RequiredState verifies that the Pen, Brush and Font objects are created and initialized. RequiredState also makes sure that the canvas has a handle allocated.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Creates an instance of TCanvas.
Call Create to instantiate a TCanvas object at runtime. Create allocates memory for the instance of TCanvas and creates the TFont, TBrush and TPen objects for the Font, Brush, and Pen properties. Create also initializes the CopyMode to cmSrcCopy.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys an instance of TCanvas.
Do not call Destroy directly in an application. Instead, call Free. Free verifies that the TCanvas object is not nil and only then calls Destroy.</docstr>
      </destructor>
      <procedure name="Arc">
        <docstr>Draws an arc on the image along the perimeter of the ellipse bounded by the specified rectangle. 
Use Arc to draw an elliptically curved line with the current Pen. The arc traverses the perimeter of an ellipse that is bounded by the points (X1,Y1) and (X2,Y2). The arc is drawn following the perimeter of the ellipse, counterclockwise, from the starting point to the ending point. The starting point is defined by the intersection of the ellipse and a line defined by the center of the ellipse and (X3,Y3). The ending point is defined by the intersection of the ellipse and a line defined by the center of the ellipse and (X4, Y4).

Note: On Windows 9x or Windows ME, the sums X1 + X2 and Y1 + Y2 cannot exceed 32768. Also, the sum X1 + X2 + Y1 + Y2 cannot exceed 32768.
On NT or Windows 2000, the drawing direction can be changed to clockwise using the Windows API call SetArcDirection.</docstr>
      </procedure>
      <procedure name="ArcTo">
        <docstr>Draws an arc on the image along the perimeter of the ellipse bounded by the specified rectangle.
Vcl.Graphics.TCanvas.ArcTo inherits from Vcl.Graphics.TCustomCanvas.ArcTo. All content below this line refers to Vcl.Graphics.TCustomCanvas.ArcTo.
Draws an arc on the image along the perimeter of the ellipse bounded by the specified rectangle.
Override the ArcTo method (or just use Arcto from descendant classes) to implement drawing of an elliptically curved line with the current Pen. The arc traverses the perimeter of an ellipse that is bounded by the points (X1,Y1) and (X2,Y2). The arc is drawn following the perimeter of the ellipse, counterclockwise, from the starting point to the ending point. The starting point is defined by the intersection of the ellipse and a line defined by the center of the ellipse and (X3,Y3). The ending point is defined by the intersection of the ellipse and a line defined by the center of the ellipse and (X4, Y4).
This procedure draws lines by using the current pen and updates the value of PenPos to the value of the last endpoint.</docstr>
      </procedure>
      <procedure name="AngleArc">
        <docstr>Draws an arc on the image along the perimeter of the circle defined by the parameters.
The AngleArc method draws a line from the current position to the starting point of the arc and then a counterclockwise circular arc to the arc endpoint.  The arc traverses the perimeter of a circle whose center lies at (X,Y) and whose radius is Radius. The arc is drawn following the perimeter of the circle, counterclockwise, from the StartAngle with a sweep angle of SweepAngle.
If the sweep angle is greater than 360 degrees, the entire circle is drawn and part of the arc is drawn multiple times.
The current position is updated to the arc endpoint.</docstr>
      </procedure>
      <procedure name="BrushCopy">
        <docstr>Copies a portion of a bitmap onto a rectangle on the canvas, replacing one of the colors of the bitmap with the brush of the canvas.
Use BrushCopy to achieve special effects such as making the copied image partially transparent. BrushCopy is provided mainly for backward compatibility. Use a TImageList instead of BrushCopy.
Dest specifies the rectangular portion of the canvas that will receive the copy of the bitmap. Bitmap specifies the graphic to copy from. Source specifies the rectangular area of Bitmap to copy. Color specifies the color in Bitmap to replace with the Brush of the canvas.
To use BrushCopy to make the copied image partially transparent, specify the color of the surface of the canvas (clBackground for example) as the Color of the Brush property, then call BrushCopy.</docstr>
      </procedure>
      <procedure name="Chord">
        <docstr>Draws a closed figure represented by the intersection of a line and an ellipse.
Use Chord to create a shape that is defined by an arc and a line that joins the endpoints of the arc. The chord consists of a portion of an ellipse that is bounded by the points (X1,Y1) and (X2,Y2). The ellipse is bisected by a line that runs between the points (X3,Y3) and (X4,Y4). 
The perimeter of the chord runs counter clockwise from (X3, Y3), counterclockwise along the ellipse to (X4,Y4), and straight back to (X3,Y3). If (X3,Y3) and (X4,Y4) are not on the surface of the ellipse, the corresponding corners on the chord are the closest points on the perimeter that intersect the line. The outline of the chord is drawn using the value of Pen, and the shape is filled using the value of Brush.

Note:  On Windows 9x or Windows ME, the sums X1 + X2 and Y1 + Y2 cannot exceed 32768. Also, the sum X1 + X2 + Y1 + Y2 cannot exceed 32768.
On NT, the drawing direction can be changed to clockwise using the Windows API call SetArcDirection.</docstr>
      </procedure>
      <procedure name="CopyRect">
        <docstr>Copies part of an image from another canvas into the canvas.
Use CopyRect to transfer part of the image on another canvas to the image of the TCanvas object. Dest specifies the rectangle on the canvas where the source image will be copied. The Canvas parameter specifies the canvas with the source image. Source specifies a rectangle bounding the portion of the source canvas that will be copied.
The portion of the source canvas is copied using the mode specified by CopyMode.</docstr>
      </procedure>
      <procedure name="Draw">
        <docstr>Renders the graphic specified by the Graphic parameter on the canvas at the location given by the coordinates (X, Y).
Call Draw to draw a graphic on the canvas. Draw calls the Draw method of the graphic. The image is rendered into a rectangle determined by the size of the graphic, with the upper left corner at the point (X, Y). 
Graphics can be bitmaps, icons, or metafiles. If the graphic is a TBitmap object, the bitmap is rendered using the value of CopyMode.</docstr>
      </procedure>
      <procedure name="Draw">
        <docstr>Renders the graphic specified by the Graphic parameter on the canvas at the location given by the coordinates (X, Y).
Call Draw to draw a graphic on the canvas. Draw calls the Draw method of the graphic. The image is rendered into a rectangle determined by the size of the graphic, with the upper left corner at the point (X, Y). 
Graphics can be bitmaps, icons, or metafiles. If the graphic is a TBitmap object, the bitmap is rendered using the value of CopyMode.</docstr>
      </procedure>
      <procedure name="DrawFocusRect">
        <docstr>Draws a rectangle in the style used to indicate that the object inside the rectangle has focus.
Call DrawFocusRect for the perimeter of the image of a control when the control gets or loses input focus. Because DrawFocusRect uses an XOR function, calling it a second time while specifying the same rectangle removes the rectangle from the screen.
The rectangle this function draws cannot be scrolled. To scroll an area containing a rectangle drawn by DrawFocusRect, call DrawFocusRect to remove the rectangle from the screen, scroll the area, and then call DrawFocusRect to draw the rectangle in the new position.</docstr>
      </procedure>
      <procedure name="Ellipse">
        <docstr>Draws the ellipse defined by a bounding rectangle on the canvas.
Call Ellipse to draw a circle or ellipse on the canvas. Specify the bounding rectangle either by giving:

The top left point at pixel coordinates (X1, Y1) and the bottom right point at (X2, Y2).
A TRect value.If the bounding rectangle is a square, a circle is drawn.The ellipse is outlined using the value of Pen, and filled using the value of Brush.Note:  On Windows 9x or Windows ME, the sums X1 + X2 and Y1 + Y2 cannot exceed 32768. Also, the sum X1 + X2 + Y1 + Y2 cannot exceed 32768.</docstr>
      </procedure>
      <procedure name="FillRect">
        <docstr>Fills the specified rectangle on the canvas using the current brush.
Use FillRect to fill a rectangular region using the current brush. The region is filled including the top and left sides of the rectangle, but excluding the bottom and right edges.</docstr>
      </procedure>
      <procedure name="FloodFill">
        <docstr>Fills an area of the canvas using the current brush.
Use FloodFill to fill a possibly non-rectangular region of the image with the value of Brush. The boundaries of the region to be filled are determined by moving outward from the point (X,Y) until a color boundary involving the Color parameter is encountered.
X and X are the coordinates on the canvas where filling starts.
Color is the color that defines the boundary of the region to fill. Its interpretation depends on the value of FillStyle.
FillStyle specifies whether the region is defined by all pixels with the same value as Color, or all points with a different value.

Tip:  Use the Pixels property to get the exact value of the color at the point (X,Y) when using a FillStyle of fsSurface. Similarly, when FillStyle is fsBorder, use Pixels to get the exact value of the boundary color if a point on the boundary is known.</docstr>
      </procedure>
      <procedure name="FrameRect">
        <docstr>Draws a rectangle using the Brush of the canvas to draw the border.
Use FrameRect to draw a 1 pixel wide border around a rectangular region. FrameRect does not fill the interior of the rectangle with the Brush pattern.
To draw a boundary using the Pen instead, use the Polygon method.</docstr>
      </procedure>
      <function name="HandleAllocated">
        <docstr>Indicates whether the TCanvas object has acquired a handle to a device context.
Use HandleAllocated to determine whether the Handle property is set to an HDC value. HandleAllocated indicates whether the canvas has acquired a device context. Use HandleAllocated rather than reading the Handle property. When an application reads the Handle property, TCanvas automatically allocates a new device context and returns its handle if the property had not been previously set.</docstr>
      </function>
      <procedure name="LineTo">
        <docstr>Draws a line on the canvas from PenPos to the point specified by X and Y, and sets the pen position to (X, Y).
Use LineTo to draw a line from PenPos up to, but not including the point (X,Y). LineTo changes the value of PenPos to (X,Y). 
The line is drawn using Pen.

Note:  If the current Pen does not have a style of psSolid, the line is drawn with a background specified by the current brush.</docstr>
      </procedure>
      <procedure name="MoveTo">
        <docstr>Changes the current drawing position to the point (X,Y).
Use MoveTo to set the value of PenPos before calling LineTo. Calling MoveTo is equivalent to setting the PenPos property.</docstr>
      </procedure>
      <procedure name="Pie">
        <docstr>Draws a pie-shaped section of the ellipse bounded by the rectangle (X1, Y1) and (X2, Y2) on the canvas.
Use Pie to draw a pie-shaped wedge on the image. The wedge is defined by the ellipse bounded by the rectangle determined by the points (X1, Y1) and (X2, Y2). The section drawn is determined by two lines radiating from the center of the ellipse through the points (X3, Y3) and (X4, Y4). 
The wedge is outlined using Pen, and filled using Brush.

Note:  On Windows 9x or Windows ME, the sums X1 + X2 and Y1 + Y2 cannot exceed 32768. Also, the sum X1 + X2 + Y1 + Y2 cannot exceed 32768.</docstr>
      </procedure>
      <procedure name="Polygon">
        <docstr>Draws a series of lines on the canvas connecting the points passed in and closing the shape by drawing a line from the last point to the first point.
Use Polygon to draw a closed, many-sided shape on the canvas, using the value of Pen. After drawing the complete shape, Polygon fills the shape using the value of Brush.
The Points parameter is an array of points that give the vertices of the polygon.

Note:  The Points_Size parameter is the index of the last point in the array (one less than the total number of points).
The first point is always connected to the last point.

Note:  In Delphi, you can use the Slice function to pass a portion of an array of points to the Polygon method. For example, to form a polygon using the first ten points from an array of 100 points, use the Slice function as follows:
Canvas.Polygon(Slice(PointArray, 10));

To draw a polygon on the canvas, without filling it, use the Polyline method, specifying the first point a second time at the end.</docstr>
      </procedure>
      <procedure name="Polyline">
        <docstr>Draws a series of lines on the canvas with the current pen, connecting each of the points passed to it in Points.
Use Polyline to connect a set of points on the canvas. If you specify only two points, Polyline draws a single line. 
The Points parameter is an array of points to be connected.

Note:  The Points_Size parameter is the index of the last point in the array (one less than the total number of points).
Note:  In Delphi, you can use the Slice function to pass a portion of an array of points to the Polyline method. For example, to form a line connecting the first ten points from an array of 100 points, use the Slice function as follows:
Canvas.Polyline(Slice(PointArray, 10));

Calling the MoveTo function with the value of the first point, and then repeatedly calling LineTo with all subsequent points will draw the same image on the canvas. However, unlike LineTo, Polyline does not change the value of PenPos.</docstr>
      </procedure>
      <procedure name="PolyBezier">
        <docstr>Draws a set of Bezier curves.
Use PolyBezier to draw cubic Bezier curves using the endpoints and control points specified by the Points parameter. The first curve is drawn from the first point to the fourth point, using the second and third points as control points. Each subsequent curve in the sequence needs exactly three more points: the ending point of the previous curve is used as the starting point, the next two points in the sequence are control points, and the third is the ending point.
The Points parameter gives the endpoints to use when generating the Bezier curves.

Note:  The Points_Size parameter is the index of the last point in the array (one less than the total number of points).
This procedure draws lines by using the current pen.

Note:  In Delphi, you can use the Slice function to pass a portion of an array of points to the PolyBezier method. For example, to form a Bezier curve using the first ten points from an array of 100 points, use the Slice function as follows:
Canvas.PolyBezier(Slice(PointArray, 10));

Control points after a[Index+3] are ignored. Nothing happens if there aren&apos;t enough control points.</docstr>
      </procedure>
      <procedure name="PolyBezierTo">
        <docstr>Draws a set of Bezier curves and updates the value of PenPos.
Use PolyBezierTo to draw cubic Bezier curves using the endpoints and control points specified by the Points parameter. The first curve is drawn from the first point to the fourth point, using the second and third points as control points. Each subsequent curve in the sequence needs exactly three more points: the ending point of the previous curve is used as the starting point, the next two points in the sequence are control points, and the third is the ending point.
The Points parameter gives the endpoints to use when generating the Bezier curves.

Note:  The Points_Size parameter is the index of the last point in the array (one less than the total number of points).
This procedure draws lines by using the current pen and updates the value of PenPos to the value of the last endpoint.

Note:  In Delphi, you can use the Slice function to pass a portion of an array of points to the PolyBezierTo method. For example, to form a Bezier curve using the first ten points from an array of 100 points, use the Slice function as follows:
Canvas.PolyBezierTo(Slice(PointArray, 10));</docstr>
      </procedure>
      <procedure name="Rectangle">
        <docstr>Draws a rectangle on the canvas.
Use Rectangle to draw a rectangle using Pen and fill it with Brush. Specify the rectangle&apos;s coordinates in one of two ways:
Giving four coordinates that define the upper left corner at the point (X1, Y1) and the lower right corner at the point (X2, Y2).
Using a TRect type.
To fill a rectangular region without drawing the boundary in the current pen, use FillRect. To outline a rectangular region without filling it, use FrameRect or Polygon. To draw a rectangle with rounded corners, use RoundRect.</docstr>
      </procedure>
      <procedure name="Refresh">
        <docstr>Deselects the Pen, Brush, and Font from the device context.
Call Refresh to return the HDC used by the canvas to a default state. Refresh does not change the values of the Font, Brush, or Pen properties. Calling any of the drawing methods of the canvas after calling Refresh will reselect the Font, Brush, or Pen into the HDC if it is used by the drawing method.</docstr>
      </procedure>
      <procedure name="RoundRect">
        <docstr>Draws a rectangle with rounded corners on the canvas.
Use RoundRect to draw a rounded rectangle using Pen and fill it with Brush. The rectangle will have edges defined by the points (X1,Y1), (X2,Y1), (X2,Y2), (X1,Y2), but the corners will be shaved to create a rounded appearance. The curve of the rounded corners matches the curvature of an ellipse with width X3 and height Y3. 
To draw an ellipse instead, use Ellipse. To draw a true rectangle, use Rectangle.</docstr>
      </procedure>
      <procedure name="StretchDraw">
        <docstr>Draws the graphic specified by the Graphic parameter in the rectangle specified by the Rect parameter.
Call StretchDraw to draw a graphic on the canvas so that the image fits in the specified rectangle. StretchDraw calls the Draw method of the graphic. The graphic object determines how to fit into the rectangle. This may involve changing magnification and/or aspect ratio.
To render the graphic in its natural size, use the Draw method, instead.
If the graphic is a TBitmap object, the bitmap is rendered using the value of CopyMode.

Note:  If the graphic is an icon, it is not stretched.</docstr>
      </procedure>
      <function name="TextExtent">
        <docstr>Returns the width and height, in pixels, of a string rendered in the current font.
Use TextExtent to determine the space a string will occupy in the image. Other elements in the image such as lines, boxes, or additional lines of text can be positioned to accommodate the size of the text. TextExtent returns the width and height of the rectangle that bounds the text on the canvas. 
To check only the height, call TextHeight. To check only the width, call TextWidth.</docstr>
      </function>
      <procedure name="TextOut">
        <docstr>Writes a string on the canvas, starting at the point (X,Y), and then updates the PenPos to the end of the string.
Use TextOut to write a string onto the canvas. The string will be written using the current value of Font. Use the TextExtent method to determine the space occupied by the text in the image. To write only the text that fits within a clipping rectangle, use TextRect instead.
After a call to TextOut, the PenPos property indicates the point at the top right of the text on the canvas.</docstr>
      </procedure>
      <procedure name="TextRect">
        <docstr>Writes a string inside a clipping rectangle.
Use TextRect to write a string within a limited rectangular region. Any portions of the string that fall outside the rectangle passed in the Rect parameter are clipped and don&apos;t appear. The upper left corner of the text is placed at the point (X, Y).</docstr>
      </procedure>
      <procedure name="TextRect">
        <docstr>Writes a string inside a clipping rectangle.
Use TextRect to write a string within a limited rectangular region. Any portions of the string that fall outside the rectangle passed in the Rect parameter are clipped and don&apos;t appear. The upper left corner of the text is placed at the point (X, Y).</docstr>
      </procedure>
      <property name="Handle">
        <docstr>Specifies the handle for this canvas.
The Handle property specifies the Windows GDI handle to the device context for this canvas.
Set Handle to the HDC for the device context the canvas must draw into. When a windowed control responds to a Windows paint message, the HDC for drawing is passed in to the PaintWindow method. In other cases, an HDC can be obtained for a window by calling the GetDeviceContext method of a control. Additionally, Windows provides API calls to obtain an HDC for a printer or for a memory image.
Read the Handle property to supplement the drawing services provided by the TCanvas object with API calls that require a handle to a device context. Most of the Windows GDI calls require an HDC.
TCanvas does not own the HDC. Applications must create an HDC and set the Handle property. Applications must release the HDC when the canvas no longer needs it. Setting the Handle property of a canvas that already has a valid HDC will not automatically release the initial HDC. 

Note:  Some descendants of TCanvas, such as TControlCanvas, do own the HDC. Do not set the Handle property for these objects. They fetch and free their own Handle.</docstr>
      </property>
      <property name="Brush">
        <docstr>Determines the color and pattern for filling graphical shapes and backgrounds.
Set the Brush property to specify the color and pattern to use when drawing the background or filling in graphical shapes. The value of Brush is a TBrush object. Set the properties of the TBrush object to specify the color and pattern or bitmap to use when filling in spaces on the canvas.

Note:  Setting the Brush property assigns the specified TBrush object, rather than replacing the current TBrush object.</docstr>
      </property>
      <property name="CopyMode">
        <docstr>Specifies how a graphical image is copied onto the canvas.
Set CopyMode to affect the way graphical images are drawn onto the canvas. The CopyMode is used when copying an image from another canvas using the CopyRect method. CopyMode is also used by TBitmap objects when they draw themselves to a canvas.
Use CopyMode to achieve a variety of affects when rendering an image. Achieve special effects like merged images and making parts of a bitmap transparent by combining multiple images with different CopyModes.</docstr>
      </property>
      <property name="Font">
        <docstr>Specifies the font to use when writing text on the image.
Set Font to specify the font to use for writing text on the image. The value of Font is a T Font object. Set the properties of the T Font object to specify the font face, color, size, style, and any other aspects of the font.
The Canvas.Font property is only guaranteed to equal the Font property if you have an owner-drawn listbox (where you are expected to use the canvas). Even in that case, it is only guaranteed to equal the Font property once the first paint message is underway. If you use a canvas inside an ownerdraw event, everything should work as expected. Using the canvas for a reason outside the scope of its intended usage may give unpredictable results.

Note:  Setting the Font property assigns the specified T Font object, rather than replacing the current T Font object.</docstr>
      </property>
      <property name="Pen">
        <docstr>Specifies the kind of pen the canvas uses for drawing lines and outlining shapes.
Set Pen to specify the pen to use for drawing lines and outlining shapes in the image. The value of Pen is a TPen object. Set the properties of the TPen object to specify the color, style, width, and mode of the pen.

Note:  Setting the Pen property assigns the specified TPen object, rather than replacing the current TPen object.</docstr>
      </property>
    </members>
  </class>
  <class unit="Vcl.Graphics" name="TGraphic">
    <docstr>TGraphic is the abstract base class type for objects such as icons, bitmaps, and metafiles that can store and display visual images.
TGraphic is an abstract class that cannot be instantiated. Descendant graphics objects override many of the methods of TGraphic to address the needs of their particular file format and graphical characteristics. TGraphic also introduces methods that work with TPicture objects and the Clipboard. Properties of TGraphic provide information about the state and size of the graphic image.
When the type of graphic is known, store the graphic in its specific type object. Otherwise, use a TPicture object that can hold any type of TGraphic.</docstr>
    <members>
      <procedure name="Changed">
        <docstr>Called when graphic has changed.
Changed is called automatically whenever the TGraphic object is modified. It sets the Modified property to True and triggers the OnChange event.</docstr>
      </procedure>
      <procedure name="DefineProperties">
        <docstr>Set virtual property for reading and writing graphic data stream.
DefineProperties overrides TPersistent.DefineProperties for the ReadData and WriteData methods for reading and writing graphic data from and to a TStream object. It creates a virtual property Data that can be treated as a property to read or write graphic data to the TGraphic object.</docstr>
      </procedure>
      <procedure name="Draw">
        <docstr>Render graphic onto canvas at rectangle.
TCanvas.Draw calls this function to render the graphic onto its canvas at the coordinates specified by the Rect parameter. Descendants of TGraphic should override this function with a specific rendering implementation.</docstr>
      </procedure>
      <procedure name="DrawTransparent">
        <docstr>Render graphic onto canvas at rectangle, blending with canvas&apos;s background.
DrawTransparent renders the graphic onto a canvas at the coordinates specified by the Rect parameter, blending it with the canvas&apos;s background.</docstr>
      </procedure>
      <function name="Equals">
        <docstr>Compare graphic to another TGraphic object and return true if objects contain same graphic.
Equals compares the contents of two TGraphic objects. Equals returns false if the TGraphic are different classes or if they contain different graphical data.

Code Examples
TGraphic (Delphi)
TGraphic (C++)</docstr>
      </function>
      <function name="GetEmpty">
        <docstr>Indicates whether graphics object contains graphic.
GetEmpty indicates whether the TGraphic object contains a graphic.
Each descendant of the TGraphic class should override the GetEmpty method to indicate whether a given TGraphic object is bound to an image.</docstr>
      </function>
      <function name="GetHeight">
        <docstr>Get vertical size of graphic in pixels.
GetHeight gets the vertical size of the TGraphic object in pixels.
Each descendant of TGraphic defines its own GetHeight and SetHeight methods to access the Height property.</docstr>
      </function>
      <function name="GetPalette">
        <docstr>Get color palette of graphical image.
GetPalette gets the color palette of the graphical image. You can also use the Palette property to get the color palette of a graphical image. If the graphic does not need or use a palette, the Palette property is zero.</docstr>
      </function>
      <function name="GetTransparent">
        <docstr>Specifies if graphic is drawn transparently.
GetTransparent specifies whether a graphic should be drawn transparently.
Use the Transparent property to specify that the graphic be drawn transparently.</docstr>
      </function>
      <function name="GetWidth">
        <docstr>Get horizontal size of graphic in pixels.
GetWidth gets the horizontal size of the graphic in pixels.
Each descendant of the TGraphic class defines its own GetWidth and SetWidth methods to access the Width property.</docstr>
      </function>
      <procedure name="Progress">
        <docstr>Generate OnProgress event when graphic is changing.
Progress generates an OnProgress event when the graphic is in the process of changing.
For certain descendants of TGraphic, OnProgress occurs during slow processes such as loading, storing, or transforming image data. OnProgress allows applications to provide feedback to the user about the progress of the process. 
Component writers can generate OnProgress events for new descendants of TGraphic by calling the protected Progress method. These events are propagated to the TPicture and TImage objects.</docstr>
      </procedure>
      <procedure name="ReadData">
        <docstr>Read graphic data from TStream.
ReadData is used to read the binary graphic from the virtual property Data (created by DefineProperties) when streaming in a TGraphic from the TStream Stream.</docstr>
      </procedure>
      <procedure name="SetHeight">
        <docstr>Set vertical size of graphic in pixels.
SetHeight sets the vertical size of the graphic in pixels.
Each descendant of the TGraphic class defines its own GetHeight and SetHeight methods to access the Height property.</docstr>
      </procedure>
      <procedure name="SetPalette">
        <docstr>Set color palette of graphical image.
SetPalette sets the color palette of the graphical image.
Use the Palette property to get the color palette of a graphical image. If the graphic does not need or does not use a palette, the Palette property is zero.</docstr>
      </procedure>
      <procedure name="SetTransparent">
        <docstr>Specify if graphic should be drawn transparently.
SetTransparent specifies if a graphic should be drawn transparently.</docstr>
      </procedure>
      <procedure name="SetWidth">
        <docstr>Set horizontal size of graphic in pixels.
SetWidth sets the horizontal size of the graphic in pixels.
Each descendant of the TGraphic class defines its own GetWidth and SetWidth methods to access the Width property.</docstr>
      </procedure>
      <procedure name="WriteData">
        <docstr>Write graphic data to TStream.
WriteData is used to write the binary graphic to the virtual property Data (created by DefineProperties) when streaming a TGraphic out to the TStream Stream.</docstr>
      </procedure>
      <function name="GetSupportsPartialTransparency">
        <docstr>Indicate whether graphic supports partial transparency.
GetSupportsPartialTransparency indicates whether the graphic supports partial transparency.
TGraphic descendants should override GetSupportsPartialTransparency if they are capable of having partially transparent pixels.</docstr>
      </function>
      <constructor name="Create">
        <docstr>Create TGraphic object.
This method creates and intializes a TGraphic object.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys the TPersistent instance and frees its memory.
Vcl.Graphics.TGraphic.Destroy inherits from System.Classes.TPersistent.Destroy. All content below this line refers to System.Classes.TPersistent.Destroy.
Destroys the TPersistent instance and frees its memory.
Do not call Destroy directly. Call Free instead. Free checks that the object reference is not nil before calling Destroy.</docstr>
      </destructor>
      <function name="Equals">
        <docstr>Compare graphic to another TGraphic object and return true if objects contain same graphic.
Equals compares the contents of two TGraphic objects. Equals returns false if the TGraphic are different classes or if they contain different graphical data.

Code Examples
TGraphic (Delphi)
TGraphic (C++)</docstr>
      </function>
      <procedure name="LoadFromFile">
        <docstr>Loads a graphic image stored in a file.
LoadFromFile reads the file specified in FileName and loads the data into the graphics object.</docstr>
      </procedure>
      <procedure name="SaveToFile">
        <docstr>Saves a graphics image to a file.
SaveToFile writes the graphic to a file, specified by Filename.

Code Examples
TJPEGImageAssign (Delphi)
TJPEGImageAssign (C++)
ImageProc Sample</docstr>
      </procedure>
      <function name="CanLoadFromStream">
        <docstr>CanLoadFromStream returns True when a specified stream contains a streamed image of a specific TGraphic subclass. 
The method uses current stream position, it does not change current stream position.</docstr>
      </function>
      <procedure name="LoadFromStream">
        <docstr>Introduces an abstract method that loads the image from a stream.
Each descendant graphic object defines a LoadFromStream method that loads a graphics object from Stream.</docstr>
      </procedure>
      <procedure name="SaveToStream">
        <docstr>Introduces an abstract method that saves the graphic image to a stream.
Each descendant graphic object defines a SaveToStream method that saves the object to a Stream.</docstr>
      </procedure>
      <procedure name="LoadFromClipboardFormat">
        <docstr>Introduces an abstract method that loads the image from a variable in Clipboard format.
Each descendant graphic object defines a LoadFromClipboardFormat method that replaces the current graphic image with the graphic indicated by AData, which it loads from the Clipboard.
The format for the new graphic object must be registered with the Clipboard in the RegisterClipboardFormat method, or an exception is raised.</docstr>
      </procedure>
      <procedure name="SaveToClipboardFormat">
        <docstr>Introduces an abstract method that assigns the graphic to a variable in clipboard format.
Each descendant graphic object defines a SaveToClipboardFormat method that saves that particular graphic image type to a Clipboard format. An application must have registered the format with the TGraphic object using the RegisterClipboardFormat method.</docstr>
      </procedure>
      <procedure name="SetSize">
        <docstr>Specifies the size of the graphic.
Use the SetSize method to set both the height and width of the graphic. This results in better performance than setting the height and width separately.</docstr>
      </procedure>
      <procedure name="EnableScaledDrawer">
        <docstr>EnableScaledDrawer Enables scaled drawer for a graphic, which is used to scale the graphic.
AGraphicScalerClass specifies the scaled drawer class, for example TWICScaledGraphicDrawer. 

See also
ScaledDrawer
DisableScaledDrawer</docstr>
      </procedure>
      <procedure name="DisableScaledDrawer">
        <docstr>DisableScaledDrawer Disables scaled drawer for a graphic.

See also
ScaledDrawer
EnableScaledDrawer</docstr>
      </procedure>
      <procedure name="UpdateScaledDrawer">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <property name="Empty">
        <docstr>Indicates whether the graphics object contains a graphic.
Use Empty to determine whether the graphic is bound to an image. Each descendant graphic object defines its own Get method to access the Empty property.</docstr>
      </property>
      <property name="Height">
        <docstr>Specifies the vertical size of the graphic in pixels.
Use Height to determine the height of the graphic image. Each descendant graphic object defines its own Get and Set methods to access the Height property.

Code Examples
SaveToFile (Delphi)
ScanLine (Delphi)
SaveToFile (C++)
ScanLine (C++)</docstr>
      </property>
      <property name="Modified">
        <docstr>Indicates whether the graphics object has been changed or edited.
If Modified is true, the graphic object has changed. If Modified is false, the graphics object is in the same state as when the object was loaded.
The Modified property indicates only if bitmap objects have been modified. Modified is not true if the graphics object contains an icon or metafile graphic, even if they have been modified.
If the graphics object was modified, save the changes to a file with the SaveToFile method. The next time the application runs, it can load the graphic from the file with the LoadFromFile method.</docstr>
      </property>
      <property name="Palette">
        <docstr>Indicates the color palette of the graphical image.
Use Palette to get the color palette of a graphical image. If the graphic does not need or does not use a palette, the Palette property is zero.

Code Examples
GetDeviceContext (Delphi)
GetDeviceContext (C++)</docstr>
      </property>
      <property name="PaletteModified">
        <docstr>Indicates whether the palette has changed.
Use PaletteModified to determine if the palette used for a graphical image has changed. PaletteModified is used in the OnChange event. PaletteModified remains true until whoever is responsible for realizing this new palette (for example, TImage) sets it to false.</docstr>
      </property>
      <property name="Transparent">
        <docstr>Indicates whether the image covers its rectangular area.
Use Transparent to specify that the graphic be drawn transparently. Some descendants of TGraphic such as TIcon and TMetafile are always transparent, so setting the property for those objects does not change their behavior. However, the TBitmap graphic&apos;s drawing is affected by this property. The TImage component sets this property to be the same as its Transparent property to achieve transparent painting.
When the Transparent property is set to True, you can either specify a color as the transparent color or you can use the default color, which is the pixel in the lower left. The specified color is not displayed in the graphic, which lets the background show through. This can be useful in layering and for non-rectangular graphics.

Code Examples
FileSelectBtnEdit (Delphi)
TransparentColor (Delphi)
FileSelectBtnEdit (C++)
TransparentColor (C++)</docstr>
      </property>
      <property name="Width">
        <docstr>Determines the maximum width of the graphics object in pixels.
Each descendant graphic object defines its own Get and Set methods to access the Width property.

Code Examples
SaveToFile (Delphi)
ScanLine (Delphi)
SaveToFile (C++)
ScanLine (C++)</docstr>
      </property>
      <property name="ScaledDrawer">
        <docstr>Returns the reference to the scaled drawer.
When the scaled drawer is enabled for graphic, then the ScaledDrawer property returns the reference to it. 

See also
EnableScaledDrawer</docstr>
      </property>
      <event name="OnChange">
        <docstr>Occurs whenever a graphical image changes.
Use OnChange to write a handler to perform an action then the graphical image changes.</docstr>
      </event>
      <event name="OnProgress">
        <docstr>Occurs when a graphical image is in the process of changing.
For certain descendants of TGraphic, OnProgress occurs during slow processes such as loading, storing, or transforming image data. OnProgress allows applications to provide feedback to the user about the progress of the slow process. 
Component writers can generate OnProgress events for new descendants of TGraphic by calling the protected Progress method. These events are propagated to the TPicture and TImage objects.
OnProgress is an event handler of type Vcl.Graphics.TProgressEvent.</docstr>
      </event>
      <property name="SupportsPartialTransparency">
        <docstr>Indicate whether graphic supports partial transparency or an alpha channel.
SupportsPartialTransparency indicates whether the graphic supports partial transparency or an alpha channel.
Some TGraphic descendants, such as TBitmap and TPngImage, can support partial transparency or an alpha channel. When a graphic that supports partial transparency is drawn on a canvas using DrawTransparent, it should be blended with the pixels on the canvas based on the value of the alpha channel.</docstr>
      </property>
    </members>
  </class>
  <class unit="Vcl.Graphics" name="TPicture">
    <docstr>TPicture contains a bitmap, icon, metafile graphic, or user-defined graphic.
TPicture is a TGraphic container, used to hold a graphic, the type of which is specified in the Graphic property. It is used in place of a TGraphic if the graphic can be of any TGraphic class. LoadFromFile and SaveToFile are polymorphic. For example, if the TPicture is holding an Icon, it is valid to LoadFromFile a bitmap file, where the class TIcon can only read .ICO files.
If the TPicture contains a bitmap graphic, the Bitmap property specifies the graphic. If the TPicture contains an icon graphic, the Icon property specifies the graphic. If the TPicture contains a metafile graphic, the Metafile property specifies the graphic.
The properties of TPicture indicate the type of graphic that the picture object contains, and its size. The methods of TPicture are used to load, save, and manipulate graphics.
To load or save a picture to the Clipboard, use the Assign method of a TClipboard object.
To draw a picture on a canvas, call the Draw or StretchDraw methods of a TCanvas object, passing the Graphic property of a TPicture as a parameter.</docstr>
    <members>
      <procedure name="AssignTo">
        <docstr>Copies the properties of an object to a destination object.
Vcl.Graphics.TPicture.AssignTo inherits from System.Classes.TPersistent.AssignTo. All content below this line refers to System.Classes.TPersistent.AssignTo.
Copies the properties of an object to a destination object.
Override the AssignTo method to extend the functionality of the Assign method of destination objects so that they handle newly created object classes. When defining a new object class, override the Assign method for every existing object class that should be able to copy its properties to the new class. Override the AssignTo method for every existing class to which the new class can copy.
The Assign method of TPersistent calls AssignTo if the descendant object does not succeed in copying the properties of a source object. The AssignTo method defined by TPersistent raises an EConvertError exception. 
For example, given the following code in which A and B are instance variables:

A.Assign(B); {Delphi}

A-&gt;Assign(B); // C++

if A knows how to handle B, then it does so and returns. If A doesn&apos;t know how to handle B&apos;s type, execution will trickle to the TPersistent version of Assign, which calls:

B.AssignTo(A); {Delphi}

B-&gt;AssignTo(A); // C++

If B knows how to copy to A, the assignment succeeds. Otherwise, TPersistent raises an exception.</docstr>
      </procedure>
      <procedure name="Changed">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DefineProperties">
        <docstr>Provides an interface for a method that reads and writes otherwise unpublished data.
Vcl.Graphics.TPicture.DefineProperties inherits from System.Classes.TPersistent.DefineProperties. All content below this line refers to System.Classes.TPersistent.DefineProperties.
Provides an interface for a method that reads and writes otherwise unpublished data.
Descendants of TPersistent override DefineProperties to designate a method for storing the object&apos;s unpublished data to a stream such as a form file. By default, writing an object to a stream writes the values of all its published properties, and reading the object in reads those values and assigns them to the properties. Objects can also specify methods that read and write data other than published properties by overriding the DefineProperties method.
When overriding DefineProperties, consider including some or all of the following:

A call to the inherited method
Calls to the filer object&apos;s DefineProperty method
Calls to the filer object&apos;s DefineBinaryProperty method
DefineProperties is virtual, so descendant classes can override it as necessary but are not required to do so.</docstr>
      </procedure>
      <procedure name="Progress">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="FindGraphicClass">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Creates a TPicture object.
Call Create to create an instance of TPicture at runtime. Create allocates the memory for the picture object and initializes its internal formats. After creating the TPicture object, use the LoadFromClipboardFormat or LoadFromFile method to assign a graphical image to the picture, so that it is available to the application.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys an instance of a picture object.
Do not call Destroy directly in an application. Instead, call Free. Free verifies that the TPicture reference is not nil before it calls Destroy.
Destroy frees the graphic image it contains before calling the inherited Destroy.</docstr>
      </destructor>
      <procedure name="LoadFromFile">
        <docstr>Reads the file specified in Filename and loads the data into the TPicture object.
Use LoadFromFile to read a picture from disk. The TGraphic class created is determined by the file extension of the file. If the file extension is not recognized an EInvalidGraphic exception is raised.</docstr>
      </procedure>
      <procedure name="SaveToFile">
        <docstr>Writes the picture to disk.
Use SaveToFile to save a TPicture object to the file specified in Filename.
The saved picture can be loaded to another TPicture or to an appropriate TGraphic descendant by calling its LoadFromFile method.</docstr>
      </procedure>
      <procedure name="LoadFromStream">
        <docstr>Reads the picture from a Stream.
Use LoadFromStream to read a picture from a TStream object. The TGraphic class created is determined by the type of data contained in the stream.
The data in the stream should be previously written by a call to the SaveToStream method of another TPicture or of a TGraphic descendant.</docstr>
      </procedure>
      <procedure name="SaveToStream">
        <docstr>Saves the picture to a stream.
Use SaveToStream to save a picture to the TStream object specified by the Stream parameter. 
The saved picture can be loaded to another TPicture or to an appropriate TGraphic descendant by calling its LoadFromStream method.</docstr>
      </procedure>
      <procedure name="LoadFromClipboardFormat">
        <docstr>Reads the picture from the handle provided in the given Clipboard format.
Use LoadFromClipboardFormat to read in a graphic from the Clipboard. If the format is not supported, an EInvalidGraphic exception is raised.
The following code snippet shows how to load a picture from the clipboard into a TImage control.

Note: To load a picture into the clipboard, you can use the code snippet for the SaveToClipboardFormat method.

Delphi:

uses
  Vcl.Clipbrd;

procedure TForm1.Button1Click(Sender: TObject);
var
  Picture: TPicture;
begin
 Picture := TPicture.Create;
 try
   Picture.LoadFromClipboardFormat(cf_BitMap, ClipBoard.GetAsHandle(cf_Bitmap), 0);
   Image1.Picture := Picture;
 finally
   Picture.Free;
   Clipboard.Clear;
 end;
end;



C++:

#include &lt;Vcl.Clipbrd.hpp&gt;

void __fastcall TForm1::Button1Click(TObject *Sender){
	TPicture* Picture;
	TClipboard* cb = Clipboard();

	Picture = new TPicture();
	try{
		Picture-&gt;LoadFromClipboardFormat(CF_BITMAP, cb-&gt;GetAsHandle(CF_BITMAP), 0);
		Image1-&gt;Picture = Picture;
	}
	__finally{
		delete Picture;
		cb-&gt;Clear();
	}
}</docstr>
      </procedure>
      <procedure name="SaveToClipboardFormat">
        <docstr>Allocates a global handle and writes the picture in its native Clipboard format (CF_BITMAP for bitmaps, CF_METAFILE for metafiles, and so on).
Use SaveToClipboardFormat to copy the picture to a Clipboard format. The resulting values can then be copied to the Windows clipboard using the clipboard&apos;s SetAsHandle method.
The palette of the picture is returned in the APalette parameter, the format in the AFormat parameter, and a handle to the data in the AData parameter. Before the picture can be saved, an application must have registered the format using the RegisterClipboardFormat method.
The following code snippet shows how to save a bitmap to the clipboard.

Note: To load a bitmap from the clipboard, you can use the code snippet for the LoadFromClipboardFormat method.

Delphi:

uses
  Vcl.Clipbrd;

procedure TForm1.Button1Click(Sender: TObject);
var
  MyFormat : Word;
  Picture : TPicture;
  AData : THandle;
  APalette : HPALETTE;
begin
  Picture := TPicture.Create;
  try
    Picture.LoadFromFile(&apos;C:\Users\Public\Pictures\Sample Pictures\desert.bmp&apos;);
    Picture.SaveToClipBoardFormat(MyFormat, AData, APalette);
    ClipBoard.SetAsHandle(MyFormat,AData);
  finally
    Picture.Free;
  end;
end;



C++:

#include &lt;Vcl.Clipbrd.hpp&gt;

void __fastcall TForm1::Button1Click(TObject *Sender){
	TClipboard* cb = Clipboard();
	unsigned short MyFormat;
	TPicture* Picture;
	unsigned int AData;
	HPALETTE APalette;

	Picture = new TPicture();
	try{
		Picture-&gt;LoadFromFile(&quot;C:\\Users\\Public\\Pictures\\Sample Pictures\\desert.bmp&quot;);
		Picture-&gt;SaveToClipboardFormat(MyFormat, AData, APalette);
		cb-&gt;SetAsHandle(MyFormat, AData);
	}
	__finally{
		delete Picture;
	}
}</docstr>
      </procedure>
      <function name="SupportsClipboardFormat">
        <docstr>Indicates if the given Clipboard format is supported by the LoadFromClipboardFormat method.
If the LoadFromClipboardFormat method supports the Clipboard format specified as the value of AFormat, SupportsClipboardFormat returns true. If the format is not supported, the method returns false.</docstr>
      </function>
      <procedure name="Assign">
        <docstr>Copies one object to another by copying the contents of that object to the other.
When Source is a object type that is valid for the Graphic property, Assign makes that graphic the value of the Graphic property.
The actions performed by Assign depend on the actual types of the TPicture Graphic property and Source. For example, if the Graphic property and Source are bitmaps (TBitmap), the bitmap contained in Source is copied into the Graphic property. Similar conversions are valid, for example, for TIcon or TMetafile.
If the Source parameter is not a valid object for the Graphic property, Assign calls the inherited method so that the picture can be copied from any object with which it is compatible.</docstr>
      </procedure>
      <procedure name="RegisterFileFormat">
        <docstr>Registers a new TGraphic class for use in LoadFromFile.
Use RegisterFileFormat to register a graphic file format with TPicture so that it can be used with a Open or Save dialog box.
The AExtension parameter specifies the three-character system file extension to associate with the graphic class (for example, &quot;bmp&quot; is associated with TBitmap). The ADescription parameter specifies the description of the graphic to appear in the drop down list of the dialog box (for example, &quot;Bitmaps&quot; is the description of TBitmap). The AGraphicClass parameter registers the new graphic class to associate with the file format.</docstr>
      </procedure>
      <procedure name="RegisterClipboardFormat">
        <docstr>Registers a new TGraphic class for use in the LoadFromClipboardFormat method.
Use RegisterClipboardFormat register a new graphic format with TPicture so that it can be used with the LoadFromClipboardFormat method.</docstr>
      </procedure>
      <procedure name="UnregisterGraphicClass">
        <docstr>Removes all references to the specified TGraphic class and all its descendants from the internal lists of file formats and clipboard formats.
Call UnregisterGraphicClass to make a graphic class unavailable to all picture objects. UnregisterGraphicClass reverses the registration accomplished by the RegisterFileFormat, or RegisterFileFormatRes, or RegisterClipboardFormat method. When a graphic class is registered, the global GraphicFilter, GraphicExtension, and GraphicFileMask functions can return dialog filter strings, default file extensions or file filters for the graphic class. Call UnregisterGraphicClass when these values should not be available. For example, component writers who implement custom graphic classes unregister those classes according to the language used. In Delphi, the classes are unregistered in the finalization block of the unit that implements them and, in C++, the classes are unregistered using the #pragma exit directive (C++). 
File formats and clipboard formats for the custom class are registered in the initialization block (Delphi) or using #pragma startup (C++).</docstr>
      </procedure>
      <procedure name="RegisterFileFormatRes">
        <docstr>Registers a new TGraphic class for use in the LoadFromFile method.
Use RegisterFileFormatRes by specifying a string resource.
The AExtension parameter specifies the three-character system file extension to associate with the graphic class (for example, &quot;bmp&quot; is associated with TBitmap).
The ADescriptionResID parameter specifies the resource ID for a description of the graphic, which then appears in the drop down list of the dialog box (for example, &quot;Bitmaps&quot; is the description of TBitmap).
The AGraphicClass parameter registers the new graphic class to associate with the file format.</docstr>
      </procedure>
      <property name="Bitmap">
        <docstr>Specifies the contents of the picture object as a bitmap graphic (.BMP file format).
Use Bitmap to reference the picture object when it contains a bitmap. If Bitmap is referenced when the picture contains a Metafile or Icon graphic, the graphic won&apos;t be converted (Types of Graphic Objects). Instead, the original contents of the picture are discarded and Bitmap returns a new, blank bitmap.

Note:  When assigning the Bitmap property, TPicture assigns the properties of a another TBitmap object. It does not take ownership of the specified value.</docstr>
      </property>
      <property name="Graphic">
        <docstr>Specifies the graphic that the picture contains.
Use Graphic to specify what graphic the TPicture object contains. The graphic can be a bitmap, icon, metafile, or user-defined graphic class (Types of Graphic Objects).

Note:  When assigning the Graphic property, TPicture assigns the properties of a another TGraphic object. It does not take ownership of the specified object.</docstr>
      </property>
      <property name="PictureAdapter">
        <docstr>Represents an OLE interface for the picture.
PictureAdapter is for internal use only.</docstr>
      </property>
      <property name="Height">
        <docstr>Specifies the vertical size (in pixels) of the graphic.
Use Height to find the height of the graphic image contained in the picture object. Height is the native, unstretched, height of the picture.</docstr>
      </property>
      <property name="Icon">
        <docstr>Specifies the contents of the TPicture object as an icon graphic (.ICO file format).
If Icon is referenced when the TPicture contains a Bitmap or Metafile graphic, the graphic won&apos;t be converted. Instead, the original contents of the TPicture are discarded and Icon returns a new, blank icon.

Note:  When assigning the Icon property, TPicture assigns the properties of a another Icon object. It does not take ownership of the specified value.</docstr>
      </property>
      <property name="Metafile">
        <docstr>Specifies the contents of the picture object as an Enhanced Windows metafile graphic (.EMF file format).
If Metafile is referenced when the TPicture contains a Bitmap or Icon graphic, the graphic won&apos;t be converted. Instead, the original contents of the TPicture are discarded and Metafile returns a new, blank metafile (Types of Graphic Objects
).

Note:  When assigning the Metafile property, TPicture assigns the properties of a another TMetafile object. It does not take ownership of the specified value.</docstr>
      </property>
      <property name="WICImage">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="Width">
        <docstr>Specifies the horizontal size (in pixels) of the picture.
Use Width to find the width of a graphic image. Width contains the native, unstretched, width of the picture.</docstr>
      </property>
      <event name="OnChange">
        <docstr>Occurs when the specific graphics item encapsulated by the picture object changes.
Use OnChange to write an event handler to process an action when the graphic is modified.</docstr>
      </event>
      <event name="OnProgress">
        <docstr>Occurs periodically during slow operations that affect the graphic.
OnProgress is generated by the particular graphic that the picture object contains. Whether OnProgress occurs depends upon the type of graphic in the Graphic property. Some graphics generate this event, others do not. Jpeg images, for example, generate an OnProgress event.
Write an OnProgress event handler to provide the user with feedback during slow operations such as loading large compressed images. TImage, for example, hooks the OnProgress event of TPicture.

Note:  The PercentDone parameter on the event handler is only an approximation. With some image formats, the value of PercentDone may actually decrease from the value in previous events, as the graphic object discovers there is more work to do.
OnProgress is an event handler of type Vcl.Graphics.TProgressEvent.</docstr>
      </event>
      <event name="OnFindGraphicClass">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </event>
    </members>
  </class>
  <class unit="Vcl.Graphics" name="TMetafile">
    <docstr>TMetafile is an encapsulation of the Win32 Enhanced metafile.
TMetafile contains a metafile graphic (EMF file format).
Properties of TMetafile indicate the size and characteristics of the metafile.
To draw a metafile on a canvas, call the Draw or StretchDraw methods of a TCanvas object, passing a TMetafile as a parameter. The Enhanced property determines how the metafile will be stored on disk. If Enhanced is true, the metafile is stored as an .EMF (Win32 Enhanced Metafile) file. If Enhanced is false, the metafile is stored as a .WMF (Windows 3.1 Metafile, with Aldus header).</docstr>
    <members>
      <function name="GetEmpty">
        <docstr>Indicates whether graphics object contains graphic.
Vcl.Graphics.TMetafile.GetEmpty inherits from Vcl.Graphics.TGraphic.GetEmpty. All content below this line refers to Vcl.Graphics.TGraphic.GetEmpty.
Indicates whether graphics object contains graphic.
GetEmpty indicates whether the TGraphic object contains a graphic.
Each descendant of the TGraphic class should override the GetEmpty method to indicate whether a given TGraphic object is bound to an image.</docstr>
      </function>
      <function name="GetHeight">
        <docstr>Get vertical size of graphic in pixels.
Vcl.Graphics.TMetafile.GetHeight inherits from Vcl.Graphics.TGraphic.GetHeight. All content below this line refers to Vcl.Graphics.TGraphic.GetHeight.
Get vertical size of graphic in pixels.
GetHeight gets the vertical size of the TGraphic object in pixels.
Each descendant of TGraphic defines its own GetHeight and SetHeight methods to access the Height property.</docstr>
      </function>
      <function name="GetPalette">
        <docstr>Get color palette of graphical image.
Vcl.Graphics.TMetafile.GetPalette inherits from Vcl.Graphics.TGraphic.GetPalette. All content below this line refers to Vcl.Graphics.TGraphic.GetPalette.
Get color palette of graphical image.
GetPalette gets the color palette of the graphical image. You can also use the Palette property to get the color palette of a graphical image. If the graphic does not need or use a palette, the Palette property is zero.</docstr>
      </function>
      <function name="GetWidth">
        <docstr>Get horizontal size of graphic in pixels.
Vcl.Graphics.TMetafile.GetWidth inherits from Vcl.Graphics.TGraphic.GetWidth. All content below this line refers to Vcl.Graphics.TGraphic.GetWidth.
Get horizontal size of graphic in pixels.
GetWidth gets the horizontal size of the graphic in pixels.
Each descendant of the TGraphic class defines its own GetWidth and SetWidth methods to access the Width property.</docstr>
      </function>
      <procedure name="Draw">
        <docstr>Render graphic onto canvas at rectangle.
Vcl.Graphics.TMetafile.Draw inherits from Vcl.Graphics.TGraphic.Draw. All content below this line refers to Vcl.Graphics.TGraphic.Draw.
Render graphic onto canvas at rectangle.
TCanvas.Draw calls this function to render the graphic onto its canvas at the coordinates specified by the Rect parameter. Descendants of TGraphic should override this function with a specific rendering implementation.</docstr>
      </procedure>
      <procedure name="ReadData">
        <docstr>Read graphic data from TStream.
Vcl.Graphics.TMetafile.ReadData inherits from Vcl.Graphics.TGraphic.ReadData. All content below this line refers to Vcl.Graphics.TGraphic.ReadData.
Read graphic data from TStream.
ReadData is used to read the binary graphic from the virtual property Data (created by DefineProperties) when streaming in a TGraphic from the TStream Stream.</docstr>
      </procedure>
      <procedure name="ReadEMFStream">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="ReadWMFStream">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="SetHeight">
        <docstr>Set vertical size of graphic in pixels.
Vcl.Graphics.TMetafile.SetHeight inherits from Vcl.Graphics.TGraphic.SetHeight. All content below this line refers to Vcl.Graphics.TGraphic.SetHeight.
Set vertical size of graphic in pixels.
SetHeight sets the vertical size of the graphic in pixels.
Each descendant of the TGraphic class defines its own GetHeight and SetHeight methods to access the Height property.</docstr>
      </procedure>
      <procedure name="SetTransparent">
        <docstr>Specify if graphic should be drawn transparently.
Vcl.Graphics.TMetafile.SetTransparent inherits from Vcl.Graphics.TGraphic.SetTransparent. All content below this line refers to Vcl.Graphics.TGraphic.SetTransparent.
Specify if graphic should be drawn transparently.
SetTransparent specifies if a graphic should be drawn transparently.</docstr>
      </procedure>
      <procedure name="SetWidth">
        <docstr>Set horizontal size of graphic in pixels.
Vcl.Graphics.TMetafile.SetWidth inherits from Vcl.Graphics.TGraphic.SetWidth. All content below this line refers to Vcl.Graphics.TGraphic.SetWidth.
Set horizontal size of graphic in pixels.
SetWidth sets the horizontal size of the graphic in pixels.
Each descendant of the TGraphic class defines its own GetWidth and SetWidth methods to access the Width property.</docstr>
      </procedure>
      <function name="TestEMF">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="WriteData">
        <docstr>Write graphic data to TStream.
Vcl.Graphics.TMetafile.WriteData inherits from Vcl.Graphics.TGraphic.WriteData. All content below this line refers to Vcl.Graphics.TGraphic.WriteData.
Write graphic data to TStream.
WriteData is used to write the binary graphic to the virtual property Data (created by DefineProperties) when streaming a TGraphic out to the TStream Stream.</docstr>
      </procedure>
      <procedure name="WriteEMFStream">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="WriteWMFStream">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Instantiates a metafile object.
Call Create to instantiate a metafile at runtime.
Create allocates memory for a metafile object, and calls the inherited Create. Then sets the Enhanced and Transparent properties to true.
To create a metafile image from scratch, draw the image in a metafile canvas. When the metafile canvas is destroyed, it transfers the image into the metafile object provided to the metafile canvas constructor. After the image is drawn on the canvas and the canvas is destroyed, the image is &apos;playable&apos; in the metafile object.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys an instance of a metafile object.
Do not call Destroy directly in an application. Instead, an application should call Free. Free verifies that the TMetafile reference is not nil before it calls Destroy.
Destroy releases the image, which frees the image and the handle when the reference count on the metafile image is zero. Then Destroy calls the inherited Destroy.</docstr>
      </destructor>
      <procedure name="Clear">
        <docstr>Deletes the metafile image.
Use Clear to release the old metafile image, create a new image, and increment a reference count on it.</docstr>
      </procedure>
      <function name="HandleAllocated">
        <docstr>Indicates whether the TMetafile object has acquired a handle to the underlying GDI object.
Use HandleAllocated to determine whether the Handle property is set to an HMETAFILE value. HandleAllocated indicates whether the underlying GDI object has already been created. Use HandleAllocated rather than reading the Handle property. When an application reads the Handle property, it automatically creates a metafile and returns its handle if the underlying GDI object does not already exist.</docstr>
      </function>
      <function name="CanLoadFromStream">
        <docstr>Vcl.Graphics.TMetafile.CanLoadFromStream inherits from Vcl.Graphics.TGraphic.CanLoadFromStream. All content below this line refers to Vcl.Graphics.TGraphic.CanLoadFromStream.
CanLoadFromStream returns True when a specified stream contains a streamed image of a specific TGraphic subclass. 
The method uses current stream position, it does not change current stream position.</docstr>
      </function>
      <procedure name="LoadFromStream">
        <docstr>Loads the metafile from a stream.
Use LoadFromStream by specifying the stream from which the metafile is loaded as the value of Stream. LoadFromStream reads a metafile from a stream and replaces the current image with it.</docstr>
      </procedure>
      <procedure name="SaveToFile">
        <docstr>Writes the metafile to disk.
Use SaveToFile to save the metafile to a file provided by the Filename parameter. To load a metafile from a file, call the LoadFromFile method.

 Note: If the Filename parameter has an extension of &quot;.wmf&quot;, the metafile is saved as a WMF file. It is not necessary to set the Enhanced property.</docstr>
      </procedure>
      <procedure name="SaveToStream">
        <docstr>Writes the metafile to a stream.
Use SaveToStream to save the metafile to the stream specified by the Stream parameter. 
If the Enhanced property is True, the metafile is saved as an EMF; if False, it it saved as a WMF.</docstr>
      </procedure>
      <procedure name="LoadFromClipboardFormat">
        <docstr>Loads a metafile from the Clipboard.
LoadFromClipboardFormat replaces the current image with the data in the clipboard. LoadFromClipboardFormat ignores the AData and APalette parameters.</docstr>
      </procedure>
      <procedure name="SaveToClipboardFormat">
        <docstr>Saves a metafile to a Clipboard format.
Use SaveToClipboardFormat to copy the metafile to a Clipboard format. The resulting values can then be copied to the Windows clipboard using the clipboard&apos;s SetAsHandle method.
The metafile&apos;s palette is returned in the APalette parameter, the format in the AFormat parameter, and a handle to the data in the AData parameter. Before the metafile can be saved, an application must have registered the format with the metafile object using the RegisterClipboardFormat method.
To save a metafile to a file, call SaveToFile.</docstr>
      </procedure>
      <procedure name="Assign">
        <docstr>Copies an object to the metafile.
Assign copies the Enhanced and Palette properties of an object to the metafile. If the metafile is nil (Delphi) or NULL (C++), Assign creates one. Otherwise, Assign calls the inherited method. For assignment, metafiles are polymorphic with other TGraphic objects, and with TPicture.</docstr>
      </procedure>
      <function name="ReleaseHandle">
        <docstr>Releases the Windows GDI object represented by the metafile.
Call ReleaseHandle to release the resources used to represent the metafile. ReleaseHandle sets the Handle property to nil. NULL. 
Call ReleaseHandle before setting the Handle property, so that the resources associated with the metafile are not lost.</docstr>
      </function>
      <procedure name="SetSize">
        <docstr>Specifies the size of the metafile.
Use the SetSize method to set both the height and width of the metafile. This results in better performance than setting the height and width separately.</docstr>
      </procedure>
      <property name="CreatedBy">
        <docstr>Specifies the name of the author or application used to create the metafile.
Use CreatedBy to set the string to an optional name of the author or application used to create the metafile. To set the CreatedBy string of a new metafile, call the TMetafileCanvas CreateWithComment constructor (Delphi) or the TMetafileCanvas constructor that takes a comment (C++).</docstr>
      </property>
      <property name="Description">
        <docstr>Provides an optional text description that is embedded in the metafile.
Set the Description string of a new metafile by calling the TMetafileCanvas CreateWithComment constructor (Delphi) or the TMetafileCanvas constructor that takes a comment (C++)..</docstr>
      </property>
      <property name="Enhanced">
        <docstr>Determines how the metafile will be stored on disk.
Use Enhanced to determine how the metafile is stored on disk. If Enhanced is True, the metafile is stored as an .EMF (Win32 Enhanced Metafile). If Enhanced is False, the metafile is stored as a .WMF (Windows 3.1 Metafile, with Aldus header).
The in-memory format is always EMF. WMF has very limited capabilities; storing as WMF will lose information that would be retained by EMF. This property is set to match the metafile type when loaded from a stream or file. If loaded as WMF, then save as WMF.
By default, the Enhanced property is True.</docstr>
      </property>
      <property name="Handle">
        <docstr>Provides access to the Windows GDI metafile handle, for accessing the GDI metafile object.
Use Handle when calling a Windows API function that requires the handle of a metafile object. Pass the handle from the Handle property of the metafile object to the function.</docstr>
      </property>
      <property name="MMWidth">
        <docstr>Contains the width of the metafile image in 0.01 millimeter units, the native scale used by enhanced metafiles.
MMWidth is used for a more accurate reading of the horizontal size of the graphic. The Width property, by contrast, is always in screen device pixel units; to avoid loss of precision in converting between device pixels and millimeters, set or read the dimensions in millimeters with MMWidth.
The MMWidth property is always in screen device pixel units.</docstr>
      </property>
      <property name="MMHeight">
        <docstr>Contains the height of the metafile image in 0.01 millimeter units, the native scale used by enhanced metafiles.
MMHeight is used for a more accurate reading of the vertical size of the graphic. The Height property, by contrast, is always in screen device pixel units; to avoid loss of precision in converting between device pixels and millimeters, set or read the dimensions in millimeters with MMHeight.</docstr>
      </property>
      <property name="Inch">
        <docstr>Returns the units per inch that are used for the metafile&apos;s coordinate mapping.
Use Inch to find the units per inch assumed by a WMF metafile, and to alter scale when writing as WMF, but otherwise this property is obsolete. Enhanced metafiles maintain complete scale information internally. For example, if the metafile was created in a Twips coordinate system (using MM_TWIPS mapping), the value of Inch is 1440.</docstr>
      </property>
    </members>
  </class>
  <class unit="Vcl.Graphics" name="TBitmap">
    <docstr>TBitmap is an encapsulation of a Windows bitmap (HBITMAP), including its palette (HPALETTE).
A bitmap is a powerful graphics object used to create, manipulate and store images in memory and as files on a disk.
TBitmap contains an internal image of the bitmap graphic and automatically manages realization of the palette when drawn. 
To draw a bitmap on a canvas, call the Draw or StretchDraw methods of a TCanvas object, passing a TBitmap as a parameter.
Creating copies of a TBitmap is very fast since the handle is copied rather than the image. If the image is modified and the handle is shared by more than one TBitmap object, the image is copied before the modification is performed (that is, copy on write).</docstr>
    <members>
      <function name="GetSupportsPartialTransparency">
        <docstr>Indicate whether graphic supports partial transparency.
Vcl.Graphics.TBitmap.GetSupportsPartialTransparency inherits from Vcl.Graphics.TGraphic.GetSupportsPartialTransparency. All content below this line refers to Vcl.Graphics.TGraphic.GetSupportsPartialTransparency.
Indicate whether graphic supports partial transparency.
GetSupportsPartialTransparency indicates whether the graphic supports partial transparency.
TGraphic descendants should override GetSupportsPartialTransparency if they are capable of having partially transparent pixels.</docstr>
      </function>
      <procedure name="Changed">
        <docstr>Called when graphic has changed.
Vcl.Graphics.TBitmap.Changed inherits from Vcl.Graphics.TGraphic.Changed. All content below this line refers to Vcl.Graphics.TGraphic.Changed.
Called when graphic has changed.
Changed is called automatically whenever the TGraphic object is modified. It sets the Modified property to True and triggers the OnChange event.</docstr>
      </procedure>
      <procedure name="Draw">
        <docstr>Render graphic onto canvas at rectangle.
Vcl.Graphics.TBitmap.Draw inherits from Vcl.Graphics.TGraphic.Draw. All content below this line refers to Vcl.Graphics.TGraphic.Draw.
Render graphic onto canvas at rectangle.
TCanvas.Draw calls this function to render the graphic onto its canvas at the coordinates specified by the Rect parameter. Descendants of TGraphic should override this function with a specific rendering implementation.</docstr>
      </procedure>
      <procedure name="DrawTransparent">
        <docstr>Render graphic onto canvas at rectangle, blending with canvas&apos;s background.
Vcl.Graphics.TBitmap.DrawTransparent inherits from Vcl.Graphics.TGraphic.DrawTransparent. All content below this line refers to Vcl.Graphics.TGraphic.DrawTransparent.
Render graphic onto canvas at rectangle, blending with canvas&apos;s background.
DrawTransparent renders the graphic onto a canvas at the coordinates specified by the Rect parameter, blending it with the canvas&apos;s background.</docstr>
      </procedure>
      <function name="GetEmpty">
        <docstr>Indicates whether graphics object contains graphic.
Vcl.Graphics.TBitmap.GetEmpty inherits from Vcl.Graphics.TGraphic.GetEmpty. All content below this line refers to Vcl.Graphics.TGraphic.GetEmpty.
Indicates whether graphics object contains graphic.
GetEmpty indicates whether the TGraphic object contains a graphic.
Each descendant of the TGraphic class should override the GetEmpty method to indicate whether a given TGraphic object is bound to an image.</docstr>
      </function>
      <function name="GetHeight">
        <docstr>Get vertical size of graphic in pixels.
Vcl.Graphics.TBitmap.GetHeight inherits from Vcl.Graphics.TGraphic.GetHeight. All content below this line refers to Vcl.Graphics.TGraphic.GetHeight.
Get vertical size of graphic in pixels.
GetHeight gets the vertical size of the TGraphic object in pixels.
Each descendant of TGraphic defines its own GetHeight and SetHeight methods to access the Height property.</docstr>
      </function>
      <function name="GetPalette">
        <docstr>Get color palette of graphical image.
Vcl.Graphics.TBitmap.GetPalette inherits from Vcl.Graphics.TGraphic.GetPalette. All content below this line refers to Vcl.Graphics.TGraphic.GetPalette.
Get color palette of graphical image.
GetPalette gets the color palette of the graphical image. You can also use the Palette property to get the color palette of a graphical image. If the graphic does not need or use a palette, the Palette property is zero.</docstr>
      </function>
      <function name="GetWidth">
        <docstr>Get horizontal size of graphic in pixels.
Vcl.Graphics.TBitmap.GetWidth inherits from Vcl.Graphics.TGraphic.GetWidth. All content below this line refers to Vcl.Graphics.TGraphic.GetWidth.
Get horizontal size of graphic in pixels.
GetWidth gets the horizontal size of the graphic in pixels.
Each descendant of the TGraphic class defines its own GetWidth and SetWidth methods to access the Width property.</docstr>
      </function>
      <procedure name="HandleNeeded">
        <docstr>Create GDI bitmap for TBitmap if it doesn&apos;t already exist.
HandleNeeded creates a GDI bitmap for the TBitmap if it doesn&apos;t already exist.</docstr>
      </procedure>
      <procedure name="MaskHandleNeeded">
        <docstr>Create GDI bitmap for TBitmap&apos;s mask if it doesn&apos;t already exist.
MaskHandleNeeded is called to create a GDI bitmap for the TBitmap object&apos;s mask if it doesn&apos;t already exist.</docstr>
      </procedure>
      <procedure name="PaletteNeeded">
        <docstr>Create color palette for TBitmap&apos;s mask if it doesn&apos;t already exist.
PaletteNeeded is called to create a color palette for the TBitmap object if it doesn&apos;t already exist. A palette is not created if IgnorePalette is true. IgnorePalette is set to true if a palette can&apos;t be created.</docstr>
      </procedure>
      <procedure name="ReadData">
        <docstr>Read graphic data from TStream.
Vcl.Graphics.TBitmap.ReadData inherits from Vcl.Graphics.TGraphic.ReadData. All content below this line refers to Vcl.Graphics.TGraphic.ReadData.
Read graphic data from TStream.
ReadData is used to read the binary graphic from the virtual property Data (created by DefineProperties) when streaming in a TGraphic from the TStream Stream.</docstr>
      </procedure>
      <procedure name="SetHeight">
        <docstr>Set vertical size of graphic in pixels.
Vcl.Graphics.TBitmap.SetHeight inherits from Vcl.Graphics.TGraphic.SetHeight. All content below this line refers to Vcl.Graphics.TGraphic.SetHeight.
Set vertical size of graphic in pixels.
SetHeight sets the vertical size of the graphic in pixels.
Each descendant of the TGraphic class defines its own GetHeight and SetHeight methods to access the Height property.</docstr>
      </procedure>
      <procedure name="SetPalette">
        <docstr>Set color palette of graphical image.
Vcl.Graphics.TBitmap.SetPalette inherits from Vcl.Graphics.TGraphic.SetPalette. All content below this line refers to Vcl.Graphics.TGraphic.SetPalette.
Set color palette of graphical image.
SetPalette sets the color palette of the graphical image.
Use the Palette property to get the color palette of a graphical image. If the graphic does not need or does not use a palette, the Palette property is zero.</docstr>
      </procedure>
      <procedure name="SetWidth">
        <docstr>Set horizontal size of graphic in pixels.
Vcl.Graphics.TBitmap.SetWidth inherits from Vcl.Graphics.TGraphic.SetWidth. All content below this line refers to Vcl.Graphics.TGraphic.SetWidth.
Set horizontal size of graphic in pixels.
SetWidth sets the horizontal size of the graphic in pixels.
Each descendant of the TGraphic class defines its own GetWidth and SetWidth methods to access the Width property.</docstr>
      </procedure>
      <procedure name="WriteData">
        <docstr>Write graphic data to TStream.
Vcl.Graphics.TBitmap.WriteData inherits from Vcl.Graphics.TGraphic.WriteData. All content below this line refers to Vcl.Graphics.TGraphic.WriteData.
Write graphic data to TStream.
WriteData is used to write the binary graphic to the virtual property Data (created by DefineProperties) when streaming a TGraphic out to the TStream Stream.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Instantiates a bitmap object.
Call Create to instantiate a bitmap object at runtime. Create is also called automatically when a bitmap image is loaded into a TImage.
Create allocates memory for a bitmap object, and calls the inherited Create. Then it creates a TBitmapImage as the internal image that represents the bitmap.</docstr>
      </constructor>
      <constructor name="Create">
        <docstr>Instantiates a bitmap object.
Call Create to instantiate a bitmap object at runtime. Create is also called automatically when a bitmap image is loaded into a TImage.
Create allocates memory for a bitmap object, and calls the inherited Create. Then it creates a TBitmapImage as the internal image that represents the bitmap.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of the instance of the bitmap object.
Destroy is the destructor for a TBitmap object.
Do not call the destructor directly in an application. Instead, call Free. Free verifies that the bitmap object is not nil before it calls Destroy.
Destroy releases the internal bitmap image (TBitmapImage object) and frees the canvas before calling the inherited destructor.</docstr>
      </destructor>
      <procedure name="Assign">
        <docstr>Copies a new bitmap image to the bitmap object.
Assign copies the bitmap image contained in Source to the bitmap object. If Source is not a bitmap, Assign calls the inherited Assign method, which can copy an image from any class that knows how to copy to a TBitmap object. If the bitmap needs to be changed, the actual bitmap image is copied before the changes are made (copy on write).

Note:  An object of one type can always be assigned to another object of the same type. Also, the Source can be of type TPicture if the Graphic property of the picture is a bitmap.</docstr>
      </procedure>
      <procedure name="Dormant">
        <docstr>Creates a memory bitmap image in order to release the bitmap handle, forcing the image into DIB format to save resources.
Use Dormant to change the format of the bitmap in memory thereby reducing the amount of GDI resources used by the application.
Dormant creates a bitmap image in memory using a memory stream object. This preserves the image so that the bitmap can then free the HBITMAP (accessed through the Handle property) that was assigned to it.
DIB handles may use fewer Win95 GDI resources than DDB, but DIBs may also use more memory than DDBs, depending on the current video driver and mode.</docstr>
      </procedure>
      <procedure name="FreeImage">
        <docstr>Frees the cached file image stored in memory by the bitmap.
Use FreeImage to reduce the memory requirements of an application when color depth and pixel format are not an issue. Freeing the image releases the memory allocated for the bitmap image when it was originally loaded to disk. Consequently, some of the original pixel format of the bitmap is lost (for example, if you changed its format to a DIB) as well as the color depth of the bitmap.
When a bitmap is loaded into a bitmap object, the bitmap object creates an image of the loaded bitmap in memory. If the bitmap isn&apos;t changed, the memory image is used when saving the bitmap, to verify that the bitmap has not lost color depth or changed the pixel format.

Code Examples
LoadFromFile (Delphi)
LoadFromFile (C++)</docstr>
      </procedure>
      <function name="HandleAllocated">
        <docstr>Indicates whether the TBitmap object has acquired a handle to the underlying GDI object.
Use HandleAllocated to determine whether the Handle property is set to an HBITMAP value. HandleAllocated indicates whether the underlying GDI object has already been created. Use HandleAllocated rather than reading the Handle property. When an application reads the Handle property, it automatically creates a bitmap and returns its handle if the underlying GDI object does not already exist.</docstr>
      </function>
      <procedure name="LoadFromClipboardFormat">
        <docstr>Loads a bitmap from the Clipboard into the bitmap object.
LoadFromClipboardFormat is called if the bitmap is registered with the TPicture object using the RegisterClipboardFormat method.
LoadFromClipboardFormat replaces the current image with the data pointed to by the AData parameter. The palette for the bitmap is specified by the APalette parameter.
The following code snippet shows how to load a bitmap from the clipboard and use that picture to draw on the canvas of the form.

Note: To load a bitmap into the clipboard, you can use the code snippet for the SaveToClipboardFormat method.

Delphi:

uses
  Vcl.Clipbrd;

procedure TForm1.Button1Click(Sender: TObject);
var
  Bitmap : TBitmap;
begin
 Bitmap := TBitMap.Create;
 try
   Bitmap.LoadFromClipBoardFormat(cf_BitMap, ClipBoard.GetAsHandle(cf_Bitmap), 0);
   Canvas.draw(0,0,Bitmap);
 finally
   Bitmap.Free;
   Clipboard.Clear;
 end;
end;



C++:

#include &lt;Vcl.Clipbrd.hpp&gt;

void __fastcall TForm1::Button1Click(TObject *Sender){
	TBitmap* Bitmap;
	TClipboard* cb = Clipboard();

	Bitmap = new TBitmap();
	try{
		Bitmap-&gt;LoadFromClipboardFormat(CF_BITMAP, cb-&gt;GetAsHandle(CF_BITMAP), 0);
		Canvas-&gt;Draw(0,0,Bitmap);
	}
	__finally{
		delete Bitmap;
		cb-&gt;Clear();
	}
}</docstr>
      </procedure>
      <function name="CanLoadFromStream">
        <docstr>Vcl.Graphics.TBitmap.CanLoadFromStream inherits from Vcl.Graphics.TGraphic.CanLoadFromStream. All content below this line refers to Vcl.Graphics.TGraphic.CanLoadFromStream.
CanLoadFromStream returns True when a specified stream contains a streamed image of a specific TGraphic subclass. 
The method uses current stream position, it does not change current stream position.</docstr>
      </function>
      <procedure name="LoadFromStream">
        <docstr>Loads the bitmap from a stream into the bitmap object.
Use LoadFromStream to load the bitmap image from a stream. The Stream parameter specifies the stream from which to read the bitmap image. For example, use LoadFromStream to load a bitmap image from a BLOB stream that reads from a graphic field in a dataset.</docstr>
      </procedure>
      <procedure name="Mask">
        <docstr>Converts the current bitmap image into a monochrome mask, replacing TransparentColor with white and every other color with black.
Use Mask to produce a monochrome mask bitmap based on a given transparent color. Mask produces the same image that MaskHandle does, except that the resulting mask image replaces the image in the TBitmap object, so it only makes sense to call Mask once. Use MaskHandle when only a bitmap handle of the mask image is needed.</docstr>
      </procedure>
      <function name="ReleaseHandle">
        <docstr>Returns the handle to the bitmap so that the TBitmap object no longer knows about the handle.
Use ReleaseHandle to disassociate the bitmap from the bitmap handle. Use it when you need to give a bitmap handle to a routine or object that will assume ownership (or destroy) the bitmap handle.</docstr>
      </function>
      <function name="ReleaseMaskHandle">
        <docstr>Returns the handle to the bitmap&apos;s mask so that the TBitmap object no longer knows about the mask handle.
Use ReleaseMaskHandle to disassociate the bitmap object from the bitmap mask handle.</docstr>
      </function>
      <function name="ReleasePalette">
        <docstr>Returns the handle to the bitmap&apos;s palette and disassociates the palette from the TBitmap object.
Use ReleasePalette to disassociate the palette from the bitmap image.</docstr>
      </function>
      <procedure name="SaveToClipboardFormat">
        <docstr>Creates a local copy of the bitmap in Clipboard format.
Use SaveToClipboardFormat to copy the bitmap to a Clipboard format. The bitmap&apos;s palette is returned in the APalette parameter, the format in the AFormat parameter, and a handle to the data in the AData parameter. Before the bitmap can be saved, an application must have registered the format with the TBitmap object using the RegisterClipboardFormat method.
The following code snippet shows how to save a bitmap to the clipboard.

Note: To load a bitmap from the clipboard, you can use the code snippet for the LoadFromClipboardFormat method.

Delphi:

uses
  Vcl.Clipbrd;

procedure TForm1.Button1Click(Sender: TObject);
var
  MyFormat : Word;
  Bitmap : TBitMap;
  AData : THandle;
  APalette : HPALETTE;
begin
  Bitmap := TBitmap.Create;
  try
    Bitmap.LoadFromFile(&apos;C:\Users\Public\Pictures\Sample Pictures\desert.bmp&apos;);
    Bitmap.SaveToClipBoardFormat(MyFormat, AData, APalette);
    ClipBoard.SetAsHandle(MyFormat,AData);
  finally
    Bitmap.Free;
  end;
end;



C++:

#include &lt;Vcl.Clipbrd.hpp&gt;

void __fastcall TForm1::Button1Click(TObject *Sender){
	TClipboard* cb = Clipboard();
	unsigned short MyFormat;
	TBitmap* Bitmap;
	unsigned int AData;
	HPALETTE APalette;

	Bitmap = new TBitmap();
	try{
		Bitmap-&gt;LoadFromFile(&quot;C:\\Users\\Public\\Pictures\\Sample Pictures\\desert.bmp&quot;);
		Bitmap-&gt;SaveToClipboardFormat(MyFormat, AData, APalette);
		cb-&gt;SetAsHandle(MyFormat, AData);
	}
	__finally{
		delete Bitmap;
	}
}</docstr>
      </procedure>
      <procedure name="SaveToStream">
        <docstr>Saves the bitmap to a stream.
Use SaveToStream to write the bitmap image to the stream specified by the Stream parameter. For example, specify a TBlobStream object as the Stream parameter to save the bitmap image to a graphic field in a dataset.</docstr>
      </procedure>
      <procedure name="SetSize">
        <docstr>Specifies the size of the bitmap.
Use the SetSize method to set both the height and width of the bitmap. This results in better performance than setting the height and width separately.</docstr>
      </procedure>
      <procedure name="LoadFromResourceName">
        <docstr>Loads a bitmap resource into the bitmap object.
LoadFromResourceName loads the specified bitmap resource along with palette information from a module&apos;s executable file.
Instance is the handle of the module that contains the resource.
ResName is the name of the resource to load.

Note:  Use this routine to load bitmaps from RES files instead of the LoadBitmap API. LoadBitmap does not support 256-color images.</docstr>
      </procedure>
      <procedure name="LoadFromResourceID">
        <docstr>Loads a bitmap from a resource into the bitmap object.
Use LoadFromResourceID to load a specified bitmap resource along with palette information from a module&apos;s executable file. 
Instance is the handle of the module that contains the resource.
ResID is the resource ID for the bitmap.</docstr>
      </procedure>
      <property name="Canvas">
        <docstr>Provides access to a drawing surface that represents the bitmap.
Canvas allows drawing on the bitmap by providing a T Canvas object for this purpose. Drawing on the canvas effectively modifies the underlying bitmap image pixels. Any canvas operation is valid on a bitmap (not just Draw and StretchDraw) including line drawing, rectangles, and circles. The bitmap object is passed as a parameter to these methods.
A canvas object is created automatically for the bitmap and the property is read-only.</docstr>
      </property>
      <property name="Handle">
        <docstr>Provides access to the Windows GDI bitmap handle for accessing the GDI bitmap object.
Use Handle to call a Windows API function that requires the handle of a bitmap object (HBITMAP). Pass Handle as the bitmap handle parameter to these functions.
Handle is the HBITMAP encapsulated by the bitmap object. Avoid grabbing the handle directly since it causes the HBITMAP to be copied if more than one TBitmap shares the handle.

Warning:  Be careful when giving the handle to an object or routine. If the receiver takes ownership (and destroys) the bitmap handle, call ReleaseHandle.</docstr>
      </property>
      <property name="HandleType">
        <docstr>Indicates whether the bitmap is a device-dependent bitmap, or a device-independent bitmap.
HandleType is used to find or modify the type of the bitmap. Device-dependent bitmaps (DDBs) may be faster to draw on the screen, but may be stored in memory in a device-specific format. Device-independent bitmaps (DIBs) are stored in memory in a standard format supported by all devices (including printers).</docstr>
      </property>
      <property name="IgnorePalette">
        <docstr>Determines whether the bitmap realizes its palette when drawing its image.
Use IgnorePalette when speed of drawing is a priority. When IgnorePalette is true, the bitmap does not realize its palette when drawing itself, resulting in lower picture quality on 256-color video drivers, but faster drawing of the bitmap image.

Note:</docstr>
      </property>
      <property name="MaskHandle">
        <docstr>Provides access to the Windows GDI bitmap handle for accessing the GDI bitmap object.
Use MaskHandle to call a Windows API function that requires the handle of a bitmap object. Pass MaskHandle as the bitmap handle parameter to these functions. MaskHandle is the HBITMAP encapsulated by the bitmap object&apos;s mask.</docstr>
      </property>
      <property name="Monochrome">
        <docstr>Determines whether the bitmap displays its image in monochrome.
If Monochrome is true if the bitmap displays as a monochrome bitmap. Monochrome is false if the bitmap displays in color, that is, if it contains more than one bit per pixel.

Note: 
Code Examples
LoadFromFile (Delphi)
LoadFromFile (C++)</docstr>
      </property>
      <property name="PixelFormat">
        <docstr>Indicates the bit format of the bitmap image, specifying how the image is displayed and how the pixels of the bitmap image are stored in memory.
Use PixelFormat to change a TBitmap&apos;s internal image to a particular memory format and color depth, or to find out what memory format and color depth a TBitmap is using. The possible formats are specified in TPixelFormat.
For example, PixelFormat can be used to set the pixel format of the bitmap image to 8-bit for video drivers that cannot display the native format of a bitmap image. 

Note: The PixelFormat of a JPEG image object applies to the bitmap if the JPEG image is copied to it.
Changing the pixel format is most commonly used with ScanLine, because your code must decode the pixel data accessed by ScanLine. Image-editing tools usually use one pixel for all internal image operations and copy the results to the screen (in whatever format) as the last step.</docstr>
      </property>
      <property name="TransparentColor">
        <docstr>Determines which color of the bitmap is to be transparent when the bitmap is drawn.
Use TransparentColor to determine how to draw the bitmap transparently. When the TransparentMode property is set to tmAuto (default), TransparentColor returns the color of the first pixel in the bitmap image data. For &quot;bottom-up&quot; bitmaps, the first pixel is the bottom leftmost pixel shown onscreen. For &quot;top-down&quot; bitmaps (less common), the first pixel is in the top left corner shown onscreen. 
If TransparentColor is assigned, the TransparentMode is automatically set to tmFixed so that the new transparent color can be used later. If you want TransparentColor to disregard any assignments and return the bottom leftmost pixel color again, set TransparentMode to tmAuto.</docstr>
      </property>
      <property name="TransparentMode">
        <docstr>Determines whether the TransparentColor property&apos;s value is automatically calculated or stored with the bitmap object.
When TransparentMode is set to tmAuto (the default), the TransparentColor property returns the color of the bottom-leftmost pixel of the bitmap image. When TransparentMode is set to tmFixed, the TransparentColor property refers to the color stored in the bitmap object.</docstr>
      </property>
      <property name="AlphaFormat">
        <docstr>Indicates how reserved byte of each pixel is used in 32 bit bitmaps.
Use AlphaFormat to change the way a TBitmap uses the reserved byte of each pixel in a 32bit Bitmap.</docstr>
      </property>
    </members>
  </class>
  <class unit="Vcl.Graphics" name="TIcon">
    <docstr>TIcon is an encapsulation of a Windows icon.
Use TIcon to represent one of the icons in an image list. Assign an icon to objects that have an Icon property, such as TForm or TPicture. 
Icon objects represent the value loaded from a Windows icon file (.ICO file). Draw an icon on a canvas, using the Draw method of the TCanvas object. Icons do not stretch, so do not use StretchDraw (TCanvas) with an icon.

Note: TIcon can be used to display the value of a multi-resolution (&gt;16 color) icon. However, it can not support the creation of multi-resolution icons, nor the resizing of the image after it is loaded from a file or stream.</docstr>
    <members>
      <procedure name="Draw">
        <docstr>Render graphic onto canvas at rectangle.
Vcl.Graphics.TIcon.Draw inherits from Vcl.Graphics.TGraphic.Draw. All content below this line refers to Vcl.Graphics.TGraphic.Draw.
Render graphic onto canvas at rectangle.
TCanvas.Draw calls this function to render the graphic onto its canvas at the coordinates specified by the Rect parameter. Descendants of TGraphic should override this function with a specific rendering implementation.</docstr>
      </procedure>
      <function name="GetEmpty">
        <docstr>Indicates whether graphics object contains graphic.
Vcl.Graphics.TIcon.GetEmpty inherits from Vcl.Graphics.TGraphic.GetEmpty. All content below this line refers to Vcl.Graphics.TGraphic.GetEmpty.
Indicates whether graphics object contains graphic.
GetEmpty indicates whether the TGraphic object contains a graphic.
Each descendant of the TGraphic class should override the GetEmpty method to indicate whether a given TGraphic object is bound to an image.</docstr>
      </function>
      <function name="GetHeight">
        <docstr>Get vertical size of graphic in pixels.
Vcl.Graphics.TIcon.GetHeight inherits from Vcl.Graphics.TGraphic.GetHeight. All content below this line refers to Vcl.Graphics.TGraphic.GetHeight.
Get vertical size of graphic in pixels.
GetHeight gets the vertical size of the TGraphic object in pixels.
Each descendant of TGraphic defines its own GetHeight and SetHeight methods to access the Height property.</docstr>
      </function>
      <function name="GetWidth">
        <docstr>Get horizontal size of graphic in pixels.
Vcl.Graphics.TIcon.GetWidth inherits from Vcl.Graphics.TGraphic.GetWidth. All content below this line refers to Vcl.Graphics.TGraphic.GetWidth.
Get horizontal size of graphic in pixels.
GetWidth gets the horizontal size of the graphic in pixels.
Each descendant of the TGraphic class defines its own GetWidth and SetWidth methods to access the Width property.</docstr>
      </function>
      <procedure name="SetHeight">
        <docstr>Set vertical size of graphic in pixels.
Vcl.Graphics.TIcon.SetHeight inherits from Vcl.Graphics.TGraphic.SetHeight. All content below this line refers to Vcl.Graphics.TGraphic.SetHeight.
Set vertical size of graphic in pixels.
SetHeight sets the vertical size of the graphic in pixels.
Each descendant of the TGraphic class defines its own GetHeight and SetHeight methods to access the Height property.</docstr>
      </procedure>
      <procedure name="SetTransparent">
        <docstr>Specify if graphic should be drawn transparently.
Vcl.Graphics.TIcon.SetTransparent inherits from Vcl.Graphics.TGraphic.SetTransparent. All content below this line refers to Vcl.Graphics.TGraphic.SetTransparent.
Specify if graphic should be drawn transparently.
SetTransparent specifies if a graphic should be drawn transparently.</docstr>
      </procedure>
      <procedure name="SetWidth">
        <docstr>Set horizontal size of graphic in pixels.
Vcl.Graphics.TIcon.SetWidth inherits from Vcl.Graphics.TGraphic.SetWidth. All content below this line refers to Vcl.Graphics.TGraphic.SetWidth.
Set horizontal size of graphic in pixels.
SetWidth sets the horizontal size of the graphic in pixels.
Each descendant of the TGraphic class defines its own GetWidth and SetWidth methods to access the Width property.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Creates an instance of TIcon.
Call Create to create an empty icon object. Once an image has been read into the icon from a file or stream, or by assigning another icon object, the icon can be drawn on a canvas or added to an image list. Do not create an icon object for setting the icon property of a form or picture. These objects create a TIcon object in their own constructors. Instead, use the LoadFromFile, LoadFromStream, or LoadFromClipboardFormat method on the TIcon object that you can obtain by reading the Icon property.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys an instance of TIcon.
Do not call Destroy directly in an application. Instead, call Free. Free verifies that the TIcon reference is not nil, and only then calls Destroy.</docstr>
      </destructor>
      <procedure name="Assign">
        <docstr>Copies an icon image from another TIcon object.
Call Assign to copy another icon object. Assign copies the icon image from the Source parameter if it is another TIcon object. Otherwise, Assign calls the inherited method, which copies the icon image from any source object that specifies how to copy to a TIcon in its AssignTo method.</docstr>
      </procedure>
      <procedure name="AssignTo">
        <docstr>Copies an icon image to a TBitmap graphical object.
Call AssignTo to copy an icon to a TBitmap object. AssignTo copies the icon image to the Dest parameter if it is a TBitmap object. Otherwise, AssignTo fails. 
The preferred way to copy an icon image to a bitmap is to use the Assign method of the TBitmap class, passing the icon object as the Source parameter.

Note:  The bitmap resulted after a call to AssignTo always has alpha channel (transparency) information and a 32-bit color depth.</docstr>
      </procedure>
      <function name="HandleAllocated">
        <docstr>Indicates whether the TIcon object has acquired a handle to the underlying GDI object.
Use HandleAllocated to determine whether the Handle property is set to an HICON value. HandleAllocated indicates whether the underlying GDI object has already been created. Use HandleAllocated rather than reading the Handle property. When an application reads the Handle property, it automatically creates an icon and returns its handle if the underlying GDI object does not already exist.</docstr>
      </function>
      <procedure name="LoadFromClipboardFormat">
        <docstr>Prevents applications from loading icons from the clipboard.
LoadFromClipboardFormat is overridden in TIcon because the clipboard format is not supported.</docstr>
      </procedure>
      <function name="CanLoadFromStream">
        <docstr>Vcl.Graphics.TIcon.CanLoadFromStream inherits from Vcl.Graphics.TGraphic.CanLoadFromStream. All content below this line refers to Vcl.Graphics.TGraphic.CanLoadFromStream.
CanLoadFromStream returns True when a specified stream contains a streamed image of a specific TGraphic subclass. 
The method uses current stream position, it does not change current stream position.</docstr>
      </function>
      <procedure name="LoadFromStream">
        <docstr>Loads the icon from a stream.
Use LoadFromStream to read the icon image from a stream. Set the Stream parameter to a stream object that provides access to the memory image of the icon. To load the icon from a .ico file, use the LoadFromFile method. To load the icon from the Clipboard, use the LoadFromClipboardFormat method.</docstr>
      </procedure>
      <function name="ReleaseHandle">
        <docstr>Releases the Windows GDI object represented by the icon.
Call ReleaseHandle to release the resources used to represent the icon. ReleaseHandle sets the Handle property to nil (Delphi) or NULL (C++).
ReleaseHandle informs the TIcon instance that it is no longer responsible for destroying the icon handle.</docstr>
      </function>
      <procedure name="SaveToClipboardFormat">
        <docstr>Prevents applications from saving icons to the clipboard.
SaveToClipboardFormat is overridden in TIcon because the format is not supported for the Clipboard.</docstr>
      </procedure>
      <procedure name="SaveToStream">
        <docstr>Saves the icon to a stream.
Use SaveToStream to write the icon image to a stream. Specify the Stream parameter as the stream object that receives the memory image of the icon. To write the icon to a .ico file, use the SaveToFile method. To write the icon to the Clipboard, use the SaveToClipboardFormat method.</docstr>
      </procedure>
      <procedure name="SetSize">
        <docstr>Specifies the size of the icon.
Use the SetSize method to set both the height and width of the icon. This results in better performance than setting the height and width separately.</docstr>
      </procedure>
      <procedure name="LoadFromResourceName">
        <docstr>Loads an icon resource into the icon object.
LoadFromResourceName loads the specified icon resource from a module&apos;s executable file.
Instance is the handle of the module that contains the resource.
ResName is the name of the resource to load.</docstr>
      </procedure>
      <procedure name="LoadFromResourceID">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <property name="Handle">
        <docstr>Provides access to the Windows GDI icon handle.
Use Handle to specify the icon when using a Windows API function that requires the handle of an icon object. The Handle property is nil (Delphi) or NULL (C++) if the icon has not been loaded.
Call the ReleaseHandle method before changing the icon image by setting the Handle property. The icon image can also be loaded by assigning another icon object or using the LoadFromClipboardFormat, LoadFromFile, or LoadFromStream method.</docstr>
      </property>
    </members>
  </class>
  <class unit="System" name="TObject">
    <docstr>TObject is the ultimate ancestor of all objects and components.
TObject encapsulates fundamental behavior common to objects by introducing methods that:

Create, maintain, and destroy instances of the object by allocating, initializing, and freeing required memory.
Respond when object instances are created or destroyed.
Return class-type and instance information on an object and runtime type information (RTTI) about its published properties.
Support message handling.
Support interfaces implemented by the object.
Use TObject as an immediate base class when declaring simple objects that do not need to persist (are not saved and reloaded) and that do not need to be assigned to other objects. 
Much of the capability of objects is established by methods that TObject introduces. Many of these methods are used internally by IDEs and are not intended for users to call directly. Others are overridden in descendant objects that have more complex behavior. 
Although TObject is the based object of a component framework, not all objects are components. All component classes descend from TComponent. 

Note: TObject is never directly instantiated. Although it does not use programming language features that prevent instantiation, TObject is an abstract class.</docstr>
    <members>
      <constructor name="Create">
        <docstr>Constructs an object and initializes its data before the object is first used.
Create constructs an object. The purpose, size, and behavior of objects differ greatly. The Create constructor defined by TObject allocates memory but does not initialize data. 
Descendant objects usually define a constructor that creates the particular kind of object and initializes its data.

Note: If an exception escapes from a constructor, the object&apos;s destructor is called to clean up the failed instance.</docstr>
      </constructor>
      <procedure name="Free">
        <docstr>Destroys an object and frees its associated memory, if necessary.
Use Free to destroy an object. Free automatically calls the destructor if the object reference is not nil. Any object instantiated at run time that does not have an owner should be destroyed by a call to Free, so that it can be properly disposed of and its memory released. Unlike Destroy, Free is successful even if the object is nil; if the object was never initialized, Free would not result in an error. 
When you call Free for a component, it calls Free for all components that it owns�that is, all components in its component list. Since a form owns all the controls and other components that are created on it in design mode, those components are automatically freed when the form is freed. By default, all forms are owned by the Application object; when the application terminates, it frees the Application object, which frees all forms. For objects that are not components, or for components created with a nil owner, be sure to call Free after you are finished with them; otherwise the allocated memory will not be usable until after the application terminates. 

Warning:  Never explicitly free a component within one of its own event handlers or the event handler of a component it owns or contains. For example, do not free a button or the form that owns the button in its OnClick event handler. 
To free a form, call its Release method, which destroys the form and releases the memory allocated for it after all its event handlers and those of the components it contains are through executing. 

Note:  In C++ code, do not use Free to destroy an object. Use the delete keyword.</docstr>
      </procedure>
      <procedure name="DisposeOf">
        <docstr>DisposeOf forces the execution of the destructor code in an object. 
It was an artifact from previous versions when the Delphi Mobile compilers supported Automatic Reference Counting. In current versions of Delphi, DisposeOf is used as a wrapper that invokes TObject.Free. 

type
  TMySimpleClass = class
  private
    stringMember: String;
    constructor Create(const Text: String);
    destructor Destroy;
  end;

constructor TMySimpleClass.Create(const Text: String);
begin
  stringMember := Text;
end;

destructor TMySimpleClass.Destroy;
begin
  // this will be executed on calling the DisposeOf method.
end;

var
  myObject: TMySimpleClass;
begin
  myObject := TMySimpleClass.Create(&apos;This is a code snippet indicating the usage of the DisposeOf method&apos;);
  try
    // Use &apos;myObject&apos; here
  finally
    myObject.DisposeOf;
  end;
end.</docstr>
      </procedure>
      <function name="InitInstance">
        <docstr>Initializes a newly allocated object instance to all zeros and initializes the instance&apos;s virtual method table pointer.
You should not call InitInstance directly. InitInstance is called by NewInstance when an object is created. When overriding NewInstance, be sure to call InitInstance as the last statement. 
InitInstance is not virtual, so you cannot override it. Instead, initialize any data for an object in the constructor.</docstr>
      </function>
      <procedure name="CleanupInstance">
        <docstr>Performs finalization on long strings, variants, and interface variables within a class.
Do not call CleanupInstance directly. CleanupInstance is called automatically when the object instance is destroyed. 
CleanupInstance releases all long strings and variants. It sets long strings to empty and variants to Unassigned.</docstr>
      </procedure>
      <function name="ClassType">
        <docstr>Returns the class reference for the object&apos;s class.

Note: ClassType dynamically determines the type of an object and returns its class reference, or metaclass.
Avoid using ClassType in application code. 

Note: In Delphi code, use the is or as operators instead of ClassType.
Note: In C++ code, use a dynamic cast or the InheritsFrom method instead of ClassType.</docstr>
      </function>
      <function name="ClassName">
        <docstr>Returns a string indicating the type of the object instance (as opposed to the type of the variable passed as an argument).
Use ClassName to obtain the class name from an object instance or class reference. This is useful for differentiating object instances that are assigned to a variable that has the type of an ancestor class. 

Note: In C++ code, call ClassName as a method to obtain an object&apos;s class name. Use the global static function to obtain the class name from a metaclass object.</docstr>
      </function>
      <function name="ClassNameIs">
        <docstr>Determines whether an object is of a specific type.
ClassNameIs determines whether an object instance or class reference has a class name that matches a specified string. This is useful to query objects across modules or shared libraries. 

Note: In C++ code, call ClassNameIs as a method to compare an object&apos;s class name. Use the global static function to compare the class name from a metaclass object.</docstr>
      </function>
      <function name="ClassParent">
        <docstr>Returns the type of the immediate ancestor of a class.
ClassParent returns the name of the parent class for an object instance or class reference. For TObject, ClassParent returns nil (Delphi) or NULL (C++). 
Avoid using ClassParent in application code. 

Note: In Delphi code, use the is or as operators instead of ClassParent.
Note: In C++ code, use a dynamic cast or the InheritsFrom method instead of ClassParent.</docstr>
      </function>
      <function name="ClassInfo">
        <docstr>Returns a pointer to the run-time type information (RTTI) table for the object type.
ClassInfo provides access to the RTTI table for a given object type.
Some classes do not provide run-time type information. For these classes, ClassInfo returns nil (Delphi) or NULL (C++). All classes descended from TPersistent do provide run-time type information.</docstr>
      </function>
      <function name="InstanceSize">
        <docstr>Returns the size in bytes of each instance of the object type.
InstanceSize indicates how many bytes of memory are required for a class&apos;s instance data. InstanceSize is called from methods that allocate and deallocate memory. InstanceSize is not a virtual method, so it cannot be overridden. InstanceSize should be called only when implementing a custom version of NewInstance.</docstr>
      </function>
      <function name="InheritsFrom">
        <docstr>Determines the relationship of two object types.
Use InheritsFrom to determine whether a particular class type or object is an instance of a class or one of its descendants. InheritsFrom returns True if the object type specified in the aClass parameter is an ancestor of the object type or the type of the object itself. Otherwise, it returns False. 

Note: InheritsFrom is similar to the Delphi is operator, but applies to class references.
Note: In C++ code, a nonstatic version of InheritsFrom is provided. This call is useful in determining whether a descendant class method or property can be used, given a variable of a base class. For example, use InheritsFrom to determine whether the Sender parameter in an event handler is of a particular class type or one of its descendants.</docstr>
      </function>
      <function name="MethodAddress">
        <docstr>Returns the address of a class method by name.

Note: You can use MethodAddress for published methods only.
There are situations when it is useful to invoke an object method without hard coding the method name in advance. Call MethodAddress to dynamically retrieve the address of such a method by specifying the method Name as a string.
An easy way to invoke the method is to define a procedure or function data type, such as:

type TProc = procedure of object;

Assign the object name and the MethodAddress method to a TMethod variable, such as: 

MethodVar.Data�:= Pointer(ObjectInstanceName);
MethodVar.Code�:= ObjectInstanceName.MethodAddress(&apos;MethodNameString&apos;);

Pass this in a call to a variable of the procedure or function type:

Proc�:= TProc(MethodVar);
Proc;</docstr>
      </function>
      <function name="MethodAddress">
        <docstr>Returns the address of a class method by name.

Note: You can use MethodAddress for published methods only.
There are situations when it is useful to invoke an object method without hard coding the method name in advance. Call MethodAddress to dynamically retrieve the address of such a method by specifying the method Name as a string.
An easy way to invoke the method is to define a procedure or function data type, such as:

type TProc = procedure of object;

Assign the object name and the MethodAddress method to a TMethod variable, such as: 

MethodVar.Data�:= Pointer(ObjectInstanceName);
MethodVar.Code�:= ObjectInstanceName.MethodAddress(&apos;MethodNameString&apos;);

Pass this in a call to a variable of the procedure or function type:

Proc�:= TProc(MethodVar);
Proc;</docstr>
      </function>
      <function name="MethodName">
        <docstr>Returns the name of a class method by address.
There are situations when it is useful to invoke an object method without hard coding the method name in advance. Call MethodAddress to dynamically retrieve the address of such a method by specifying the method name as a string. 
MethodName is the opposite of this process--by supplying an Address method, the name of the method is returned as a string.</docstr>
      </function>
      <function name="QualifiedClassName">
        <docstr>Returns the qualified name of the class.
QualifiedClassName returns the class&apos;s unit scope concatenated with the class name. Example:

uses
  SysUtils, SyncObjs;

begin
  Writeln(TEvent.QualifiedClassName); // displays System.SyncObjs.TEvent</docstr>
      </function>
      <function name="FieldAddress">
        <docstr>Returns the address of a published object field.
FieldAddress is used internally by the component streaming system to access a specified published field of an object. FieldAddress returns a pointer to the field, if it exists. If the object has no published field by that name, FieldAddress returns nil (Delphi) or NULL (C++). 
Programs should access and manipulate fields by using properties instead of FieldAddress.</docstr>
      </function>
      <function name="FieldAddress">
        <docstr>Returns the address of a published object field.
FieldAddress is used internally by the component streaming system to access a specified published field of an object. FieldAddress returns a pointer to the field, if it exists. If the object has no published field by that name, FieldAddress returns nil (Delphi) or NULL (C++). 
Programs should access and manipulate fields by using properties instead of FieldAddress.</docstr>
      </function>
      <function name="GetInterface">
        <docstr>Retrieves a specified interface.
GetInterface retrieves the interface designated by a GUID or type name. The basic implementation of GetInterface uses the GUID specified in the IID parameter. If the specified interface is supported by the class, it is returned in the Obj parameter, and GetInterface has a return value of True. Otherwise, Obj contains nil (Delphi) or NULL (C++), and GetInterface returns False. 

Note:  In Delphi code, IID can be an interface name. The compiler automatically translates this name into the corresponding GUID. 
Note:  In C++ code, use the templated version of GetInterface to obtain an interface from a DelphiInterface object. 
GetInterface is equivalent to the as operator (Delphi) and dynamic casts (C++), except that GetInterface does not raise an exception if the interface is not supported.</docstr>
      </function>
      <function name="GetInterfaceEntry">
        <docstr>Returns the entry for a specific interface implemented in a class.
GetInterfaceEntry returns the class entry for the interface specified by the IID parameter. 

Note:  In Delphi Code, IID can be an interface name. The compiler replaces this name with the actual GUID. 
Note:  COM objects can use GetInterfaceEntry to automate dispatch calls to a dual-IDispatch interface.</docstr>
      </function>
      <function name="GetInterfaceTable">
        <docstr>Returns a pointer to a structure containing all of the interfaces implemented by a given class.
GetInterfaceTable returns the interface entries for the class. This list contains only interfaces implemented by this class, not its ancestors. To find the ancestor list, iteratively call ClassParent and then call GetInterfaceTable on the value it returns. To find the entry for a specific interface, use the GetInterfaceEntry method instead.</docstr>
      </function>
      <function name="UnitName">
        <docstr>Returns the name of the unit where the class is defined.
UnitName can be used to obtain the unit where a specific class is defined. For example, calling UnitName on TButton returns the Vcl.StdCtrls string.</docstr>
      </function>
      <function name="UnitScope">
        <docstr>Returns the class&apos;s unit scope.
The class&apos;s unit scope is currently equivalent with the class&apos;s unit name.

uses
  SysUtils, SyncObjs;

begin
  Writeln(TEvent.UnitScope); // displays System.SyncObjs
  // ...</docstr>
      </function>
      <function name="Equals">
        <docstr>Checks whether the current instance and the Obj parameter are equal.
The function has one Obj parameter of the TObject type.
By default, the Equals method shows whether the addresses corresponding to the current object and the Obj object are identical. The method returns a boolean value that represents the equality between the two addresses. 


Note: Equals is supposed to be overridden in user-derived classes, to provide consumer objects with an equality determining function. 
For example, in the FMX.Types.TBounds class, Equals also returns True if the Rect properties of the current object and of the Obj object are equal. In the FMX.StdActns.TBaseValueRange class, Equals also returns True if all the properties of the current object and of the Obj object are equal.</docstr>
      </function>
      <function name="GetHashCode">
        <docstr>Returns an integer containing the hash code.
By default, calling GetHashCode on an object returns an integer representing the virtual address at which the object is stored. 

Notes:
GetHashCode is supposed to be overridden in user-derived classes, to provide consumer objects with an integer hash code representation.
The sign of the hash code depends on the address of the particular object instance. Negative hash code can appear for object instances that reside at higher memory locations.</docstr>
      </function>
      <function name="ToString">
        <docstr>Returns a string containing the class name.
By default, the ToString returns a string containing the class name of the instance that is being called. 
For example, calling ToString on a TButton instance returns a string containing &quot;TButton&quot;. 

Note: ToString is intended to be overridden in user-derived classes, to provide consumer objects with a string representation.</docstr>
      </function>
      <function name="SafeCallException">
        <docstr>Handles exceptions in methods declared using the safecall calling convention.
SafeCallException handles exceptions in methods that use the safecall calling convention. Some classes that implement interfaces override this method to handle possible errors. 
As implemented in TObject, SafeCallException simply returns E_UNEXPECTED. This is the appropriate response for classes that do no support interfaces.</docstr>
      </function>
      <procedure name="AfterConstruction">
        <docstr>Responds after the last constructor has executed.
AfterConstruction is called automatically after the object&apos;s last constructor has executed. Do not call it explicitly in your applications. 
The AfterConstruction method implemented in TObject does nothing. Override this method when creating a class that performs an action after the object is created. For example, TCustomForm overrides AfterConstruction to generate an OnCreate event.</docstr>
      </procedure>
      <procedure name="BeforeDestruction">
        <docstr>Responds before the first destructor executes.
BeforeDestruction is called automatically before the object&apos;s first destructor executes. Do not call it explicitly in your applications. 
The BeforeDestruction method implemented in TObject does nothing. Override this method when creating a class that performs an action before the object is destroyed. For example, TCustomForm overrides BeforeDestruction to generate an OnDestroy event. 

Note: BeforeDestruction is not called when the object is destroyed before it is fully constructed. That is, if the object&apos;s constructor raises an exception, the destructor is called to dispose of the object, but BeforeDestruction is not called.</docstr>
      </procedure>
      <procedure name="Dispatch">
        <docstr>Calls message-handling methods for the object, based on the contents of the Message parameter.
Call Dispatch to automatically pass messages to the appropriate message handler. 
Dispatch determines whether a message is in the list of message handlers declared for the object. If the object does not handle the message, Dispatch then examines the message-handler list of the ancestor class, and continues checking ancestors until it either finds a specific handler or runs out of ancestors, in which case it calls DefaultHandler. 
The only assumption Dispatch makes about the data in Message is that the first two bytes contain a message ID�that is, an integer that determines which message handler Dispatch calls. Although any kind of data can be passed to Dispatch, most TObject descendants expect a message record such as TMessage or a specific data structure type.</docstr>
      </procedure>
      <procedure name="DefaultHandler">
        <docstr>Provides the interface for a method that processes message records.
DefaultHandler is called by Dispatch when it cannot find a method for a particular message. DefaultHandler provides message handling for all messages for which an object does not have specific handlers. Descendant classes that process messages override DefaultHandler according to the types of messages they handle. 

Note:  In a Delphi message-handling method, calling inherited results in a call to the ancestor&apos;s DefaultHandler method only if that ancestor does not specify a message method for the particular message being handled. Otherwise, calling inherited results in a call to the specific handler for that type of message.</docstr>
      </procedure>
      <function name="NewInstance">
        <docstr>Allocates memory for an instance of an object type and returns a pointer to that new instance.
All constructors call NewInstance automatically. NewInstance calls InstanceSize to determine how much memory containing a particular instance to allocate from the heap. Do not call NewInstance directly. 
Override NewInstance only for special memory allocation requirements. For example, when allocating a large number of identical objects that all need to be in memory at the same time, you can allocate a single block of memory for the entire group, then override NewInstance to use part of that larger block for each instance. 
If you override NewInstance to allocate memory, you may need to override FreeInstance to deallocate the memory. 

Note:  By default, NewInstance calls InitInstance.</docstr>
      </function>
      <procedure name="FreeInstance">
        <docstr>Deallocates memory allocated by a previous call to the NewInstance method.
All destructors call FreeInstance automatically to deallocate memory that was allocated by overriding NewInstance. 
Do not call FreeInstance directly. FreeInstance should be overridden if NewInstance was overridden to change the way the object&apos;s instance data was allocated. 
Like NewInstance, FreeInstance uses the value returned from InstanceSize to deallocate the object&apos;s memory.</docstr>
      </procedure>
      <destructor name="Destroy">
        <docstr>Disposes of an object instance.
Do not call Destroy directly. Call Free instead. Free verifies that the object reference is not nil before calling Destroy. 
The Destroy method defined by TObject deallocates memory. Descendent objects usually define a destructor that is customized for that particular kind of object. 
When declaring a Destroy method in a descendant, always add the override directive to the declaration and call the inherited Destroy as the last statement in the overriding method. Because Destroy is a virtual method, overriding it ensures that the proper inherited behavior occurs. 

Note:  If an exception escapes from the constructor, the destructor is called to destroy the partially constructed object instance that failed to initialize completely. Therefore, destructors should check that allocated resources such as handles were actually allocated before trying to release them, since their value might be zero. 
Destroy should be implemented so that it calls Free on all subobjects created within the object&apos;s constructor (that is, allocated by the constructor). Unlike Destroy, Free provides a safeguard when destroying objects that are nil.</docstr>
      </destructor>
      <function name="GetDisposed">
        <docstr>Getter for the Disposed property.</docstr>
      </function>
      <procedure name="CheckDisposed">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <property name="Disposed">
        <docstr>Disposed is a read-only property that shows the current state of this object.
The Disposed property returns True if the object has been disposed using the DisposeOf method. Otherwise, it returns False. 

type
  TMySimpleClass = class
  private
    //
    stringMember: String;
    constructor Create(Text: String);
    destructor Destroy;
  end;

constructor TMySimpleClass.Create(Text: String);
begin
  stringMember := Text;
end;

destructor TMySimpleClass.Destroy;
begin
  // this will be executed on calling the DisposeOf method.
end;

var
  myObject: TMySimpleClass;
begin
  myObject := TMySimpleClass.Create
    (&apos;This is a code snippet illustrating the functionality for the DisposeOf method and Disposed property&apos;);
  if not myObject.Disposed then
    myObject.DisposeOf;
  //Starting here, the object has entered the Disposed state.
end.

Note: The System.TObject.DisposeOf method is supported by the Delphi mobile compilers. The Disposed state only takes effect under compilers that use Automatic Reference Counting, such as DCCIOSARM.EXE, DCCIOSARM64.EXE, and DCCIOS32.EXE.</docstr>
      </property>
    </members>
  </class>
  <class unit="System" name="HFAAttribute">
    <docstr>For internal use only.</docstr>
    <members>
      <field name="FElementType">
        <docstr>Internal use only</docstr>
      </field>
      <field name="FElementCount">
        <docstr>Internal use only</docstr>
      </field>
      <property name="ElementType">
        <docstr>TypeInfo of element type</docstr>
      </property>
      <property name="ElementCount">
        <docstr>Number of element type</docstr>
      </property>
    </members>
  </class>
  <class unit="System" name="AlignAttribute">
    <docstr>Internal use only.</docstr>
    <members>
      <field name="FAlign">
        <docstr>Internal use only</docstr>
      </field>
      <property name="Align">
        <docstr>Alignment in bytes</docstr>
      </property>
    </members>
  </class>
  <class unit="Vcl.MPlayer" name="TMediaPlayer">
    <docstr>TMediaPlayer controls devices that provide a Media Control Interface (MCI) driver.
The TMediaPlayer component includes a set of buttons (Play, Stop, Eject, and so on) that control a multimedia device such as a CD-ROM drive, MIDI sequencer, or VCR. A multimedia device may be hardware or software.
The media player component contains of multiple buttons. These buttons can be clicked with the mouse, but are not separate objects or button components.





Button

Value

Action



Play



btPlay



Plays the media player




Pause



btPause



Pauses playing or recording. If already paused when clicked, resumes playing or recording.




Stop



btStop



Stops playing or recording




Next



btNext



Skips to the next track, or to the end if the medium doesn&apos;t use tracks




Prev



btPrev



Skips to the previous track, or to the beginning if the medium doesn&apos;t use tracks




Step



btStep



Moves forward a number of frames




Back



btBack



Moves backward a number of frames




Record



btRecord



Starts recording




Eject



btEject



Ejects the medium




The multimedia device is played, paused, stopped, and so on when the user clicks the corresponding button on the TMediaPlayer component. The device can also be controlled by the control methods that correspond to the buttons (Play, Pause, Stop, Next, Previous, Step, Back, StartRecording, and Eject).
The type of multimedia device (such as dtWaveAudio or dtVideodisc) is specified by the DeviceType property. If the device stores its media in a file, the name of the media file is specified by the FileName property. If DeviceType is dtAutoSelect, the media player attempts to determine the type of device from the extension of the file specified by FileName.
To have the media player attempt to open the device specified by DeviceType automatically when the media player component is created at runtime, set the AutoOpen property to true.</docstr>
    <members>
      <procedure name="KeyDown">
        <docstr>Provides responses when the user types arrow keys or the space bar.
KeyDown overrides the inherited method to implement the media player&apos;s response to certain keystrokes. It changes the current button when the user types the left or right arrow keys. When the user presses the space bar, KeyDown simulates a click on the current button.</docstr>
      </procedure>
      <procedure name="Loaded">
        <docstr>Initializes the media player after it is loaded from a stream.
Loaded provides an opportunity for a component to initialize itself after all its parts have loaded from a stream. TMediaPlayer overrides the inherited method to implement the AutoOpen property.</docstr>
      </procedure>
      <procedure name="AutoButtonSet">
        <docstr>Enables or Disables the media player&apos;s buttons.
AutoButtonSet implements the automatic enabling and disabling of the media player&apos;s buttons when the AutoEnable property is true. The Btn parameter indicates which of the media player&apos;s buttons the user pressed.</docstr>
      </procedure>
      <procedure name="Notification">
        <docstr>Responds when components are about to be inserted or removed.
By default, components pass along the notification to their owned components, if any. Notification calls the inherited Notification and then, if the Display window is deleted at runtime, it sets the video display back to original window.</docstr>
      </procedure>
      <procedure name="Paint">
        <docstr>Renders the image of the media player.
When the media player component receives a WM_PAINT message, like other custom controls, it responds by initializing the control&apos;s canvas and calling Paint. Paint draws the frame and all visible buttons.
When creating a descendant media player class, Paint can be overridden to draw the image of the corresponding media player object.</docstr>
      </procedure>
      <procedure name="MMNotify">
        <docstr>Responds to a notification that the MCI device has completed an operation.
MMNotify responds to a notification message from Windows that a multimedia command completed by updating button states if the AutoEnable property is true, setting internal flags to reflect the outcome of the command, then calling the DoNotify method to trigger the OnNotify event and any other special responses.</docstr>
      </procedure>
      <procedure name="Click">
        <docstr>Generates an OnClick event.
Click for media-player components is the implementation method for the OnClick event. By default, Click does nothing other than call any event handler attached to the media player&apos;s OnClick event. Click can be overridden in descendant classes to customize responses to clicks.</docstr>
      </procedure>
      <procedure name="PostClick">
        <docstr>Determines the action that takes place when an OnPostClick event occurs.
PostClick is the implementation method for the OnPostClick event. By default, PostClick does nothing other than call any event handler attached to the media player&apos;s OnPostClick event. PostClick can be overridden in descendant types to customize responses to clicks.</docstr>
      </procedure>
      <procedure name="DoNotify">
        <docstr>Generates an OnNotify event.
DoNotify is the implementation method for a media-player component&apos;s OnNotify event. The media player&apos;s MMNotify method calls DoNotify after correcting the enabling and disabling of buttons and setting internal flags from the values passed in the notification message parameters.
By default, DoNotify does nothing except call any event handler attached to the media player&apos;s OnNotify event. DoNotify can be overridden to provide other responses in addition to the inherited event-handler call.</docstr>
      </procedure>
      <procedure name="Updated">
        <docstr>Signals that the media player has finished updating.
Updated calls the inherited Updated before it modifies the layout of the media player buttons and forces a repaint.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Creates a media player object.
Call Create to instantiate a media player at runtime. For media players created at design time, Create is called automatically.
Create allocates memory for a media player and calls the inherited Create. Then it loads the bitmaps for the media player&apos;s buttons and initializes its properties, setting AutoEnable, AutoRewind, Colored, Enabled, and Visible to true, AutoOpen to false, and DeviceType to dtAutoSelect.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys an instance of the media player.
Do not call Destroy directly in an application. Call Free instead. Free checks that the TMediaPlayer reference is not nil before it calls Destroy.
Destroy first verifies that no device is open, then destroys the bitmaps used for the media player&apos;s buttons and calls the inherited Destroy.</docstr>
      </destructor>
      <procedure name="Open">
        <docstr>Opens a multimedia device.
Use Open to open a multimedia device. The multimedia device type must be specified in the DeviceType property before a device can be opened.
Upon completion, Open stores a numerical error code in the Error property, and the corresponding error message in the ErrorMessage property.
The Wait property determines whether control is returned to the application before the Open method is completed. The Notify property determines whether Open generates an OnNotify event.</docstr>
      </procedure>
      <procedure name="Close">
        <docstr>Closes the open multimedia device.
Upon completion, Close stores a numerical error code in the Error property, and the corresponding error message in the ErrorMessage property.
The Wait property determines whether control is returned to the application before the Close method is completed. The Notify property determines whether Close generates an OnNotify event.
Close is called automatically when the application is terminated.</docstr>
      </procedure>
      <procedure name="Play">
        <docstr>Plays the media loaded in the open multimedia device.
Play is called when the Play button on the media player control is clicked at runtime.
Upon completion, Play stores a numerical error code in the Error property and the corresponding error message in the ErrorMessage property.
The Wait property determines whether control is returned to the application before the Play method has completed. The Notify property determines whether Play generates an OnNotify event.
If the StartPos property is set, playing starts at the position specified in StartPos. Otherwise, playing starts at the current position, specified in the Position property. Similarly, if the EndPos property is set, playing stops at the position specified in EndPos. Otherwise, playing stops at the end of the medium.
Whether the medium (specified in the Position property) is rewound before playing starts depends on the AutoRewind property.</docstr>
      </procedure>
      <procedure name="Stop">
        <docstr>Halts playing or recording.
Stop is called when the Stop button on the media player control is clicked at runtime.
Upon completion, Stop stores a numerical error code in the Error property, and the corresponding error message in the ErrorMessage property.
The Wait property determines whether control is returned to the application before the Stop method has completed. The Notify property determines whether Stop generates an OnNotify event.</docstr>
      </procedure>
      <procedure name="Pause">
        <docstr>Toggles the open multimedia device on or off.
If the device is already paused when Pause is called, the device resumes playing or recording by calling the Resume method. Pause is called when the Pause button on the media player control is clicked at runtime.
Upon completion, Pause stores a numerical error code in the Error property and the corresponding error message in the ErrorMessage property.
The Wait property determines whether control is returned to the application before the Pause method has completed. The Notify property determines whether Pause generates an OnNotify event.</docstr>
      </procedure>
      <procedure name="Step">
        <docstr>Moves forward a number of frames (determined by the Frames property) in the currently loaded medium.
Step is called when the Step button on the media player control is clicked at runtime.
Upon completion, Step stores a numerical error code in the Error property and the corresponding error message in the ErrorMessage property.
The Wait property determines whether control is returned to the application before the Step method has completed. The Notify property determines whether Step generates an OnNotify event.</docstr>
      </procedure>
      <procedure name="Back">
        <docstr>Steps backward a number of frames (determined by the value of the Frames property) in the currently loaded medium.
Back is called when the Back button on the media player control is clicked at runtime.
Upon completion, Back stores a numerical error code in the Error property and the corresponding error message in the ErrorMessage property.
The Wait property determines whether control is returned to the application before the Back method has been completed. The Notify property determines whether Back generates an OnNotify event.</docstr>
      </procedure>
      <procedure name="Previous">
        <docstr>Sets the current position to the beginning of the previous track if the position was at the beginning of a track when Previous was called.
If the position is at the first track or somewhere other than the beginning of a track when Previous was called, Previous sets the current position to the beginning of the current track. If the device doesn&apos;t use tracks, Previous sets the current position to the beginning of the medium, which is specified in the Start property. Previous is called when the Previous button on the media player control is clicked at runtime.
Upon completion, Previous stores a numerical error code in the Error property and the corresponding error message in the ErrorMessage property.
The Wait property determines whether control is returned to the application before the Previous method has completed. The Notify property determines whether Previous generates an OnNotify event.</docstr>
      </procedure>
      <procedure name="Next">
        <docstr>Moves to the beginning of the next track of the currently loaded medium.
If the current position is at the last track when Next is called, Next makes the current position the beginning of the last track. If the multimedia device doesn&apos;t use tracks, Next goes to the end of the medium. Next is called when the Next button on the media player control is clicked at runtime.
Upon completion, Next stores a numerical error code in the Error property, and the corresponding error message in the ErrorMessage property.
The Wait property determines whether control is returned to the application before the Next method has completed. The Notify property determines whether Next generates an OnNotify event.</docstr>
      </procedure>
      <procedure name="StartRecording">
        <docstr>Begins recording from the current Position or from the position specified in StartPos.
StartRecording is called when the Record button on the media player control is clicked at runtime.
Upon completion, StartRecording stores a numerical error code in the Error property and the corresponding error message in the ErrorMessage property.
The Wait property determines whether control is returned to the application before the StartRecording method has completed. The Notify property determines whether StartRecording generates an OnNotify event.
By default, the Notify property becomes true, and the Wait property becomes false upon completion of the StartRecording method. However, if these properties have been set to specific values prior to calling StartRecording, they remain unchanged.</docstr>
      </procedure>
      <procedure name="Eject">
        <docstr>Releases the loaded medium from the open multimedia device.
Eject is called when the Eject button on the media player control is clicked at runtime. It ejects the loaded medium from the open multimedia device.
Upon completion, Eject stores a numerical error code in the Error property, and the corresponding error message in the ErrorMessage property.
The Wait property determines whether control is returned to the application before the Eject method has been completed. The Notify property determines whether Eject generates an OnNotify event.</docstr>
      </procedure>
      <procedure name="Save">
        <docstr>Saves the currently loaded medium to the file specified in the FileName property.
Save is ignored for devices that don&apos;t use media stored in files (videodiscs, for example).
Upon completion, Save stores a numerical error code in the Error property, and the corresponding error message in the ErrorMessage property.
The Wait property determines whether control is returned to the application before the Save method has completed. The Notify property determines whether Save generates an OnNotify event.</docstr>
      </procedure>
      <procedure name="PauseOnly">
        <docstr>Pauses the open multimedia device.
If the device is already paused when PauseOnly is called, the device will remain paused.
Upon completion, PauseOnly stores a numerical error code in the Error property and the corresponding error message in the ErrorMessage property.
The Wait property determines whether control is returned to the application before the PauseOnly method has completed. The Notify property determines whether PauseOnly generates an OnNotify event.</docstr>
      </procedure>
      <procedure name="Resume">
        <docstr>Resumes playing or recording the currently paused multimedia device.
Resume is called when the Pause button on the media player control is clicked at runtime, when the device is paused.
Upon completion, Resume stores a numerical error code in the Error property, and the corresponding error message in the ErrorMessage property.
The Wait property determines whether control is returned to the application before the Resume method has completed. The Notify property determines whether Resume generates an OnNotify event.</docstr>
      </procedure>
      <procedure name="Rewind">
        <docstr>Sets the current position to the beginning of the the medium, which is stored in the Start property.
Upon completion, Rewind stores a numerical error code in the Error property, and the corresponding error message in the ErrorMessage property.
The Wait property determines whether control is returned to the application before the Rewind method has completed. The Notify property determines whether Rewind generates an OnNotify event.</docstr>
      </procedure>
      <property name="Capabilities">
        <docstr>Determines the capabilities of the open multimedia device.
The various capabilities specified in Capabilities are determined when the device is opened with the Open method.

Note:  Currently, there is no way to check whether a device can step forward or backward. Capabilities includes mpCanStep only if the device type (specified in the DeviceType property) is Animation, AVI Video, Digital Video, Overlay, or VCR.</docstr>
      </property>
      <property name="Error">
        <docstr>Specifies the MCI error code returned by the media control method.
Error specifies the MCI error code returned by the most recent media control method (Back, Close, Eject, Next, Open, Pause, PauseOnly, Play, Previous, StartRecording, Resume, Rewind, Step, or Stop). The ErrorMessage property describes the Error.
The error code returned by media control methods are the same error code returned by the mciSendCommand function. The message describing the error code is stored in the ErrorMessage property.
The value of Error is zero if the most recent media control method didn&apos;t cause an error. If a method results in an error, a value other than zero is stored in Error. If the error occurs during the opening of the device, an EMCIDeviceError exception occurs.</docstr>
      </property>
      <property name="ErrorMessage">
        <docstr>Describes the error code stored in the Error property.
ErrorMessage specifies the error message that describes the error code returned from the most recent media control method (Back, Close, Eject, Next, Open, Pause, PauseOnly, Play, Previous, StartRecording, Resume, Rewind, Step, or Stop). 
The error code described by the message is stored in the Error property.</docstr>
      </property>
      <property name="Start">
        <docstr>Specifies the starting position within the currently loaded medium.
Start is the beginning of the medium for devices that don&apos;t use tracks, or the beginning of the first track for devices that use tracks. Start is defined when a multimedia device is opened with the Open method. Start is specified according to the current time format, which is stored in the TimeFormat property. Start is read-only at runtime and is unavailable at design time.</docstr>
      </property>
      <property name="Length">
        <docstr>Specifies the length of the medium in the open multimedia device.
Length is specified using the current time format, which is specified by the TimeFormat property.</docstr>
      </property>
      <property name="Tracks">
        <docstr>Specifies the number of playable tracks on the open multimedia device.
Tracks indicates how many of playable tracks are available on the open multimedia device.
Tracks is undefined for devices that don&apos;t use tracks.</docstr>
      </property>
      <property name="Frames">
        <docstr>Specifies the number of frames moved forward or backward.
Frames specifies the number of frames the Step method steps forward or the Back method steps backward. Frames defaults to ten percent of the length of the currently loaded medium, which is specified by the Length property.
The definition of a frame varies by multimedia device. For display media, a frame is one still image.</docstr>
      </property>
      <property name="Mode">
        <docstr>Indicates the state of the currently open multimedia device.
Mode specifies the current state or mode of the currently open multimedia device.
The TMPModes type defines the modes for a multimedia device used with a TMediaPlayer.</docstr>
      </property>
      <property name="Position">
        <docstr>Specifies the current position within the currently loaded medium.
The value of Position is specified according to the current time format, which is specified in the TimeFormat property.
Position defaults to the beginning of the medium. If the medium supports multiple tracks, Position defaults to the beginning of the first track.</docstr>
      </property>
      <property name="Wait">
        <docstr>Determines whether a media control method returns control to the application only after it has been completed.
Wait determines whether a media control method (Back, Close, Eject, Next, Open, Pause, PauseOnly, Play, Previous, StartRecording, Resume, Rewind, Step, or Stop) returns control to the application only after it has been completed.
Wait is unavailable at design time.
If Wait is true, the media player component waits until the next media control method has completed before returning control to the application. If Wait is false, the application won&apos;t wait for the next media control method to finish before continuing.
Wait affects only the next media control method called after setting Wait. Wait must be reset to affect any subsequent call to a media control method.
By default, Play and StartRecording function as if Wait is false. Wait must be set to true before calling Play or StartRecording to prevent control from returning to the application before playing or recording has finished. By default, all other media control methods function as if Wait is true.

Note: Wait is usually set to false only if the next media control is expected to take a long time, so that the application can execute other code before the media control method has completed. If Wait is set to false, you should set Notify to true so the application is notified when the media control method completes.</docstr>
      </property>
      <property name="Notify">
        <docstr>Determines whether an OnNotify event is generated.
Notify determines whether the next call to a media control method (Back, Close, Eject, Next, Open, Pause, PauseOnly, Play, Previous, StartRecording, Resume, Rewind, Step, or Stop) generates an OnNotify event when the method has completed.
If Notify is true, the next media control method generates OnNotify event upon completion and stores the notification message in the NotifyValue property. If Notify is false, the method does not generate an OnNotify event and NotifyValue remains unchanged.
Notify affects only the next call to a media control method. After an OnNotify event, Notify must be reset to affect any subsequent media control methods.
By default, Play and StartRecording function as if Notify is true. Set Notify to false before calling Play or StartRecording to prevent an OnNotify event from being generated when playing or recording has finished. By default, all other media control methods function as if Notify is false.

Tip:  Set Notify to true if the next media control is expected to take a long time, so the application is notified when the media control method has completed. If Notify is set to true, it is recommended to set Wait to false so that control returns to the application before the media control method is finished.
Note:  When trying to resume a device that doesn&apos;t support Resume, the device is resumed as if the Play method was called. If Notify was assigned true before calling Resume (or any other media control method), Notify doesn&apos;t affect the call to Resume. Resume does not generate an OnNotify event upon completion, and NotifyValue remains unchanged.</docstr>
      </property>
      <property name="NotifyValue">
        <docstr>Indicates the result of the last media control method that requested a notification.
NotifyValue reports the result of the last media control method (Back, Close, Eject, Next, Open, Pause, PauseOnly, Play, Previous, StartRecording, Resume, Rewind, Step, or Stop) that requested a notification.
To request notification, set Notify to true before calling a media control method.</docstr>
      </property>
      <property name="StartPos">
        <docstr>Specifies the position within the currently loaded medium from which to begin playing or recording.
StartPos is specified using the current time format, which is specified in the TimeFormat property.
The StartPos property affects only the next Play or StartRecording method called after setting StartPos. Reset must be set to StartPos to affect any subsequent calls to Play or StartRecording.
StartPos does not affect the current position of the medium (specified in the Position property) until the next Play or StartRecording method is called.</docstr>
      </property>
      <property name="EndPos">
        <docstr>Specifies the position within the currently loaded medium at which to stop playing or recording.
EndPos is specified using the current time format, which is specified in the TimeFormat property.
The EndPos property affects only the next Play or StartRecording method called after setting EndPos. Reset EndPos to affect any subsequent calls to Play or StartRecording.</docstr>
      </property>
      <property name="DeviceID">
        <docstr>Specifies the device ID for the currently open multimedia device.
The value of DeviceID is determined when a device is opened with the Open method. If no device is open, DeviceID is 0.</docstr>
      </property>
      <property name="TimeFormat">
        <docstr>Determines the format used to specify position information.
TimeFormat determines how the StartPos, Length, Position, Start, and EndPos properties are interpreted. For example, if Position is 180 and TimeFormat is tfMilliseconds, the current position is 180 milliseconds into the medium. If Position is 180 and TimeFormat is tfMSF, the current position is 180 minutes into the medium.
Not all formats are supported by every device. When trying to set an unsupported format, the assignment is ignored.
The current timing information is always passed in a 4-byte integer. In some formats, the timing information returned is not really one integer, but single bytes of information packed in the long integer.</docstr>
      </property>
      <property name="DisplayRect">
        <docstr>Specifies a rectangular area in the control specified by the Display property that is used to display output from a multimedia device.
To display output in a specific rectangle area on a form assign a TRect record to DisplayRect. The Rect function can be used to create a TRect record.
Media that use a rectangle to display output usually perform best if the default DisplayRect size is used. To set DisplayRect to the default size, position the rectangle in the upper left corner and use 0, 0 for the lower right corner.
DisplayRect is ignored if Display is nil (Delphi) or NULL (C++).
Examples of multimedia devices that use a window to display output are Animation, AVI Video, Digital Video, Overlay, and VCR.

Note: DisplayRect can be set only after the media device is opened.</docstr>
      </property>
      <property name="ColoredButtons">
        <docstr>Determines which buttons on the media player control have color.
ColoredButtons controls which buttons on the media player are colored.
If a button is not colored with ColoredButtons, it appears in black-and-white when visible. All media player control buttons are colored by default.</docstr>
      </property>
      <property name="EnabledButtons">
        <docstr>Determines which buttons on the media player are usable.
EnabledButtons controls which buttons on the media player are enabled and usable.
An enabled button is colored and usable. A disabled button is dimmed and not usable. If a button is not enabled with EnabledButtons, it is disabled. By default, all buttons are enabled.
If the AutoEnable property is true, AutoEnable supersedes EnabledButtons. The buttons automatically enabled or disabled by the media player override any buttons enabled or disabled with the EnabledButtons property.</docstr>
      </property>
      <property name="VisibleButtons">
        <docstr>Indicates which of the buttons on the media player are visible.
VisibleButtons determines which buttons on the media player that are visible. If a button is not made visible with VisibleButtons, it does not appear on the media player control. By default, all buttons are visible when a media player component is added to a form.</docstr>
      </property>
      <property name="AutoEnable">
        <docstr>Determines whether the media player automatically enables and disables individual buttons in the component.
Use AutoEnable to automatically enable or disable the control buttons on the media player. If AutoEnable is true, the media player automatically enables or disables its control buttons. The media player determines which buttons to enable or disable by the current mode specified in the Mode property, and the current multimedia device type specified in the DeviceType property.
AutoEnable overrides the EnabledButtons property. The buttons enabled or disabled automatically by the media player supersede any buttons enabled or disabled with EnabledButtons.
If AutoEnable is false, the media player does not enable or disable buttons. The buttons must enabled or disabled with the EnabledButtons property.
The following table shows whether buttons are automatically enabled or disabled for each device mode:





Button

Play

Record

Pause

Stop

Not Open



Back



Enabled



Enabled



Enabled



Enabled



Disabled




Eject



Enabled



Enabled



Enabled



Enabled



Disabled




Next



Enabled



Enabled



Enabled



Enabled



Disabled




Pause



Enabled



Enabled



Enabled



Disabled



Disabled




Play



Disabled



Disabled



Enabled



Enabled



Disabled




Prev



Enabled



Enabled



Enabled



Enabled



Disabled




Record



Disabled



Disabled



Enabled



Enabled



Disabled




Step



Enabled



Enabled



Enabled



Enabled



Disabled




Stop



Enabled



Enabled



Disabled



Disabled



Disabled</docstr>
      </property>
      <property name="AutoOpen">
        <docstr>Determines if the media player is opened automatically when the application is run.
Use AutoOpen to have the media player automatically open at runtime.
If AutoOpen is true, the media player attempts to open the multimedia device specified by the DeviceType property (or FileName if DeviceType is dtAutoSelect) when the form containing the media player component is created at runtime. 
If AutoOpen is false, the device must be opened with a call to the Open method.
If an error occurs when opening the device, an exception of type EMCIDeviceError exception is raised that contains the error message. Upon completion, a numerical error code is stored in the Error property, and the corresponding error message is stored in the ErrorMessage property.
The Wait property determines whether control is returned to the application before opening the multimedia device. The Notify property determines whether opening the device generates an OnNotify event.</docstr>
      </property>
      <property name="AutoRewind">
        <docstr>Determines if the media player control rewinds before playing or recording.
If AutoRewind is true and the current position is at the end of the medium, Play or StartRecording moves the current position to the beginning of the medium before playing or recording. If AutoRewind is false, the user must click the Prev button or write code to call Previous to move to the beginning.
If values have been assigned to StartPos or EndPos or if the multimedia device uses tracks, AutoRewind has no effect on playing or recording. When calling Play or StartRecording, the current position remains at the end of the medium.</docstr>
      </property>
      <property name="DeviceType">
        <docstr>Specifies a multimedia device type to open with the media player.
DeviceType specifies a multimedia device type to open with the Open method. The default is dtAutoSelect.
If DeviceType is dtAutoSelect, the device type is determined by the file extension specified in the FileName property. If no device type is associated with the extension, the correct device type must be explicitly specified by setting DeviceType to a value other than dtAutoSelect.
A multimedia device is typically associated with an appropriate file name extension when the device is installed. Associations are specified in the registry or SYSTEM.INI file. See the documentation for the specific device for instructions about how to associate file name extensions with the device.</docstr>
      </property>
      <property name="Display">
        <docstr>Specifies the display window for a multimedia device that uses a window for output.
To use Display, assign the name of a windowed control such as a form or panel to Display to display output in that control.
The default value of Display is nil (Delphi) or NULL (C++), meaning that the device creates its own window to display output. Also, by freeing the control assigned to Display after the device has been opened, video output will be in its own default window.
Examples of multimedia devices that use a window to display output are Animation, AVI Video, Digital Video, Overlay, and VCR.</docstr>
      </property>
      <property name="FileName">
        <docstr>Specifies the opened or saved media file.
FileName specifies the media file to be opened by the Open method, or the file to save by the Save method.
At design time, use a file open dialog box to specify the FileName property by clicking the ellipsis button (...) in the Object Inspector.</docstr>
      </property>
      <property name="Shareable">
        <docstr>Determines whether more than one application can share a multimedia device.
If Shareable is false, no other components or applications can access the device. If Shareable is true, more than one component or application can access the device. Shareable defaults to false.
Be sure to set Shareable before opening a device.
Some devices are not shareable. If Shareable is set to true for a device that isn&apos;t shareable, the Open method fails and the error code is returned to the Error property.</docstr>
      </property>
      <event name="OnClick">
        <docstr>Occurs when the user presses and releases the mouse button while the mouse pointer is over one of the control buttons, or when the user presses Spacebar while the media player control has focus.
When the media player control has focus and the Spacebar is pressed, the user can use the Left Arrow or Right Arrow keys to select which control button to click.
The EMPNotify type is a method pointer that is called when an OnClick event for a TMediaPlayer components occurs. The Button argument can be one of the following values: btBack, btEject, btNext, btPause, btPlay, btPrev, btRecord, btStep, or btStop.
The default value of the event handler&apos;s DoDefault argument is true. If DoDefault is true, the media player control calls the method that corresponds to the clicked button. For example, if the user clicks the Play button (btPlay), the Play method is called.
If DoDefault is false, the user must write code that executes when a media player control button is clicked in the OnClick event handler. The following table lists the default methods corresponding to the media player control buttons:





Control button

Button value

Method called



Play



btPlay



Play




Record



btRecord



StartRecording




Stop



btStop



Stop




Next



btNext



Next




Prev



btPrev



Previous




Step



btStep



Step




Back



btBack



Back




Pause



btPause



Pause




Eject



btEject



Eject</docstr>
      </event>
      <event name="OnPostClick">
        <docstr>Occurs after the OnClick event handler is called.
OnPostClick is generated after the code of the OnClick event handler has been called. If Wait is true when the media player was clicked, OnPostClick won&apos;t be called until the completion of the OnClick code. If Wait is false, control can return to the application before completion of the OnClick code; therefore, the OnPostClick event may occur before the actions initiated by the OnClick event have completed.
For example, if the user clicks the Play button and the DoDefault parameter of the OnClick event handler for the media player is true, the media is played. If the media is long enough, it will still be playing when the OnPostClick event is generated if Wait is true. If Wait is false, however, OnPostClick won&apos;t occur until the media has finished playing.</docstr>
      </event>
      <event name="OnNotify">
        <docstr>Occurs upon the completion of a media control method.
OnNotify occurs upon the completion of a media control method (Back, Close, Eject, Next, Open, Pause, PauseOnly, Play, Previous, Resume, Rewind, StartRecording, Step, or Stop) when the Notify property is set to true before the call to the media control method. After an OnNotify event, the Notify property must be reset to true for the next OnNotify event to occur.</docstr>
      </event>
    </members>
  </class>
  <class unit="Vcl.Forms" name="TTitleBar">
    <docstr>TTitleBar encapsulates the properties and methods used to draw a custom titlebar.</docstr>
    <members>
      <procedure name="DrawTitleBarIcon">
        <docstr>DrawTitleBarIcon is used to draw the icon of the owner form.</docstr>
      </procedure>
      <procedure name="DrawTitleBarCaption">
        <docstr>DrawTitleBarCaption is used to draw the text of the owner form.</docstr>
      </procedure>
      <procedure name="DrawCustomTitleBar">
        <docstr>DrawCustomTitleBar is used to draw a custom title bar, supports basic customization like show/hide icon and set caption and foreground colors.</docstr>
      </procedure>
      <procedure name="InitTitleBarColors">
        <docstr>InitTitleBarColors use this method to reset the colors used in the titlebar.</docstr>
      </procedure>
      <property name="IconRect">
        <docstr>IconRect retrieves the bounds of the icon in the owner form.</docstr>
      </property>
      <property name="FrameRect">
        <docstr>ClientRect retrieves the bounds of the window returned by AdjustWindowRectEx.</docstr>
      </property>
      <property name="ClientRect">
        <docstr>ClientRect retrieves the bounds of the titlebar.</docstr>
      </property>
      <property name="CaptionButtonsRect">
        <docstr>CaptionButtonsRect retrieves the bounds of the caption button area in the owner form.</docstr>
      </property>
      <property name="CaptionAlignment">
        <docstr>CaptionAlignment used to set the alignment for the caption.</docstr>
      </property>
      <property name="Control">
        <docstr>Control is used to assign a TCustomTitleBarPanel descendent to handle the titlebar drawing.</docstr>
      </property>
      <property name="Enabled">
        <docstr>Enabled allows enable/disable the customization of the titlebar area.</docstr>
      </property>
      <property name="Height">
        <docstr>Height retrieves the height of the titlebar and allows set a custom height for titlebar if the SystemHeight property is False .</docstr>
      </property>
      <property name="SystemHeight">
        <docstr>SystemHeight used to specify if titlebar should use the system default  height. Set to False allows set a custom height for the titlebar.</docstr>
      </property>
      <property name="ShowCaption">
        <docstr>ShowCaption used to show/hide the caption on the title-bar</docstr>
      </property>
      <property name="ShowIcon">
        <docstr>ShowIcon used to  show/hide the icon on the title-bar.</docstr>
      </property>
      <property name="SystemColors">
        <docstr>SystemColors used to specify if titlebar should use the system default colors. Set to False allows set customs colors for the titlebar.</docstr>
      </property>
      <property name="SystemButtons">
        <docstr>SystemButtons used to specify if titlebar should use the system caption buttons. Set to False allows set customs colors for the titlebar buttons. Windows 10 Only.</docstr>
      </property>
      <property name="BackgroundColor">
        <docstr>BackgroundColor gets or sets the color of the title bar background.</docstr>
      </property>
      <property name="ForegroundColor">
        <docstr>ForegroundColor gets or sets the color of the title bar foreground.</docstr>
      </property>
      <property name="InactiveBackgroundColor">
        <docstr>InactiveBackgroundColor gets or sets the color of the title bar background when the owner form is inactive.</docstr>
      </property>
      <property name="InactiveForegroundColor">
        <docstr>InactiveForegroundColor gets or sets the color of the title bar foreground when the owner form is inactive.</docstr>
      </property>
      <property name="ButtonForegroundColor">
        <docstr>ButtonForegroundColor gets or sets the foreground color of the title bar buttons.</docstr>
      </property>
      <property name="ButtonBackgroundColor">
        <docstr>ButtonBackgroundColor gets or sets the background color of the title bar buttons.</docstr>
      </property>
      <property name="ButtonHoverForegroundColor">
        <docstr>ButtonHoverForegroundColor gets or sets the foreground color of the title bar buttons when are hovered.</docstr>
      </property>
      <property name="ButtonHoverBackgroundColor">
        <docstr>ButtonHoverBackgroundColor gets or sets the background color of the title bar buttons when are hovered.</docstr>
      </property>
      <property name="ButtonPressedForegroundColor">
        <docstr>ButtonPressedForegroundColor gets or sets the foreground color of the title bar buttons when are pressed.</docstr>
      </property>
      <property name="ButtonPressedBackgroundColor">
        <docstr>ButtonPressedBackgroundColor gets or sets the background color of the title bar buttons when are pressed.</docstr>
      </property>
      <property name="ButtonInactiveForegroundColor">
        <docstr>ButtonInactiveForegroundColor gets or sets the color of the title bar buttons foreground when the owner form is inactive.</docstr>
      </property>
      <property name="ButtonInactiveBackgroundColor">
        <docstr>ButtonInactiveBackgroundColor gets or sets the color of the title bar buttons background when the owner form is inactive.</docstr>
      </property>
    </members>
  </class>
  <class unit="Vcl.Forms" name="TCustomForm">
    <docstr>TCustomForm is the base class from which to derive a window such as a form or dialog.
Derive from TCustomForm to create a custom window. The TCustomForm descendant can contain other objects, such as TButton, TCheckBox, and TComboBox objects.</docstr>
    <members>
      <procedure name="Activate">
        <docstr>Activation event dispatcher.
Activation is the event dispatcher for form activations.
The form component calls Activate in response to the CM_ACTIVATE message, sent when a form gets the focus either because of a change in active windows within an application or because of the application becoming active. As defined in TCustomForm, Activate simply calls the OnActivate event handler.</docstr>
      </procedure>
      <procedure name="ActiveChanged">
        <docstr>Active state event dispatcher.
ActiveChanged is the event dispatcher for changes in the form&apos;s active status. As implemented in TCustomForm, ActiveChanged does nothing. Override this method in a descendant class to implement event handling or other response to a change in the active form.</docstr>
      </procedure>
      <procedure name="AdjustClientRect">
        <docstr>Adjusts the ClientRect property to exclude the scroll bars.
Vcl.Forms.TCustomForm.AdjustClientRect inherits from Vcl.Forms.TScrollingWinControl.AdjustClientRect. All content below this line refers to Vcl.Forms.TScrollingWinControl.AdjustClientRect.
Adjusts the ClientRect property to exclude the scroll bars.
AdjustClientRect is called internally when the control needs accurate information on where to place child controls within the client area. It indents Rect to exclude the area taken by the scroll bars, then calls the inherited AdjustClientRect method.</docstr>
      </procedure>
      <procedure name="AlignControls">
        <docstr>Aligns all child controls of the form that fall within a specified rectangle.
Use AlignControls to align all controls within an area of the form. Specify the area in which to align the controls as the value of the Rect parameter.
AlignControls uses the Align property value for each child control to determine how to align it. The AControl parameter can be nil (Delphi) or NULL (C++). If you specify a control in AControl, that control takes precedence in alignment over other, similarly aligned controls.</docstr>
      </procedure>
      <procedure name="BeginAutoDrag">
        <docstr>Responds when the user starts dragging the form if DragMode is dmAutomatic.
BeginAutoDrag suppresses the default behavior of the BeginAutoDrag method. This is because forms do not change the mouse cursor when dragged.</docstr>
      </procedure>
      <procedure name="ChangeScale">
        <docstr>Repositions and resizes the form by the ratio M/D, adjusting its client area and font size as needed.
TCustomForm overrides ChangeScale to rescale any scroll bars and child controls.</docstr>
      </procedure>
      <procedure name="ClientWndProc">
        <docstr>Provides specific message responses for a MDI form from the client.
The ClientWndForm method receives message for a MDI form from a client. ClientWndForm is called when a form is created. ClientWndForm handles messages that deal with background erase, repaint, and determining which part of the window corresponds to a particular screen coordinate. Override ClientWndForm to change how the form responds to Windows client messages.</docstr>
      </procedure>
      <procedure name="CloseModal">
        <docstr>CloseModal prepares a modal form for closing.
Do not call CloseModal in your application. CloseModal is used by the VCL when a modal form needs to be closed. CloseModal does not close the form by itself; it simply calls the registered close events and updates the ModalResult property.</docstr>
      </procedure>
      <procedure name="CreateParams">
        <docstr>Initializes the window-creation parameter record when the form window is created.
The CreateWnd method calls CreateParams to initialize the parameters it passes to CreateWindowHandle. TCustomForm overrides CreateParams to customize the way the form creates its Windows representation after calling the inherited method. You should never need to override this method in the context of a form class.
The fields of the Params parameter become the parameters to a call to the CreateWindowEx OS function.</docstr>
      </procedure>
      <procedure name="CreateWindowHandle">
        <docstr>Creates a form window given a set of window-creation parameters.
The CreateWnd method calls CreateWindowHandle to create the form window once it has been specified in the window-creation parameters. CreateWindowHandle creates the window by calling the CreateWindowEx API function, passing parameters from the record passed in the Params parameter. CreateWindowHandle removes the CS_HREDRAW and CS_VREDRAW class styles from the window class.
Params holds information needed when telling Windows to create a window handle.</docstr>
      </procedure>
      <procedure name="CreateWnd">
        <docstr>Creates the form window.
CreateWnd is called when the form is created, and whenever a change to the form requires the window to be recreated. CreateWnd calls (indirectly) the CreateParams method to obtain the window creation parameters, and then calls CreateWindowHandle to direct Windows to create the underlying window for the form. It then initializes the newly-created window to reflect the property settings of the form.</docstr>
      </procedure>
      <procedure name="Deactivate">
        <docstr>Generates an OnDeactivate event.
The form component calls Deactivate in response to the CM_DEACTIVATE message, sent when a form gets the focus either because of a change in active windows within an application or because of the application becoming active.
The default Deactivate method calls any event handler attached by the user to the OnDeactivate event. Override this method to block the OnDeactivate event or provide additional responses to the loss of activation.</docstr>
      </procedure>
      <procedure name="DefineProperties">
        <docstr>Designates methods for storing a form&apos;s unpublished data on a stream such as a form file.
DefineProperties calls the inherited method and calls the filer object&apos;s DefineProperty method for the PixelsPerInch,and TextHeight properties. TForm descendants can also specify methods that read and write data other than properties by overriding the DefineProperties method.</docstr>
      </procedure>
      <procedure name="DestroyHandle">
        <docstr>Destroys the control&apos;s window without destroying the control.
Vcl.Forms.TCustomForm.DestroyHandle inherits from Vcl.Controls.TWinControl.DestroyHandle. All content below this line refers to Vcl.Controls.TWinControl.DestroyHandle.
Destroys the control&apos;s window without destroying the control.
Call DestroyHandle to dispose of the window, but leave the control intact. The control can later recreate the window if needed. DestroyHandle is the converse operation to CreateHandle. Applications should call the high-level CreateHandle and DestroyHandle methods, rather than the lower-level methods of CreateWnd and DestroyWnd, whenever possible.
If the control has TWinControl objects as child controls, DestroyHandle calls each of their DestroyHandle methods before calling DestroyWnd to destroy its own handle.</docstr>
      </procedure>
      <procedure name="DestroyWindowHandle">
        <docstr>Destroys the window created in the CreateWindowHandle method.
DestroyWindowHandle is called automatically to destroy the window associated with a form before destroying the form.</docstr>
      </procedure>
      <procedure name="DoClose">
        <docstr>Form closing event dispatcher.
DoClose is called automatically when the form is about to close. DoClose can alter closing behavior by changing the Action parameter. For more information, refer to the OnClose event handler.
As implemented in TCustomForm, DoClose simply calls the OnClose event handler.</docstr>
      </procedure>
      <procedure name="DoCreate">
        <docstr>Form creation event dispatcher.
DoCreate is called automatically after form construction is complete. The precise way DoCreate is called can be modified by setting the OldCreateOrder property.
As implemented in TCustomForm, DoCreate simply calls the OnCreate event handler.</docstr>
      </procedure>
      <procedure name="DoDestroy">
        <docstr>Form destruction event dispatcher.
DoDestroy is called automatically when the TCustomForm object is about to be deallocated. The precise way DoDestroy is called can be modified by setting the OldCreateOrder property.
As implemented in TCustomForm, DoDestroy simply calls the OnDestroy event handler.</docstr>
      </procedure>
      <procedure name="DoHide">
        <docstr>Form hide event dispatcher.
DoHide is called automatically when the form is hidden.
As implemented in TCustomForm, DoHide calls the OnHide event handler.</docstr>
      </procedure>
      <procedure name="DoShow">
        <docstr>Form show event dispatcher.
DoShow is called automatically when the application is about to show the form. As implemented in TCustomForm, DoShow simply calls the OnShow event handler.</docstr>
      </procedure>
      <procedure name="DoThumbButtonNotify">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoWindowPreviewRequest">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoThumbPreviewRequest">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="DoWritePixelsPerInch">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="GetBorderIconStyles">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="GetBorderStyles">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GetClientRect">
        <docstr>Returns the value of the ClientRect property.
GetClientRect is the protected access function for the ClientRect property. It returns the dimensions of the form window, indented by any scroll bars and menus.
Override this method to change the way the client area of the form is defined.</docstr>
      </function>
      <function name="GetFloating">
        <docstr>Returns the value of the Floating property.
GetFloating is the protected access function for the Floating property. Override this method in descendants that implement floating windows in some class-specific way.</docstr>
      </function>
      <function name="GetInternalTextHeight">
        <docstr>Returns the FTextHeight integer value of  TCustomForm.</docstr>
      </function>
      <function name="GetOwnerWindow">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="HandleCreateException">
        <docstr>Handles exceptions that are raised by the OnCreate event handler.
The form calls HandleCreateException internally if the OnCreate event handler raises an exception. HandleCreateException forwards the exception on to the application object, which generates an OnException event. If there is no OnException event handler, the application displays an exception message box.
HandleCreateException returns true if it handles the exception, false otherwise.</docstr>
      </function>
      <procedure name="InitializeNewForm">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Loaded">
        <docstr>Performs fix-ups when the form is first loaded into memory.
Loaded overrides the inherited method to give focus to the ActiveControl if it is assigned. Before assigning focus, Loaded calls the inherited method to perform any lower-level initialization.</docstr>
      </procedure>
      <procedure name="Notification">
        <docstr>Responds to notifications that objects are about to be inserted or removed.
Notification is called when the component specified by AComponent is about to be inserted or removed, as specified by Operation. By default, forms pass along the notification to their owned components, if any. In addition, Notification makes internal adjustments if the main menu is added or deleted.
A form can, if needed, override Notification to make other adjustments when components are inserted or removed. In particular, if a form has object fields or properties that contains references to other components, it might check the notifications of component removals and invalidate those references as needed.</docstr>
      </procedure>
      <procedure name="Paint">
        <docstr>Generates an OnPaint event.
The form component calls Paint in response to the WM_PAINT message (sent when the window needs to be painted) before rendering all controls on the form.
The default Paint method calls any event handler attached by the user to the OnPaint event. Override Paint to block the OnPaint event or to draw additional features before or after the OnPaint event.</docstr>
      </procedure>
      <procedure name="PaintWindow">
        <docstr>Renders the image of the form.
Applications can&apos;t call this protected method. It is called when the form needs to be painted.
PaintWindow locks the canvas to prevent threading issues, assigns the DC parameter as the Handle of the form&apos;s canvas, and then calls the Paint method to render the image of the form.</docstr>
      </procedure>
      <function name="PaletteChanged">
        <docstr>Responds to changes in the system&apos;s palette by realizing the control&apos;s palette as returned from GetPalette.
PaletteChanged is called automatically when the system palette changes. The Foreground parameter indicates whether the palette realization should treat this control&apos;s palette as being in the foreground or the background. The return value from PaletteChanged indicates whether the form actually realized its palette, returning true only if the form has an associated palette.
Most applications should not need to alter the default behavior of PaletteChanged.</docstr>
      </function>
      <function name="GetDesignDpi">
        <docstr>Obtains the design Dpi for the form where the control was designed. 
Vcl.Forms.TCustomForm.GetDesignDpi inherits from Vcl.Controls.TControl.GetDesignDpi. All content below this line refers to Vcl.Controls.TControl.GetDesignDpi.
Obtains the design Dpi for the form where the control was designed.</docstr>
      </function>
      <procedure name="SetPixelsPerInch">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="ReadState">
        <docstr>Reads the form&apos;s published properties, stored data, and owned components from a reader object.
ReadState is part of a sequence of calls used by the VCL streaming system that loads and saves VCL components. It reads the values of all the component&apos;s published properties, stored data, and owned components from the reader object passed in Reader. Do not call ReadState directly.
Any descendant classes overriding ReadState should end with a call to the inherited ReadState method.</docstr>
      </procedure>
      <procedure name="RequestAlign">
        <docstr>Instructs the form&apos;s parent (if any) to reposition the form, enforcing its Align property.
RequestAlign is called internally when changes are made to the size or position of the form, so that it remains properly aligned within a dock site or properly positioned on the screen.</docstr>
      </procedure>
      <procedure name="SetChildOrder">
        <docstr>Changes the order in which Child appears when GetChildren is called.
Use SetChildOrder to change the order in which child components are loaded and saved. The Child moves as if it were an item in a list object: items previously below the child&apos;s old position move up, and those below the new position move down.</docstr>
      </procedure>
      <procedure name="SetParentBiDiMode">
        <docstr>Sets the ParentBiDiMode property.
SetParentBiDiMode is the protected implementation of the ParentBiDiMode property. It overrides the inherited method to obtain the BiDiMode property of the application if the form does not have a parent.</docstr>
      </procedure>
      <procedure name="DoDock">
        <docstr>Docking event dispatcher.
DoDock supplements the inherited DoDock method by updating form borders.</docstr>
      </procedure>
      <procedure name="SetParent">
        <docstr>Sets the Parent property.
SetParent is the protected implementation of the Parent property. It overrides the inherited method to regenerate the form&apos;s window when the Parent property is changed to nil (Delphi) or NULL (C++).</docstr>
      </procedure>
      <procedure name="UpdateActions">
        <docstr>Updates all actions associated with the form.
UpdateActions is called automatically when the application is idle to allow all components in the form an opportunity to update any actions for which the component is a target. This allows actions to be checked, grayed, and so on to reflect the current state of their targets.
UpdateActions updates all actions associated with the form, its menus, and the components contained in the form.</docstr>
      </procedure>
      <procedure name="UpdateWindowState">
        <docstr>Updates the WindowState property to reflect the current state of the form.
UpdateWindowState ensures that the WindowState property reflects the current state of the form.</docstr>
      </procedure>
      <procedure name="UpdateStyleElements">
        <docstr>Called when the StyleElements property changes.
Vcl.Forms.TCustomForm.UpdateStyleElements inherits from Vcl.Controls.TControl.UpdateStyleElements. All content below this line refers to Vcl.Controls.TControl.UpdateStyleElements.
Called when the StyleElements property changes.
Override the UpdateStyleElements method in a descendant class to provide customized behavior for the control when the value of the StyleElements property changes.</docstr>
      </procedure>
      <procedure name="ValidateRename">
        <docstr>Determines if a form can rename one of its owned components.
The ValidateRename method checks to see if a form can rename one of its owned components, passed in AComponent, from its current name (CurName) to the string passed in NewName. If AComponent is nil (Delphi) or NULL (C++) or NewName is already the name of a component in the form&apos;s list, ValidateRename raises an EComponentError exception.</docstr>
      </procedure>
      <procedure name="VisibleChanging">
        <docstr>Responds just before the form changes the value of its Visible property.
This protected method raises an exception if, for some reason, the form should not change its visible state.</docstr>
      </procedure>
      <procedure name="WndProc">
        <docstr>Provides specific message responses for the form.
WndProc is the first method that receives messages for a form. After calling the inherited method, WndProc performs some window activation, focus, and position message handling necessary to keep in sync with Windows. Override WndProc to change how the form responds to Windows messages.</docstr>
      </procedure>
      <procedure name="Resizing">
        <docstr>Makes any required adjustments when the form changes size.
This protected method is called automatically when the form is resized, including when it is maximized, minimized, or restored to normal size. Resizing adjusts the size and position of any child controls that are aligned to the form.
The State parameter indicates the state of the form after the resize.</docstr>
      </procedure>
      <function name="get_ActiveMDIChild">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="get_MDIChildCount">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="get_MDIChildren">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="QueryInterface">
        <docstr>Returns a reference to a specified interface if that interface is supported by the form.
For forms that support interfaces, QueryInterface calls the QueryInterface method of the interface supported by the form. QueryInterface returns a reference to the interface specified by the IID parameter, as the Obj parameter. If the form does not support the interface, the Obj parameter is nil (Delphi) or NULL (C++).
QueryInterface returns S_OK if the Obj parameter is successfully assigned.</docstr>
      </function>
      <procedure name="DoBeforeMonitorDpiChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DoAfterMonitorDpiChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <property name="ActiveMDIChild">
        <docstr>Specifies the MDI child that has focus.
Use ActiveMDIChild to get the MDI child that has focus.
If the form is not an MDI parent (that is, if the FormStyle property of the form is not fsMDIForm), ActiveMDIChild returns nil (Delphi) or NULL (C++).</docstr>
      </property>
      <property name="AlphaBlend">
        <docstr>Specifies whether the form is translucent.
Set AlphaBlend to specify that the form represents a layered window that allows a translucent color. The AlphaBlendValue property specifies the degree of translucency.

Note: AlphaBlend does not work on all systems. The application must be running under Windows 2000 or better, and the machine must be a P90 or better.</docstr>
      </property>
      <property name="AlphaBlendValue">
        <docstr>Specifies the degree of translucency on a translucent form.
Set AlphaBlendValue to a value between 0 and 255 to indicate the degree of translucency when the AlphaBlend property is true. A value of 0 indicates a completely transparent window. A value of 255 indicates complete opacity.

Note: AlphaBlendValue only has an effect when the AlphaBlend property is true.</docstr>
      </property>
      <property name="BorderIcons">
        <docstr>Specifies which icons appear on the title bar of the form.
Use BorderIcons to get or set the icons that appear on the title bar of the form. BorderIcons can include any of the following TBorderIcons values:





Value

Meaning



biSystemMenu



The form has a Control menu (also known as a System menu).




biMinimize



The form has a Minimize button




biMaximize



The form has a Maximize button




biHelp



If BorderStyle is bsDialog or biMinimize and biMaximize are excluded, a question mark appears in the form&apos;s title bar and when clicked, the cursor changes to crHelp; otherwise,no question mark appears.





Note:  Certain combinations of the BorderIcons and BorderStyle properties are mutually exclusive. For example, BorderIcons biMax, biMin with BorderStyle of bsDialog are mutually exclusive.</docstr>
      </property>
      <property name="AutoScroll">
        <docstr>Indicates whether scroll bars appear automatically on the scrolling windowed control if it is not large enough to display all of its controls.
If AutoScroll is true, the scroll bars appear automatically when necessary. For example, if the user resizes the control so that some of its controls are partially obscured, scroll bars appear.
If AutoScroll is false, scroll bars don&apos;t appear automatically. In this case, use the HorzScrollBar and VertScrollBar properties to make scroll bars appear.</docstr>
      </property>
      <property name="ClientHeight">
        <docstr>Specifies the height of the control&apos;s client area in pixels.
Use ClientHeight to read or change the height of the control&apos;s client area.
For TControl, ClientHeight is the same as Height. Derived classes may implement a ClientHeight property that differs from Height. For example, the ClientHeight of a form is the value of the Height property minus the height of the title bar, resize border, and scroll bars.</docstr>
      </property>
      <property name="ClientWidth">
        <docstr>Specifies the horizontal size of the control&apos;s client area in pixels.
Use ClientWidth to read or change the width of the control&apos;s client area. ClientWidth is equivalent to ClientRect.Right.
For TControl, ClientWidth is the same as Width. Derived classes may implement a ClientWidth property that differs from Width. For example, the ClientWidth of a form is the value of the Width property minus the width of the resize border and scroll bars.</docstr>
      </property>
      <property name="TransparentColor">
        <docstr>Specifies whether a color on the form appears transparent.
Use TransparentColor to indicate that one of the colors on the form should be treated as transparent, allowing windows behind the form to completely show through. The TransparentColorValue property indicates the color that appears completely transparent.

Note:  To make the entire form transparent, or to make it translucent rather than transparent, use the AlphaBlend and AlphaBlendValue properties.
Note: TransparentColor does not work on all systems. The application must be running under Windows 2000 or better, with adequate hardware.</docstr>
      </property>
      <property name="TransparentColorValue">
        <docstr>Indicates the color on the form that appears transparent when TransparentColor is true.
Use TransparentColorValue to indicate the color that appears transparent when the TransparentColor property is true.

Note:  If the application uses a 16-bit color palette, TransparentColorValue must be a basic color.</docstr>
      </property>
      <property name="Ctl3D">
        <docstr>Determines whether a control has a three-dimensional (3-D) or two-dimensional look.
Ctl3D is provided for backward compatibility. It is not used by 32-bit versions of Windows or NT4.0 and later, with the exception of Windows XP Home, where it is used on occasion.
On earlier platforms, Ctl3D controlled whether the control had a flat or beveled appearance.


Note RAD Studio no longer supports Windows Vista or earlier.</docstr>
      </property>
      <property name="DefaultMonitor">
        <docstr>Specifies the monitor on which the form appears.
Use DefaultMonitor to associate a form with a particular monitor in a multi-monitor application. The following table lists the possible values:





Value

Meaning



dmDesktop



No attempt is made to position the form on a specific monitor.




dmPrimary



The form is positioned on the first monitor listed in the global screen object&apos;s Monitors property.




dmMainForm



The form appears on the same monitor as the application&apos;s main form.




dmActiveForm



The form appears on the same monitor as the currently active form.





Note: DefaultMonitor has no effect if the application does not have a main form.</docstr>
      </property>
      <property name="HorzScrollBar">
        <docstr>Represents the horizontal scroll bar for the scrolling windowed control.
Use HorzScrollBar to hide, show, or manipulate the horizontal scroll bar for the scrolling windowed control.</docstr>
      </property>
      <property name="Icon">
        <docstr>Specifies the icon that appears when the form is minimized.
Set the Icon property to provide an icon for the form. If Icon is not set, the system provides a default icon when the form is minimized.</docstr>
      </property>
      <property name="MDIChildCount">
        <docstr>Specifies the number of open MDI child forms.
Use MDIChildCount to get the number of open MDI child forms.
MDIChildCount is meaningful only if the form is an MDI parent (that is, if the form&apos;s FormStyle property is set to fsMDIForm).</docstr>
      </property>
      <property name="ObjectMenuItem">
        <docstr>Represents an OLE object menu item that reacts to selections of OLE objects.
Use ObjectMenuItem to get or set a menu item that becomes enabled or disabled when an OLE object on the form is selected or unselected respectively.
The OLE object menu item can be used for standard OLE commands, such as Activate or Convert. (The implementations of these commands are provided by the OLE server.)</docstr>
      </property>
      <property name="ParentFont">
        <docstr>Specifies where a control looks for its font information.
To have a control use the same font as its parent control, set ParentFont to true. If ParentFont is false, the control uses its own Font property. Many controls default ParentFont to true so that all the controls in a form or other container present a uniform appearance. When the value of a control&apos;s Font property changes, ParentFont becomes false automatically.
When ParentFont is true for a form, the form uses the default font. Currently, the default font is Tahoma 8 pt.</docstr>
      </property>
      <property name="PopupMenu">
        <docstr>Specifies the pop-up menu associated with the control.
Assign a value to PopupMenu to make a pop-up menu appear when the user selects the control and clicks the right mouse button. If the TPopupMenu&apos;s AutoPopup property is True, the pop-up menu appears automatically. If the menu&apos;s AutoPopup property is False, display the menu with a call to its Popup method from the control&apos;s OnContextPopup event handler.</docstr>
      </property>
      <property name="PopupChildren">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="Position">
        <docstr>Represents the size and placement of the form.
Use Position to get or set the size and placement of the form. Position can have one of the following TPosition values:





Value

Meaning



poDesigned



The form appears positioned on the screen and with the same height and width as it had at design time.




poDefault



The form appears in a position on the screen and with a height and width determined by the operating system. Each time you run the application, the form moves slightly down and to the right. The right side of the form is always near the rightmost side of the screen, and the bottom of the form is always near the bottom of the screen, regardless of the screen&apos;s resolution.
The operating system only supports this for overlapped windows. For a pop-up or child window (that has a BorderStyle of bsDialog or bsNone, for example), the window is positioned in the upper-left corner of the screen.




poDefaultPosOnly



The form displays with the size you created it at design time, but the operating system chooses its position on the screen. Each time you run the application, the form moves slightly down and to the right. When the form can no longer move down and to the right and keep the same size while remaining entirely visible on the screen, the form displays at the upper-left corner of the screen.
The operating system only supports this for overlapped windows. For a pop-up or child window (that has a BorderStyle of bsDialog or bsNone, for example), the window is positioned in the upper-left corner of the screen.




poDefaultSizeOnly



The form appears in the position you left it at design time, but the operating system chooses its size. The right side of the form is always near the rightmost side of the screen, and the bottom of the form is always near the bottom of the screen, regardless of the screen&apos;s resolution.




poScreenCenter



The form remains the size you left it at design time, but is positioned in the center of the screen. In multi-monitor applications, the form may be moved from this center position so that it falls entirely on one monitor, as specified by the DefaultMonitor property. 




poDesktopCenter



The form remains the size you left it at design time, but is positioned in the center of the screen. No adjustments are made for multi-monitor applications.




poMainFormCenter



The form remains the size you left it at design time, but is positioned in the center of the application&apos;s main form. No adjustments are made for multi-monitor applications. This position should only be used with secondary forms. If set for a main form, it acts like poScreenCenter.




poOwnerFormCenter



The form remains the size you left it at design time, but is positioned in the center of the form specified by the Owner property. If the Owner property does not specify a form, this position acts like poMainFormCenter.




Note that if Position is set to poDefault, poDefaultPosOnly or poDefaultSizeOnly, and BorderStyle is set to bsDialog or bsNone, the form will be positioned at (0,0).</docstr>
      </property>
      <property name="PrintScale">
        <docstr>Represents the proportions of a printed form.
Use PrintScale to get or set the proportions of the printed form. PrintScale can have one of the following TPrintScale values:





Value

Meaning



poNone



No special scaling occurs; therefore, the printed form and how the form appears onscreen may appear squished or stretched.




poProportional



The form is printed so that the printed image is approximately the same visible size as on the screen (WYSIWYG). The form image is scaled so that the printed image is approximately the same visible size as on the screen.




poPrintToFit



The form is printed using the same screen proportions, but in a size that just fits the printed page.</docstr>
      </property>
      <property name="TileMode">
        <docstr>Represents how MDI child forms are arranged when the Tile method is called.
TileMode can have one of the following TTileMode values:





Value

Meaning



tbHorizontal



Each form stretches across the width of the parent form




tbVertical



Each form stretches along the height of the parent form




TileMode is meaningful only if the form is an MDI child (that is, if the form&apos;s FormStyle property is set to fsMDIChild).</docstr>
      </property>
      <property name="VertScrollBar">
        <docstr>Represents the vertical scroll bar for the scrolling windowed control.
Use VertScrollBar to hide, show, or manipulate the vertical scroll bar for the scrolling windowed control.</docstr>
      </property>
      <property name="Visible">
        <docstr>Specifies whether the component appears onscreen.
Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible.
Calling the Show method sets the control&apos;s Visible property to True. Calling the Hide method sets it to False.
For TCustomForm descendants, the Show and ShowModal methods set Visible to True and bring the form to the front of all open windows.
For TTabSheet descendants, Visible does not control the visibility of the control at run time. For more information, see the description of the TabVisible property.</docstr>
      </property>
      <property name="WindowMenu">
        <docstr>Specifies the Window menu for an MDI parent form.
Use WindowMenu to get or set the Window menu for an MDI parent form. The Window menu is a standard menu in MDI applications. It contains commands that let the user manage the windows in the application. Menu items usually include Cascade, Arrange Icons, Tile, and so on. 
The Window menu also lists (at the bottom) the child windows that are currently open in the application. When the user selects one of these windows from the menu, the window becomes the active window in the application.
Although this menu is commonly called the Window menu, it can have any name that corresponds to an existing menu item on the menu bar. The names of open child forms are merged onto the menu automatically at run-time.
WindowMenu is meaningful only if the form is an MDI parent (that is, if the form&apos;s FormStyle property is set to fsMDIForm).</docstr>
      </property>
      <property name="ClientHandle">
        <docstr>Provides access to the handle of the form&apos;s internal MDI client window.
Use ClientHandle to get the handle for the form&apos;s internal MDI client window.
ClientHandle is meaningful only if the form is an MDI parent (that is, if the form&apos;s FormStyle property is set to fsMDIForm).

Note:  Use the Handle property instead to get the handle to the form window itself.</docstr>
      </property>
      <property name="FormStyle">
        <docstr>Determines the form&apos;s style.
Use FormStyle to get or set the form&apos;s style. FormStyle is one of the following values:





Value

Meaning



fsNormal



The form is neither an MDI parent window nor an MDI child window.




fsMDIChild



The form is an MDI child window.




fsMDIForm



The form is an MDI parent window.




fsStayOnTop



This form remains on top of the desktop and of other forms in the project, except any others that also have FormStyle set to fsStayOnTop. If one fsStayOnTop form launches another, neither form will consistently remain on top.




If the form is the main form of an MDI application, its FormStyle property must be set to fsMDIForm.

Note:  It is not advisable to change FormStyle at runtime.
Warning:  TGraphicControl descendants placed in the client area of a form with FormStyle set to fsMDIForm will not paint.</docstr>
      </property>
      <property name="Height">
        <docstr>Specifies the vertical size of the control in pixels.
Use the Height property to read or change the height of the control.</docstr>
      </property>
      <property name="Width">
        <docstr>Specifies the horizontal size of the control or form in pixels.
Use the Width property to read or change the width of the control.

Note:  For tab sheet controls, changing this property at run time has no effect.</docstr>
      </property>
      <event name="OnActivate">
        <docstr>Occurs when the form becomes active.
Use OnActivate to perform special processing when the form receives focus. A form becomes active when focus is transferred to it (when the user clicks on the form, for example).

Note:  The OnActivate event of the application (TApplication), not the form, occurs when Windows switches control from another application.</docstr>
      </event>
      <event name="OnAfterMonitorDpiChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </event>
      <event name="OnBeforeMonitorDpiChanged">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </event>
      <event name="OnCanResize">
        <docstr>Occurs when an attempt is made to resize the control.
Use OnCanResize to adjust the way a control is resized. If necessary, change the new width and height of the control in the OnCanResize event handler. The OnCanResize event handler also allows applications to indicate that the entire resize should be aborted.
If there is no OnCanResize event handler, or if the OnCanResize event handler indicates that the resize attempt can proceed, the OnCanResize event is followed immediately by an OnConstrainedResize event.
OnCanResize is an event handler of type Vcl.Controls.TCanResizeEvent.</docstr>
      </event>
      <event name="OnClick">
        <docstr>Occurs when the user clicks the control.
Use the OnClick event handler to respond when the user clicks the control. If the control has an associated action, and that action has an OnExecute method, the action&apos;s OnExecute method responds to click events unless it is superseded by an OnClick event handler.
Usually, OnClick occurs when the user presses and releases the left mouse button with the mouse pointer over the control. This event can also occur when:

The user selects an item in a grid, outline, list, or combo box by pressing an arrow key.
The user presses the SPACEBAR while a button or check box has focus.
The user presses ENTER when the active form has a default button (specified by the Default property).
The user presses ESC when the active form has a cancel button (specified by the Cancel property).
The user presses the accelerator key for a button or check box. For example, if the value of the Caption property of a check box is &apos;&amp;Bold&apos;, the B is underlined at run time and the OnClick event of the check box is triggered when the user presses Alt+B. However, focus does not move to the control in these instances.
The Checked property of a radio button is set to True.
The value of the Checked property of a check box is changed.
Note: When you change the value of the Checked property programmatically, the OnClick event of the check box control occurs. Do not modify the value of the Checked property in the event handler of the OnClick event, because that leads into a deadlock situation.
The Click method of a menu item is called.
For a form, an OnClick event occurs when the user clicks a disabled component or in a blank area of the form.
OnClick is an event handler of type TNotifyEvent.</docstr>
      </event>
      <event name="OnClose">
        <docstr>Occurs when the form closes.
Use OnClose to perform special processing when the form closes. The OnClose event specifies which event handler to call when a form is about to close. The handler specified by OnClose might, for example, test to make sure all fields in a data-entry form have valid contents before allowing the form to close.
A form is closed by the Close method or when the user chooses Close from the form&apos;s system menu.
The TCloseEvent type points to a method that handles the closing of a form. The value of the Action parameter determines if the form actually closes. These are the possible values of Action:





Value

Meaning



caNone



The form is not allowed to close, so nothing happens.




caHide



The form is not closed, but just hidden. Your application can still access a hidden form.




caFree



The form is closed and all allocated memory for the form is freed.




caMinimize



The form is minimized, rather than closed. This is the default action for MDI child forms.




If a form is an MDI child form, and its BorderIcons property is biMinimize, then the default Action is caMinimize. If a MDI child form does not have these settings, the default Action is caNone, meaning that nothing happens when the user attempts to close the form.
If a form is an SDI child form, Action defaults to caHide.
To close the form and free it in an OnClose event, set Action to caFree.

Note:  When the application shuts down, the main form receives an OnClose event, but any child forms do not receive the OnClose event.</docstr>
      </event>
      <event name="OnCloseQuery">
        <docstr>Occurs when close is attempted.
Use OnCloseQuery to specify the conditions under which the form can close. An OnCloseQuery event handler returns a Boolean CanClose value that determines whether a form is allowed to close. Its default value is true. 
You can use an OnCloseQuery event handler to ask users if they are sure they really want the form closed immediately. For example, you can use the handler to display a message box that prompts the user to save a file before closing the form.
The TCloseQueryEvent type points to the method that determines whether a form can be closed. The value of the CanClose parameter determines if the form can close or not.</docstr>
      </event>
      <event name="OnCreate">
        <docstr>Occurs when the form is created.
Use OnCreate to perform special processing when the form is created and is invoked by TCustomForm&apos;s constructor. Either implement this event or override the constructor of the form; do not do both. Any objects created in the OnCreate event should be freed by the OnDestroy event.
When a form is being created and its Visible property is true, the following events occur in the order listed:

OnCreate
OnShow
OnActivate
OnPaint
Note:  Use of the OnCreate event is discouraged in C++ code because it can interact badly with the form&apos;s constructor (see OldCreateOrder). It is recommended that you override the form constructor instead.</docstr>
      </event>
      <event name="OnDblClick">
        <docstr>Occurs when the user double-clicks the left mouse button when the mouse pointer is over the control.
Use the OnDblClick event to respond to mouse double-clicks.
OnDblClick is an event handler of type System.Classes.TNotifyEvent.</docstr>
      </event>
      <event name="OnDestroy">
        <docstr>Occurs when the form is destroyed.
Use OnDestroy to perform special processing when the form is destroyed. Either implement this event or override the destructor of the class, but not both. This event should destroy any objects created in the OnCreate event.</docstr>
      </event>
      <event name="OnDeactivate">
        <docstr>Occurs when the form loses focus.
Use OnDeactivate to perform special processing when the active form becomes inactive and another form in the same application becomes the active one. If activation goes to another application, this event is not triggered. To determine whether another application has become active, use the TApplication object&apos;s OnDeactivate event.

Note: OnDeactivate is called differently than described, when the form&apos;s parent is set to another component (for example, a panel).</docstr>
      </event>
      <event name="OnDragDrop">
        <docstr>Occurs when the user drops an object being dragged.
Use the OnDragDrop event handler to specify what happens when the user drops an object. The Source parameter of the OnDragDrop event is the object being dropped, and the Sender is the control on which the object is being dropped. The X and Y parameters are the coordinates of the mouse positioned over the control.
OnDragDrop is an event handler of type TDragDropEvent.</docstr>
      </event>
      <event name="OnDragOver">
        <docstr>Occurs when the user drags an object over a control.
Use an OnDragOver event to signal that the control can accept a dragged object so the user can drop or dock it.
Within the OnDragOver event handler, change the Accept parameter to False to reject the dragged object. Leave Accept as True to allow the user to drop or dock the dragged object on the control.
To change the shape of the cursor, indicating that the control can accept the dragged object, change the value of the DragCursor property for the control before the OnDragOver event occurs. 
The Source is the object being dragged, the Sender is the potential drop or dock site, and X and Y are screen coordinates in pixels. The State parameter specifies how the dragged object is moving over the control.

Note: Within the OnDragOver event handler, the Accept parameter defaults to True. However, if an OnDragOver event handler is not supplied, the control rejects the dragged object, as if the Accept parameter were changed to False.
OnDragOver is an event handler of type TDragOverEvent.</docstr>
      </event>
      <event name="OnHelp">
        <docstr>Occurs when the form receives a request for Help.
Write an OnHelp event handler to perform special processing when the user requests Help. The HelpContext and HelpJump methods automatically trigger the OnHelp event.
The THelpEvent type has the following parameters: CallHelp, Command, and Data.
Set CallHelp to true if the application should still invoke the Help system after the event. Set CallHelp to false to prevent the default response given by the Help system. All application Help methods go through OnHelp. The application calls the Help system only if OnHelp&apos;s CallHelp parameter is true or if no OnHelp event handler is assigned.
The event handler returns True if it succeeds, False if it fails.
The possible values for the Data parameter depend upon the value of the Command parameter. To find the possible values of the Command and Data parameters, see the appropriate HTMLHelp topics in the MSDN Library.
In order for the OnHelp event handler to work properly, insert in the uses clause of your application the Vcl.HtmlHelpViewer or another unit that provides an interface to the external Help viewer to use. The Vcl.HtmlHelpViewer unit provides a Delphi interface to the HTMLHelp Windows native Help handling function. For C++, you need to include the HTMLHelpViewer.hpp header file.</docstr>
      </event>
      <event name="OnHide">
        <docstr>Occurs when the form is hidden (that is, when its Visible property is set to false).
Use OnHide to perform special processing when the form is hidden (that is, when the form&apos;s Visible property is set to false).</docstr>
      </event>
      <event name="OnKeyDown">
        <docstr>Occurs when a user presses any key while the control has focus.
Use the OnKeyDown event handler to specify special processing to occur when a key is pressed. The OnKeyDown handler can respond to keyboard keys, including function keys and keys combined with the SHIFT, ALT, and CTRL keys, and pressed mouse buttons.

Note: TCheckBox does not fire OnKeyDown events for arrow keys.
OnKeyDown is an event handler of type Vcl.Controls.TKeyEvent.  See TKeyEvent for a description of the parameters.
An application gets Windows WM_KEYDOWN messages for all keys when the user presses a key. These messages indirectly fire the OnKeyDown event. Setting the Key parameter to #0 prevents any further processing of this message. But for keys that generate characters Windows also produces WM_CHAR. At the time your OnKeyDown event fires, the WM_CHAR message for the key will already be in the message queue. Setting Key to #0 does not stop it from being delivered, so it fires the OnKeyPress event. If you set the Key to #0, OnKeyPress will be prevented from being fired only for keys that do not have chars. For keys that represent characters, OnKeyPress will continue to be fired. 
This method of organizing key processing has advantages. Code that only deals with characters, including control characters like #13 for carriage return, #3 for CTRL-C, and so on, should go into the OnKeyPress event. Code that deals with keys that do not generate characters should be put into the OnKeyDown event.</docstr>
      </event>
      <event name="OnKeyPress">
        <docstr>Occurs when a key is pressed.
Use the OnKeyPress event handler to make something happen as a result of a single character key press. 
The Key parameter in the OnKeyPress event handler is of type Char; therefore, the OnKeyPress event registers the ASCII character of the key pressed. Keys that do not correspond to an ASCII Char value (SHIFT or F1, for example) do not generate an OnKeyPress event. Key combinations (such as SHIFT+A) generate only one OnKeyPress event (for this example, SHIFT+A results in a Key value of &quot;A&quot; if Caps Lock is off). To respond to non-ASCII keys or key combinations, use the OnKeyDown or OnKeyUp event handler. 
An application gets Windows WM_KEYDOWN messages for all keys when the user presses a key. These messages indirectly fire the OnKeyDown event. Setting the Key parameter to #0 prevents any further processing of this message. But for keys that generate characters Windows also produces WM_CHAR. At the time your OnKeyDown event fires, the WM_CHAR message for the key will already be in the message queue. Setting Key to #0 does not stop it from being delivered, so it fires the OnKeyPress event. If you set the Key to #0, OnKeyPress will be prevented from being fired only for keys that do not have chars. For keys that represent characters, OnKeyPress will continue to be fired. 
This method of organizing key processing has advantages. Code that only deals with characters, including control characters like #13 for carriage return, #3 for CTROL-C, and so on, should go into the OnKeyPress event. Code that deals with keys that do not generate characters should be put into the OnKeyDown event. 
OnKeyPress is an event handler of type Vcl.Controls.TKeyPressEvent.</docstr>
      </event>
      <event name="OnKeyUp">
        <docstr>Occurs when the user releases a key that was pressed.
Use the OnKeyUp event handler to provide special processing that occurs when a key is released. The OnKeyUp handler can respond to all keyboard keys, keys that represent characters, function keys, and keys combined with the SHIFT, ALT, and CTRL keys.
If Key is set to #0, any further processing of the OnKeyUp event will be prevented. 
OnKeyUp is an event handler of type Vcl.Controls.TKeyEvent.  See TKeyEvent for a description of the parameters.</docstr>
      </event>
      <event name="OnMouseActivate">
        <docstr>Occurs when the user presses a mouse button with the mouse pointer over a control and the parent form is not active.
Use the OnMouseActivate event handler to implement any special processing that should occur as a result of pressing a mouse button on a control when the parent top-level form is not active.
The event type is:

TMouseActivateEvent = procedure (Sender: TObject; Button: TMouseButton; ShiftState: TShiftState;
X, Y: Integer; HitTest: Integer; var MouseActivate: TMouseActivate) of object;

When you click a control and the parent top-level form is not active, this event fires on the control that the mouse cursor is over. MouseActivate is a protected virtual function in TControl. MouseActivate can be overridden in custom control descendants to provide special built-in processing of the OnMouseActivate events. If you leave the default value of MouseActivate as maDefault, the parent control fires the OnMouseActivate event and repeats the process all the way up to the top-level form. If no control in the chain sets the value of MouseActivate, the behavior is the same as if a control set TMouseActivate to maActivate. At any point, a control can set the value of TMouseActivate and the parent processing stops. 
Some controls set focus to themselves when they get a button down message so, in some cases, setting maNoActivate appears to have no effect. For instance, a TButton control sets focus to itself in the WM_LBUTTONDOWN message regardless of whether or not TMouseActivate is set to maNoActivate. In this case, setting maNoActivateAndEat will work because the top-level form is not activated and the WM_LBUTTONDOWN message is suppressed. 
The HitTest parameter is the hit test value obtained from the WM_NCHITTEST message. See Windows.pas for valid values and their meanings. In most cases this value will be HTCLIENT, which means that the user clicked in the client area of a control. However, in the case of a top-level form, this can take other values such as HTCAPTION or HTBOTTOM. This allows the code to decide which value to set for MouseActivate, based on the HitTest code. For example, the following code in the OnMouseActivate event handler for a TForm forces the user to click into a non-client area to activate the form: 

if HitTest = HTCLIENT then
MouseActivate�:= maNoActivateAndEat;

Even though this event is tied to how Windows processes WM_MOUSEACTIVATE, the actual handling of the message is done at the TControl level, which is the point in the VCL hierarchy where the control has no window handle. The OnMouseActivate event is then simulated because all the TControl descendants also have OnMouseDown, OnMouseMove, and OnMouseUp events. This information is applicable to both VCL Win32 and VCL.NET.</docstr>
      </event>
      <event name="OnMouseDown">
        <docstr>Occurs when the user presses a mouse button with the mouse pointer over a control.
Use the OnMouseDown event handler to implement any special processing that should occur as a result of pressing a mouse button.
The OnMouseDown event handler can respond to left, right, or center mouse button presses and shift key plus mouse-button combinations. Shift keys are the SHIFT, CTRL, and ALT keys. X and Y are the pixel coordinates of the mouse pointer in the client area of the Sender.
OnMouseDown is an event handler of type Vcl.Controls.TMouseEvent.</docstr>
      </event>
      <event name="OnMouseMove">
        <docstr>Occurs when the user moves the mouse pointer while the mouse pointer is over a control.
Use the OnMouseMove event handler to respond when the mouse pointer moves after the control has captured the mouse.
Use the Shift parameter of the OnMouseMove event handler to determine the state of the shift keys and mouse buttons. Shift keys are the SHIFT, CTRL, and ALT keys or shift key-mouse button combinations. X and Y are pixel coordinates of the new location of the mouse pointer in the client area of the Sender.
OnMouseMove is an event handler of type Vcl.Controls.TMouseMoveEvent.</docstr>
      </event>
      <event name="OnMouseUp">
        <docstr>Occurs when the user releases a mouse button that was pressed with the mouse pointer over a component.
Use an OnMouseUp event handler to implement special processing when the user releases a mouse button.
The OnMouseUp event handler can respond to left, right, or center mouse button presses and shift key plus mouse-button combinations. Shift keys are the SHIFT, CTRL, and ALT keys. X and Y are the pixel coordinates of the mouse pointer in the client area of the Sender.
OnMouseUp is an event handler of type Vcl.Controls.TMouseEvent.</docstr>
      </event>
      <event name="OnPaint">
        <docstr>Occurs when the form is redrawn.
Use OnPaint to perform special processing when the form is redrawn. Any special painting on the form should be done in this event. OnPaint occurs before any controls on the form are painted.
To determine which portions of the form&apos;s canvas need to be repainted, use the ClipRect property of the canvas.
If you use the form&apos;s Canvas property outside the OnPaint event, it will be erased and drawn-over by the next OnPaint event.</docstr>
      </event>
      <event name="OnResize">
        <docstr>Occurs immediately after the control is resized.
Use OnResize to make any final adjustments after a control is resized.
To modify the way a control responds when an attempt is made to resize it, use OnCanResize or OnConstrainedResize.

Note: Some controls call this event handler when the control is first created.
OnResize is an event handler of type System.Classes.TNotifyEvent.</docstr>
      </event>
      <event name="OnShortCut">
        <docstr>Occurs when the user presses a key (before the OnKeyDown event).
Use OnShortCut to dispatch shortcut keystrokes before the form handles them. When the user presses a key, the form can dispatch it as a shortcut key instead of allowing the standard keystroke processing (OnKeyDown, OnKeyPress, and OnKeyUp). Built-in shortcut processing is provided for menu shortcuts and actions associated with the form. OnShortCut allows the form to implement additional shortcuts.
If the OnShortCut implements a response to the keystroke, set the Handled parameter of the event handler to true. This prevents the keystroke from being passed on to menus or actions associated with the form. It also prevents the standard keystroke processing in the same way that a menu or action shortcut does.</docstr>
      </event>
      <event name="OnShow">
        <docstr>Occurs when the form is shown (that is, when its Visible property is set to true).
Use OnShow to perform special processing when the form is shown (that is, when the form&apos;s Visible property is set to true).</docstr>
      </event>
      <constructor name="Create">
        <docstr>Creates and initializes a new TForm object.
Use Create to instantiate a TForm object or descendant of TForm at runtime. AOwner is the owner of the TCustomForm object.
For descendants of TCustomForm that are not TForm objects, use CreateNew instead. Calling Create for a TCustomForm descendant that is not a TForm will raise an exception.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Removes the form from memory.
Do not call Destroy. Instead, call Release, which indirectly produces a call to the Free method, which in turn calls Destroy.</docstr>
      </destructor>
      <procedure name="ScaleForCurrentDPI">
        <docstr>Checks if there is a change in Dpi and performs the necessary changes to scale all the controls for the new Dpi.</docstr>
      </procedure>
      <procedure name="ScaleForPPI">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Close">
        <docstr>Closes the form.
Call Close to close a form.
Attempts to close a form can be aborted by the CloseQuery event dispatcher or the OnCloseQuery event handler.

Note:  When the main form of the application closes, the application terminates.</docstr>
      </procedure>
      <function name="CloseQuery">
        <docstr>Close attempt event dispatcher.
CloseQuery is called automatically when an attempt is made to close the form. CloseQuery can allow the form to close by returning true, or prevent the form from closing by returning false.
As implemented in TCustomForm, CloseQuery polls any MDI children by calling their CloseQuery methods. If no child form aborts the close, CloseQuery then calls the OnCloseQuery event handler, if it exists, to determine if the close should be allowed. If no such event handler exists, CloseQuery returns true.</docstr>
      </function>
      <procedure name="DefaultHandler">
        <docstr>Provides message handling for all messages that the form does not fully process.
Override DefaultHandler to change the default message handling for the form. This is seldom necessary because messages can be handled by creating message methods.
DefaultHandler passes any otherwise-unhandled messages to the form&apos;s window procedure by calling the CallWindowProc OS function.

Note:  In Delphi code, calling inherited in a message-handling method results in a call to the ancestor&apos;s DefaultHandler method unless that ancestor specifies a handler for the message.</docstr>
      </procedure>
      <procedure name="DefocusControl">
        <docstr>Removes focus from a control on the form.
Use DefocusControl to remove focus from a control on the form. This method is used internally by the VCL.
Control is the control from which to remove focus. If Control is the form&apos;s active control, DefocusControl sets the form&apos;s ActiveControl property to nil (Delphi) or NULL (C++).
Removing specifies whether to set focus to the control&apos;s parent.</docstr>
      </procedure>
      <procedure name="Dock">
        <docstr>Handles automatic docking of the form into other windows.
Do not call Dock in application code. It is called automatically when the form is released on a docking site that will accept it. To dock a form programmatically, use the ManualDock method instead.</docstr>
      </procedure>
      <procedure name="FocusControl">
        <docstr>Sets focus to a control on the form.
Use FocusControl to set focus to a control on the form.
Control is a TWinControl object encapsulating the control on which to set focus. FocusControl sets the ActiveControl property.</docstr>
      </procedure>
      <procedure name="GetChildren">
        <docstr>Returns the &quot;child&quot; components of the form; that is, those components that return the form from their GetParentComponent method.
The component streaming system calls GetChildren to request that the form execute a callback for every child component in the form. The callback must execute in creation order (the order the child components appear in the form file). A child component is defined as any component that returns this form from its GetParentComponent method.
Proc is the callback to execute for every child component.
Root specifies the top-level component (such as a form or data module) that is currently being loaded or saved.
In TCustomForm, GetChildren first calls the inherited method, which executes Proc for every control that lists the form as its Parent. Then, if the Root parameter identifies this form, GetChildren executes Proc for every child component that does not have a Parent.</docstr>
      </procedure>
      <function name="GetFormImage">
        <docstr>Returns a bitmap of the form.
Use the GetFormImage method to obtain a bitmap of the form.</docstr>
      </function>
      <procedure name="Hide">
        <docstr>Hides the form.
Hide sets the Visible property to false.</docstr>
      </procedure>
      <function name="IsShortCut">
        <docstr>Processes shortcut keys when the form has focus.
IsShortCut is called automatically when the user presses a key while the form has focus. It allows the form to dispatch shortcut keys and bypass the standard keystroke processing (OnKeyDown, OnKeyPress, and OnKeyUp events).
The Message parameter encapsulates the Windows message describing the keypress. If a shortcut for the key exists, IsShortCut executes the appropriate command and returns true. Otherwise IsShortCut returns false.
IsShortCut generates an OnShortCut event to allow the developer to insert shortcuts for the form. If the keystroke is not handled in an OnShortCut event handler, IsShortCut checks for any shortcuts associated with the form&apos;s menus and actions.</docstr>
      </function>
      <procedure name="MakeFullyVisible">
        <docstr>Ensures that the form is fully visible on a specified monitor.
Call MakeFullyVisible to ensure that the form does not appear split over more than one monitor in a multi-monitor application.
AMonitor is the monitor on which the form should appear. If AMonitor is nil (Delphi) or NULL (C++), MakeFullyVisible uses the Monitor property.
MakeFullyVisible checks whether the form fits entirely on the specified monitor. If not, it repositions the form so that it fits, if possible.</docstr>
      </procedure>
      <procedure name="MouseWheelHandler">
        <docstr>Directs mouse wheel messages to the appropriate control.
MouseWheelHandler is called automatically when the form or any windowed control contained in the form receives a message from a mouse wheel. The Message parameter encapsulates the message.
As implemented in TCustomForm, MouseWheelHandler performs no special processing, but simply redirects the message to the active control by calling its Perform method. By default, the Perform method generates the appropriate mouse wheel events.</docstr>
      </procedure>
      <procedure name="Print">
        <docstr>Prints the form.
Call Print to print the form. Print uses the GetFormImage method to obtain a bitmap of the form and draws that to the printer&apos;s HDC.</docstr>
      </procedure>
      <procedure name="RecreateAsPopup">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Release">
        <docstr>Destroys the form and frees its associated memory.
Use Release to destroy the form and free its associated memory.
Release does not destroy the form until all event handlers of the form and event handlers of components on the form have finished executing. Release also guarantees that all messages in the form&apos;s event queue are processed before the form is released. Any event handlers for the form or its children should use Release instead of Free (Delphi) or delete (C++). Failing to do so can cause a memory access error.

Note: Release returns immediately to the caller. It does not wait for the form to be freed before returning.</docstr>
      </procedure>
      <procedure name="SendCancelMode">
        <docstr>Cancels modes on the form.
Use SendCancelMode to release the mouse capture and cancel scroll bar input and menu processing on the form.</docstr>
      </procedure>
      <procedure name="SetFocus">
        <docstr>Sets focus to the form.
Use SetFocus to give the form input focus. SetFocus calls the SetFocus method of the active control, if one exists. To determine whether the form has focus, use the Active property.</docstr>
      </procedure>
      <function name="SetFocusedControl">
        <docstr>Sets focus to a control on the form.
Use SetFocusedControl to give a control on the form input focus. SetFocusedControl returns false if the Control specified by the Control parameter was already in the process of receiving focus, true otherwise.

Note:  A return value of true does not indicate the control has successfully received input focus. If the Control can&apos;t have focus (for example, if it is not visible), SetFocusedControl will still return true, indicating that an attempt was made.</docstr>
      </function>
      <procedure name="Show">
        <docstr>Shows the form.
Use Show to set the form&apos;s Visible property to true and to bring the form to the front of other forms on the screen.</docstr>
      </procedure>
      <function name="ShowModal">
        <docstr>Shows a form as a modal dialog.
Use ShowModal to show a form as a modal form. A modal form is one where the application can&apos;t continue to run until the form is closed. Thus, ShowModal does not return until the form closes. When the form closes, it returns the value of the ModalResult property.
To close a modal form, set its ModalResult property to a nonzero value.

Note:  If the form contains buttons with a ModalResult property set to a value other than mrNone, the form automatically closes when the user clicks one of those buttons and returns the ModalResult value as the return value of ShowModal.
You can check the return value against common return values using the global IsAbortResult, IsAnAllResult, IsNegativeResult, or IsPositiveResult functions.</docstr>
      </function>
      <function name="WantChildKey">
        <docstr>Indicates whether the form processes keyboard input for a control it owns.
WantChildKey is called by any control that the form owns when the control receives keyboard input. If WantChildKey returns true, the control performs no further processing in response to the keyboard input, instead deferring to its parent form to respond to the keystroke. In its default implementation, WantChildKey always returns false; it is overridden in TActiveForm to implement certain ActiveX functionality.</docstr>
      </function>
      <procedure name="set_PopupParent">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="AfterConstruction">
        <docstr>Construction event dispatcher.
AfterConstruction is the dispatcher for the event that occurs immediately after the form object&apos;s construction. As implemented in TCustomForm, AfterConstruction calls the OnCreate event handler, provided the OldCreateOrder property is false.</docstr>
      </procedure>
      <procedure name="BeforeDestruction">
        <docstr>Destruction event dispatcher.
BeforeDestruction is the dispatcher for the event that occurs immediately before the form object&apos;s destruction. As implemented in TCustomForm, BeforeDestruction calls the OnDestroy event handler, provided the OldCreateOrder property is false.</docstr>
      </procedure>
      <procedure name="UpdateDesignerCaption">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <property name="Active">
        <docstr>Specifies whether the form has focus.
Use Active to determine whether the form has focus. The Active Form receives all keyboard input. If it has a title bar, it is drawn using the active colors specified in the Control panel.
If Active is true , the form has focus; if Active is false, the form does not have focus.</docstr>
      </property>
      <property name="ActiveControl">
        <docstr>Specifies the control that has focus on the form.
Use ActiveControl to get or set the control that has focus on the form. Only one control can have focus at a given time in an application.
If the form does not have focus, ActiveControl is the control on the form that will receive focus when the form receives focus.

Note:  When focus shifts to another control, ActiveControl is updated before the OnExit event occurs.</docstr>
      </property>
      <property name="ActiveOleControl">
        <docstr>Specifies the OLE control on the form that reacts to changes in focus.
Use ActiveOleControl to get or set an OLE control on the form that reacts to changes in focus.
If ActiveOleControl is not nil (Delphi) or NULL (C++), the user interface for the specified OLE control is deactivated when it is not focused. Also, when the form receives or loses focus, the document window for the specified OLE control is activated or deactivated respectively.</docstr>
      </property>
      <property name="BorderStyle">
        <docstr>Specifies the appearance and behavior of the form border.
Use BorderStyle to get or set the appearance and behavior of the form border. BorderStyle can be any of the following TForm BorderStyle values:





Value

Meaning



bsDialog



Not resizable; no minimize/maximize menu




bsSingle



Not resizable; minimize/maximize menu




bsNone



Not resizable; no visible border line




bsSizeable



Standard resizable border




bsToolWindow



like bsSingle but with a smaller caption




bsSizeToolWin



like bsSizeable with a smaller caption





Note:  Changing the border style of an MDI child form to bsDialog or bsNone has no effect.</docstr>
      </property>
      <property name="Canvas">
        <docstr>Provides access to the drawing area of the form.
Use TCanvas to draw on the client area of the form. Canvas is often used in the OnPaint event handler.</docstr>
      </property>
      <property name="Designer">
        <docstr>Specifies the designer interface for the form.
The Designer property is used internally at design time. Never assign a value to this property. This is done automatically by the form designer. Only use this property when designing classes for use in the form designer, such as property editors and component editors.</docstr>
      </property>
      <property name="DropTarget">
        <docstr>Specifies whether the form is the target of a drag-and-drop operation.
Use DropTarget to determine whether the form is currently the target of a drag-and-drop operation.</docstr>
      </property>
      <property name="FormState">
        <docstr>Indicates transitional state information about the form.
Read FormState to determine the state of the form. FormState indicates when the form is in various transitional states or when certain Windows operations have occurred. The following table lists the values that can be included in a form&apos;s state:





Value

Meaning



fsCreating



The form&apos;s constructor is currently executing.




fsVisible



The form&apos;s window is visible. This state is used to update the Visible property.




fsShowing



The form&apos;s WindowState property is changing. This state is used to prevent WindowState changes from interfering with a transition that is in progress.




fsModal



The form was created as a modal window.




fsCreatedMDIChild



The form is an MDI parent window. This state is only set once the MDI client window has been created.




fsActivated



The form has received a CM_ACTIVATE message (because it received focus or the application became active) but has not yet called the Activate method to generate an OnActivate event.</docstr>
      </property>
      <property name="GlassFrame">
        <docstr>Accesses the Glass Frame under Windows Vista, Windows 7, or later Windows operating systems.
Use GlassFrame to make your forms Windows Vista or Windows 7 Aero-compatible, displaying a glass effect. 
GlassFrame is a property of a TGlassFrame object created automatically for any form. 

Note: The property is only available for Windows Vista or Windows 7 with Aero. Otherwise, the Glass Frame is ignored.</docstr>
      </property>
      <property name="CustomTitleBar">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="HelpFile">
        <docstr>Specifies the name of the Help file the form uses to display the Help from.
If your form should have a Help file different from the default Help file of the application specified using the TApplication.HelpFile property of the global TApplication type object, then use the HelpFile property of the form to specify the name of the Help file the form will use to display the Help from. 
The Help system specified by TApplication.HelpSystem displays Help topics from the Help file specified by the HelpFile property of the form when the form has the focus.</docstr>
      </property>
      <property name="KeyPreview">
        <docstr>Specifies whether the form should receive keyboard events before the active control.
If KeyPreview is true, keyboard events occur on the form before they occur on the active control. (The active control is specified by the ActiveControl property.) 
If KeyPreview is false, keyboard events occur only on the active control.
Navigation keys (Tab, BackTab, the arrow keys, and so on) are unaffected by KeyPreview because they do not generate keyboard events. Similarly, when a button has focus or when its Default property is true, the Enter key is unaffected by KeyPreview because it does not generate a keyboard events.
KeyPreview is false by default.</docstr>
      </property>
      <property name="Menu">
        <docstr>Specifies the form&apos;s main menu.
Use Menu to get or set the form&apos;s main menu. At design time, Menu is set to the first TMainMenu component added to the form.</docstr>
      </property>
      <property name="ModalResult">
        <docstr>Represents the return value of a form that is used as a modal dialog.
Use ModalResult to close the form when it is displayed modally.
By default, ModalResult is mrNone. Set ModalResult to any nonzero value to close the form. The value assigned to ModalResult becomes the return value of the ShowModal function call used to display the form.

Note: This property is modified automatically by some components such as the TButton control.
Tip: If you call the Close method from a modal form, then ModalResult is automatically set to mrCancel.</docstr>
      </property>
      <property name="Monitor">
        <docstr>Provides access to the monitor on which the form appears.
Use Monitor to access information about the monitor on which the form appears if the application runs on a multi-monitor system. The monitor is determined by the DefaultMonitor property.</docstr>
      </property>
      <property name="OleFormObject">
        <docstr>Specifies the IOleForm interface for an in-place OLE object contained in the form.
OleFormObject is used to communicate resize and destroy notifications when a form is used as a frame for an in-place OLE object.</docstr>
      </property>
      <property name="PopupMode">
        <docstr>Controls how the top-level form behaves with respect to Window&apos;s WS_POPUP style.
The PopupMode property controls how the top-level form behaves with respect to Window&apos;s WS_POPUP style. A window that has the WS_POPUP style is always above its &quot;owner&quot; in Z-order. You can use the PopupMode property in conjunction with the PopupParent property to avoid the appearance of a hung application caused by a modal dialog showing up behind another form on the screen.

Note: Using the PopupMode property is similar to specifying fsStayOnTop for the FormStyle property, but allows better control over the layering. 
The PopupMode property is automatically set to pmAuto when the ShowModal method is called. However, this causes the window handle to be recreated, which is not usually desirable. To avoid the re-creation of window handles, you can explicitly set the PopupMode property to pmAuto prior to calling the ShowModal method (such as at design time). 
Set the PopupMode property to pmExplicit for non-modal design windows such as tool palettes and other floating tool windows. This causes the windows to always remain on top of the main form. In the case of a snapped together design (in which the window is docked to the main form), the design window remains on top of the designer.

Note: For undocked windows, the design window remains above the main form, allowing other top-level forms to obscure the design window. 
Set the PopupMode property to pmNone if you want the pop-up window to have the pre-Delphi 8 behavior (except for the ShowModal item mentioned above).
You can force the Z-Ordering of your forms and create a &quot;stacked&quot; appearance that the user cannot change by setting the PopupParent property to an explicit TCustomForm. If the PopupMode property is pmExplicit and PopupParent is nil, then the Application.MainForm is implicitly used as the PopupParent. If no Application.MainForm is assigned, then Application.Handle is used as the PopupParent. If the PopupMode property is set to pmAuto, Screen.ActiveForm is used as the PopupParent.</docstr>
      </property>
      <property name="Scaled">
        <docstr>Specifies whether the form is sized according to the value of the PixelsPerInch property.
Scaled determines whether the form adjusts itself to differences between the font used at design time and the current system font used by a system at runtime. If Scaled is true, the form resizes itself and all its child controls to maintain the relationship between the size of controls and the height of text displayed in the default font. If Scaled is false, no such resizing occurs.
By setting Scaled to true, the form can adjust to fonts that are not scalable (that is, fonts that only supply discrete point sizes) or to differences such as forms designed using small fonts at design time that are run on systems that use large fonts.
The degree of resizing is determined by the PixelsPerInch property, which measures the proportion of the font on the system used when designing the form.</docstr>
      </property>
      <property name="ScreenSnap">
        <docstr>Specifies whether form snaps to edge of screen.
ScreenSnap determines whether the edges of the form snap to the edge of the screen when the user moves the form. To control the snap distance, set the SnapBuffer property.</docstr>
      </property>
      <property name="SnapBuffer">
        <docstr>Specifies distance for screen snap.
If ScreenSnap is true, SnapBuffer determines the maximum number of pixels that be between the form edge and the screen edge before the form snaps to the screen edge.</docstr>
      </property>
      <property name="WindowState">
        <docstr>Represents how the form appears on the screen.
Set WindowState to minimize, maximize, or restore the form window. Read WindowState to determine whether the form is minimized, maximized, or in a normal state.</docstr>
      </property>
      <property name="PopupParent">
        <docstr>Sets an order for stacked forms that users cannot change.
If the PopupMode property is set to pmExplicit and PopupParent is nil, then the Application.MainForm is implicitly used as the PopupParent. If no Application.MainForm is assigned, then Application.Handle is used as the PopupParent.
If the PopupMode property is set to pmAuto, Screen.ActiveForm is used as the PopupParent property.</docstr>
      </property>
      <property name="TaskbarHandler">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
      <property name="Left">
        <docstr>Specifies the horizontal coordinate of the left edge of a component relative to its parent.
Vcl.Forms.TCustomForm.Left inherits from Vcl.Controls.TControl.Left. All content below this line refers to Vcl.Controls.TControl.Left.
Specifies the horizontal coordinate of the left edge of a component relative to its parent.
Use the Left property to determine where the left side of the control begins or to reposition the left side of the control.
If the control is contained in another control, the Left and Top properties are relative to the parent control. If the control is contained directly by the form, the property values are relative to the form. For forms, the value of the Left property is relative to the screen in pixels.</docstr>
      </property>
      <property name="Top">
        <docstr>Specifies the Y coordinate of the upper-left corner of a control, relative to its parent or containing control in pixels.
Vcl.Forms.TCustomForm.Top inherits from Vcl.Controls.TControl.Top. All content below this line refers to Vcl.Controls.TControl.Top.
Specifies the Y coordinate of the upper-left corner of a control, relative to its parent or containing control in pixels.
Use Top to locate the top of the control or reposition the control to a different Y coordinate. The Top property, like the Left property, is the position of the control relative to its container. Thus, if a control is contained in a TPanel, the Left and Top properties are relative to the panel. If the control is contained directly by the form, it is relative to the form. For forms, the value of the Top property is relative to the screen in pixels.</docstr>
      </property>
    </members>
  </class>
  <class unit="Vcl.Forms" name="TForm">
    <docstr>TForm represents a standard application window (form).
When you create forms in the Form designer at design time, they are implemented as descendants of TForm. Forms can represent the application&apos;s main window, or dialog boxes, or MDI children. A form can contain other objects, such as TButton, TCheckBox, and TComboBox objects.
Examples of forms include TLoginDialog and TPasswordDialog objects.</docstr>
    <members>
      <procedure name="ArrangeIcons">
        <docstr>Arranges the icons of minimized MDI child forms.
Use ArrangeIcons to arrange the icons of minimized MDI child forms so they are evenly spaced and don&apos;t overlap.
ArrangeIcons works only if the form is an MDI parent form (that is, if the form&apos;s FormStyle property is fsMDIForm).</docstr>
      </procedure>
      <procedure name="Cascade">
        <docstr>Arranges MDI child forms so they overlap.
Use Cascade to arrange MDI child forms so they overlap.
Cascade works only if the form is an MDI parent form (that is, if the form&apos;s FormStyle property is fsMDIForm).</docstr>
      </procedure>
      <procedure name="Next">
        <docstr>Activates the next child form in the form sequence.
Use Next to change the active child form of an MDI parent. For example, if you have three child forms within a parent form and Form2 is the active form, the Next method makes Form3 the active form. Calling Next again makes Form4 active. The next time your application calls Next, the sequence starts over again and Form2 becomes the active form once again.
The Next method applies only to forms that are MDI parent forms (have a FormStyle property value of fsMDIForm).</docstr>
      </procedure>
      <procedure name="Previous">
        <docstr>Activates the previous MDI child form in the form sequence.
Use Previous to change the active child form of an MDI parent. For example, if you have three child forms within a parent form and Form4 is the active form, the Previous method makes Form3 the active form. Calling Previous again makes Form2 active. The next time your application calls Previous, the sequence starts over again and Form4 becomes the active form once again.
The Previous method applies only to forms that are MDI parent forms (have a FormStyle property value of fsMDIForm).</docstr>
      </procedure>
      <procedure name="Tile">
        <docstr>Arranges MDI child forms so that they are all the same size.
Use Tile to arrange MDI child forms so that they are all the same size. Tiled forms completely fill up the client area of the parent form. How the forms arrange themselves depends upon the values of their TileMode properties.
Tile works only if the form is an MDI parent form (that is, if the form&apos;s FormStyle property is fsMDIForm).</docstr>
      </procedure>
      <event name="OnCanResize">
        <docstr>Occurs when an attempt is made to resize the control.
Use OnCanResize to adjust the way a control is resized. If necessary, change the new width and height of the control in the OnCanResize event handler. The OnCanResize event handler also allows applications to indicate that the entire resize should be aborted.
If there is no OnCanResize event handler, or if the OnCanResize event handler indicates that the resize attempt can proceed, the OnCanResize event is followed immediately by an OnConstrainedResize event.
OnCanResize is an event handler of type Vcl.Controls.TCanResizeEvent.</docstr>
      </event>
      <event name="OnClick">
        <docstr>Occurs when the user clicks the control.
Use the OnClick event handler to respond when the user clicks the control. If the control has an associated action, and that action has an OnExecute method, the action&apos;s OnExecute method responds to click events unless it is superseded by an OnClick event handler.
Usually, OnClick occurs when the user presses and releases the left mouse button with the mouse pointer over the control. This event can also occur when:

The user selects an item in a grid, outline, list, or combo box by pressing an arrow key.
The user presses the SPACEBAR while a button or check box has focus.
The user presses ENTER when the active form has a default button (specified by the Default property).
The user presses ESC when the active form has a cancel button (specified by the Cancel property).
The user presses the accelerator key for a button or check box. For example, if the value of the Caption property of a check box is &apos;&amp;Bold&apos;, the B is underlined at run time and the OnClick event of the check box is triggered when the user presses Alt+B. However, focus does not move to the control in these instances.
The Checked property of a radio button is set to True.
The value of the Checked property of a check box is changed.
Note: When you change the value of the Checked property programmatically, the OnClick event of the check box control occurs. Do not modify the value of the Checked property in the event handler of the OnClick event, because that leads into a deadlock situation.
The Click method of a menu item is called.
For a form, an OnClick event occurs when the user clicks a disabled component or in a blank area of the form.
OnClick is an event handler of type TNotifyEvent.</docstr>
      </event>
      <event name="OnDblClick">
        <docstr>Occurs when the user double-clicks the left mouse button when the mouse pointer is over the control.
Use the OnDblClick event to respond to mouse double-clicks.
OnDblClick is an event handler of type System.Classes.TNotifyEvent.</docstr>
      </event>
      <event name="OnDragDrop">
        <docstr>Occurs when the user drops an object being dragged.
Use the OnDragDrop event handler to specify what happens when the user drops an object. The Source parameter of the OnDragDrop event is the object being dropped, and the Sender is the control on which the object is being dropped. The X and Y parameters are the coordinates of the mouse positioned over the control.
OnDragDrop is an event handler of type TDragDropEvent.</docstr>
      </event>
      <event name="OnDragOver">
        <docstr>Occurs when the user drags an object over a control.
Use an OnDragOver event to signal that the control can accept a dragged object so the user can drop or dock it.
Within the OnDragOver event handler, change the Accept parameter to False to reject the dragged object. Leave Accept as True to allow the user to drop or dock the dragged object on the control.
To change the shape of the cursor, indicating that the control can accept the dragged object, change the value of the DragCursor property for the control before the OnDragOver event occurs. 
The Source is the object being dragged, the Sender is the potential drop or dock site, and X and Y are screen coordinates in pixels. The State parameter specifies how the dragged object is moving over the control.

Note: Within the OnDragOver event handler, the Accept parameter defaults to True. However, if an OnDragOver event handler is not supplied, the control rejects the dragged object, as if the Accept parameter were changed to False.
OnDragOver is an event handler of type TDragOverEvent.</docstr>
      </event>
      <event name="OnKeyDown">
        <docstr>Occurs when a user presses any key while the control has focus.
Use the OnKeyDown event handler to specify special processing to occur when a key is pressed. The OnKeyDown handler can respond to keyboard keys, including function keys and keys combined with the SHIFT, ALT, and CTRL keys, and pressed mouse buttons.

Note: TCheckBox does not fire OnKeyDown events for arrow keys.
OnKeyDown is an event handler of type Vcl.Controls.TKeyEvent.  See TKeyEvent for a description of the parameters.
An application gets Windows WM_KEYDOWN messages for all keys when the user presses a key. These messages indirectly fire the OnKeyDown event. Setting the Key parameter to #0 prevents any further processing of this message. But for keys that generate characters Windows also produces WM_CHAR. At the time your OnKeyDown event fires, the WM_CHAR message for the key will already be in the message queue. Setting Key to #0 does not stop it from being delivered, so it fires the OnKeyPress event. If you set the Key to #0, OnKeyPress will be prevented from being fired only for keys that do not have chars. For keys that represent characters, OnKeyPress will continue to be fired. 
This method of organizing key processing has advantages. Code that only deals with characters, including control characters like #13 for carriage return, #3 for CTRL-C, and so on, should go into the OnKeyPress event. Code that deals with keys that do not generate characters should be put into the OnKeyDown event.</docstr>
      </event>
      <event name="OnKeyPress">
        <docstr>Occurs when a key is pressed.
Use the OnKeyPress event handler to make something happen as a result of a single character key press. 
The Key parameter in the OnKeyPress event handler is of type Char; therefore, the OnKeyPress event registers the ASCII character of the key pressed. Keys that do not correspond to an ASCII Char value (SHIFT or F1, for example) do not generate an OnKeyPress event. Key combinations (such as SHIFT+A) generate only one OnKeyPress event (for this example, SHIFT+A results in a Key value of &quot;A&quot; if Caps Lock is off). To respond to non-ASCII keys or key combinations, use the OnKeyDown or OnKeyUp event handler. 
An application gets Windows WM_KEYDOWN messages for all keys when the user presses a key. These messages indirectly fire the OnKeyDown event. Setting the Key parameter to #0 prevents any further processing of this message. But for keys that generate characters Windows also produces WM_CHAR. At the time your OnKeyDown event fires, the WM_CHAR message for the key will already be in the message queue. Setting Key to #0 does not stop it from being delivered, so it fires the OnKeyPress event. If you set the Key to #0, OnKeyPress will be prevented from being fired only for keys that do not have chars. For keys that represent characters, OnKeyPress will continue to be fired. 
This method of organizing key processing has advantages. Code that only deals with characters, including control characters like #13 for carriage return, #3 for CTROL-C, and so on, should go into the OnKeyPress event. Code that deals with keys that do not generate characters should be put into the OnKeyDown event. 
OnKeyPress is an event handler of type Vcl.Controls.TKeyPressEvent.</docstr>
      </event>
      <event name="OnKeyUp">
        <docstr>Occurs when the user releases a key that was pressed.
Use the OnKeyUp event handler to provide special processing that occurs when a key is released. The OnKeyUp handler can respond to all keyboard keys, keys that represent characters, function keys, and keys combined with the SHIFT, ALT, and CTRL keys.
If Key is set to #0, any further processing of the OnKeyUp event will be prevented. 
OnKeyUp is an event handler of type Vcl.Controls.TKeyEvent.  See TKeyEvent for a description of the parameters.</docstr>
      </event>
      <event name="OnMouseActivate">
        <docstr>Occurs when the user presses a mouse button with the mouse pointer over a control and the parent form is not active.
Use the OnMouseActivate event handler to implement any special processing that should occur as a result of pressing a mouse button on a control when the parent top-level form is not active.
The event type is:

TMouseActivateEvent = procedure (Sender: TObject; Button: TMouseButton; ShiftState: TShiftState;
X, Y: Integer; HitTest: Integer; var MouseActivate: TMouseActivate) of object;

When you click a control and the parent top-level form is not active, this event fires on the control that the mouse cursor is over. MouseActivate is a protected virtual function in TControl. MouseActivate can be overridden in custom control descendants to provide special built-in processing of the OnMouseActivate events. If you leave the default value of MouseActivate as maDefault, the parent control fires the OnMouseActivate event and repeats the process all the way up to the top-level form. If no control in the chain sets the value of MouseActivate, the behavior is the same as if a control set TMouseActivate to maActivate. At any point, a control can set the value of TMouseActivate and the parent processing stops. 
Some controls set focus to themselves when they get a button down message so, in some cases, setting maNoActivate appears to have no effect. For instance, a TButton control sets focus to itself in the WM_LBUTTONDOWN message regardless of whether or not TMouseActivate is set to maNoActivate. In this case, setting maNoActivateAndEat will work because the top-level form is not activated and the WM_LBUTTONDOWN message is suppressed. 
The HitTest parameter is the hit test value obtained from the WM_NCHITTEST message. See Windows.pas for valid values and their meanings. In most cases this value will be HTCLIENT, which means that the user clicked in the client area of a control. However, in the case of a top-level form, this can take other values such as HTCAPTION or HTBOTTOM. This allows the code to decide which value to set for MouseActivate, based on the HitTest code. For example, the following code in the OnMouseActivate event handler for a TForm forces the user to click into a non-client area to activate the form: 

if HitTest = HTCLIENT then
MouseActivate�:= maNoActivateAndEat;

Even though this event is tied to how Windows processes WM_MOUSEACTIVATE, the actual handling of the message is done at the TControl level, which is the point in the VCL hierarchy where the control has no window handle. The OnMouseActivate event is then simulated because all the TControl descendants also have OnMouseDown, OnMouseMove, and OnMouseUp events. This information is applicable to both VCL Win32 and VCL.NET.</docstr>
      </event>
      <event name="OnMouseDown">
        <docstr>Occurs when the user presses a mouse button with the mouse pointer over a control.
Use the OnMouseDown event handler to implement any special processing that should occur as a result of pressing a mouse button.
The OnMouseDown event handler can respond to left, right, or center mouse button presses and shift key plus mouse-button combinations. Shift keys are the SHIFT, CTRL, and ALT keys. X and Y are the pixel coordinates of the mouse pointer in the client area of the Sender.
OnMouseDown is an event handler of type Vcl.Controls.TMouseEvent.</docstr>
      </event>
      <event name="OnMouseMove">
        <docstr>Occurs when the user moves the mouse pointer while the mouse pointer is over a control.
Use the OnMouseMove event handler to respond when the mouse pointer moves after the control has captured the mouse.
Use the Shift parameter of the OnMouseMove event handler to determine the state of the shift keys and mouse buttons. Shift keys are the SHIFT, CTRL, and ALT keys or shift key-mouse button combinations. X and Y are pixel coordinates of the new location of the mouse pointer in the client area of the Sender.
OnMouseMove is an event handler of type Vcl.Controls.TMouseMoveEvent.</docstr>
      </event>
      <event name="OnMouseUp">
        <docstr>Occurs when the user releases a mouse button that was pressed with the mouse pointer over a component.
Use an OnMouseUp event handler to implement special processing when the user releases a mouse button.
The OnMouseUp event handler can respond to left, right, or center mouse button presses and shift key plus mouse-button combinations. Shift keys are the SHIFT, CTRL, and ALT keys. X and Y are the pixel coordinates of the mouse pointer in the client area of the Sender.
OnMouseUp is an event handler of type Vcl.Controls.TMouseEvent.</docstr>
      </event>
      <event name="OnResize">
        <docstr>Occurs immediately after the control is resized.
Use OnResize to make any final adjustments after a control is resized.
To modify the way a control responds when an attempt is made to resize it, use OnCanResize or OnConstrainedResize.

Note: Some controls call this event handler when the control is first created.
OnResize is an event handler of type System.Classes.TNotifyEvent.</docstr>
      </event>
    </members>
  </class>
  <class unit="Vcl.Forms" name="TMonitor">
    <docstr>TMonitor represents a monitor on which an application runs.
TMonitor represents a monitor that displays the user interface of an application. It introduces properties to describe the dimensions of a single monitor. In addition, the Primary property distinguishes the primary property from other monitors on the system.
When writing multi-monitor applications, use TMonitor to help lay out forms and dialogs so that they are not split over several monitors.
Applications do not create instances of TMonitor. Instead, monitor components for all available monitors are listed by the Monitors property of the global Screen variable. The global Screen variable also provides global information about the monitors on which the application runs, such as screen resolution, available fonts, and so on.</docstr>
    <members>
      <property name="Handle">
        <docstr>Indicates the Windows handle for the monitor.
Read Monitor to obtain a Windows handle for the monitor represented by this TMonitor component. Use this handle for Windows API calls such as GetMonitorInfo.</docstr>
      </property>
      <property name="MonitorNum">
        <docstr>Specifies the index of the monitor in the global screen object&apos;s Monitors list.
The global screen variable maintains a list of all monitors in a multi-monitor application. MonitorNum is the index of this monitor in the list object that is the screen&apos;s Monitors property.
Use MonitorNum to identify a specific monitor when working with multiple monitors.</docstr>
      </property>
      <property name="Left">
        <docstr>Indicates the logical position of the left edge of the monitor.
In multi-monitor applications, the available screen space can span multiple monitors from left to right. Read Left to determine where, in the entire available screen space, this monitor appears. The value of Left is in pixels relative to the left edge of the primary monitor.</docstr>
      </property>
      <property name="Height">
        <docstr>Indicates the vertical size of the monitor in pixels.
Read Height to learn the size of the monitor in pixels. Use this value along with the Top property to calculate how to position objects vertically in multi-monitor applications.

Note:  The Height property does not take into account any task bars or tool bars docked on the monitor. To determine the area on the monitor that is free of such docked windows, use the WorkareaRect property.</docstr>
      </property>
      <property name="Top">
        <docstr>Indicates the logical position of the top edge of the monitor.
In multi-monitor applications, the available screen space can span multiple monitors from top to bottom. Read Top to determine where, in the entire available screen space, this monitor appears. The value of Top is in pixels relative to the top edge of the primary monitor.</docstr>
      </property>
      <property name="Width">
        <docstr>Indicates the horizontal size of the monitor in pixels.
Read Width to learn the size of the monitor in pixels. Use this value along with the Left property to calculate vertical positions for objects in multi-monitor applications.

Note:  The Width property does not take into account any task bars or tool bars docked on the monitor. To determine the area on the monitor that is free of such docked windows, use the WorkareaRect property.</docstr>
      </property>
      <property name="BoundsRect">
        <docstr>Indicates the dimensions of the monitor in pixels.
Read BoundsRect to learn the dimensions of the monitor. BoundsRect gives the dimensions of the monitor in pixels, where (0,0) represents the top-left corner of the primary monitor. 
The top of BoundsRect is given by the Top property, the left edge by the Left property, and the height and width by the Height and Width properties respectively.

Note:  The BoundsRect property does not take into account any task bars or tool bars docked on the monitor. To determine the area on the monitor that is free of such docked windows, use the WorkareaRect property.</docstr>
      </property>
      <property name="WorkareaRect">
        <docstr>Gives the application useable area of the monitor.
WorkareaRect returns a TRect value furnished with the coordinates and dimensions of the work area of the Monitor. On Windows, for example, the application tabs at the screen mean that the Workarea is smaller than the monitor size. 

Note:  The TRect Right and Bottom values are one pixel beyond Workarea boundary. They are given these values to allow for easy calculation of Workarea width and height as (Right-Left) and (Bottom-Top) respectively.</docstr>
      </property>
      <property name="Primary">
        <docstr>Indicates whether this is the primary monitor.
Read Primary to determine whether a monitor is the primary monitor in a multi-monitor application. When Primary is true, the monitor is the primary monitor. The coordinates of other monitors are given in terms of the primary monitor.</docstr>
      </property>
      <property name="PixelsPerInch">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
    </members>
  </class>
  <class unit="Vcl.ComCtrls" name="TCustomTabControl">
    <docstr>TCustomTabControl is the base type for tab control components such as TTabControl and TPageControl.
Use TCustomTabControl as a base class when defining a control that includes a set of notebook style tabs across the top. TCustomTabControl introduces many properties, methods, and events to manage appearance and behavior of the tabs, and to respond when the user selects one of the tabs.

Note:  When using one of the page controls, if you want to restrict a user from switching to a tab, you cannot set TTabSheet.Enabled to false to accomplish that restriction. Instead, use the OnChanging event to prevent the user from selecting a tab.</docstr>
    <members>
      <procedure name="AdjustClientRect">
        <docstr>Calculates the control&apos;s display area given a rectangle.
AdjustClientRect is called internally when the tab control needs accurate information on where to place child controls within the client area. As implemented in TCustomTabControl, returns the DisplayRect property as the Rect parameter.</docstr>
      </procedure>
      <function name="CanChange">
        <docstr>Change permission event dispatcher.
CanChange is called automatically when an attempt is made to change the selected tab. CanChange generates an OnChanging event so that an OnChanging event handler can prevent the selection from changing. If there is no OnChanging event handler, CanChange returns true, allowing the change.
Override CanChange to specify additional processing before the OnChanging event handler executes or to block the OnChanging event.</docstr>
      </function>
      <function name="CanShowTab">
        <docstr>Selection permission event dispatcher.
CanShowTab is called automatically when an attempt is made to show a tab. CanShowTab is exposed as a protected method so that descendants can override this method to provide application-specific criteria that determines whether a tab is accessible.
TabIndex is the index of the tab in the list of labels maintained by the Tabs property.
CanShowTab returns a Boolean value that indicates whether the tab specified in TabIndex can be accessed.

Tip: CanShowTab can be used with such methods as CanFocus (TWinControl) to determine whether the tab can both be accessed and can receive focus. Criteria for an overridden CanShowTab might include checking whether the tab is enabled.</docstr>
      </function>
      <procedure name="Change">
        <docstr>Pending tab change event dispatcher.
Change is called automatically when the selected tab changes. Override Change to specify additional processing before the OnChange event handler executes, or to block the OnChange event.</docstr>
      </procedure>
      <procedure name="ChangeScale">
        <docstr>Resize and reposition children and self.
Vcl.ComCtrls.TCustomTabControl.ChangeScale inherits from Vcl.Controls.TWinControl.ChangeScale. All content below this line refers to Vcl.Controls.TWinControl.ChangeScale.
Resize and reposition children and self.
ChangeScale rescales the control in the same manner as the ChangeScale method in TControl. If the control contains any children, their ChangeScale methods are called before the parent itself is rescaled.
To rescale the control&apos;s children without rescaling the control itself, use ScaleControls. To rescale the control without repositioning, use ScaleBy.</docstr>
      </procedure>
      <procedure name="CreateParams">
        <docstr>Sets up the window-creation parameters for the tab control.
Tab controls call CreateParams internally when the window for the tab control must be generated. CreateParams overrides the inherited method to specify a tab control window with the current property settings.</docstr>
      </procedure>
      <procedure name="CreateWnd">
        <docstr>Creates the window for a tab control.
CreateWnd is called automatically when the tab control&apos;s window is recreated. CreateWnd calls the inherited method, before assigning any saved tab text strings in internal storage.</docstr>
      </procedure>
      <procedure name="DrawTab">
        <docstr>Tab drawing event dispatcher.
Override DrawTab in a derived class to control the painting of tabs.
TabIndex is the index of the tab that requires painting.
Rect is the area in which the tab should be painted.
Active is whether the tab is active.
Use the Canvas property to paint the tab.</docstr>
      </procedure>
      <function name="GetImageIndex">
        <docstr>Generates an OnGetImageIndex event
Override GetImageIndex in a derived class to specify the index of the image to display for a particular tab.
TabIndex is the index of the tab that is about to be displayed.
The Return Value is an integer that is the index of the image in the Images property that will be displayed in the tab.</docstr>
      </function>
      <procedure name="Loaded">
        <docstr>Form load event dispatcher.
The protected Loaded method is called automatically when the form that contains the tab control is loaded into memory. It provides an opportunity for the tab control to perform any initializations after the control and all other components in the form are loaded into memory, but before the first paint operation.
In TCustomTabControl, Loaded ensures that the layout of the tabs accommodate the images specified by the Images property.</docstr>
      </procedure>
      <procedure name="UpdateTabImages">
        <docstr>Updates the tab images.
UpdateTabImages is called automatically to update the tab images after streaming in the control.</docstr>
      </procedure>
      <procedure name="CheckTabImagesIndexAndName">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <property name="DisplayRect">
        <docstr>Specifies the bounding rectangle of a tab control client area.
Use DisplayRect to obtain the coordinates, in pixels, of the portion of the tab control that represents the contents of the tab pages. The appearance of this portion of the tab control does not change when different tabs are selected. 
Use DisplayRect rather than the ClientRect property to determine the portion of the tab control that can contain other objects.</docstr>
      </property>
      <property name="HotTrack">
        <docstr>Determines whether labels on the tab under the mouse are automatically highlighted.
Set HotTrack to true to provide visual feedback to the user about which tab would be selected if the mouse button is clicked. HotTrack is especially useful when the tab control contains multiple rows of tabs.</docstr>
      </property>
      <property name="Images">
        <docstr>Specifies the images drawn in tabs.
Images specifies the images that are drawn in tabs. For disabled tabs, grayed versions of the images are used. 
In the implementation of TCustomTabControl, the order of images in image list properties directly corresponds to the associated tabs in the control. In the descendant class, TPageControl, this behavior is replaced by support for individual  TTabSheet objects, each with an ImageIndex property. In any case, the application programmer can define customized image displays by defining an OnGetImageIndex event handler.</docstr>
      </property>
      <property name="MultiLine">
        <docstr>Determines whether the tabs can appear on more than one row.
Use MultiLine to determine how the tabs are displayed. If MultiLine is true, the tabs are displayed on more than one row when the number of tabs exceeds the number that fits across the top of the tab control. How many rows is determined by how many tabs are in the tab control. If MultiLine is false, the tabs are displayed on one row only, and the user must scroll the displayed scroll arrows to view all the tabs.</docstr>
      </property>
      <property name="MultiSelect">
        <docstr>Specifies whether multiple tabs can be selected.
Use MultiSelect to get or set whether multiple tabs can be selected.
MultiSelect can only be true if Style is tsFlatButtons or tsButtons.</docstr>
      </property>
      <procedure name="Notification">
        <docstr>Event dispatcher for creation and destruction of child objects.
Notification checks whether the notification indicates that the component that implements the Images property is about to be destroyed, and if so, sets that property to nil (Delphi) or NULL (C++).</docstr>
      </procedure>
      <procedure name="SetTabIndex">
        <docstr>Sets the TabIndex property.
SetTabIndex is called to change the value of the TabIndex property. Descendant classes should override SetTabIndex to provide special implementations of this property.</docstr>
      </procedure>
      <property name="OwnerDraw">
        <docstr>Specifies whether the tab control handles its own painting.
Set OwnerDraw to true to override any default painting behavior.</docstr>
      </property>
      <property name="RaggedRight">
        <docstr>Specifies whether rows of tabs stretch to fill the width of the control.
Use RaggedRight to get or set whether rows of tabs stretch to fill the width of the control.</docstr>
      </property>
      <property name="ScrollOpposite">
        <docstr>Determines how the rows of tabs are scrolled in a multi-line tab control.
Set ScrollOpposite to determine where previous rows of tabs in a multi-line tab control move when the user selects a tab in another row. When ScrollOpposite is true, previous rows of tabs are moved to the bottom of the tab control if TabPosition is tpTop, or to the top if TabPosition is tpBottom. When ScrollOpposite is false, previous rows of tabs are moved to the back of all other rows of tabs.
For example, in a tab control with three rows of tabs at the top, if the user selects a tab in the second row, ScrollOpposite determines where the first row moves. If ScrollOpposite is true, the second row now appears at the front (bottom) row on top of the tab control, followed by the third row behind (above) it. The first row moves to the bottom of the tab control. If ScrollOpposite is false, the first row moves to the back (top), so that the tab control displays the second row in front (at the bottom of the tab region), followed by the third row (now in the middle), followed by the first row.

Note:  Setting ScrollOpposite to true automatically sets the MultiLine property to true.</docstr>
      </property>
      <property name="Style">
        <docstr>Specifies the style of the tab control.
Use Style to determine the appearance of the tabs. These can appear as notebook tabs or as buttons.</docstr>
      </property>
      <property name="TabHeight">
        <docstr>Specifies the height, in pixels, of the tabs in the tab control.
Set TabHeight to control the height of the tabs that appear above the client region of the tab control. The TabHeight property is the vertical size in pixels of the individual tabs. If TabHeight is set to 0, the tabs automatically size themselves to fit their text.</docstr>
      </property>
      <property name="TabIndex">
        <docstr>Identifies the selected tab on a tab control.
Read TabIndex to determine which tab was selected by the user. TabIndex is the index of the tab in the list of labels maintained by the Tabs property. The first (leftmost) tab has a TabIndex of 0, the next has 1, and so on. If no tabs are selected, TabIndex has a value of -1.
Set TabIndex to programmatically change the selected tab in the tab control.</docstr>
      </property>
      <property name="TabPosition">
        <docstr>Determines whether tabs appear at the top or bottom.
Set TabPosition to tpTop to display the tabs at the top of the tab control. Set TabPosition to tpBottom to display the tabs at the bottom. If the ScrollOpposite property is True, tabs can appear at both top and bottom, with the row containing the current tab and all subsequent rows on the side indicated by TabPosition.
Due to a limitation in the windows common control, if TabPosition is tpLeft or tpRight, Font must be a True Type font. Otherwise, tab text may paint incorrectly.</docstr>
      </property>
      <property name="Tabs">
        <docstr>Contains the list of text strings that label the tabs of the tab control.
Tabs contains a TStrings, a list of strings that label the tabs in the tab control.  To add new tabs to the tab control or to edit the tabs themselves, add a new string or edit the strings currently in the Tabs property. (To open the String List editor, double-click the Tabs property in the Object Inspector.) To rearrange the tabs, rearrange the list of strings. 
Tabs can also contain objects associated with the labels, using the System.Classes.TStrings.Objects property.</docstr>
      </property>
      <property name="TabWidth">
        <docstr>Specifies the horizontal size, in pixels, of the tabs in the tab control.
TabWidth specifies a fixed width for all tabs. If TabWidth is 0, then each tab is automatically made wide enough to show its caption.</docstr>
      </property>
      <event name="OnChange">
        <docstr>Occurs after a new tab is selected.
Write an OnChange event handler to take specific action immediately after the selected tab changes. Use the TabIndex property to determine which tab is now selected. This is the opportunity to make any changes to the control that reflect the new state implied by the selected tab.
Before the value of TabIndex changes, an OnChanging event occurs.

Note: The event is not called if you change the active page in code, for example, by setting the value of ActivePage.</docstr>
      </event>
      <event name="OnChanging">
        <docstr>Occurs immediately before a new tab is selected.
Write an OnChanging event handler to take specific action immediately before the selected tab changes. Set the AllowChange parameter to False to prevent the change.
Use an OnChanging event handler to prevent the user from leaving a tab setting until certain conditions have been met. An OnChanging event handler can also be used to save information about the current state of the tab control before it is changed by a new tab selection.

Note: The event is not called if you change the active page in code, for example, by setting the value of TPageControl.ActivePage.
OnChanging is an event handler of type Vcl.ComCtrls.TTabChangingEvent.</docstr>
      </event>
      <event name="OnDrawTab">
        <docstr>Occurs when a tab is about to be drawn.
Use OnDrawTab to customize the painting of tabs.
You can paint the tab using the Canvas property.
OnDrawTab is an event handler of type Vcl.ComCtrls.TDrawTabEvent.  See TDrawTabEvent for a description of the parameters.</docstr>
      </event>
      <event name="OnGetImageIndex">
        <docstr>Occurs when a tab is about to display its associated image.
Write an OnGetImageIndex event handler to specify the ImageIndex for a given TabIndex.
On entry to the event handler, the ImageIndex parameter is the same as the TabIndex parameter, where TabIndex is the index of the tab which is about to display its image. Change the ImageIndex parameter to specify the index into the Images property that specifies the image that should be painted.
OnGetImageIndex is an event handler of type Vcl.ComCtrls.TTabGetImageEvent.</docstr>
      </event>
      <constructor name="Create">
        <docstr>Creates and initializes an instance of TCustomTabControl.
Call Create to instantiate a tab control at runtime. Tab controls placed on forms at design time are created automatically. Create calls the inherited Create method and sets the initial values for the tab control, including the creation of a tab list that contains the text strings for the tabs.
AOwner is a component, typically the form, that is responsible for freeing the tab control. It becomes the value of the Owner property.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys an instance of TCustomTabControl.
Do not call Destroy directly in an application. Instead, use Free. Free checks that the tab control is not nil, and only then calls Destroy. Destroy frees the tab list that holds the list of text strings for the tabs and calls the inherited destructor.</docstr>
      </destructor>
      <function name="IndexOfTabAt">
        <docstr>Indicates the index of the tab at a specified point.
Use IndexOfTabAt to locate which tab is at the point specified by X and Y. If the point with X-coordinate X and Y-coordinate Y is over a tab, IndexOfTabAt returns the 0-offset index of that tab in the Tabs property (TTabControl) or in the Pages property (TPageControl). If the point defined by X and Y is not over a tab, IndexOfTabAt returns 1.</docstr>
      </function>
      <function name="GetHitTestInfoAt">
        <docstr>Returns information about the location of a point relative to the client area of the tab control.
Call GetHitTestInfoAt to determine what portion of the tab control, if any, sits under the point specified by the X and Y parameters.
GetHitTestInfo returns a THitTests type. This set describes the possible elements under the mouse. When interpreting these values, each tab can be considered an &quot;item&quot; of the tab control.</docstr>
      </function>
      <function name="TabRect">
        <docstr>Returns the bounding rectangle for a specified tab.
Use TabRect to determine the current position of the tab with the specified index. Index is the 0-offset index of a tab in the Tabs property (TTabControl) or in the Pages property (TPageControl). TabRect returns the bounding rectangle (in client coordinates) of the specified tab.</docstr>
      </function>
      <function name="RowCount">
        <docstr>Sets TabIndex property.
RowCount is called to change the value of the TabIndex property. Descendant classes should override RowCount to provide special implementations of this property.</docstr>
      </function>
      <procedure name="ScrollTabs">
        <docstr>Scrolls the tabs that are visible when the tab control is not multi-line.
Call ScrollTabs to change the tabs that are visible in the tab control. When Delta is positive, Delta additional tabs to the right are scrolled into view. When Delta is negative, the tabs to the left are scrolled into view, with the absolute value of Delta indicating how many tabs are scrolled. If there are fewer than the absolute value of Delta tabs in the indicated direction, ScrollTabs scrolls as far as possible.
ScrollTabs has no effect if there are no scrolled tabs, either because the control is wide enough to display all tabs or because the MultiLine property is true. 

Note: ScrollTabs scrolls the visible tabs. It does not change the current selection. Calling ScrollTabs may scroll the selected tab out of view.</docstr>
      </procedure>
      <property name="Canvas">
        <docstr>Gives access to the tab control&apos;s canvas.
Use Canvas to paint to the tab control&apos;s canvas during the OnDrawTab event.</docstr>
      </property>
    </members>
  </class>
  <class unit="Vcl.ComCtrls" name="TTabControl">
    <docstr>TTabControl is a tab set that has the appearance of notebook dividers.
Use TTabControl to add a control with multiple tab settings to a form. Unlike a page control, TTabControl is not made up of several pages that contain different controls. Instead, TTabControl is a single object. When the current tab changes, the tab control must directly update its contents to reflect the change in an OnChange event handler.
Disabling a TTabControl object disables all tabs because it is one control. To disable individual tabs, use TPageControl and disable the individual TTabSheet controls that represent the pages.

Note:  When using one of the page controls, if you want to restrict a user from switching to a tab, you cannot set TTabSheet.Enabled to false to accomplish that restriction. Instead, use the OnChanging event to prevent the user from selecting a tab.
The Tabs property can be used to define an accelerator key to a tab item of the TTabControl.</docstr>
  </class>
  <class unit="Vcl.ComCtrls" name="TTabSheet">
    <docstr>TTabSheet is an individual page in a TPageControl object.
Use TTabSheet to represent a single page in a tabbed page control. Tab sheets are typically referred to as pages. TPageControl maintains an indexed array of its tab sheets in its Pages property. Users can click on a tab to activate the tab sheet.
You can use the Caption property of the TTabSheet control to define an accelerator key to a page of the TPageControl.</docstr>
    <members>
      <procedure name="CreateParams">
        <docstr>Initializes window-creation parameters for the tab sheet.
The tab sheet calls CreateParams internally when the tab sheet must be generated. CreateParams overrides the inherited method to specify the type of window for the tab sheet.</docstr>
      </procedure>
      <procedure name="DoHide">
        <docstr>Called when the user selects another tab.
Generates an OnHide event. DoHide is called automatically when the TabVisible property changes to false. Override DoHide in a derived class to perform class-specific actions when the tab sheet is temporarily removed from its page control, or to block the OnHide event.</docstr>
      </procedure>
      <procedure name="DoShow">
        <docstr>Called when the user selects another tab.
Generates an OnShow event. DoShow is called automatically when the TabVisible property changes to false. Override DoShow in a derived class to perform class-specific actions when the tab sheet appears in its page control after being temporarily hidden, or to block the OnHide event.</docstr>
      </procedure>
      <procedure name="PaintWindow">
        <docstr>Renders the image of a windowed control.
Vcl.ComCtrls.TTabSheet.PaintWindow inherits from Vcl.Controls.TWinControl.PaintWindow. All content below this line refers to Vcl.Controls.TWinControl.PaintWindow.
Renders the image of a windowed control.
Call PaintWindow to repaint the control. PaintWindow sends a WM_PAINT message to the windowed control&apos;s DefaultHandler method, setting the message record&apos;s WParam field to the value passed in DC and the other parameter and result fields to zeros.</docstr>
      </procedure>
      <procedure name="ReadState">
        <docstr>Prepare control to be initialized from a stream.
TTabSheet reimplements in order to assign Reader&apos;s parent as the Tab Sheet&apos;s parent.</docstr>
      </procedure>
      <procedure name="UpdateControlOriginalParentSize">
        <docstr>Updates the original size of the parent control.
Vcl.ComCtrls.TTabSheet.UpdateControlOriginalParentSize inherits from Vcl.Controls.TWinControl.UpdateControlOriginalParentSize. All content below this line refers to Vcl.Controls.TWinControl.UpdateControlOriginalParentSize.
Updates the original size of the parent control.
UpdateControlOriginalParentSize is a protected method that updates the original size of the parent control. It is used internally to update the anchor rules of the control.</docstr>
      </procedure>
      <procedure name="UpdateImageName">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="UpdateImageIndex">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="CheckImageIndexAndName">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="SetParent">
        <docstr>Sets the parent of the control.
Vcl.ComCtrls.TTabSheet.SetParent inherits from Vcl.Controls.TControl.SetParent. All content below this line refers to Vcl.Controls.TControl.SetParent.
Sets the parent of the control.
SetParent is the protected implementation of the Parent property. Override SetParent to execute additional code when the value of the Parent property changes.
The AParent parameter specifies the new parent of the control.
If the control already has a parent, SetParent removes the control from that parent&apos;s list of controls by calling the parent&apos;s RemoveControl method. If AParent is not nil (Delphi) or NULL (C++), SetParent calls its InsertControl method to add the control to its list of controls.
The TControl destructor calls SetParent(nil (Delphi) or NULL (C++)) to remove the control from its parent&apos;s control list before destroying the component.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Creates and initializes an instance of TTabSheet.
Call Create to instantiate a tab sheet at runtime. Tab sheets added to a page control at design time are created automatically.
Create calls the inherited Create method, then sets the initial values for the tab sheet component.
When creating tab sheets at runtime, use the PageControl property to insert them into a page control object.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys an instance of TTabSheet.
Do not call Destroy directly at runtime. Instead, call Free. Free verifies that the tab sheet is not nil and only then calls Destroy. Destroy removes the tab sheet from the page control and then calls the inherited Destroy method.</docstr>
      </destructor>
      <property name="PageControl">
        <docstr>Indicates the page control object that contains the tab sheet.
Read PageControl to gain access to the page control object that uses the tab sheet. The properties and methods of the PageControl object can be used to locate the selected page, iterate through the other pages in the page control, or change the display properties of the tabs.
Set PageControl to remove the tab sheet from its current page control (if any) and insert it into a new page control.

Code Examples
TTabSheetPageControl (Delphi)
TabSheetPageControl (Delphi)
TTabSheetPageControl (C++)
TabSheetPageControl (C++)</docstr>
      </property>
      <property name="TabIndex">
        <docstr>Indicates the position of the tab sheet in the set of visible tabs in a TPageControl object.
Read TabIndex to determine where the user sees the tab sheet. A value of 0 indicates the first visible tab sheet, a value of 1 indicates the second visible tab sheet, and so on. TabIndex is always less than or equal to PageIndex. For example, a tab sheet that has a PageIndex of 3 will have a TabIndex of 2 if one of the previous tab sheets in the page control is not visible. 
If a tab sheet&apos;s TabVisible property is false, the TabIndex property is -1.</docstr>
      </property>
      <property name="Highlighted">
        <docstr>Indicates whether the tab sheet appears highlighted.
Use Highlighted to make a tab sheet stand out visually. When Highlighted is true, the tab sheet is drawn using a highlight color so that it stands out visually from other tab sheets.

Note: Highlighted is not linked to the active page of the host page control. A page control can have only one active page, but can have multiple highlighted pages.</docstr>
      </property>
      <property name="ImageIndex">
        <docstr>Specifies an image for the tab.
Use ImageIndex to get or set the index of an image to be drawn in the tab. This index identifies an image from the Images property of the page control that contains the tab sheet. Specify -1 to prevent an image from being drawn.</docstr>
      </property>
      <property name="ImageName">
        <docstr>Displays the name of linked items from the Image Collection.</docstr>
      </property>
      <property name="PageIndex">
        <docstr>Indicates the index of the tab sheet in the list of tab sheets maintained by the page control.
Use PageIndex to determine where the tab sheet sits in its page control. Each tab sheet in a page control is automatically assigned a PageIndex when it is inserted in the page control. The first tab sheet receives a value of 0, the second has a value of 1, and so on. PageIndex values are reassigned if tab sheets are deleted or moved.
To access a particular tab sheet given its index value, use the indexed Pages property of the TPageControl object.</docstr>
      </property>
      <property name="TabVisible">
        <docstr>Specifies whether the tab of the TTabSheet object appears in its TPageControl.
Use TabVisible to temporarily remove a tab sheet from a page control. When TabVisible is false, the tab does not appear in the page control and its TabIndex property is -1. Setting TabVisible to true allows the user to see the tab of the tab sheet again.</docstr>
      </property>
      <event name="OnHide">
        <docstr>Occurs when the TabVisible property changes to false.
Write an OnHide event handler to take specific action when the tab sheet is temporarily removed from its page control.</docstr>
      </event>
      <event name="OnShow">
        <docstr>Occurs when the TabVisible property changes to true.
Write an OnShow event handler to take specific action when the tab sheet appears in its page control after being temporarily hidden.</docstr>
      </event>
    </members>
  </class>
  <class unit="Vcl.ComCtrls" name="TPageControl">
    <docstr>TPageControl is a set of pages used to make a multiple page dialog box.
Use TPageControl to create a multiple page dialog or tabbed notebook. TPageControl displays multiple overlapping pages that are TTabSheet objects. The user selects a page by clicking the page&apos;s tab that appears at the top of the control. To add a new page to a TPageControl object at design time, right-click the TPageControl object and choose New Page.
You can define an accelerator key to a page of the TPageControl. To define the accelerator key use the Caption property of the TTabSheet control. 
To create a tabbed control that uses only a single body portion (page), use TTabControl instead.

Note:  When using one of the page controls, if you want to restrict a user from switching to a tab, you cannot set TTabSheet.Enabled to false to accomplish that restriction. Instead, use the OnChanging event to prevent the user from selecting a tab.</docstr>
    <members>
      <function name="CanShowTab">
        <docstr>Indicates whether a tab sheet in the page control can be selected.
Call CanShowTab to determine whether a tab can be selected or accessed.
TabIndex is the index of the tab in the list of tab sheets maintained by the Pages property.
CanShowTab returns true if the specified Tab sheet is enabled (its Enabled property is true ).</docstr>
      </function>
      <procedure name="Change">
        <docstr>Responds to changes in the page control.
Change is called automatically when Windows notifies the page control of a change. TPageControl responds to this notification by updating its display to show the new current page.</docstr>
      </procedure>
      <procedure name="DoAddDockClient">
        <docstr>Provides necessary adjustments when a new client is docked in the page control.
DoAddDockClient is called when a new client is docked to the page control. It sets the page control&apos;s tab sheet as the new client&apos;s parent.
Client is the client being docked.</docstr>
      </procedure>
      <procedure name="DockOver">
        <docstr>Indicates whether an object that is dragged over the page control can be docked.
DockOver is called automatically when the user drags a dockable window over the page control.
The Source parameter describes the object that is being dragged.
The X and Y parameters give the current position of the dragged control.
The State parameter indicates how the mouse is moving.
DockOver initializes the Source parameter to reflect the dockable region of the page control and generates an OnDockOver event. An OnDockOver event handler can change the Accept parameter to false if the Source control should not be docked.

Note: DockOver is only called if the DockSite property is true.</docstr>
      </procedure>
      <procedure name="DoRemoveDockClient">
        <docstr>Provides necessary adjustments when a control is undocked from the page control.
DoRemoveDockClient is called when a client is undocked from the page control. It selects the next page in the tab sheet.
Client is the client being undocked.</docstr>
      </procedure>
      <function name="GetImageIndex">
        <docstr>Specifies the image to display for a particular page.
Override GetImageIndex in a derived class to specify the index of the image to display for a particular page.
TabIndex is the page&apos;s index that is about to be displayed.
The Return Value is an integer that is the image&apos;s index (in the Images property) that will be displayed in the tab.
By default, if there is no OnGetImageIndex event handler, GetImageIndex returns the ImageIndex property for the page with the specified index; otherwise, GetImageIndex calls the inherited GetImageIndex method, returning the result.</docstr>
      </function>
      <function name="GetPageFromDockClient">
        <docstr>Returns the tab sheet on which a client is docked.
Call GetPageFromDockClient to get the tab sheet on which Client is docked.
Returns nil (Delphi) or NULL (C++) if Client is not docked.</docstr>
      </function>
      <procedure name="GetSiteInfo">
        <docstr>Returns the page control&apos;s docking information.
Call GetSiteInfo to determine the docking region of the page control and whether a dragged window can be docked.
Client is a potential docking client.
InfluenceRect returns the area in which the client can be docked.
MousePos is the current mouse position.
CanDock indicates whether the client can be docked in the page control.
GetSiteInfo initializes CanDock to true if Client is not already docked in the page control. It then inflates the influence rectangle by 10 pixels and generates an OnOnGetSiteInfo event.</docstr>
      </procedure>
      <procedure name="Loaded">
        <docstr>Initializes the page control after all its parts have been loaded from a stream.
Loaded is called automatically when the form containing the page control is first loaded into memory. TPageControl overrides the Loaded method to ensure that all tab sheets with a Highlighted property of true appear highlighted.</docstr>
      </procedure>
      <procedure name="SetActivePage">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="SetChildOrder">
        <docstr>Assigns indexes to the pages that reflect the order in which pages are loaded from a stream.
SetChildOrder is called automatically when the children of the page control are loaded from a stream. It assigns each page an index that reflects the order in which pages are loaded and saved.
The Child parameter is a page of the page control. The Order parameter indicates when the page is loaded or saved. The first page loaded or saved is called with Order set to 0, the second with Order set to 1, and so on.
SetChildOrder assigns the PageIndex property of the individual pages to the value of Order.</docstr>
      </procedure>
      <procedure name="SetTabIndex">
        <docstr>Sets the TabIndex property.
Vcl.ComCtrls.TPageControl.SetTabIndex inherits from Vcl.ComCtrls.TCustomTabControl.SetTabIndex. All content below this line refers to Vcl.ComCtrls.TCustomTabControl.SetTabIndex.
Sets the TabIndex property.
SetTabIndex is called to change the value of the TabIndex property. Descendant classes should override SetTabIndex to provide special implementations of this property.</docstr>
      </procedure>
      <procedure name="ShowControl">
        <docstr>Displays a specified page.
ShowControl is called automatically when a particular page of the page control should be visible. The AControl parameter specifies the page that should be displayed on screen.
ShowControl makes the specified page active it is not already active, and sets its own Visible property to true. It then calls the ShowControl method of its parent object to ensure that the page control is showing (and therefore able to display the active page).</docstr>
      </procedure>
      <procedure name="UpdateActivePage">
        <docstr>Updates the ActivePage property when changes are made to the Pages property.
This protected method is used internally when the pages listed in the Pages property change. It ensures that the page control is internally consistent and that the active page is displayed.</docstr>
      </procedure>
      <procedure name="CheckTabImagesIndexAndName">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Creates an instance of PageControl.
Call Create to instantiate a page control at runtime. Page controls added to forms at design time are created automatically.
AOwner is the form in which the page control should appear. It becomes the value of the Owner property.
When creating a page control at runtime, the pages must be added programmatically. To add a page to a page control at runtime, create the TTabSheet object for the page and set its PageControl property.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys an instance of TPageControl.
Do not call Destroy directly in an application. Instead, call Free. Free verifies that the TPageControl reference is not nil, and only then calls Destroy. Destroy frees the TList object that holds the pages of the control, and then calls the inherited destructor.</docstr>
      </destructor>
      <function name="FindNextPage">
        <docstr>Returns the next page in the page control before or after a specified page.
Call FindNextPage to locate a page in the page control by its position relative to the page specified by the CurPage parameter. If the GoForward parameter is true, FindNextPage returns the next page in the page control after CurPage. If GoForward is false, FindNextPage returns the previous page. If CurPage is not a page in the page control, FindNextPage returns the first page when GoForward is true or the last page when GoForward is false. If GoForward is true and CurPage is the last page in the page control, FindNextPage returns the first page. If GoForward is false and CurPage is the first page in the page control, FindNextPage returns the last page.
When CheckTabVisible is true, FindNextPage returns the next page with a TabVisible property set to true, if CheckTabVisible is false, FindNextPage returns the next page, including pages with TabVisible set to false.</docstr>
      </function>
      <procedure name="GetChildren">
        <docstr>Calls a specified procedure for every page in the page control.
Call GetChildren to execute a callback for every page in the page control. The Proc parameter is the callback. The Root parameter is ignored by TPageControl.
GetChildren is intended primarily for the streaming system that loads and saves components.</docstr>
      </procedure>
      <procedure name="SelectNextPage">
        <docstr>Changes the ActivePage to the first visible page that is before or after the currently active page.
Use SelectNextPage to select the page next to the currently active page. 
If the GoForward parameter is true, SelectNextPage selects the first page after ActivePage; if GoForward is false, SelectNextPage selects the first page previous to ActivePage. 
If CheckTabVisible is true, SelectNextPage only considers pages with their TabVisible property set to true.

Note:  To select a page at design-time, right-click the TPageControl and choose Previous Page or Next Page.</docstr>
      </procedure>
      <property name="ActivePageIndex">
        <docstr>Specifies the page currently displayed by the page control.
Use ActivePageIndex to get or set the active page by index rather than by object. The value of ActivePageIndex identifies a page in the Pages property array. Changing the value of ActivePageIndex changes the ActivePage property, and vice versa.
If there is no active page, reading ActivePageIndex gives a value of -1.
Setting ActivePageIndex to a value that is out of bounds (less than 0 or greater than PageCount - 1) results in the page control having no active page.</docstr>
      </property>
      <property name="PageCount">
        <docstr>Indicates the number of pages in the TPageControl object.
Use PageCount to determine the number of pages listed by the Pages property. If the MultiLine property is false, not all pages may have tabs visible to the user.</docstr>
      </property>
      <property name="ActivePage">
        <docstr>Specifies the page currently displayed by the page control.
Read ActivePage to determine which page is selected by the user. The user selects a page by clicking the mouse on its tab. Set ActivePage to bring a page to the foreground. Only one page can be active at a time.
To change the ActivePage to the page that precedes or follows the active page, use the SelectNextPage method. To iterate through all the pages to locate a specific page, use the FindNextPage method. 
Two events occur when one attempts to change the current page. They are OnChange and OnChanging. OnChanging occurs immediately before you attempt to change the current page, while OnChange occurs immediately after the page has been changed.</docstr>
      </property>
    </members>
  </class>
  <class unit="Vcl.ComCtrls" name="TCustomStatusBar">
    <docstr>TCustomStatusBar is the base class for objects that represent status bars.
TCustomStatusBar component is the base class for status bar controls. Status bars consist of a row of panels, usually aligned at the bottom of a form, that display information about an application as it runs. Each panel is represented by a TStatusPanel object listed in the Panels property.
TCustomStatusBar is intended only as a base class. To add a status bar to a form, use a TCustomStatusBar descendant such as TStatusBar.</docstr>
    <members>
      <procedure name="ChangeScale">
        <docstr>Repositions and resizes the status bar by a specified ratio.
ChangeScale is called automatically when the form that contains the status bar is rescaled. ChangeScale modifies the position as well as the size of a control. Thus, ChangeScale modifies the control&apos;s Top, Left, Width, and Height properties.
The M and D parameters define a fraction by which to scale the control. The M parameter is the multiplier and the D parameter is the divisor. For example, to make a control 75% of its original size, specify the value of M as 75, and the value of D as 100 (75/100). Alternately, the same results are achieved by specifying the value of M as 3, and the value of D as 4 (3/4). Both fractions are equal and result in the control being scaled by the same amount, 75%.
TCustomStatusBar overrides the inherited method to ensure that the new size of the status bar matches the system font if the UseSystemFont property is true.</docstr>
      </procedure>
      <function name="CreatePanel">
        <docstr>Creates a new panel that can be added to the Panels property.
The TStatusPanels object that implements the Panels property calls CreatePanel when it needs to add a new panel. CreatePanel generates an OnCreatePanelClass event to determine the class of the new TStatusPanel object, and then creates an instance of that class. CreatePanel returns the new status panel instance.</docstr>
      </function>
      <function name="CreatePanels">
        <docstr>Creates the TStatusPanels object that implements the Panels property.
TCustomStatusBar calls CreatePanels internally generate the implementation object for the Panels property.
Override this method to substitute a TStatusPanels descendant as the implementation of the Panels property or to provide special initializations to the TStatusPanels instance.</docstr>
      </function>
      <procedure name="CreateParams">
        <docstr>Initializes the window-creation parameter record when the status bar window is created.
The CreateWnd method calls CreateParams to initialize the parameters it passes to CreateWindowHandle. TCustomStatusBar overrides CreateParams to customize the parameters to specify a status bar control that reflects the properties of TCustomStatusBar.
The fields of the Params parameter become the parameters to a call to the CreateWindowEx API function.</docstr>
      </procedure>
      <procedure name="CreateWnd">
        <docstr>Creates the Windows control that represents the status bar.
The CreateHandle method calls CreateWnd to handle the particulars of creating the status bar window. TCustomStatusBar overrides the inherited method to ensure that the newly-created window and the TCustomStatusBar properties correctly reflect each other.
The Windows control for the status bar can be temporarily destroyed and recreated in order to set properties that require changing the window creation parameters. Thus, CreateWnd may be called more than once during the lifetime of the TCustomStatusBar instance.</docstr>
      </procedure>
      <function name="DoHint">
        <docstr>Generates an OnHint event.
DoHint is called automatically when the value of AutoHint is true and the status bar receives notification that it should display a hint.
If there is an OnHint event handler, DoHint calls the event handler and returns true. If no OnHint event handler is assigned, DoHint returns false.</docstr>
      </function>
      <procedure name="DrawPanel">
        <docstr>Draws an owner-drawn panel.
DrawPanel is called automatically for each status panel that has a Style of psOwnerDraw. If there is an event handler for the OnDrawPanel event, DrawPanel calls the OnDrawPanel event handler. Otherwise, it fills the panel background using the color specified by the Color property.
Panel is the owner drawn status panel that needs to be drawn.
Rect indicates the dimensions of that panel on the status bar&apos;s canvas.</docstr>
      </procedure>
      <function name="GetPanelClass">
        <docstr>Returns the class to use for implementing the panels of the status bar.
The CreatePanel method calls GetPanelClass to determine the default class to use when creating new panels for the status bar. This class can then be changed by an OnCreatePanelClass event handler.
TCustomStatusBar returns TStatusPanel as the default class for status bar panels. Descendants that use a TStatusPanel descendant by default can override this method to indicate a different default class.</docstr>
      </function>
      <function name="IsFontStored">
        <docstr>Indicates whether the value of the Font property should be saved in the form file.
TCustomStatusBar uses IsFontStored internally to determine whether the value of the Font property should be stored in a form file with the other properties of the status bar object. IsFontStored checks the UseSystemFont, ParentFont, and DesktopFont properties. If any of these is true, the status bar gets its font from an external source, and the value of the Font property does not need to be saved.</docstr>
      </function>
      <procedure name="SetParent">
        <docstr>Sets the value of the Parent property.
SetParent is the protected write implementation of the Parent property.
AParent is the new parent of the status bar.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Creates and initializes a TCustomStatusBar component.
The Create method creates a status bar along with its canvas and status panels.
AOwner is a component, typically the form, that becomes the value of the Owner property.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys TCustomStatusBar and frees its memory.
Do not call Destroy directly. Instead, use the Free method, which checks for a nil object before calling Destroy.
The Destroy method destroys the status bar along with its canvas and status panels.</docstr>
      </destructor>
      <function name="ExecuteAction">
        <docstr>Processes actions for the status bar.
When an action executes, the application makes a series of calls to respond to that action. If, in the course of that processing, the application identifies the status bar as a potential target of the action, it calls the status bar&apos;s ExecuteAction method.
If the action in a hint action (THintAction), ExecuteAction checks the AutoHint property, and if it is true, displays the hint and returns true. Otherwise, it allows the inherited method to respond to any other actions.
The Action parameter specifies the action that was invoked.
ExecuteAction returns true if the action was successfully dispatched, and false if the component could not handle the action.</docstr>
      </function>
      <procedure name="FlipChildren">
        <docstr>Reverses the positions of the status bar&apos;s panels.
FlipChildren iterates through the panels of the status bar, reversing their order but otherwise leaving their properties intact. 
AllLevels specifies whether FlipChildren should be called recursively on the control&apos;s children. TCustomStatusBar ignores this parameter when reversing the panels.</docstr>
      </procedure>
      <procedure name="SetBounds">
        <docstr>Sets the Left, Top, Width, and Height properties all at once.
TCustomStatusBar overrides SetBounds in order to update the size grip.
ALeft, ATop, AWidth, and AHeight specify the new values for the Left, Top, Width, and Height properties, respectively.</docstr>
      </procedure>
      <property name="Canvas">
        <docstr>Provides runtime access to the status bar&apos;s drawing surface.
The read-only Canvas property provides access to the status bar&apos;s drawing surface that you can use when implementing a handler for the OnDrawPanel event.</docstr>
      </property>
      <property name="AutoHint">
        <docstr>Specifies whether the status bar&apos;s text is set automatically to the current hint.
Use AutoHint to specify whether the status bar&apos;s text is set automatically to the current hint. When AutoHint is True, the status bar automatically responds to hint actions by displaying the long version of the hint&apos;s text in the first panel.</docstr>
      </property>
      <property name="Panels">
        <docstr>Lists the panels (TStatusPanel objects) in the status bar.
The Panels property holds a TStatusPanels, that is, a collection of TStatusPanel objects. At design time, you can add, remove, or modify panels with the Panels editor. To open the Panels editor, select the Panels property in the Object Inspector, then double-click in the Value column to the right or click the ellipsis (...) button.
At design time, you can add, remove, or modify panels with the Panels editor:

To open the Panels editor from the the Object Inspector, select the Panels property and either double-click in the Value column to the right or click the ellipsis (...) button.
To open the Panels editor from the Form Designer, right-click TStatusBar and select Panels editor from the context menu.</docstr>
      </property>
      <property name="SimplePanel">
        <docstr>Determines whether the status bar displays a single panel or multiple panels.
If SimplePanel is set to True, the status bar consists of a single panel displaying the text in SimpleText. If SimplePanel is set to False, the status bar displays a separate panel for each item in its Panels property.

Note: When SimplePanel is False, you cannot use the SimpleText property to display text in the status bar. Instead, you must set the Text property on one of the panel objects.</docstr>
      </property>
      <property name="SimpleText">
        <docstr>Contains a text string to be displayed in the status panel when SimplePanel is True.

Note: Microsoft Windows XP and earlier versions limited the size of the string to 127 chars. Under Microsoft Windows Vista, Windows 7, or later Windows operating systems, SimpleText has no such limit.</docstr>
      </property>
      <property name="SizeGrip">
        <docstr>Determines whether the status bar is resizable at run time.
If SizeGrip is set to True, the status bar has a triangular grip on the lower right corner. The user can resize the status bar by dragging the grip with the mouse.
A size grip will not be drawn unless the Parent property refers to the child of a TCustomForm descendant with a BorderStyle of bsSizeable or bsSizeToolWin.

Note: If Align is set to alBottom, alRight, or alClient, the sizing grip will not work. If the Alignment property of the last panel in the status bar is set to taRightJustify, the sizing grip will truncate the panel&apos;s text.</docstr>
      </property>
      <property name="UseSystemFont">
        <docstr>Specifies whether the status bar uses the system font.
UseSystemFont specifies whether the status bar uses the system font. To change fonts, use the Font property.</docstr>
      </property>
      <event name="OnCreatePanelClass">
        <docstr>Occurs when a status panel needs to be created.
Write an OnCreatePanelClass event handler to specify a custom TStatusPanel descendant that the status bar should use to implement its panels.
OnCreatePanelClass is an event handler of type Vcl.ComCtrls.TSBCreatePanelClassEvent.</docstr>
      </event>
      <event name="OnHint">
        <docstr>Occurs when the AutoHint property is True and the status bar receives a hint action.
Write an OnHint event handler to customize the way the status bar displays hints when the AutoHint property is True. When AutoHint is True and the status bar needs to display a hint, it generates an OnHint event. If the status bar has an OnHint event handler, then the status bar assumes that the event handler displays the hint and does not set the panel text to the value of the application&apos;s current hint. If there is no OnHint event handler (and AutoHint is True), the status bar displays the text of the hint in the first panel.
OnHint does not occur if the AutoHint property is False.</docstr>
      </event>
      <event name="OnDrawPanel">
        <docstr>Occurs when a status panel needs to be redrawn.
The OnDrawPanel event occurs when a status panel needs to be redisplayed for example, when the user resizes the status bar. OnDrawPanel occurs only if the status panel&apos;s Style property is set to psOwnerDraw.
OnDrawPanel is an event handler of type Vcl.ComCtrls.TCustomDrawPanelEvent.</docstr>
      </event>
    </members>
  </class>
  <class unit="Vcl.ComCtrls" name="TStatusBar">
    <docstr>TStatusBar represents a status bar.
The TStatusBar component is a row of panels, usually aligned at the bottom of a form, that display information about an application as it runs. Each panel is represented by a TStatusPanel object listed in the Panels property. The SimplePanel property can be used to toggle the status bar at runtime between a single- and multiple-panel display.</docstr>
    <members>
      <event name="OnDrawPanel">
        <docstr>Occurs when a status panel needs to be redrawn.
The OnDrawPanel event occurs when a status panel needs to be redisplayed for example, when the user resizes the status bar.  OnDrawPanel occurs only if the status panel&apos;s Style property is set to psOwnerDraw.
OnDrawPanel is an event handler of type Vcl.ComCtrls.TDrawPanelEvent.</docstr>
      </event>
    </members>
  </class>
  <class unit="Vcl.ComCtrls" name="TCustomTreeView">
    <docstr></docstr>
    <members>
      <function name="IsTouchPropertyStored">
        <docstr>Sets the stored directive for Touch properties.</docstr>
      </function>
      <procedure name="SetEncoding">
        <docstr>Setter for the Encoding property.</docstr>
      </procedure>
      <property name="Encoding">
        <docstr>Read-only property that contains the value of the encoding detected when the LoadFromStream or
           LoadFromFile methods are called.</docstr>
      </property>
    </members>
  </class>
  <class unit="Vcl.ComCtrls" name="TTrackBar">
    <docstr>TTrackBar is a wrapper for a track bar control.
Use TTrackBar to put a track bar on a form. A track bar represents a position along a continuum using a slider and, optionally, tick marks. A track bar can also display a selected range marked by triangular ticks at the starting and ending positions of the selection.
During program execution, the slider can be moved to the desired position by dragging it with the mouse or by clicking the mouse on the bar. To use the keyboard to move the slider, press the arrow keys or the Page Up and Page Down keys.</docstr>
    <members>
      <procedure name="CreateParams">
        <docstr>Initializes a window-creation parameter data structure.
Vcl.ComCtrls.TTrackBar.CreateParams inherits from Vcl.Controls.TWinControl.CreateParams. All content below this line refers to Vcl.Controls.TWinControl.CreateParams.
Initializes a window-creation parameter data structure.
The CreateWnd method calls CreateParams to initialize the parameters it passes to CreateWindowHandle. Override CreateParams to customize the way a control creates its Windows representation. When overriding CreateParams, always call the inherited method first to set the default values, then make any desired adjustments.
CreateParams fills in the parameter that is passed as the value of the Params parameter. This data structure holds information needed when telling Windows to create a window handle. The fields of a TCreateParams record become the parameters to a call to the CreateWindowEx API function.
TWinControl implements CreateParams by setting all the fields of Params to generic base values. A number of the standard controls override CreateParams to change one or more of the default values in Params.</docstr>
      </procedure>
      <procedure name="ChangeScale">
        <docstr>Resize and reposition children and self.
Vcl.ComCtrls.TTrackBar.ChangeScale inherits from Vcl.Controls.TWinControl.ChangeScale. All content below this line refers to Vcl.Controls.TWinControl.ChangeScale.
Resize and reposition children and self.
ChangeScale rescales the control in the same manner as the ChangeScale method in TControl. If the control contains any children, their ChangeScale methods are called before the parent itself is rescaled.
To rescale the control&apos;s children without rescaling the control itself, use ScaleControls. To rescale the control without repositioning, use ScaleBy.</docstr>
      </procedure>
      <procedure name="CreateWnd">
        <docstr>Creates the underlying window.
Vcl.ComCtrls.TTrackBar.CreateWnd inherits from Vcl.Controls.TWinControl.CreateWnd. All content below this line refers to Vcl.Controls.TWinControl.CreateWnd.
Creates the underlying window.
CreateWnd is called automatically when the control is first created or when the underlying screen object must be destroyed and recreated to reflect property changes. Override CreateWnd to pass additional initialization messages to the screen object when it is created.</docstr>
      </procedure>
      <procedure name="DestroyWnd">
        <docstr>Destroys the control&apos;s window.
Vcl.ComCtrls.TTrackBar.DestroyWnd inherits from Vcl.Controls.TWinControl.DestroyWnd. All content below this line refers to Vcl.Controls.TWinControl.DestroyWnd.
Destroys the control&apos;s window.
DestroyWnd is called when the control needs to replace its window. For example, changing properties that are implemented by window parameter settings require the control to be destroyed and then recreated using the CreateWnd method. 
Before the window is destroyed, DestroyWnd saves a copy of the control&apos;s text in memory, frees any device contexts, and finally calls DestroyWindowHandle. When the window is recreated, the stored copy of the control&apos;s text is assigned to the new window.</docstr>
      </procedure>
      <procedure name="Changed">
        <docstr>Sends a CM_CHANGED message to the control.
Vcl.ComCtrls.TTrackBar.Changed inherits from Vcl.Controls.TControl.Changed. All content below this line refers to Vcl.Controls.TControl.Changed.
Sends a CM_CHANGED message to the control.
Call Changed after changing the properties of the control in a way that affects the properties of a parent object. Changed sends a CM_CHANGED message back to the control. If the control is a windowed control, this message is sent to the parent so that it can make any necessary adjustments.</docstr>
      </procedure>
      <procedure name="Tracking">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Creates and initializes an instance of TTrackBar.
Call Create to instantiate a TTrackBar object at runtime. Track bars placed on forms at design time are created automatically.
Create allocates memory and initializes the following properties:
ControlStyle is set to [csCaptureMouse, csClickEvents, csSetCaption].
Frequency is set to 1.
Height is set to 45 and Width to 150.
LineSize is set to 1 and PageSize to 2.
Max is set to 10 and Min to 0.
Orientation is set to trHorizontal.
TickMarks is set to tbBottomRight and TickStyle to tsAuto.
TabStop is set to true.</docstr>
      </constructor>
      <procedure name="SetTick">
        <docstr>Adds a tick mark to the track bar at a specified location.
Use SetTick to place a tick mark on the bar at the position that corresponds to the Value parameter. Tick marks specified in this manner are only displayed when the TickStyle is set to tsManual.</docstr>
      </procedure>
      <property name="LineSize">
        <docstr>Indicates the amount the value of Position changes when the user presses the arrow keys.
Use LineSize to specify the distance along the slider that represents a single unit. The current Position is marked by a slider. The right and down arrow keys increment the value of Position by LineSize, and the left and up arrow keys decrement the value of Position by LineSize.
Use the PageSize property to set the number of ticks moved using the Page Up and Page Down keys.</docstr>
      </property>
      <property name="Max">
        <docstr>Specifies the maximum Position of a TTrackBar.
Use Max to set an upper limit to the value that can be represented using the track bar. A slider indicates the current Position in a range between Min and Max.</docstr>
      </property>
      <property name="Min">
        <docstr>Specifies the minimum Position of a TTrackBar.
Use Min to set a lower limit to the value that can be represented using the track bar. A slider indicates the current Position in a range between Min and Max.</docstr>
      </property>
      <property name="Orientation">
        <docstr>Specifies whether the track bar is horizontal or vertical.
Set Orientation to the desired orientation of the track bar. Orientation has these possible values: 





Value

Meaning



tbHorizontal



The long edge of the track is parallel to the top of the form. The Min position is on the left and the Max position is on the right.




tbVertical



The long edge of the track is parallel to the side of the form. The Min position is on the top and the Max position is on the bottom.</docstr>
      </property>
      <property name="PageSize">
        <docstr>Specifies the amount Position is changed when the PageUp or PageDown key is pressed, or when the bar is clicked.
Set PageSize to the distance along the track bar that corresponds to a single view. A slider marks the current Position. The Page Up key increments the value of Position by PageSize, and Page Down key decrements the value of Position by PageSize. 
Use the LineSize property to set the number of ticks moved using the arrow keys.</docstr>
      </property>
      <property name="Frequency">
        <docstr>Specifies the increment between tick marks on the track bar.
Use Frequency to specify the spacing of the tick marks, using the logical units used by the Position property. For example, a Frequency of 5 sets a tick mark at every fifth possible increment. To provide visual feedback about the units used by the track bar, set Frequency to LineSize or PageSize.

Note:  If the value of the TickStyle property is not set to tsAuto, the value of Frequency is ignored.</docstr>
      </property>
      <property name="Position">
        <docstr>Contains the current position of the slider of a TTrackBar.
Read Position to determine the current value represented by the track bar. Position is a value in the range between Min and Max (inclusive). Set Position to programmatically move the slider of the track bar to a new value.</docstr>
      </property>
      <property name="PositionToolTip">
        <docstr>Determines the position of the (optional) Tool Tip displaying the position of the track bar.
You can set this property to one of the following values.





Value

Meaning



ptNone



No Tool Tip is shown.




ptTop



The Tool Tip appears at the top side of the TrackBar.




ptBottom



The Tool Tip appears at the bottom side of the TrackBar.




ptLeft



The Tool Tip appears at the left side of the TrackBar.




ptRight



The Tool Tip appears at the right side of the TrackBar.





Note:  Use ptLeft and ptRight for the vertical Track Bars. Use ptTop and ptBottom for the horizontal Track Bars.</docstr>
      </property>
      <property name="SliderVisible">
        <docstr>Specifies whether the track bar&apos;s slider is visible.
Use SliderVisible to get or set whether the track bar&apos;s slider is visible.</docstr>
      </property>
      <property name="SelEnd">
        <docstr>Specifies the position of the end point of the selection range.
Set SelEnd to determine the length of a selection that begins at SelStart. The track bar indicates a selection range on the bar by placing special tick marks at the positions specified by the SelStart and SelEnd properties and highlighting the selected portion of the bar. 
SelEnd must be greater than or equal to Position. If SelEnd is set to a value less than Position, Position changes to SelEnd. SelEnd must be greater than or equal to SelStart. If SelEnd is the same as SelStart, there is no selection, and the value of Position is the same as SelStart and SelEnd.</docstr>
      </property>
      <property name="SelStart">
        <docstr>Specifies the position of the starting point of the selection range.
Set SelStart to determine the beginning of a selection that runs to SelEnd. The track bar indicates a selection range on the bar by placing special tick marks at the positions specified by the SelStart and SelEnd properties and highlighting the selected portion of the bar. 
SelStart must be less than or equal to Position. If SelStart is set to a value greater than Position, Position changes to SelStart. SelStart must be less than or equal to SelEnd. If SelStart is the same as SelEnd, there is no selection, and the value of Position is the same as SelStart and SelEnd.</docstr>
      </property>
      <property name="ShowSelRange">
        <docstr>Specifies whether the track bar shows the selection range.
If set to True, the selection range on the track bar is displayed. If set to False, the selection range is not displayed.</docstr>
      </property>
      <property name="ThumbLength">
        <docstr>Specifies the length of the track bar&apos;s slider.
Use ThumbLength to get or set the length of the track bar&apos;s slider.</docstr>
      </property>
      <property name="TickMarks">
        <docstr>Specifies the location of the tick marks.
Set TickMarks to specify where the tick marks should be drawn. TickMarks has these possible values:





Value

Meaning



tmBottomRight



Tick marks are on the bottom or right of the track bar, depending of the value of Orientation.




tmTopLeft



Tick marks are on the top or left of the track bar, depending of the value of Orientation.




tmBoth



Tick marks are on both sides of the track bar.




If the TickStyle property is tsNone, the value of TickMarks is ignored.</docstr>
      </property>
      <property name="TickStyle">
        <docstr>Specifies how tick marks are placed on the track bar.
Set TickStyle to specify whether the track bar should display tick marks, and if so, how those tick marks are set. TickStyle has these possible values:





Value

Meaning



tsAuto



Tick marks are automatically displayed at increments equal to the value of the Frequency property.




tsManual



Tick marks are displayed at the Min and Max values. Additional tick marks can be set using the SetTick method.




tsNone



No tick marks are displayed.</docstr>
      </property>
    </members>
  </class>
  <class unit="Vcl.ComCtrls" name="TToolBar">
    <docstr>TToolBar manages tool buttons and other controls, arranging them in rows and automatically adjusting their sizes and positions.
TToolBar is a container for tool buttons (TToolButton). It provides an easy way to arrange and manage visual controls.
All tool buttons on a toolbar maintain a uniform width and height.
Other controls can sit on a toolbar. These controls (which are held in place by invisible tool buttons) maintain a uniform height.
Controls can automatically wrap around and start a new row when they do not fit horizontally on the toolbar.
The Flat property allows the background to show through the toolbar and gives pop-up borders to the tool buttons.
Spaces and dividers (which are in fact specially configured tool buttons) can group controls on the toolbar both visually and functionally.
Typically, the tool buttons correspond to items in an application&apos;s menu and give the user more direct access to the application&apos;s commands.</docstr>
    <members>
      <procedure name="AlignControls">
        <docstr>Aligns any child controls of the toolbar within a specified area of the control.
The protected AlignControls method is called automatically to align all controls within an area of container control (in this case the tool bar). In TToolBar, AlignControls takes into account the special needs of a tool bar in arranging its buttons.
Control is a child control that should have precedence when laying out the child controls. If Control is nil (Delphi) or NULL (C++), none of the child controls has precedence.
Rect is the area in which to align the child controls.</docstr>
      </procedure>
      <function name="CanAutoSize">
        <docstr>Indicates whether the toolbar can resize itself automatically to accommodate its contents.
CanAutoSize is called automatically when the AutoSize property is true and an attempt is made to resize the control. It allows the toolbar to implement the AutoSize property before the resize sequence that ends with the OnResize event.
When CanAutoSize is called, the NewWidth and NewHeight parameters indicate the proposed new dimensions of the toolbar. CanAutoSize adjusts these values so that the toolbar&apos;s size adjusts to its buttons. If the adjustment results in values of NewWidth and NewHeight that differ from the control&apos;s current width and height, CanAutoSize returns true, indicating that the resize sequence should proceed. If, after adjustment, NewWidth and NewHeight equal Width and Height, CanAutoSize returns false, and the resize sequence is aborted.</docstr>
      </function>
      <procedure name="CancelMenu">
        <docstr>Called when the menu associated with a toolbar button is canceled.
Override CancelMenu in a derived class to handle the canceling of a menu on one of the tool buttons.
By default, CancelMenu clears the highlighting and hot item in the menu.</docstr>
      </procedure>
      <procedure name="ChangeScale">
        <docstr>Repositions and resizes the toolbar by a specified ratio.
Use ChangeScale to change the scale of the toolbar.
ChangeScale modifies the position and size of a toolbar as well as rescaling the buttons. Thus, ChangeScale modifies the Top, Left, Width, and Height properties.
The M and D parameters define a fraction by which to scale the control. The M parameter is the multiplier and the D parameter is the divisor. For example, to make a control 75% of its original size, specify the value of M as 75, and the value of D as 100 (75/100). Alternately, the same results are achieved by specifying the value of M as 3, and the value of D as 4 (3/4). Both fractions are equal and result in the control being scaled by the same amount, 75%.</docstr>
      </procedure>
      <function name="CheckMenuDropdown">
        <docstr>Displays a toolbar button&apos;s drop-down menu.
CheckMenuDropdown is called automatically when the drop-down arrow portion of a toolbutton is clicked or if a toolbutton has an assigned MenuItem property.
Button is the drop-down toolbar button that was clicked.
CheckMenuDropdown has no effect unless the button&apos;s Style property contains tbsDropDown.</docstr>
      </function>
      <procedure name="ClickButton">
        <docstr>Simulates the clicking of a toolbar button.
Call ClickButton to simulate the clicking of a toolbar button.
Button is the toolbar button to click.</docstr>
      </procedure>
      <procedure name="CreateParams">
        <docstr>Initializes a window-creation parameter record passed in the Params parameter.
CreateParams is called automatically to initialize the window-creation parameters whenever the window for the toolbar needs to be created. CreateParams overrides the inherited method to implement those properties that require a specialize window style.</docstr>
      </procedure>
      <procedure name="CreateWnd">
        <docstr>Creates the window that implements the toolbar.
The Windows control for the toolbar can be temporarily destroyed and recreated in order to set properties that require changing the window creation parameters. TToolBar calls CreateWnd to create this Windows control when necessary.</docstr>
      </procedure>
      <function name="GradientDrawToolBar">
        <docstr>Use this method for drawing the toolbar when gdoGradient and dsGradient are both set.
This method is used for drawing the toolbar when gdoGradient and dsGradient are both set</docstr>
      </function>
      <function name="GradientDrawButton">
        <docstr>Use this method for drawing toolbuttons when gdoGradient and dsGradient are both set.
This method is used for drawing toolbuttons when gdoGradient and dsGradient are both set.</docstr>
      </function>
      <function name="CustomDraw">
        <docstr>Generates OnCustomDraw and OnAdvancedCustomDraw events.
CustomDraw is called automatically at discrete stages during the drawing process to generate the OnCustomDraw and OnAdvancedCustomDraw events.
ARect specifies the boundaries of the toolbar on the toolbar&apos;s Canvas.
Stage indicates the current stage of the paint process. When Stage is cdPrePaint, CustomDraw generates an OnCustomDraw event followed by an OnAdvancedCustomDraw event. At all other stages, CustomDraw generates only the OnAdvancedCustomDraw event.
CustomDraw returns true if the toolbar should continue with its default painting sequence, false if the painting sequence should end after the call.</docstr>
      </function>
      <function name="CustomDrawButton">
        <docstr>Generates OnCustomDrawButton and OnAdvancedCustomDrawButton events.
CustomDrawButton is called automatically at discrete stages during the drawing process to generate the OnCustomDrawButton and OnAdvancedCustomDrawButton events.
Button specifies the tool button that needs to be drawn.
State describes the state of the button, so that the event handler can reflect that state in the button&apos;s image.
Stage indicates the current stage of the paint process. When Stage is cdPrePaint, CustomDrawButton generates an OnCustomDrawButton event followed by an OnAdvancedCustomDrawButton event. At all other stages, CustomDrawButton generates only the OnAdvancedCustomDrawButton event.
Flags is used only when Stage is cdPrePaint. It influences how the button is subsequently rendered by the default drawing process. CustomDrawButton returns the set of flags that indicates how the toolbar should proceed with rendering the button.</docstr>
      </function>
      <function name="DoQueryInsert">
        <docstr>Generates an OnCustomizeCanInsert event.
DoQueryInsert is called automatically when the user tries to add a button to a customizable tool bar. It generates an OnCustomizeCanInsert event, allowing the application to block the insertion.
Index is the index (in the Buttons property) where the user is trying to insert a new button.</docstr>
      </function>
      <function name="DoQueryDelete">
        <docstr>Generates an OnCustomizeCanDelete event.
DoQueryDelete is called automatically when the user tries to delete a button from a customizable tool bar. It generates an OnCustomizeCanDelete event, allowing the application to block the deletion.
Index is the index (in the Buttons property) of the button that the user is trying to delete.</docstr>
      </function>
      <function name="FindButtonFromAccel">
        <docstr>Returns the toolbar button with the specified accelerator.
Use FindButtonFromAccel to determine which toolbar button has the specified accelerator.
If the accelerator is not found, FindButtonFromAccel returns nil (Delphi) or NULL (C++).</docstr>
      </function>
      <procedure name="InitMenu">
        <docstr>Called when the menu associated with a drop-down toolbar button is about to be displayed.
InitMenu initializes the highlighting and hot-tracking for the drop-down menu associated with the tool button that Button specifies.
Override InitMenu in a derived class to perform other initializations to the toolbar button&apos;s menu.</docstr>
      </procedure>
      <function name="IsCustomDrawn">
        <docstr>Indicates whether an event handler exists to respond at a particular stage in the paint process.
TToolBar uses IsCustomDrawn internally to determine whether it needs generate the various custom draw events.
Target indicates what object is currently being painted. If Target is dtControl, it is the background of the toolbar, and IsCustomDrawn checks whether there is an OnCustomDraw or OnAdvancedCustomDraw event handler. If Target is dtItem, it is one of the tool buttons, and IsCustomDrawn checks for an OnCustomDrawButton or OnAdvancedCustomDrawButton event handler. TToolBar does not use dtSubItem as a target.
Stage indicates the current stage of the paint process. If stage is not cdPrePaint, then the tool bar only generates an event if it has one of the advanced custom draw event handlers.
IsCustomDrawn returns true if the toolbar should generate an event (there is an event handler to respond.) IsCustomDrawn returns false if there is no need to generate a custom draw event.</docstr>
      </function>
      <procedure name="Loaded">
        <docstr>Initializes the component after the form file has been read into memory.
TToolBar overrides Loaded in order to managed the ButtonWidth property.</docstr>
      </procedure>
      <procedure name="Notification">
        <docstr>Responds to a notification that a component has been added or is about to be deleted.
Notification is called automatically when a component has just been added to the form or is about to be deleted.
AComponent is the component that was just added or that is about to be deleted.
Operation indicates whether AComponent was added or is about to be deleted.
As implemented in TToolBar, Notification checks whether the image list that is the value of the Images, HotImages, or DisabledImages property is about to be deleted. If so, it resets the property to nil (Delphi) or NULL (C++).</docstr>
      </procedure>
      <procedure name="RepositionButton">
        <docstr>Updates the position of a specified button in the toolbar.
TToolBar uses RepositionButton internally when laying out the buttons in the toolbar. RepositionButton calculates where to place the button with the specified index, given the positions of all previous buttons in the toolbar. It then changes the position and size of the specified tool button.</docstr>
      </procedure>
      <procedure name="RepositionButtons">
        <docstr>Updates the positions of all buttons in the toolbar from a specified button on.
TToolBar uses RepositionButtons internally when laying out the buttons in the toolbar. RepositionButtons calculates where to place all the buttons with the specified index or greater, and updates their positions and sizes.</docstr>
      </procedure>
      <procedure name="WndProc">
        <docstr>Provides specific message responses for the toolbar.
WndProc overrides the WndProc for TWinControl to handle mouse messages, and sends all others to the inherited WndProc.
Derived classes that override WndProc to provide specialized responses to messages should call the inherited WndProc at the end to dispatch any other messages.</docstr>
      </procedure>
      <function name="WrapButtons">
        <docstr>Rearranges the toolbar&apos;s buttons so they fit in the toolbar.
Call WrapButtons to rearrange the toolbar&apos;s buttons.
NewWidth is the width in which the buttons must fit.
NewHeight is the height in which the buttons must fit.
WrapButtons returns true if the buttons fit; otherwise, WrapButtons returns false.</docstr>
      </function>
      <procedure name="Resize">
        <docstr>Respond to control resize.
Vcl.ComCtrls.TToolBar.Resize inherits from Vcl.Controls.TControl.Resize. All content below this line refers to Vcl.Controls.TControl.Resize.
Respond to control resize.
Resize is called automatically immediately after the control&apos;s dimensions change. As implemented in TControl, Resize calls the control&apos;s OnResize event handler if it is assigned.</docstr>
      </procedure>
      <procedure name="SetAutoSize">
        <docstr>Sets the value of the AutoSize property.
Vcl.ComCtrls.TToolBar.SetAutoSize inherits from Vcl.Controls.TControl.SetAutoSize. All content below this line refers to Vcl.Controls.TControl.SetAutoSize.
Sets the value of the AutoSize property.
SetAutoSize is a protected method in the TControl class and is used to set the value of the AutoSize property.</docstr>
      </procedure>
      <procedure name="UpdateStyleElements">
        <docstr>Called when the StyleElements property changes.
Vcl.ComCtrls.TToolBar.UpdateStyleElements inherits from Vcl.Controls.TControl.UpdateStyleElements. All content below this line refers to Vcl.Controls.TControl.UpdateStyleElements.
Called when the StyleElements property changes.
Override the UpdateStyleElements method in a descendant class to provide customized behavior for the control when the value of the StyleElements property changes.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Creates and initializes a TToolBar instance.
Call Create to create a toolbar at runtime. Toolbars added to forms at design time are created automatically.
AOwner is the component, typically the form, that is responsible for freeing the toolbar instance. It becomes the value of the Owner property.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys the TToolBar instance and frees its memory.
Do not call Destroy directly in an application. Instead, call Free. Free verifies that the TToolBar reference is not nil, and only then calls Destroy.</docstr>
      </destructor>
      <procedure name="FlipChildren">
        <docstr>Prevents the toolbar buttons from reversing position when the parent control is flipped.
FlipChildren overrides the inherited method in order to prevent the flipping of the toolbar&apos;s children.</docstr>
      </procedure>
      <function name="GetEnumerator">
        <docstr>Returns a TComponent enumerator.
Vcl.ComCtrls.TToolBar.GetEnumerator inherits from System.Classes.TComponent.GetEnumerator. All content below this line refers to System.Classes.TComponent.GetEnumerator.
Returns a TComponent enumerator.
GetEnumerator returns a TComponentEnumerator reference, which enumerates the components contained within a specified containing component. 
To process all these subcomponents, call the TComponentEnumerator GetCurrent method within a While MoveNext do loop.</docstr>
      </function>
      <procedure name="GetChildren">
        <docstr>Allows the streaming system to load and save child controls in the order they appear in the toolbar.
GetChildren is introduced in TComponent for the streaming system that loads and saves VCL components. It executes the callback specified by Proc for all the button in the toolbar, as well as any other controls that have the toolbar as a parent and the component specified by Root as an Owner.
Proc is a callback that the streaming system uses to load or save persistent objects on a form.
Root is the the top-level component (such as a form or data module) that is currently being loaded or saved.</docstr>
      </procedure>
      <function name="TrackMenu">
        <docstr>Called when the accelerator for a toolbar button is pressed.
TrackMenu is called automatically in response to the accelerator on a toolbar button. It initializes the menu of a drop-down menu button, and forwards a click to the underlying Windows control.
Button is the toolbar button for which an accelerator was pressed.
Override TrackMenu in a derived class to perform additional actions when the accelerator for a toolbar button is pressed.</docstr>
      </function>
      <property name="ButtonCount">
        <docstr>Gives the number of buttons in the toolbar.
ButtonCount gives the number of buttons in the Buttons array.</docstr>
      </property>
      <property name="Canvas">
        <docstr>Specifies the drawing surface for the toolbar.
Use Canvas to draw or paint on the surface of the toolbar in an OnCustomDraw or OnCustomDrawButton event handler. The TCanvas object provides the properties and methods needed for drawing and painting.</docstr>
      </property>
      <property name="CustomizeKeyName">
        <docstr>Specifies the registry key where the tool bar saves its current button configuration before the user changes it using the toolbar customize dialog.
Use CustomizeKeyName to specify where the toolbar saves its button configuration when the user first displays the toolbar customize dialog. This is a subkey of HKEY_CURRENT_USER. 
When the user double-clicks the tool bar to display the toolbar customize dialog, the tool bar receives an OnCustomizing event and then automatically saves its current configuration to this key using the name specified by the CustomizeValueName property. If the user instructs the dialog to restore this configuration, the toolbar fetches the saved configuration from this registry key.</docstr>
      </property>
      <property name="CustomizeValueName">
        <docstr>Specifies the registry value under which the tool bar saves its current button configuration before the user changes it using the toolbar customize dialog.
Use CustomizeValueName to specify the name that the toolbar uses to save its button configuration when the user first displays the toolbar customize dialog. This is a value under the registry key specified by the CustomizeKeyName property.
When the user double-clicks the tool bar to display the toolbar customize dialog, the tool bar receives an OnCustomizing event and then automatically saves its current configuration to the Registry using this value. If the user instructs the dialog to restore this configuration, the toolbar fetches this saved configuration.</docstr>
      </property>
      <property name="RowCount">
        <docstr>Indicates the number of rows in the toolbar.
Reading RowCount returns the number of rows in which the tool buttons are arranged.</docstr>
      </property>
      <property name="ButtonHeight">
        <docstr>Specifies the height of the controls in the toolbar.
ButtonHeight represents the height, in pixels, of the controls in the toolbar.</docstr>
      </property>
      <property name="ButtonWidth">
        <docstr>Specifies the width of the tool buttons (TToolButton) in the toolbar.
ButtonWidth represents the width, in pixels, of the TToolButton components on the toolbar. It has no effect on tool buttons whose Style property is set to tbsSeparator or tbsDivider.</docstr>
      </property>
      <property name="Customizable">
        <docstr>Specifies whether the user can customize the toolbar at runtime.
Set Customizable to true to allow the user to add, delete, and move toolbar buttons at runtime. There are two ways the user can change a customizable toolbar:
By holding the shift key, the user can drag a button to a new position on the tool bar, or drag it off the toolbar entirely to delete the button.
By double-clicking on the toolbar, the user can display the toolbar customize dialog. The toolbar customize dialog shows all the possible buttons in two list boxes, one that contains buttons not on the tool bar, and one that contains buttons currently on the tool bar. The user can use this dialog to add or remove buttons and to change their order.

Note:  When Customizable is true, a number of events inform the tool bar component when the user makes changes.</docstr>
      </property>
      <property name="DisabledImages">
        <docstr>Lists the images that can appear on disabled tool buttons.
DisabledImages contains a list of images that can appear on tool buttons when they are disabled. Each tool button&apos;s ImageIndex property determines the specific image displayed on it. If DisabledImages is unassigned, disabled tool buttons display grayed versions of their regular images (specified by the Images property).</docstr>
      </property>
      <property name="DrawingStyle">
        <docstr>Stores the style type.
This property stores either the dsNormal or dsGradient style choice.</docstr>
      </property>
      <property name="Flat">
        <docstr>Makes the toolbar transparent and eliminates tool-button borders.
If Flat is set to true, the toolbar and its tool buttons are transparent; background colors and graphics show through them. In addition, when Flat is true, tool buttons (TToolButton) on the toolbar have pop-up borders that appear only when the mouse is passed over the button.</docstr>
      </property>
      <property name="GradientEndColor">
        <docstr>Color used as end color for the gradient.
This property stores the color that is used to paint the gradient when the drawing ends. (The end color blends with the start color).</docstr>
      </property>
      <property name="GradientStartColor">
        <docstr>Color used as start color for the gradient.
The property stores the value that represents the drawing color when the gradient starts painting.</docstr>
      </property>
      <property name="HideClippedButtons">
        <docstr>Specifies handling of buttons obscured by adjacent toolbar.
If HideClippedButtons is set to true, any button partially obscured by a neighboring band is hidden.</docstr>
      </property>
      <property name="HotImages">
        <docstr>Lists the images that can appear on tool buttons when the mouse points to them.
HotImages contains a list of images that can appear on tool buttons when the mouse passes over them at runtime. Each tool button&apos;s ImageIndex property determines the specific image displayed when the mouse points to it. If HotImages is unassigned, tool buttons retain their regular images (specified by the Images property) when pointed to. Use a TImageList control to hold the images that will be shown for hot images. Typically, then, the application will have two TImageList controls, one for the Images property and one for the HotImages property.
To use HotImages set the Flat property to True.</docstr>
      </property>
      <property name="HotTrackColor">
        <docstr>Color used as hot tracking color when in gradient style.
This is the color used as the hot tracking color when the toolbar&apos;s DrawingStyle property is set to dsGradient. The hot tracking color is the color the button turns when the mouse moves over it.</docstr>
      </property>
      <property name="Images">
        <docstr>Lists the images that can appear on tool buttons.
Images contains a list of images that can appear on the toolbar&apos;s tool buttons. Each tool button&apos;s ImageIndex property determines the specific image displayed on it. If Images is unassigned, no images are displayed on the tool buttons.
Images in the list should be 16x16.</docstr>
      </property>
      <property name="Indent">
        <docstr>Specifies the margin on the left side of the toolbar.
Indent specifies, in pixels, the margin that separates the left edge of the toolbar from the controls within it.</docstr>
      </property>
      <property name="List">
        <docstr>Aligns captions on the right and images on the left in tool buttons.
When List is false, tool buttons (TToolButton) appear in the toolbar with their images (if any) centered and their captions (if visible) underneath. Setting List to true aligns captions to the right and images to the left.</docstr>
      </property>
      <property name="Menu">
        <docstr>Causes the toolbar to populate itself with buttons that correspond to items in a menu.
Use the menu property to populate the tool bar to match a menu component. Setting Menu causes the toolbar to delete all of its current buttons and replace them with tool buttons that match the items in the specified menu component.
In applications that use Menu to populate the toolbar, do not change the Buttons property by adding, deleting, or editing toolbar buttons.

Note:  The toolbar does not dynamically track any changes to the menu specified by Menu. That is, it sets the tool buttons to reflect the set of items in the menu at the point when the application sets this property, and ignores any subsequent changes.</docstr>
      </property>
      <property name="GradientDirection">
        <docstr>Specifies whether the direction of the gradient is horizontal or vertical.
This property stores the value for the gradient direction.</docstr>
      </property>
      <property name="GradientDrawingOptions">
        <docstr>Stores the drawing option chosen.
This property contains either the gdoHotTrack or gdoGradient option, depending on which one was chosen.</docstr>
      </property>
      <property name="ShowCaptions">
        <docstr>Determines whether text captions are displayed on tool buttons.
If ShowCaptions is set to true, tool buttons appear in the toolbar with their captions displayed. Setting ShowCaptions to true may increase the size of the tool buttons.</docstr>
      </property>
      <property name="AllowTextButtons">
        <docstr>Determines whether tool buttons that consist only of text can be placed on the Toolbar.
When set to true, the tbsTextButton style is available for the TToolButton control, allowing you to create tool buttons on the Toolbar that consist only of text. When set to false, the tbsTextButton style is not available for the TToolButton control.</docstr>
      </property>
      <property name="Transparent">
        <docstr>Specifies whether the toolbar is transparent.
Use Transparent to get or set whether the toolbar is transparent. Note the Transparent property applies only to the toolbar itself not its buttons.

Tip:  To avoid painting problems, set the Transparent property before the toolbar becomes visible.</docstr>
      </property>
      <property name="Wrapable">
        <docstr>Enables automatic line-wrap for components in the toolbar.
If Wrapable is true, components automatically wrap around and form new rows when they do not fit horizontally in the toolbar.</docstr>
      </property>
      <event name="OnAdvancedCustomDraw">
        <docstr>Occurs at discrete stages during the painting of the toolbar&apos;s background.
Write an OnAdvancedCustomDraw event handler to enhance or replace the automatic painting of the toolbar. Use the toolbar&apos;s Canvas property to render the toolbar&apos;s image. OnAdvancedCustomDraw is for painting the background of the toolbar. The painting of individual buttons on the toolbar should be handled in an OnCustomDrawButton or OnAdvancedCustomDrawButton event handler.

Note: OnAdvancedCustomDraw occurs at several points during the painting of the toolbar&apos;s background. If you only need to respond immediately prior to the default painting of the toolbar, use OnCustomDraw instead.
OnAdvancedCustomDraw is an event handler of type Vcl.ComCtrls.TTBAdvancedCustomDrawEvent.</docstr>
      </event>
      <event name="OnAdvancedCustomDrawButton">
        <docstr>Occurs at discrete stages during the painting of the toolbar&apos;s buttons.
Write an OnAdvancedCustomDrawButton event handler to enhance or replace the automatic painting of the toolbar&apos;s buttons. Use the toolbar&apos;s Canvas property to render the button&apos;s image. OnAdvancedCustomDrawButton occurs during the erasure and painting of individual buttons on the toolbar. The painting of the toolbar itself should be handled in an OnCustomDraw or OnAdvancedCustomDraw event handler.

Note: OnAdvancedCustomDrawButton occurs at several points during the painting of the toolbar&apos;s buttons. If you only need to respond immediately prior to the default painting of each button and are not using the Flags parameter, use OnCustomDrawButton instead.
OnAdvancedCustomDrawButton is an event handler of type Vcl.ComCtrls.TTBAdvancedCustomDrawBtnEvent.</docstr>
      </event>
      <event name="OnCustomDraw">
        <docstr>Occurs when the toolbar must be painted.
Write an OnCustomDraw event handler to enhance or replace the automatic painting of the toolbar. Use the toolbar&apos;s Canvas property to render the toolbar&apos;s image. OnCustomDraw is for painting the background of the toolbar. The painting of individual buttons on the toolbar should be handled in an OnCustomDrawButton or OnAdvancedCustomDrawButton event handler.

Note: OnCustomDraw only occurs prior to painting the toolbar&apos;s background. To respond at other points in the paint process (when the background is erased, or after the default painting of the toolbar&apos;s background), use OnAdvancedCustomDraw instead.
OnCustomDraw is an event handler of type Vcl.ComCtrls.TTBCustomDrawEvent.</docstr>
      </event>
      <event name="OnCustomDrawButton">
        <docstr>Occurs when one of the buttons in the toolbar must be painted.
Write an OnCustomDrawButton event handler to enhance or replace the automatic painting of the toolbar&apos;s buttons. Use the toolbar&apos;s Canvas property to render the button&apos;s image. OnCustomDrawButton is for painting individual buttons on the toolbar. The painting of the toolbar itself should be handled in an OnCustomDraw or OnAdvancedCustomDraw event handler.

Note: OnCustomDrawButton only occurs prior to painting the button. To respond at other points in the process of painting a button (when the background is erased, or after the default painting of the button), use OnAdvancedCustomDrawButton instead.
OnCustomDrawButton is an event handler of type Vcl.ComCtrls.TTBCustomDrawBtnEvent.</docstr>
      </event>
      <event name="OnCustomizeAdded">
        <docstr>Occurs when the user adds a button to the toolbar.
Write an OnCustomizeAdded handler to respond when the user adds a new button to the toolbar using the toolbar customize dialog. 
This event occurs after the new button is already added to the toolbar. To respond before the button is added, possibly even preventing the user from adding the button, use the OnCustomizeCanInsert event instead.
OnCustomizeAdded is an event handler of type Vcl.ComCtrls.TTBButtonEvent.</docstr>
      </event>
      <event name="OnCustomizeCanInsert">
        <docstr>Occurs when user tries to add a button to the toolbar.
When the Customizable property is true, the user can add buttons to the toolbar using the toolbar customize dialog. OnCustomizeCanInsert occurs when the user tries to add a button, and allows the application to reject the insertion. If the OnCustomizeCanInsert event handler sets its Allow parameter to false, the toolbar customize dialog rejects the insertion.
OnCustomizeCanInsert is an event handler of type Vcl.ComCtrls.TTBCustomizeQueryEvent.</docstr>
      </event>
      <event name="OnCustomizeCanDelete">
        <docstr>Occurs when user tries to delete one of the buttons on the toolbar.
When the Customizable property is true, the user can remove buttons from the toolbar by dragging them off the toolbar when the Shift key is pressed or using the toolbar customize dialog. OnCustomizeCanDelete occurs when the user tries to delete a button in one of these ways, and allows the application to reject the deletion. If the OnCustomizeCanDelete event handler sets its Allow parameter to false, the tool button returns to the position it occupied before the user tried to delete it.
OnCustomizeCanDelete is an event handler of type Vcl.ComCtrls.TTBCustomizeQueryEvent.</docstr>
      </event>
      <event name="OnCustomized">
        <docstr>Occurs when the user finishes making changes to the toolbar.
Write an OnCustomized event handler to take action after the user has finished making changes to the toolbar. This event occurs when the user finishes a drag operation (with the Shift key down) that moves or deletes a tool button, and when the user exits the toolbar customize dialog.</docstr>
      </event>
      <event name="OnCustomizeDelete">
        <docstr>Occurs when the user deletes a button from the toolbar.
Write an OnCustomizeDelete event handler to respond when the user deletes a tool button by dragging it off the toolbar when the SHIFT key is pressed or by using the toolbar customize dialog. 
This event occurs after the button has been removed from the toolbar. To respond before the button is being deleted, possibly preventing the user from deleting the button, use the OnCustomizeCanDelete event instead.
OnCustomizeDelete is an event handler of type Vcl.ComCtrls.TTBButtonEvent.</docstr>
      </event>
      <event name="OnCustomizing">
        <docstr>Occurs when the user displays the toolbar customize dialog in order to make changes to the toolbar.
Write an OnCustomizing event handler to take action when the user first displays the toolbar customize dialog.</docstr>
      </event>
      <event name="OnCustomizeNewButton">
        <docstr>Occurs when the user tries to add a new button to the tool bar.
Write an OnCustomizeNewButton event handler to supply your own TToolButton objects to represent the tool buttons that a user adds in the toolbar customize dialog.
OnCustomizeNewButton is an event handler of type Vcl.ComCtrls.TTBNewButtonEvent.</docstr>
      </event>
      <event name="OnCustomizeReset">
        <docstr>Occurs when the user cancels a customization to the toolbar.
Write an OnCustomizeReset event handler to respond when the user cancels changes made in the toolbar customize dialog.</docstr>
      </event>
    </members>
  </class>
  <class unit="Vcl.ComCtrls" name="TMonthCalendar">
    <docstr></docstr>
    <members>
      <procedure name="WMEraseBkgnd">
        <docstr>Override background painting for custom style</docstr>
      </procedure>
    </members>
  </class>
  <class unit="Vcl.ComCtrls" name="TDateTimePicker">
    <docstr>TDateTimePicker displays a list box for entering dates or times.
TDateTimePicker is a visual component designed specifically for entering dates or times. In dmComboBox date mode, it resembles a list box or combo box, except that the drop-down list is replaced with a calendar illustration; users can select a date from the calendar. Dates or times can also be selected by scrolling with Up and Down arrows and by typing.
Date-time picker ignores the BiDiMode setting for right-to-left reading, displaying dates according to the system locale.
TDateTimePicker formats date and time values according to the date and time settings in the Regional Settings of the Control panel on the user&apos;s system. Because TDateTimePicker is a wrapper for a Windows control, these formats can&apos;t be changed by changing the formatting variables in the SysUtils unit. However, you can use the Windows API call DateTime_SetFormat to programmatically specify these settings.

Note: The underlying Windows control is known to behave unpredictably when used to set dates in 1752, the year English-speaking countries changed to the Gregorian calendar. Similar problems may appear for different dates when a non-English locale is used. If an application might be used to specify dates on or before the changeover in the current locale (for example, 1918 or before in Russian locales), be sure to test the application using the dates affected.</docstr>
    <members>
      <function name="CanObserve">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="CheckEmptyDate">
        <docstr>Clears the check box associated with the calendar.
Vcl.ComCtrls.TDateTimePicker.CheckEmptyDate inherits from Vcl.ComCtrls.TCommonCalendar.CheckEmptyDate. All content below this line refers to Vcl.ComCtrls.TCommonCalendar.CheckEmptyDate.
Clears the check box associated with the calendar.
CheckEmptyDate is called automatically when DateTime is assigned a value that represents a time and not a date value (or Date is assigned a value of 0). As implemented in TCommonCalendar, CheckEmptyDate does nothing.
TDateTimePicker overrides CheckEmptyDate to clear the check box associated with the calendar, or raise an EDateTimeError if the ShowCheckbox property is false. This allows TDateTimePicker to represent time values that do not include a date portion. (When a TDateTime value represents a time and not a date, the date portion is 0).</docstr>
      </procedure>
      <procedure name="CreateParams">
        <docstr>Initializes a window-creation parameter data structure.
Vcl.ComCtrls.TDateTimePicker.CreateParams inherits from Vcl.Controls.TWinControl.CreateParams. All content below this line refers to Vcl.Controls.TWinControl.CreateParams.
Initializes a window-creation parameter data structure.
The CreateWnd method calls CreateParams to initialize the parameters it passes to CreateWindowHandle. Override CreateParams to customize the way a control creates its Windows representation. When overriding CreateParams, always call the inherited method first to set the default values, then make any desired adjustments.
CreateParams fills in the parameter that is passed as the value of the Params parameter. This data structure holds information needed when telling Windows to create a window handle. The fields of a TCreateParams record become the parameters to a call to the CreateWindowEx API function.
TWinControl implements CreateParams by setting all the fields of Params to generic base values. A number of the standard controls override CreateParams to change one or more of the default values in Params.</docstr>
      </procedure>
      <procedure name="CreateWnd">
        <docstr>Creates the windows control for the calendar.
Vcl.ComCtrls.TDateTimePicker.CreateWnd inherits from Vcl.ComCtrls.TCommonCalendar.CreateWnd. All content below this line refers to Vcl.ComCtrls.TCommonCalendar.CreateWnd.
Creates the windows control for the calendar.
CreateWnd is called automatically when the windowed control is first created or when the window must be destroyed and recreated to reflect property changes. Override CreateWnd to pass additional initialization messages to the window when it is first created.
CreateWnd calls the TWinControl CreateWnd method to generate the window, and then sends messages to initialize the control so that it reflects the current property settings.</docstr>
      </procedure>
      <procedure name="Change">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="GetCalendarHandle">
        <docstr>Returns the calendar control&apos;s window handle.
Vcl.ComCtrls.TDateTimePicker.GetCalendarHandle inherits from Vcl.ComCtrls.TCommonCalendar.GetCalendarHandle. All content below this line refers to Vcl.ComCtrls.TCommonCalendar.GetCalendarHandle.
Returns the calendar control&apos;s window handle.
GetCalendarHandle is the protected read implementation of the CalendarHandle property. For TCommonCalendar, this is an abstract method. It must be implemented in descendant classes.</docstr>
      </function>
      <function name="MsgSetCalColors">
        <docstr>Sets the calendar&apos;s colors.
Vcl.ComCtrls.TDateTimePicker.MsgSetCalColors inherits from Vcl.ComCtrls.TCommonCalendar.MsgSetCalColors. All content below this line refers to Vcl.ComCtrls.TCommonCalendar.MsgSetCalColors.
Sets the calendar&apos;s colors.
MsgSetCalColors implements the CalColors property by sending a message to the calendar window handle. MsgSetCalColors is an abstract method, and must be overridden in descendant objects to send the appropriate message.
The ColorIndex parameter indicates which of the TMonthCalColors properties is being set. It is one of the following values:





Value

Property



0



BackColor




1



TextColor




2



TitleBackColor




3



TitleTextColor




4



MonthBackColor




5



TrailingTextColor




The ColorValue parameter is the value that should be set.
MsgSetCalColors returns true if the color is set by the method.</docstr>
      </function>
      <function name="MsgSetDateTime">
        <docstr>Sets the calendar&apos;s date/time.
Vcl.ComCtrls.TDateTimePicker.MsgSetDateTime inherits from Vcl.ComCtrls.TCommonCalendar.MsgSetDateTime. All content below this line refers to Vcl.ComCtrls.TCommonCalendar.MsgSetDateTime.
Sets the calendar&apos;s date/time.
MsgSetDateTime implements the DateTime property by sending a message to the calendar window handle. MsgSetDateTime is an abstract method, and must be overridden in descendant objects to send the appropriate message.
The Value parameter indicates the value of DateTime as a TSystemTime value. This can be obtained from the DateTime property value by calling DateTimeToSystemTime.
MsgSetDateTime returns true if the date/time value is set by the method.</docstr>
      </function>
      <function name="MsgSetRange">
        <docstr>Implements the MinDate and MaxDate properties.
Vcl.ComCtrls.TDateTimePicker.MsgSetRange inherits from Vcl.ComCtrls.TCommonCalendar.MsgSetRange. All content below this line refers to Vcl.ComCtrls.TCommonCalendar.MsgSetRange.
Implements the MinDate and MaxDate properties.
MsgSetRange implements the MinDate and MaxDate properties by sending a message to the calendar window handle. MsgSetRange is an abstract method, and must be overridden in descendant objects to send the appropriate message.
The Flags parameter indicates what type of information is included in the SysTime array. It includes the GDTR_MIN flag if a minimum date is supplied and GDTR_MAX if a maximum date is supplied.
The SysTime parameter is a two-element array containing the minimum date as the first element and the maximum date as the second element. These values can be obtained from the MinDate and MaxDate properties by calling DateTimeToSystemTime.
MsgSetRange returns true if the range is set by the method.</docstr>
      </function>
      <function name="MsgSetRange">
        <docstr>Implements the MinDate and MaxDate properties.
Vcl.ComCtrls.TDateTimePicker.MsgSetRange inherits from Vcl.ComCtrls.TCommonCalendar.MsgSetRange. All content below this line refers to Vcl.ComCtrls.TCommonCalendar.MsgSetRange.
Implements the MinDate and MaxDate properties.
MsgSetRange implements the MinDate and MaxDate properties by sending a message to the calendar window handle. MsgSetRange is an abstract method, and must be overridden in descendant objects to send the appropriate message.
The Flags parameter indicates what type of information is included in the SysTime array. It includes the GDTR_MIN flag if a minimum date is supplied and GDTR_MAX if a maximum date is supplied.
The SysTime parameter is a two-element array containing the minimum date as the first element and the maximum date as the second element. These values can be obtained from the MinDate and MaxDate properties by calling DateTimeToSystemTime.
MsgSetRange returns true if the range is set by the method.</docstr>
      </function>
      <constructor name="Create">
        <docstr>Creates and initializes a TDateTimePicker instance.
Create calls the inherited constructor method and initializes the Date and Time properties to the current date and time. It also sets the following ControlStyle flags: csCaptureMouse, csOpaque, csClickEvents, csDoubleClicks, and csFixedHeight.</docstr>
      </constructor>
      <property name="DroppedDown">
        <docstr>Specifies whether the date time picker control is dropped down.
DroppedDown specifies whether the date time picker control is dropped down.</docstr>
      </property>
      <property name="CalAlignment">
        <docstr>Determines the alignment of the drop-down calendar.
Set CalAlignment to dtaLeft or dtaRight to align the drop-down calendar on the left or right side of the component. This property is applicable only if the Kind property is dtkDate and the DateMode property is dmComboBox.</docstr>
      </property>
      <property name="Format">
        <docstr>Specify format for date-time string.
Format specifies custom format string for the date-time display, overriding the control panel strings. A custom format can include both date and time fields, but time fields are not editable unless the Kind property is dtkTime. The following format characters are understood.





Element

Description



d



The one- or two-digit day.




dd



The two-digit day. Single-digit day values are preceded by a zero.




ddd



The three-character weekday abbreviation.




dddd



The full weekday name.




h



The one- or two-digit hour in 12-hour format.




hh



The two-digit hour in 12-hour format. Single-digit values are preceded by a zero.




H



The one- or two-digit hour in 24-hour format.




HH



The two-digit hour in 24-hour format. Single-digit values are preceded by a zero.




m



The one- or two-digit minute.




mm



The two-digit minute. Single-digit values are preceded by a zero.




M



The one- or two-digit month number.




MM



The two-digit month number. Single-digit values are preceded by a zero.




MMM



The three-character month abbreviation.




MMMM



The full month name.




t



The one-letter AM/PM abbreviation (that is, AM is displayed as &quot;A&quot;).




tt



The two-letter AM/PM abbreviation (that is, AM is displayed as &quot;AM&quot;).




yy



The last two digits of the year (that is, 2001 would be displayed as &quot;01&quot;).




yyyy



The full year (that is, 2001 would be displayed as &quot;2001&quot;).




To include literal strings in the format, enclose them in single quotes. Failing to quote literal strings can have unpredictable results, even if they do not include formatting codes. Use two single quotes to represent one single quote character in a literal string. For example,
Today&apos;s date: MMM dd, yyyy
entered in the property editor, produces the following results for April 1, 2001:
&quot;Today&apos;s date: Apr 01, 2001&quot;

Note:  When setting Format programmatically in Delphi code, double each single quote again:



DateTimePicker1.Format := &apos;&apos;&apos;Today&apos;&apos;&apos;&apos;s date:&apos;&apos; MMM dd, yyyy&apos;;</docstr>
      </property>
      <property name="Time">
        <docstr>Indicates the time entered by the user.
Time represents the time entered by the user. Set Time in program code or in the Object Inspector to determine which time is selected by default. (Applies only when Kind = dtkTime.)</docstr>
      </property>
      <property name="ShowCheckbox">
        <docstr>Displays a check box next to the date or time.
Set ShowCheckbox to true to display a check box in the TDateTimePicker component.</docstr>
      </property>
      <property name="Checked">
        <docstr>Indicates whether the check box next to the date or time is selected.
Checked is true if the check box in the TDateTimePicker component is selected. Setting Checked to true at design time makes the check box appear selected by default.</docstr>
      </property>
      <property name="DateFormat">
        <docstr>Specifies format in which the date is presented.
If DateFormat is set to dfShort, the date is formatted using the short date format specified in the Windows control panel. By default, it appears like this: 3/21/97. 
If DateFormat is set to dfLong, the date is formatted using the long date format specified in the Windows control panel. By default, it appears like this: Friday, March 21, 1997. (Applies only when Kind is dtkDate.)
For custom date formats, set the Format property.</docstr>
      </property>
      <property name="DateMode">
        <docstr>Determines the method of date selection used by the component.
If DateMode is dmComboBox, the component has a drop-down calendar illustration from which the user can select a date. If DateMode is dmUpDown, the component has Up/Down arrows with which the user can adjust the date. (Applies only when Kind is dtkDate.)</docstr>
      </property>
      <property name="Kind">
        <docstr>Determines whether the component is a date selector or a time selector.
If the Kind property is dtkDate, the control is configured to support date editing. The default format gives only the date portion of the control value, and a drop-down calendar is available if the DateMode property is dmComboxBox.
If the Kind property is dtkTime, the control is configured to support time editing. The default format give only the time portion of the control value, but the date portion can also be edited if the Format property includes date field codes..</docstr>
      </property>
      <property name="ParseInput">
        <docstr>Enables the OnUserInput event.
If ParseInput is True, the OnUserInput event occurs whenever the user types into the component&apos;s edit box.</docstr>
      </property>
      <event name="OnCloseUp">
        <docstr>Occurs when the drop-down calendar closes.
Write an OnCloseUp event handler to implement special processing that needs to occur only when the drop-down calendar closes.</docstr>
      </event>
      <event name="OnChange">
        <docstr>Occurs when a date or time is entered.
Write an OnChange event handler to take specific action whenever the date or time entered in the component changes.</docstr>
      </event>
      <event name="OnDropDown">
        <docstr>Occurs when the user opens the drop-down calendar by clicking the arrow at the right of the control.
Write an OnDropDown event handler to implement special processing that needs to occur only when the drop-down calendar is opened.</docstr>
      </event>
      <event name="OnUserInput">
        <docstr>Occurs when the user types directly into the component&apos;s edit box.
This event occurs only if ParseInput is set to True. Write an OnUserInput event handler implementing special processing that needs to occur when the user types directly into the TDateTimePicker (rather than selecting with the drop-down calendar or scroll arrows).
OnUserInput is an event handler of type Vcl.ComCtrls.TDTParseInputEvent.</docstr>
      </event>
    </members>
  </class>
  <class unit="Vcl.ComCtrls" name="TCustomComboBoxEx">
    <docstr></docstr>
    <members>
      <procedure name="WMGetTextLength">
        <docstr>Custom handler for WM_GETTEXTLENGTH message.</docstr>
      </procedure>
      <procedure name="WMGetText">
        <docstr>Custom handler for WM_GETTEXT message.</docstr>
      </procedure>
      <procedure name="WMSetText">
        <docstr>Custom handler for WM_SETTEXT message.</docstr>
      </procedure>
      <procedure name="CBGetEditSel">
        <docstr>Custom handler for CB_GETEDITSEL message.</docstr>
      </procedure>
      <procedure name="CBSetEditSel">
        <docstr>Custom handler for CB_SETEDITSEL message.</docstr>
      </procedure>
    </members>
  </class>
  <class unit="Vcl.ComCtrls" name="TStatusBarStyleHook">
    <docstr></docstr>
    <members>
      <procedure name="WMEraseBkgnd">
        <docstr>Override background painting</docstr>
      </procedure>
    </members>
  </class>
  <class unit="Vcl.ExtCtrls" name="TTimer">
    <docstr>TTimer encapsulates the Windows API timer functions.
TTimer is used to simplify calling the Windows API timer functions SetTimer and KillTimer, and to simplify processing the WM_TIMER messages. Use one timer component for each timer in the application.
The execution of the timer occurs through its OnTimer event. TTimer has an Interval property that determines how often the timer&apos;s OnTimer event occurs. The interval corresponds to the parameter for the Windows API SetTimer function.

Warning: Limitations on the total number of timers system-wide are system-dependent.</docstr>
    <members>
      <procedure name="Timer">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Instantiates a timer object.
Call Create to instantiate a timer at runtime. Timers added to forms or data modules at design time are created automatically.
AOwner specifies the component, typically a form or data module, that is responsible for freeing the timer.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Disposes of a timer object.
Do not call Destroy directly in an application. Instead, an application should call Free. Free verifies that the timer is not nil before it calls Destroy.
Destroy deactivates the timer by setting Enabled to False before freeing the resources required by the timer.</docstr>
      </destructor>
      <property name="Enabled">
        <docstr>Controls whether the timer generates OnTimer events periodically.
Use Enabled to enable or disable the timer. If Enabled is true, the timer responds normally. If Enabled is false, the timer does not generate OnTimer events. The default is true.</docstr>
      </property>
      <property name="Interval">
        <docstr>Determines the amount of time, in milliseconds, that passes before the timer component initiates another OnTimer event.
Interval determines how frequently the OnTimer event occurs. Each time the specified interval passes, the OnTimer event occurs.
Use Interval to specify any cardinal value as the interval between OnTimer events. The default value is 1000 (one second).

Note:   A 0 value is valid, however the timer will not call an OnTimer event for a value of 0.</docstr>
      </property>
      <event name="OnTimer">
        <docstr>Occurs when a specified amount of time, determined by the Interval property, has passed.
Write an OnTimer event handler to execute an action at regular intervals.
The Interval property of a timer determines how frequently the OnTimer event occurs. Each time the specified interval passes, the OnTimer event occurs.</docstr>
      </event>
    </members>
  </class>
  <class unit="Vcl.ExtCtrls" name="TPage">
    <docstr>Specifies a page in a TNotebook control.
The TPage class implements a page in a TNotebook control.</docstr>
    <members>
      <procedure name="ReadState">
        <docstr>Prepares the control for having its properties assigned values from a stream.
Vcl.ExtCtrls.TPage.ReadState inherits from Vcl.Controls.TWinControl.ReadState. All content below this line refers to Vcl.Controls.TWinControl.ReadState.
Prepares the control for having its properties assigned values from a stream.
Override ReadState to change the preparations the control makes as it readies itself to have its property values assigned from a stream. For example, a control might destroy temporary internal data structures or objects before new instances are loaded from the stream. Be sure to include a call to the inherited method when overriding ReadState.
As implemented in TWinControl, ReadState disables control alignment until all the child controls have been read from the stream, calls the inherited ReadState method, and re-enables the alignment of all the controls. The method then builds the tab order list of controls and synchronizes its visibility with that of its parent control.</docstr>
      </procedure>
      <procedure name="Paint">
        <docstr>Renders the image of a custom control.
Vcl.ExtCtrls.TPage.Paint inherits from Vcl.Controls.TCustomControl.Paint. All content below this line refers to Vcl.Controls.TCustomControl.Paint.
Renders the image of a custom control.
The Paint method for TCustomControl does nothing other than provide the interface for a method that responds to WM_PAINT messages. Paint is called by the PaintWindow method, after that method has supplied the Canvas with the handle to a device context. When creating a custom control, always override Paint to draw the image of the control.

Tip:  To determine which portions of the control&apos;s canvas need to be repainted when Paint is called, use the ClipRect property of the canvas.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Creates an instance of TCustomControl.
Vcl.ExtCtrls.TPage.Create inherits from Vcl.Controls.TCustomControl.Create. All content below this line refers to Vcl.Controls.TCustomControl.Create.
Creates an instance of TCustomControl.
Calling Create constructs and initializes an instance of TCustomControl. However, you should never attempt to instantiate a TCustomControl. This class is intended solely as a base class from which other control classes descend and you should only call Create to instantiate one of these descendants. Controls placed on forms at design time are created automatically.
After calling the inherited constructor, Create initializes the control and also a TCanvas object for its Canvas property.
When overriding Create, always call the inherited Create method first, then proceed with the control&apos;s initialization. Remember to specify the override directive when overriding the Create method.

Note: If a component&apos;s constructor allocates resources or memory, also override the destructor to free those resources.</docstr>
      </constructor>
    </members>
  </class>
  <class unit="Vcl.ExtCtrls" name="TNotebook">
    <docstr>TNotebook displays multiple pages, each with its own set of controls.
Notebook components are frequently used with tab set controls (TTabSet) to let the user select pages in the notebook by clicking a tab. TNotebook is provided for backward compatibility. New applications should use TPageControl instead.</docstr>
    <members>
      <procedure name="CreateParams">
        <docstr>Initializes a window-creation parameter data structure.
Vcl.ExtCtrls.TNotebook.CreateParams inherits from Vcl.Controls.TWinControl.CreateParams. All content below this line refers to Vcl.Controls.TWinControl.CreateParams.
Initializes a window-creation parameter data structure.
The CreateWnd method calls CreateParams to initialize the parameters it passes to CreateWindowHandle. Override CreateParams to customize the way a control creates its Windows representation. When overriding CreateParams, always call the inherited method first to set the default values, then make any desired adjustments.
CreateParams fills in the parameter that is passed as the value of the Params parameter. This data structure holds information needed when telling Windows to create a window handle. The fields of a TCreateParams record become the parameters to a call to the CreateWindowEx API function.
TWinControl implements CreateParams by setting all the fields of Params to generic base values. A number of the standard controls override CreateParams to change one or more of the default values in Params.</docstr>
      </procedure>
      <function name="GetChildOwner">
        <docstr>Returns the owner of a child component being read from a stream.
Vcl.ExtCtrls.TNotebook.GetChildOwner inherits from System.Classes.TComponent.GetChildOwner. All content below this line refers to System.Classes.TComponent.GetChildOwner.
Returns the owner of a child component being read from a stream.
GetChildOwner is used internally by the component streaming system. It is rarely necessary to call it directly.
In TComponent, GetChildOwner always returns nil (Delphi) or NULL (C++), indicating that the owner is the root component currently being read (usually a form or data module). The Owner of a component is responsible for destroying it.</docstr>
      </function>
      <procedure name="ReadState">
        <docstr>Prepares the control for having its properties assigned values from a stream.
Vcl.ExtCtrls.TNotebook.ReadState inherits from Vcl.Controls.TWinControl.ReadState. All content below this line refers to Vcl.Controls.TWinControl.ReadState.
Prepares the control for having its properties assigned values from a stream.
Override ReadState to change the preparations the control makes as it readies itself to have its property values assigned from a stream. For example, a control might destroy temporary internal data structures or objects before new instances are loaded from the stream. Be sure to include a call to the inherited method when overriding ReadState.
As implemented in TWinControl, ReadState disables control alignment until all the child controls have been read from the stream, calls the inherited ReadState method, and re-enables the alignment of all the controls. The method then builds the tab order list of controls and synchronizes its visibility with that of its parent control.</docstr>
      </procedure>
      <procedure name="ShowControl">
        <docstr>Ensures that a specified child control is visible.
Vcl.ExtCtrls.TNotebook.ShowControl inherits from Vcl.Controls.TWinControl.ShowControl. All content below this line refers to Vcl.Controls.TWinControl.ShowControl.
Ensures that a specified child control is visible.
Call ShowControl to display a child control. Specify the control you want to ensure will be visible as the value of the AControl parameter.
As implemented in TWinControl, ShowControl simply calls the ShowControl method of the control&apos;s parent. Derived objects override ShowControl to perform whatever actions are necessary to allow the indicated child object to be visible. Possible actions include scrolling the particular child object into view, or changing to the appropriate notebook page.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Constructs a TNotebook component.
Call Create to instantiate a notebook at runtime. Notebook components placed in forms at design time are created automatically.
The AOwner parameter specifies the component (usually the form) that is responsible for freeing the notebook.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys the TNotebook component.
Do not call Destroy directly in an application. Instead, use Free, which checks that the TNotebook reference is not nil before calling Destroy.</docstr>
      </destructor>
      <procedure name="GetChildren">
        <docstr>Calls a specified method for each child of the control.
Vcl.ExtCtrls.TNotebook.GetChildren inherits from Vcl.Controls.TWinControl.GetChildren. All content below this line refers to Vcl.Controls.TWinControl.GetChildren.
Calls a specified method for each child of the control.
GetChildren is called by the streaming system that loads and saves components. Applications seldom need to call this routine.
GetChildren executes the callback specified by the Proc parameter for every child control listed by the Controls property that lists the Root parameter as its Owner.
Override GetChildren to limit or augment which child controls are saved with the control. When overriding GetChildren, call the procedure passed as the Proc parameter for every child control that should be saved. The Root parameter indicates the component (usually a form) that owns the control.</docstr>
      </procedure>
      <property name="ActivePage">
        <docstr>Determines which page displays in the notebook.
ActivePage determines which page displays in the notebook. The value of ActivePage must be one of the strings contained in the Pages property.
To get or set the active page by index rather than string, use the PageIndex property instead.</docstr>
      </property>
      <property name="PageIndex">
        <docstr>Determines which page displays in the notebook control.
The value of PageIndex determines which page displays in the notebook. Changing the PageIndex value changes the page in the control.
Each string in the Pages property is automatically assigned a PageIndex value when the page is created. The first page receives a value of 0, the second has a value of 1, and so on. If you delete a string from the Pages property, the PageIndex values are reassigned so that the values always begin with 0 and continue to increase without any gaps between values.
To get or set the current page using its string rather than its index, use the ActivePage property instead.</docstr>
      </property>
      <property name="Pages">
        <docstr>Contains the strings that identify the individual pages of the notebook control.
The Pages property contains the strings that identify the individual pages of the notebook control. Both these controls create a separate page for each string in the Pages property. For example, if Pages contains three strings, First, Second, and Third, the control has three separate pages. 
You can access the various pages in a notebook or tabbed notebook control with either the ActivePage or PageIndex property.</docstr>
      </property>
      <event name="OnPageChanged">
        <docstr>Occurs when the user selects a new page in the notebook.
Use the OnPageChanged event when you want special processing to occur when the active page changes.</docstr>
      </event>
    </members>
  </class>
  <class unit="Vcl.ExtCtrls" name="THeader">
    <docstr>THeader is a sectioned visual control that displays text and allows each section to be resized with the mouse.
THeader is provided for backward compatibility. New applications should use THeaderControl instead.</docstr>
    <members>
      <procedure name="ChangeScale">
        <docstr>Resize and reposition children and self.
Vcl.ExtCtrls.THeader.ChangeScale inherits from Vcl.Controls.TWinControl.ChangeScale. All content below this line refers to Vcl.Controls.TWinControl.ChangeScale.
Resize and reposition children and self.
ChangeScale rescales the control in the same manner as the ChangeScale method in TControl. If the control contains any children, their ChangeScale methods are called before the parent itself is rescaled.
To rescale the control&apos;s children without rescaling the control itself, use ScaleControls. To rescale the control without repositioning, use ScaleBy.</docstr>
      </procedure>
      <procedure name="Paint">
        <docstr>Renders the image of a custom control.
Vcl.ExtCtrls.THeader.Paint inherits from Vcl.Controls.TCustomControl.Paint. All content below this line refers to Vcl.Controls.TCustomControl.Paint.
Renders the image of a custom control.
The Paint method for TCustomControl does nothing other than provide the interface for a method that responds to WM_PAINT messages. Paint is called by the PaintWindow method, after that method has supplied the Canvas with the handle to a device context. When creating a custom control, always override Paint to draw the image of the control.

Tip:  To determine which portions of the control&apos;s canvas need to be repainted when Paint is called, use the ClipRect property of the canvas.</docstr>
      </procedure>
      <procedure name="CreateParams">
        <docstr>Initializes a window-creation parameter data structure.
Vcl.ExtCtrls.THeader.CreateParams inherits from Vcl.Controls.TWinControl.CreateParams. All content below this line refers to Vcl.Controls.TWinControl.CreateParams.
Initializes a window-creation parameter data structure.
The CreateWnd method calls CreateParams to initialize the parameters it passes to CreateWindowHandle. Override CreateParams to customize the way a control creates its Windows representation. When overriding CreateParams, always call the inherited method first to set the default values, then make any desired adjustments.
CreateParams fills in the parameter that is passed as the value of the Params parameter. This data structure holds information needed when telling Windows to create a window handle. The fields of a TCreateParams record become the parameters to a call to the CreateWindowEx API function.
TWinControl implements CreateParams by setting all the fields of Params to generic base values. A number of the standard controls override CreateParams to change one or more of the default values in Params.</docstr>
      </procedure>
      <procedure name="MouseDown">
        <docstr>OnMouseDown event dispatcher.
Vcl.ExtCtrls.THeader.MouseDown inherits from Vcl.Controls.TControl.MouseDown. All content below this line refers to Vcl.Controls.TControl.MouseDown.
OnMouseDown event dispatcher.
Override the protected MouseDown method to provide other responses in addition to calling the OnMouseDown event handler when the user presses the mouse button down while the cursor&apos;s hotspot is over the control.
The Button parameter determines which mouse button the user pressed. Shift indicates which shift keys (Shift, Ctrl, or Alt) were down when the user pressed the mouse button. X and Y are the pixel coordinates of the mouse pointer within the client area of the control.
A control calls MouseDown in response to any of the Windows mouse-down messages (WM_LBUTTONDOWN, WM_MBUTTONDOWN, WM_RBUTTONDOWN), decoding the message parameters into the shift-key state and position, which it passes in the Shift, X, and Y parameters, respectively. The value of the Button parameter indicates which mouse button was pressed down: left, right, or middle.</docstr>
      </procedure>
      <procedure name="MouseMove">
        <docstr>Responds to mouse moving over control area.
Vcl.ExtCtrls.THeader.MouseMove inherits from Vcl.Controls.TControl.MouseMove. All content below this line refers to Vcl.Controls.TControl.MouseMove.
Responds to mouse moving over control area.
Override the protected MouseMove method to provide other responses in addition to calling the OnMouseMove event handler when the user moves the mouse.
A control calls MouseMove in response to any of the Windows mouse-move messages (WM_MOUSEMOVE), decoding the message parameters into the shift-key state and position, which it passes in the Shift, X, and Y parameters, respectively.
As the mouse cursor moves across a control, this method is called repeatedly. Each time it is called, it is with the new coordinates that reflect the continuous path of the mouse cursor across the screen real estate covered by the control&apos;s visual representation.</docstr>
      </procedure>
      <procedure name="MouseUp">
        <docstr>Is an OnMouseUp event dispatcher.
Vcl.ExtCtrls.THeader.MouseUp inherits from Vcl.Controls.TControl.MouseUp. All content below this line refers to Vcl.Controls.TControl.MouseUp.
Is an OnMouseUp event dispatcher.
Override the protected MouseUp method to provide other responses in addition to calling the OnMouseUp event handler when the user releases a previously pressed mouse button while the cursor&apos;s hot spot is over the control.
A control calls MouseUp in response to any of the Windows mouse-up messages (WM_LBUTTONUP, WM_MBUTTONUP, WM_RBUTTONUP), decoding the message parameters into the shift-key state and position, which it passes in the Shift, X, and Y parameters, respectively. The value of the Button parameter indicates which mouse button was released: left, right, or middle.</docstr>
      </procedure>
      <procedure name="Sizing">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="Sized">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Creates a new THeader object.
Call Create to instantiate a header at runtime. Headers added to forms at design time are created automatically.
The AOwner parameter initializes the Owner property of the header.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Frees the memory associated with the THeader object.
Do not call Destroy directly. Instead, use the Free method, which checks whether the THeader reference is nil before calling Destroy.</docstr>
      </destructor>
      <property name="AllowResize">
        <docstr>Determines if the user can modify the size of the header at runtime with the mouse.
If AllowResize is false, the sections within a header can&apos;t be resized. If AllowResize is true, clicking a border of a header section and dragging it left or right changes the width of the section. The default value is true.</docstr>
      </property>
      <property name="BorderStyle">
        <docstr>Determines whether the header control has a border.
These are the possible values:





Value

Meaning



bsNone



No visible border




bsSingle



Single-line border</docstr>
      </property>
      <property name="Sections">
        <docstr>Lists the strings that contain the text for the sections of a header.
The number of lines of the string list determines the number of sections of the header. If the string list is empty, the header has one blank section. If this string list contains one or more lines, the text of each line is in its own section. The first line is in the leftmost section, the second line is in the next section to the right, and so on.</docstr>
      </property>
      <event name="OnSizing">
        <docstr>Occurs before the header is resized.
Write an OnSizing event handler to perform special processing immediately before the header is resized. In this event, AWidth is the width that the section will have after it is resized. Use the SectionWidth property to determine the current size of the section.</docstr>
      </event>
      <event name="OnSized">
        <docstr>Occurs after the header has been resized.
Write an OnSized event handler to perform special processing after the header has been resized. In this event, the AWidth parameter is the width of the section before it was resized. Use the SectionWidth property to determine the new size of the section.
OnSized is an event handler of type Vcl.ExtCtrls.TSectionEvent.</docstr>
      </event>
    </members>
  </class>
  <class unit="Vcl.ExtCtrls" name="TRadioGroup">
    <docstr>TRadioGroup represents a group of radio buttons that function together.
A TRadioGroup object is a special group box that contains only radio buttons. Radio buttons that are placed directly in the same control component are said to be &quot;grouped.&quot; When the user checks a radio button, all other radio buttons in its group become unchecked. Hence, two radio buttons on a form can be checked at the same time only if they are placed in separate containers, such as group boxes.
To add radio buttons to a TRadioGroup, edit the Items property in the Object Inspector. Each string in Items makes a radio button appear in the group box with the string as its caption. The value of the ItemIndex property determines which radio button is currently selected.
Display the radio buttons in a single column or in multiple columns by setting the Columns property.

Note:  Setting the radio group&apos;s BiDiMode to bdRightToLeft automatically flips its radio buttons. The FlipChildren method has no effect.</docstr>
  </class>
  <class unit="Vcl.ExtCtrls" name="TControlBar">
    <docstr>TControlBar manages the layout of toolbar components.
Use TControlBar as a docking site for toolbar components. Control bars contain child controls (usually TToolBar objects) that can be moved and resized independently. As with a cool bar, each child control resides on its own individual band that the user positions by dragging its sizing grip.

Tip:  When docking TToolBar objects to a control bar, you may find it useful to use TToolDockObject.
Note:  If you want to use TActionToolBar on a TControlBar component, you should set the AutoSize property to False. When the AutoSize property is set to True (default), the TActionToolBar control wraps its controls and expands itself in size, accordingly. This does not allow the TActionToolBar component to display properly on a TControlBar component. When the AutoSize property is set to False, the TActionToolBar hides items on the end of the bar and displays a dropdown button that provides access to those items. The control displays in the proper size.</docstr>
  </class>
  <class unit="Vcl.ExtCtrls" name="TBoundLabel">
    <docstr>TBoundLabel is the type of a labeled edit control&apos;s label.
TBoundLabel implements the label of a labeled edit control. Unlike other label controls such as TLabel, TBoundLabel &quot;belongs&quot; to the labeled edit control (it is a subcomponent of the edit control). This means that the bound label&apos;s Owner is the edit control rather than the form, and the edit control is responsible for loading and saving the bound label.
Use the properties of TBoundLabel to specify how you want the labeled edit control&apos;s label to appear. For example, you can use the Caption property to specify the text that appears in the label. You can use the Alignment and Layout properties to specify the placement of that caption within the label.</docstr>
    <members>
      <procedure name="AdjustBounds">
        <docstr>Resizes the label when the text changes.
Vcl.ExtCtrls.TBoundLabel.AdjustBounds inherits from Vcl.StdCtrls.TCustomLabel.AdjustBounds. All content below this line refers to Vcl.StdCtrls.TCustomLabel.AdjustBounds.
Resizes the label when the text changes.
When the text in the label or the font changes, AdjustBounds is implicitly called. It redraws the text in the client area, and then resizes the label if the AutoSize property is true.
When WordWrap is true, the width of the label is fixed. If AutoSize is also true, changes to the text cause the label to change in height. When AutoSize is true and WordWrap is false, the height of the label is determined by the font, and changes to the text cause the label to change in width.
Override AdjustBounds to make additional adjustments when the text changes.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Creates a new TBoundLabel object.
Do not create instances of TBoundLabel. Bound labels are instantiated by the labeled edit controls to which they belong.
AOwner specifies the labeled edit control that acts as the bound label&apos;s Owner.</docstr>
      </constructor>
      <property name="IsLabelModified">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
    </members>
  </class>
  <class unit="Vcl.ExtCtrls" name="TLabeledEdit">
    <docstr>TLabeledEdit is an edit control that has an associated label.
Use TLabeledEdit to add an edit control with a label to a form. TLabeledEdit works with an associated label control, which is the value of its EditLabel property. The position of that label relative to the edit control is determined by the LabelPosition and LabelSpacing properties.
Use the Text property to work with the text in the control, and the label&apos;s Caption property to work with the text in the label.</docstr>
  </class>
  <class unit="Vcl.ExtCtrls" name="TColorBox">
    <docstr>TColorBox represents a combo box that lets users select a color.
Use TColorBox to provide the user with a drop-down combo box from which to select a color. Use the Style property to specify which colors the color box should list. Each color is displayed next to a small square that is drawn in the corresponding color.
Use the Selected property to access the color that the user selects. The Colors property provides access to the entire list of colors, while the ColorNames property lists their names.</docstr>
  </class>
  <class unit="Vcl.ExtCtrls" name="TLinkLabelStyleHook">
    <docstr></docstr>
    <members>
      <procedure name="CNCtlColorStatic">
        <docstr>Override background painting and font color</docstr>
      </procedure>
    </members>
  </class>
  <class unit="System.Actions" name="EActionError">
    <docstr>The class of errors that appear when working with actions</docstr>
  </class>
  <class unit="System.Actions" name="TCustomShortCutList">
    <docstr>This is the base class that implements the operation with
       a list of keyboard shortcuts. Should be established descendants
       of this class (see TContainedAction.CreateShortCutList) for each platform (VCL, FMX), which should be overridden the method Add.</docstr>
  </class>
  <class unit="System.Actions" name="TContainedAction">
    <docstr>TContainedAction is the base class for actions that can be grouped by category and that can appear in action lists.
TContainedAction introduces properties and methods that enable actions to appear in an action list. The properties of TContainedAction contain information about the relationship between the action and its action list. Methods of TContainedAction override those of the base class to take into account the action list that owns the action.
TContainedAction defines the published Category property.
Objects of type TContainedAction can be associated with a Category of actions. This category is used at design time to organize the actions in an action list using the Action List editor or the Action Manager editor (only available for VCL).</docstr>
    <members>
      <procedure name="ReadState">
        <docstr>Reads the state of the action.
ReadState is used internally in the actions system. It is not necessary to call it directly.
ReadState calls the inherited System.Classes.TComponent.ReadState procedure. Then 
ReadState checks whether the Parent of Reader (Reader.Parent) is an action list, then ReadState sets that the action belongs to this action list (ActionList).</docstr>
      </procedure>
      <function name="SecondaryShortCutsCreated">
        <docstr>Retrieves whether the list stored in the SecondaryShortCuts property is created.
SecondaryShortCutsCreated returns True if the SecondaryShortCuts list is created.</docstr>
      </function>
      <function name="CreateShortCutList">
        <docstr>Introduces an interface for creating the ShortCutList object for the action.
As implemented in TContainedAction, CreateShortCutList does not create any shortcut list object and just returns nil.</docstr>
      </function>
      <property name="SavedEnabledState">
        <docstr>Stores the value of the Enabled property when the action is suspended.
The System.Actions.TContainedActionList.SetState method uses SavedEnabledState internally:

When System.Actions.TContainedActionList.SetState changes State from asSuspendedEnabled to asNormal, then the value stored in SavedEnabledState is used to set the Enabled property.
When System.Actions.TContainedActionList.SetState sets State to asSuspendedEnabled, then the value of the Enabled property is saved in SavedEnabledState and Enabled is set to True.</docstr>
      </property>
      <procedure name="AssignTo">
        <docstr>Copies the properties of this action to a destination action.
Dest specifies the destination action. AssignTo ensures the correct assignment of property values.
If Dest is nil or Dest is not of the TContainedAction type, then an error is raised.</docstr>
      </procedure>
      <function name="HandleShortCut">
        <docstr>Executes the action when the user types one of its shortcuts.
HandleShortCut calls System.Classes.TBasicAction.Execute to cause the action to perform its function. HandleShortCut returns the value that System.Classes.TBasicAction.Execute returns.
Descendant classes can override HandleShortCut to respond in other ways when the user types the action&apos;s shortcut keys.</docstr>
      </function>
      <procedure name="SetAutoCheck">
        <docstr>Sets the specified Value to the AutoCheck property of the action, and propagates this Value to all clients of the action.</docstr>
      </procedure>
      <procedure name="SetCaption">
        <docstr>Sets the specified Value to the Caption property of the action, and propagates this Value to all the clients of the action.</docstr>
      </procedure>
      <procedure name="SetName">
        <docstr>Sets the Name and Caption properties of the action.
SetName calls the inherited System.Classes.TComponent.SetName method to set the specified Value to the Name property of the action. If the action does not have any clients and the current values of the Name and Caption properties of the action are equal, then SetName sets Value to the Caption property of the action also. 

Warning: Using SetName to change the name of an action at run time causes any references to the old name to become undefined. Any subsequent code that uses the old name will cause an exception.</docstr>
      </procedure>
      <procedure name="SetChecked">
        <docstr>Sets the specified Value to the Checked property of the action, and propagates this Value to all clients of the action.
If the action has a GroupIndex value greater than 0, then setting Checked to True causes all other actions in the group to have their Checked property set to False.</docstr>
      </procedure>
      <procedure name="SetEnabled">
        <docstr>Sets the Enabled property of the action to the specified Value and propagates this Value to all clients of the action.
The behavior of SetEnabled depends upon the State of the ActionList action list:

If the value of State is asSuspended, then SetEnabled sets to the specified Value only the Enabled property of the action.
If the value of State is asSuspendedEnabled, then SetEnabled sets to True the Enabled property of the action and of all clients of the action.
Otherwise, SetEnabled sets to the specified Value the Enabled property of the action and propagates this Value to all clients of the action.</docstr>
      </procedure>
      <procedure name="SetGroupIndex">
        <docstr>Sets the specified Value to the GroupIndex property of the action and properly handles the ON or OFF state of the Checked properties of all actions in the group specified by Value.
SetGroupIndex sets the specified Value to the GroupIndex property of the action. If the Checked property of this action is True, then SetGroupIndex sets the Checked property to False for all the other actions in the group defined by the specified Value. 
When Value is greater than 0, the group of actions with the GroupIndex property having this Value forms a group of actions that act like a group of radio buttons. When the Checked property of any action in this group is True, the Checked properties of all other actions in the group are False. That is, one and only one action in the group is checked ON at a time.

Note: All actions in a group must be listed by the same action list.</docstr>
      </procedure>
      <procedure name="SetHelpContext">
        <docstr>Sets the Help context ID for the action and action&apos;s clients.
SetHelpContext sets the new Value of the integer help context ID, stored in the HelpContext property, for the action.
SetHelpContext always propagates this Value to all clients of the action.
HelpContext is only used when htContext is selected in the HelpType property.

Note: To use Help in your application, you need to enable Help in your application.</docstr>
      </procedure>
      <procedure name="SetHelpKeyword">
        <docstr>Defines the Help keyword for the action and action&apos;s clients.
SetHelpKeyword sets the new Value of the string help keyword, stored in the HelpKeyword property, for the action.
SetHelpKeyword always propagates this Value to all clients of the action.
HelpKeyword is only used when htKeyword is selected in the HelpType property.</docstr>
      </procedure>
      <procedure name="SetHelpType">
        <docstr>Sets the HelpType property for the action and action&apos;s clients.
SetHelpType sets the new Value of the HelpType property for the action.
SetHelpType always propagates this Value to all clients of the action.</docstr>
      </procedure>
      <procedure name="SetHint">
        <docstr>Sets the Hint property for the action and action&apos;s clients to a new Value.
SetHint sets the new Value of the Hint property for the action. 
SetHint always propagates this Value to all clients of the action.</docstr>
      </procedure>
      <procedure name="SetVisible">
        <docstr>Sets the new Value of the Visible property for the action and action&apos;s clients.
SetVisible always propagates this Value to all clients of the action.</docstr>
      </procedure>
      <procedure name="SetShortCut">
        <docstr>Sets the new Value of the ShortCut property for the action and action&apos;s clients.
SetShortCut always propagates this Value to all clients of the action.</docstr>
      </procedure>
      <procedure name="SetImageIndex">
        <docstr>Sets the new Value of the ImageIndex property for the action and action&apos;s clients.
SetImageIndex always propagates this Value to all clients of the action.</docstr>
      </procedure>
      <procedure name="SetStatusAction">
        <docstr>Sets the new Value of the StatusAction property for the action and action&apos;s clients.
SetStatusAction always propagates this Value to all clients of the action.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Instantiates and initializes a TContainedAction object.
Applications do not need to call Create directly. Actions are created automatically when you choose New Action in the Action List editor. 
Create calls the inherited System.Classes.TBasicAction.Create constructor and then 
initializes the Enabled (setting it to True), Visible (setting it to True), and ImageIndex (setting it to -1) properties.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys the instance of the contained action.
If the action is contained in an action list or action manager, Destroy removes the action from that list. Then it calls the inherited Destroy method.</docstr>
      </destructor>
      <function name="GetParentComponent">
        <docstr>Returns the action list containing the action.
GetParentComponent returns the action list containing the action. This action list is stored in the ActionList property. If ActionList stores nil, then GetParentComponent calls the inherited System.Classes.TComponent.GetParentComponent method.</docstr>
      </function>
      <function name="HasParent">
        <docstr>Indicates whether the action is contained in an action list.
HasParent returns True if the action is contained in an action list stored in the  ActionList property. If ActionList stores nil, then HasParent calls the inherited System.Classes.TComponent.HasParent method.</docstr>
      </function>
      <procedure name="SetParentComponent">
        <docstr>Sets the action list containing the action.
SetParentComponent sets the specified AParent action list as the action list containing the action. This action list is stored in the ActionList property.</docstr>
      </procedure>
      <property name="ActionList">
        <docstr>Holds the action list to which the action belongs.</docstr>
      </property>
      <function name="Suspended">
        <docstr>Returns True if the action list of the action is suspended.</docstr>
      </function>
      <property name="Index">
        <docstr>Specifies the index of the action in its action list.
Index indicates the position of the action in its action list. You can change the action&apos;s Index at design time using one of the IDE editors to handle actions.
The index of actions determines the order in which they appear in user interface elements such as menus and tool bars.
Index is zero-based. When Index is -1, this means that the ActionList property does not contain any list.</docstr>
      </property>
      <property name="DisableIfNoHandler">
        <docstr>Indicates whether the action&apos;s clients should be disabled if no OnExecute event handler is found.
DisableIfNoHandler defines whether to set the Enabled property of the action to False if no OnExecute event handler is set for the action. Setting Enabled to False disables all the action&apos;s clients.
See, for example, how FMX.Forms.TApplication.UpdateAction uses DisableIfNoHandler to define whether to set Enabled to False if the OnExecute event handler is not defined to the action.
For example, setting DisableIfNoHandler to False can be useful when managing submenus. In this case, pointing to a command on the main menu, which causes the submenu to open, does not need any OnExecute event handler. Then, if DisableIfNoHandler is True, this main menu command becomes disabled and the submenu cannot be opened. In such cases it can be convenient to use actions of types FMX.Controls.TControlAction and Vcl.Controls.TControlAction.  Objects of these classes have the value of DisableIfNoHandler set to False, by default.</docstr>
      </property>
      <property name="AutoCheck">
        <docstr>Controls whether the Checked property toggles when the action executes.
AutoCheck causes the Checked property to toggle when the action executes. This allows the Checked property of the action to remain in sync with the Checked property of the client (or an equivalent).
If the client has an AutoCheck property of its own, the AutoCheck property of the action is propagated to the AutoCheck property of the client.</docstr>
      </property>
      <property name="Caption">
        <docstr>Represents the caption of the action.
Caption holds the string that is used as the caption of the action, when it is set. The value of Caption can be propagated to all client controls and client menu items linked to the action.</docstr>
      </property>
      <property name="Checked">
        <docstr>Indicates whether client controls and menu items appear checked.
Checked specifies the checked state for the action. The value of Checked can be propagated to all client controls and client menu items linked to the action.

Note:  If the action has a GroupIndex value greater than 0, then setting Checked to True sets to False the Checked properties of all other actions in the GroupIndex group.
Tip: Use the AutoCheck property to ensure that the action&apos;s Checked property toggles when the action executes.</docstr>
      </property>
      <property name="Enabled">
        <docstr>Specifies the enabled state for the action.
The value of Enabled can be propagated to all client controls and client menu items linked to the action.</docstr>
      </property>
      <property name="GroupIndex">
        <docstr>Indicates a group of actions in one action list. Actions in this group act like the group of radio buttons.
The value of GroupIndex is used to define groups of actions. Actions in each group act like groups of radio buttons. When GroupIndex is greater than 0, this value identifies the group to which some actions belong. The value of GroupIndex can be propagated to all client controls and client menu items linked to the action.
When the Checked property of any action in that group is set to True, the Checked properties of all other actions in the group are set to False. That is, only one action in the group can be checked at a time.

Note:  All actions in a group must be listed by the same action list.</docstr>
      </property>
      <property name="HelpContext">
        <docstr>Keeps the integer context ID that identifies the Help topic for the action.
HelpContext specifies the integer context ID  to identify the Help topic to show when invoking Help for the action. The value of HelpContext can be propagated to all client controls and client menu items linked to the action. See also IsHelpLinked.
HelpContext is only used when htContext is selected in the HelpType property.

Note: To use Help, you need to enable Help in your application. When your application supports usage of the appropriate Help system, then it can show Help topics from the associated Help file. When a client control has focus and the user presses the F1 key, the control uses the value of the HelpContext property to invoke the online Help that shows the topic with this context ID. The target topic is uniquely identified by a HelpContext context ID value.</docstr>
      </property>
      <property name="HelpKeyword">
        <docstr>Contains the keyword string that identifies the Help topic for the action.
The value of HelpKeyword can be propagated to all client controls and client menu items linked to the action. 
HelpKeyword is only used when htKeyword is selected in the HelpType property.

Note: To use Help, you need to enable Help in your application. When your application supports usage of the appropriate Help system, then it can show Help topics from the associated Help file. When a client control has focus and the user presses the F1 key, the control uses the HelpKeyword property&apos;s value to invoke the online Help showing the topic with this keyword.</docstr>
      </property>
      <property name="HelpType">
        <docstr>Keeps whether to use the HelpContext or HelpKeyword property to identify the Help topic.
The value of HelpType can be propagated to all client controls and client menu items linked to the action. 
HelpType can keep one of the following constants:

htContext � instructs to use the HelpContext property to identify the Help topic to show when invoking Help.
htKeyword � instructs to use the HelpKeyword property to identify the Help topic to show when invoking Help.</docstr>
      </property>
      <property name="Hint">
        <docstr>Stores the Help hint text.
Hint holds the hint string indicating the hint text for the action.
Hint contains the text strings that appear in a pop-up box (or in a status bar) when the user moves the mouse over screen elements.
This hint string can be propagated to clients of the action � to controls, menu items, and other GUI elements. 

Note: VCL controls support hint strings containing three parts that can be shown in separate locations (see Vcl.Controls.TControl.Hint).</docstr>
      </property>
      <property name="Visible">
        <docstr>Stores whether the action representation is visible.
Visible specifies the visible state for the action (True means visible, False means invisible).
This Visible value is propagated to a client of the action if IsVisibleLinked method of the action link linking the client to the action  returns True.
If the Visible of an action is False and IsVisibleLinked of an action link returns True, then the Visible of the client (a control, menu item, or others) is also set False and this client is also invisible. Typically, IsVisibleLinked of an action link returns False if the action belongs to TCustomViewAction. Otherwise, when the action belongs to TAction, then  IsVisibleLinked of an action link returns True. That is, TCustomViewAction is used when one need to provide visible representation of clients of actions that have Visible set True.</docstr>
      </property>
      <property name="ShortCut">
        <docstr>Shortcut that triggers the action.
The value of Shortcut can be propagated to all client controls and client menu items linked to the action.</docstr>
      </property>
      <property name="SecondaryShortCuts">
        <docstr>Stores shortcuts (in addition to ShortCut) for triggering the action.
Actions can execute in response to multiple shortcut key combinations. SecondaryShortCuts lists all the shortcut key combinations (other than the one specified by the ShortCut property) that can trigger the action. This lets you provide additional, secondary shortcuts.
When the user types one of the key combinations listed in SecondaryShortCuts, the action&apos;s Execute method is called.</docstr>
      </property>
      <property name="ImageIndex">
        <docstr>Stores an index in a list of images.
ImageIndex is a zero-based index in a list of images. TContainedAction does not provide the actual list of images, only implementations of actions in GUI application frameworks provide such a property. In general, this list of images contains images that are associated with controls and menu items that use this action.
The value of ImageIndex can be propagated to all client controls and client menu items linked to the action. 

Note: When ImageIndex is -1, this means that the list does not contain any images.
In typical implementations of controls, an image is drawn at the leftmost position in the control, and a control&apos;s text is drawn to the right of the image. If ImageIndex is -1, then a control does not offset the text to the right to reserve a placeholder for the image. Otherwise, if ImageIndex is not -1, then the control&apos;s text is always drawn with the offset to the right to reserve a place for drawing an image.</docstr>
      </property>
      <function name="DoHint">
        <docstr>Calls the OnHint event handler.
Typically, applications do not call the DoHint method. It is called automatically when the user pauses the mouse on one of the action&apos;s client controls or menu items. DoHint is called by the action&apos;s client when the client asks to show the hint.

DoHint checks for an OnHint event handler and passes HintStr to it, if the event handler exists. The OnHint event handler can change the specified hint string HintStr. DoHint returns True if no event handler is assigned or if OnHint returns True. DoHint can be used to determine which hint text should be shown. For example, Vcl.Controls.TControlActionLink.DoShowHint calls DoHint internally, and if DoHint returns True, then Vcl.Controls.TControlActionLink.DoShowHint appends the action&apos;s shortcut specification to the hint text to display.</docstr>
      </function>
      <event name="OnHint">
        <docstr>Occurs when the mouse pauses over a client control or menu item.
Use OnHint to override the default hint that appears when the user pauses the mouse over a client control or menu item. The OnHint event handler can change the hint that appears (by changing the string stored in the client&apos;s Hint property), or display the hint in an application-specific way.</docstr>
      </event>
      <property name="StatusAction">
        <docstr>Stores the status for an input field in an action.
StatusAction holds the status for an input field in the action, when it is set. 
The value of StatusAction  can be propagated to all client controls and client menu items linked to the action.</docstr>
      </property>
      <property name="Category">
        <docstr>Group or category where the action belongs.
IDE editors for actions group together actions that share the same category. In the VCL, if you are using an action manager, you can generate user interface elements that correspond to action categories.
Action categories group actions by similarities, usually of behavior or functionality. Standard categories are Edit, Format, Help, Windows, and others. At design time you can modify or set the Category for an action by selecting the action from the action list or object tree view, and choosing Category in the Object Inspector.</docstr>
      </property>
    </members>
  </class>
  <class unit="System.Actions" name="TContainedActionLink">
    <docstr>This class is designed to communicate with some of the object.</docstr>
  </class>
  <class unit="System.Actions" name="TActionListEnumerator">
    <docstr>Auxiliary class for enumeration actions in TContainedActionList</docstr>
  </class>
  <class unit="System.Actions" name="TContainedActionList">
    <docstr>The base class for list of actions, without the published properties.
Implement TContainedActionList to work with common properties for all GUI application frameworks.
Actions lists the actions maintained by the action list.
The ActionCount property returns the number of actions in the list.
OnStateChange sends a notification when the State changes.</docstr>
    <members>
      <function name="ActionsCreated">
        <docstr>Returns True if the internal list of actions of the TContainedActionList instance has been created. It returns False otherwise.
The internal list of actions is created when you create the TContainedActionList instance.</docstr>
      </function>
      <procedure name="CheckActionsCreated">
        <docstr>Raises an EActionError exception if the internal list of actions of the TContainedActionList has not been created.</docstr>
      </procedure>
      <procedure name="AddAction">
        <docstr>Adds an action to the list.
Applications cannot call this protected method. AddAction is used internally to add an action to the Actions property array.
To add an action to an action list, set the action&apos;s ActionList property.</docstr>
      </procedure>
      <procedure name="RemoveAction">
        <docstr>Removes an action from the list.
Applications cannot call this protected method. RemoveAction is used internally to remove an action from the Actions property array. RemoveAction removes the action and sets its ActionList property to nil (Delphi) or NULL (C++).
To remove an action from an action list, change the action&apos;s ActionList property.</docstr>
      </procedure>
      <procedure name="Change">
        <docstr>Triggers the OnChange event on the action list and then on all its actions.
The internal list of actions is created when you create the TContainedActionList instance.</docstr>
      </procedure>
      <procedure name="Notification">
        <docstr>Handles notifications about the removal of one of the actions of the list.
If AComponent is an action of the list and Operation is opRemove, the action is removed from the list.</docstr>
      </procedure>
      <procedure name="SetChildOrder">
        <docstr>Sets the order in which actions are passed to a callback by the GetChildren method.
SetChildOrder specifies the order in which the component streaming system loads and saves the action components owned by this action list. It ensures that the actions are loaded and saved in the same order that they appear in the Actions property array. You should not need to call this method directly.</docstr>
      </procedure>
      <procedure name="SetState">
        <docstr>Sets the State property for the action list. 
If Value is asSuspendedEnabled, then SetState also sets Enabled to True for all the actions in the action list. This is useful when designing in the Action Manager.
If the OnStateChange event handler is set, then SetState calls this event handler.</docstr>
      </procedure>
      <event name="OnChange">
        <docstr>Occurs when a change occurs in the action list.
Write an OnChange event handler to update your application in response to changes in the action list. Changes to the action list that trigger an OnChange event include changes to an action category or to the action list&apos;s image list.

Note:  The action list automatically informs the actions in the list when an OnChange event occurs. You need only provide an OnChange event handler for application-specific responses.
OnChange is an event handler of type TNotifyEvent.</docstr>
      </event>
      <event name="OnExecute">
        <docstr>Occurs when a client object triggers an action in the list.
Write an OnExecute event handler to respond when an action in the list fires.
When the user invokes a client object, the action list�s OnExecute event is the first event to occur in response. If the OnExecute event handler sets its Handled parameter to True, the action is considered handled, and processing stops there. This blocks the execution of any other event handlers or any built-in response by a predefined action class in response to the user action.
If the OnExecute event handler does not set its Handled parameter to True, the application�s OnActionExecute event occurs next. If the OnActionExecute event does not respond to the user input, the action object�s OnExecute event occurs. Finally, if the action does not have an OnExecute event handler, the application locates a target object and executes any predefined response implemented by the action object.</docstr>
      </event>
      <event name="OnUpdate">
        <docstr>Occurs when the application is idle so that the action list can update a specific action in the list.
Write an OnUpdate event handler to configure the properties of a specified action in the list so that it reflects current conditions.
When the application is idle, it cycles through every action in turn, giving it a chance to update itself to reflect current conditions. For each action, the first event to occur in this sequence is the action list&apos;s OnUpdate event. If the OnUpdate event handler sets its Handled parameter to True, the action is considered updated, and processing stops there. This blocks the execution of any other event handlers or any built-in response by a predefined action class.
If the OnUpdate event handler does not set its Handled parameter to True, the application&apos;s OnActionUpdate event occurs next. If the OnActionUpdate event does not update the action, the action object&apos;s OnUpdate event occurs. Finally, if the action does not have an OnUpdate event handler, the application executes any predefined update method implemented by the action object.</docstr>
      </event>
      <function name="SameCategory">
        <docstr>Returns True if the Source and Dest categories are the same. If IncludeSubCategory is True, this function also returns true if Dest is a subcategory of Source.
These are some examples of calls to this function:



Source

Dest

IncludeSubCategory

Result


File

File

True

True


File.Recent

File

True

False


File

File.Recent

True

True


File

File

False

True


File.Recent

File

False

False


File

File.Recent

False

False</docstr>
      </function>
      <constructor name="Create">
        <docstr>Creates an instance of TContainedActionList.
This creator is inherited from TComponent, see TComponent.Create for more information.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys an instance of TContainedActionList.
This destructor is inherited from TComponent, see TComponent.Destroy for more information.</docstr>
      </destructor>
      <function name="ExecuteAction">
        <docstr>Generates an OnExecute event.
Typically, applications do not call the ExecuteAction method. Instead, the action indicated by the Action parameter calls ExecuteAction in response to a user command. It is possible, however, to call ExecuteAction to generate an OnExecute event even though no client control has been triggered.
ExecuteAction invokes the OnExecute event handler for the action list. It returns True if the event handler handles the action, False otherwise.</docstr>
      </function>
      <procedure name="GetChildren">
        <docstr>Calls a specified method for each child action of the action list.
GetChildren is used by the component streaming system. For each action in the action list, GetChildren calls the method passed in Proc. The actions are passed to the callback in the order that they are loaded or saved by the component streaming system.</docstr>
      </procedure>
      <function name="GetEnumerator">
        <docstr>Returns a TContainedActionList enumerator, a TActionListEnumerator reference that enumerates the actions in the list.
To process all actions, read Current from the enumerator within a �while MoveNext do� loop.</docstr>
      </function>
      <function name="UpdateAction">
        <docstr>Generates an OnUpdate event.
Typically, applications do not call the UpdateAction method. Instead, the action indicated by the Action parameter calls UpdateAction when informed by the application that it can update itself. It is possible, however, to call UpdateAction to generate an OnUpdate event even though this has not been initiated by the application.
UpdateAction invokes the OnUpdate event handler for the action list. It returns True if the event handler updates the action, False otherwise.</docstr>
      </function>
      <function name="EnumByCategory">
        <docstr>Calls the specified procedure (TEnumActionListEvent or TEnumActionListRef) once for every action of the list in the specified category.
IncludeSubCategory determines whether actions in subcategories are included (True) or not (False) in the loop of calls.
Proc, an instance of either TEnumActionListEvent or TEnumActionListRef, can set its Done argument to True to stop the loop of calls prematurely.</docstr>
      </function>
      <function name="EnumByCategory">
        <docstr>Calls the specified procedure (TEnumActionListEvent or TEnumActionListRef) once for every action of the list in the specified category.
IncludeSubCategory determines whether actions in subcategories are included (True) or not (False) in the loop of calls.
Proc, an instance of either TEnumActionListEvent or TEnumActionListRef, can set its Done argument to True to stop the loop of calls prematurely.</docstr>
      </function>
      <property name="ActionCount">
        <docstr>Indicates the number of actions in the action list.
ActionCount indicates how many actions are contained in the action list.</docstr>
      </property>
      <property name="State">
        <docstr>Indicates whether the actions in the action list respond when the user triggers a client object. 
State can be one of the constants defined in the TActionListState type: 
asNormal, asSuspended, and asSuspendedEnabled.</docstr>
      </property>
      <event name="OnStateChange">
        <docstr>Occurs after the State property&apos;s value is changed.
Write an OnStateChange event handler to respond after the State property&apos;s value is changed.</docstr>
      </event>
    </members>
  </class>
  <class unit="Vcl.Grids" name="TCustomGrid">
    <docstr>TCustomGrid is the base type for all components that present information in a two-dimensional grid.
Use TCustomGrid as a base class when defining components that represent information in a tabular format. TCustomGrid introduces properties and methods to control the appearance and behavior of the grid, including responses to mouse actions and user editing.
Do not create instances of TCustomGrid. Instead, put a grid control in a form by instantiating a descendant of TCustomGrid. Use TDrawGrid to represent non-textual material in a tabular grid. For text, use a TStringGrid object. If the text represents field values from a dataset, use TDBGrid.</docstr>
    <members>
      <function name="CanObserve">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="ObserverAdded">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="ObserverToggle">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="ObserverCurrent">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="CalcDrawInfo">
        <docstr>Calculates the pixel locations of the grid boundaries.
Use CalcDrawInfo to determine the pixel locations of the major grid boundaries in the X and Y directions, including things like the first visible column/row, the last visible column/row, the pixel extent of the fixed column/row, etc.</docstr>
      </procedure>
      <procedure name="CalcFixedInfo">
        <docstr>Calculates the pixel locations of the fixed cells.
Use CalcDrawInfo to determine the pixel locations of the fixed cells in the X and Y directions.</docstr>
      </procedure>
      <procedure name="CalcSizingState">
        <docstr>Determines the appearance of the mouse cursor during resizing.
Use CalcSizingState to determine if the mouse cursor should be changed to a resize or drag cursor based on where the mouse is in the grid. For example, cursor over a grid line, in the fixed cell region, and column resize is enabled = resize cursor.</docstr>
      </procedure>
      <function name="CalcColWidth">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <procedure name="ChangeGridOrientation">
        <docstr>Prepares the grid&apos;s canvas for painting to reflect a right-to-left or left-to-right orientation.
TCustomGrid uses ChangeGridOrientation internally when painting. ChangeGridOrientation sets the origin and dimensions of the grid&apos;s canvas so that painting occurs from right-to-left or from left-to-right based on the value of the RightToLeftOrientation parameter.
RightToLeftOrientation is true if the grid should prepare for painting from right to left. RightToLeftOrientation is false if the grid should restore the canvas to normal.</docstr>
      </procedure>
      <function name="CreateEditor">
        <docstr>Creates the inplace editor control.
Grid controls call CreateEditor internally the first time the grid goes into edit mode. CreateEditor is exposed as a protected method so that descendants of TCustomGrid can substitute a specialized descendant of TInplaceEdit to handle cell editing.</docstr>
      </function>
      <procedure name="CreateParams">
        <docstr>Initializes the window-creation parameter record.
The CreateWnd method is called internally to specify the properties of the window that implements this control. These properties are set in the window-creation parameter record passed as Params. The fields of this record become the parameters to a call to the CreateWindowEx API function.
After calling the inherited method, CreateParams adjusts the value of Params to request that the grid receive double click messages, and to implement the values of the ScrollBars and BorderStyle properties.</docstr>
      </procedure>
      <procedure name="CreateWnd">
        <docstr>CreateWnd is used in control initialization.
The CreateWnd method is called internally to specify the properties of the window that implements this control. As implemented in TCustomGrid, CreateWnd makes sure that the grid can use the themes before continuing with the other initializations.</docstr>
      </procedure>
      <procedure name="DoGesture">
        <docstr>Processes the unhandled gesturing events.
Vcl.Grids.TCustomGrid.DoGesture inherits from Vcl.Controls.TControl.DoGesture. All content below this line refers to Vcl.Controls.TControl.DoGesture.
Processes the unhandled gesturing events.
DoGesture is run automatically for all gesturing events that were not handled by the user. DoGesture is run only if OnGesture is not set or if it did not handle the gesture event. 
Override DoGesture in descending classes to support default behavior for gesture events that were not handled by the user. In TControl, the DoGesture method simply returns and does no special processing.</docstr>
      </procedure>
      <procedure name="KeyDown">
        <docstr>Provides special processing when the user presses a key.
After generating an OnKeyDown event, KeyDown calls CanGridAcceptKey to screen out problematic key combinations. KeyDown moves to the appropriate cell in response to navigational key combinations, or sets the EditorMode property to true when the user presses F2.</docstr>
      </procedure>
      <procedure name="KeyPress">
        <docstr>Provides special processing when the user presses a key.
KeyPress is called automatically after the KeyDown method, but before the user releases the key.
After generating an OnKeyPress event, KeyPress toggles the EditorMode property when the user presses the Enter key.</docstr>
      </procedure>
      <procedure name="MouseDown">
        <docstr>Provides special processing when the user presses a mouse button.
MouseDown hides the editor window so that it can move selection to the cell that receives the mouse click. If the mouse lands in the hot region for beginning a move or resize of a row or column, MouseDown starts the move or resize, and provides visual feedback by changing the cursor. If the editor window was hidden, it is brought back up in its new location. Finally, MouseDown generates an OnMouseDown event.</docstr>
      </procedure>
      <procedure name="MouseMove">
        <docstr>Provides special processing when the user moves the mouse.
If the grid is in the middle of moving or resizing a row or column, or in the middle of selecting a range of cells using the mouse, MouseMove calculates the changes implied by the mouse move and provides visual feedback to the user. Finally, MouseMove generates an OnMouseMove event.</docstr>
      </procedure>
      <procedure name="MouseUp">
        <docstr>Provides special processing when the user releases the mouse button.
MouseUp finishes a move or resize operation on a row or column, or if the user is selecting a range of cells using the mouse, MouseUp finishes the select operation. Finally, MouseUp generates an OnMouseUp event.</docstr>
      </procedure>
      <procedure name="AdjustSize">
        <docstr>Adds or deletes rows or columns from the grid.
Grid components call AdjustSize internally to fix up the number of rows or columns when the user resizes them using the mouse. Index is the index of the row or column where the insertion or deletion should begin. Amount is the number of rows or columns to insert (Amount &gt; 0) or delete (Amount &lt; 0). Rows is a boolean that indicates whether the rows or the columns are changing.</docstr>
      </procedure>
      <function name="BoxRect">
        <docstr>Returns the screen coordinates of a specified set of cells.
Call BoxRect to obtain the screen coordinates, in pixels, of the cells that run from the column with index ALeft to the column with index ARight and the row with index ATop to the row with index ABottom. The coordinates of cells that are not visible onscreen are not included in the final rectangle.</docstr>
      </function>
      <procedure name="DoExit">
        <docstr>Hides the inplace editor when selection moves to another control in a form.
After calling the inherited method, which generates an OnExit event, DoExit hides the inplace editor unless the Options property includes goAlwaysShowEditor.</docstr>
      </procedure>
      <function name="CalcExpandedCellRect">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <function name="CellRect">
        <docstr>Returns the screen coordinates of a cell in the grid.
Call CellRect to obtain the boundaries, in pixels, of the cell in the column and row indicated by the ACol and ARow parameters. The top left cell is specified when ACol and ARow are set to zero.
If the indicated cell is not visible, CellRect returns an empty rectangle.</docstr>
      </function>
      <function name="CanEditAcceptKey">
        <docstr>Indicates whether the Key parameter can be entered into the current cell.
CanEditAcceptKey provides a simple screening of keyboard input while the user is editing the contents of a cell. The CanEditAcceptKey method for TCustomGrid always returns true. Descendants of TCustomGrid override this method to screen out illegal characters.
More refined validation can be obtained by using an edit mask.</docstr>
      </function>
      <function name="CanGridAcceptKey">
        <docstr>Indicates whether the grid should respond to a given key combination.
Grid controls call CanGridAcceptKey internally to screen key combinations when the user first presses a key. The CanGridAcceptKey method for TCustomGrid always returns true. Descendants of TCustomGrid override this method to screen out irrelevant key combinations, or key combinations that indicate actions that would violate the Options or mode of the grid.</docstr>
      </function>
      <function name="CanEditModify">
        <docstr>Indicates whether the current cell in the grid can be edited.
Grid components use CanEditModify internally to determine whether to allow the user to edit the current cell. CanEditModify returns true unless the inplace editor has disallowed editing for the cell.</docstr>
      </function>
      <function name="CanEditShow">
        <docstr>Indicates whether the inplace edit control can be created to allow editing.
Grid controls call CanEditShow internally before creating the editor for a cell. CanEditShow is called after the grid has determined that the field can be edited by calling CanEditModify.
CanEditShow returns false if the Options property does not indicate that the grid allows editing, or if it indicates that the grid permits row selection. Otherwise, if the Options property indicates that the grid is locked in edit mode, or if the grid has input focus, CanEditShow returns true. If the grid is not locked in edit mode and the grid does not have input focus, CanEditShow returns false.</docstr>
      </function>
      <procedure name="ChangeScale">
        <docstr>Resize and reposition children and self.
Vcl.Grids.TCustomGrid.ChangeScale inherits from Vcl.Controls.TWinControl.ChangeScale. All content below this line refers to Vcl.Controls.TWinControl.ChangeScale.
Resize and reposition children and self.
ChangeScale rescales the control in the same manner as the ChangeScale method in TControl. If the control contains any children, their ChangeScale methods are called before the parent itself is rescaled.
To rescale the control&apos;s children without rescaling the control itself, use ScaleControls. To rescale the control without repositioning, use ScaleBy.</docstr>
      </procedure>
      <function name="DoMouseWheelDown">
        <docstr>Performs tasks when the mouse wheel is rotated downward.
Override DoMouseWheelDown to perform tasks when the mouse wheel is rotated downward.
DoMouseWheelDown returns false if the control&apos;s parent should handle the message.
In TCustomGrid, DoMouseWheelDown increments the current row and returns true.</docstr>
      </function>
      <function name="DoMouseWheelUp">
        <docstr>Performs tasks when the mouse wheel is rotated upward.
Override DoMouseWheelUp to perform tasks when the mouse wheel is rotated downward.
DoMouseWheelUp should return false if the control&apos;s parent should handle the message.
In TCustomGrid, DoMouseWheelUp decrements the current row and returns true.</docstr>
      </function>
      <procedure name="FixedCellClick">
        <docstr>Triggers the OnFixedCellClick event.
FixedCellClick is called whenever the user clicks in a fixed cell. Descending classes can override FixedCellClick to support custom processing for this event. As defined in TCustomGrid, FixedCellClick simply triggers the OnFixedCellClick event. 
OnFixedCellClick is only triggered if the Options property includes either goFixedRowClick or goFixedColClick, or both. Also, at least one fixed column or row must me defined.</docstr>
      </procedure>
      <procedure name="FocusCell">
        <docstr>Changes the current cell to a specified cell.
TCustomGrid calls FocusCell internally to change the currently selected cell. FocusCell changes the current cell and updates the selection appropriately.
ACol is the column of the cell to select.
ARow is the row of the cell to select.
MoveAnchor determines how the selection changes. If the grid does not allow multiple cells to be selected (Options does not include goRangeSelect), MoveAnchor is ignored and the specified cell becomes the selected cell. If the grid allows multiple cells to be selected, MoveAnchor determines whether the new cell becomes the starting cell (anchor) of a new selection, or whether the current selection is updated to range from the current anchor to the specified cell.</docstr>
      </procedure>
      <function name="GetEditText">
        <docstr>Returns the value of the indicated cell formatted for editing.
The inplace editor calls GetEditText to obtain the text for the indicated cell. GetEditText returns an empty string. Descendants of TCustomGrid override the GetEditText method to return a string that represents the contents of the cell indicated by the ACol and ARow parameters.</docstr>
      </function>
      <procedure name="SetEditText">
        <docstr>Provides the interface for a method that updates the text associated with a cell.
SetEditText is called by the inplace editor so that the grid can store the new value for the current cell. The SetEditText method for TCustomGrid does nothing. Descendants of TCustomGrid override this method to update an internal representation of the cell&apos;s value or to generate an event, such as Vcl.Grids.TCustomDrawGrid.OnSetEditText.</docstr>
      </procedure>
      <function name="GetEditLimit">
        <docstr>Provides the interface for a method that limits the number of characters the user can type into cells.
The inplace editor calls GetEditLimit to determine if a limit should be placed on the number of characters a user can type into a cell. GetEditLimit sets no limits. Descendants of TCustomGrid override this method to limit the text for certain cells.</docstr>
      </function>
      <function name="GetEditMask">
        <docstr>Provides the interface for a method that returns an input mask for the specified cell.
The inplace editor calls GetEditMask to obtain any input mask associated with the cell specified by the ACol and ARow parameters. GetEditMask returns an empty string, indicating that the cell has no input mask. Descendants of TCustomGrid override this method to provide an input mask or to generate an event, such as Vcl.Grids.TCustomDrawGrid.OnGetEditMask.</docstr>
      </function>
      <function name="GetEditStyle">
        <docstr>Indicates whether a specified cell has an ellipsis button or drop-down arrow.
GetEditStyle indicates whether the specified cell can only be edited directly (esSimple), whether it has an ellipsis button that users can click to launch an editor for modifying field values (esEllipsis ), or whether it has a drop-down arrow that users can click to display a pick list of possible values (esPickList).
ACol is the column that contains the cell. ARow is the row that contains the cell.
In TCustomGrid, GetEditStyle always returns esSimple, indicating that there is no ellipsis button or drop-down arrow. Descendant classes can override this methods if they provide a way to add pick lists or ellipsis buttons to cells.</docstr>
      </function>
      <function name="GetGridWidth">
        <docstr>Returns the value of the GridWidth property.
GetGridWidth is the protected property access method for the GridWidth property. It computes the value of the GridWidth property based on the column widths, separator width, and the size of the control.</docstr>
      </function>
      <function name="GetGridHeight">
        <docstr>Returns the value of the GridHeight property.
GetGridHeight is the protected property access method for the GridHeight property. It computes the value of the GridHeight property based on the row heights, separator width, and the size of the control.</docstr>
      </function>
      <procedure name="HideEdit">
        <docstr>Hides the inplace editor.
The HideEditor method calls the protected HideEdit method to hide the editor. This method hides the editor window after updating the text to reflect the text in the editor.</docstr>
      </procedure>
      <procedure name="HideEditor">
        <docstr>Hides the inplace editor when it is not in use.
Grid controls call HideEditor when the grid goes out of edit mode. HideEditor hides the window of the inplace editor.</docstr>
      </procedure>
      <procedure name="ShowEditor">
        <docstr>Displays the inplace editor when the grid enters edit mode.
Grid controls call ShowEditor when the grid enters edit mode. ShowEditor displays the window of the inplace editor over the currently selected cell. If the inplace editor does not yet exist, ShowEditor creates it.</docstr>
      </procedure>
      <procedure name="ShowEditorChar">
        <docstr>Displays the inplace editor, with its text set to the specified character.
Grid controls call ShowEditorChar when the user types a character into a cell and the editor is not already showing. ShowEditorChar displays the window of the inplace editor over the currently selected cell, and sets its text property to the character Ch. If the inplace editor does not yet exist, ShowEditorChar creates it.</docstr>
      </procedure>
      <procedure name="InvalidateEditor">
        <docstr>Causes the inplace editor to repaint itself, moving to a new location if necessary.
InvalidateEditor is called when the selected cell changes while the grid is in edit mode.</docstr>
      </procedure>
      <procedure name="InvalidateGrid">
        <docstr>Tells Windows to repaint the grid after other important Windows messages are handled.
InvalidateGrid is used internally to ensure that the grid is repainted when its properties change. It calls the Invalidate method to indicate that the grid needs repainting.</docstr>
      </procedure>
      <procedure name="MoveColumn">
        <docstr>Moves a column to a new position.
Call MoveColumn to move the column identified by the FromIndex parameter to the position specified by the ToIndex parameter.</docstr>
      </procedure>
      <procedure name="ColumnMoved">
        <docstr>Provides the interface for a method that responds when the position of a column changes.
ColumnMoved is called immediately after a column in the grid has moved. 
The FromIndex parameter is the old index of the column, 
The ToIndex parameter is the new index. 
The ColumnMoved method of TCustomGrid does nothing. Descendants of TCustomGrid override this method to make internal adjustments or to generate an event, such as Vcl.Grids.TCustomDrawGrid.OnColumnMoved.</docstr>
      </procedure>
      <procedure name="MoveRow">
        <docstr>Moves a row to a new position.
Call MoveRow to move the row identified by the FromIndex parameter to the position specified by the ToIndex parameter.</docstr>
      </procedure>
      <procedure name="RowMoved">
        <docstr>Provides the interface for a method that responds when the position of a row changes.
RowMoved is called immediately after a row in the grid changes position. 
The FromIndex parameter is the old index of the row, and the ToIndex parameter is the new index. 
The RowMoved method of TCustomGrid does nothing. Descendants of TCustomGrid override this method to make internal adjustments or to generate an event, such as Vcl.Grids.TCustomDrawGrid.OnRowMoved.</docstr>
      </procedure>
      <procedure name="SelectionMoved">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="DrawCell">
        <docstr>Provides the prototype for a method that draws the contents of a cell in the grid.
Descendants of TCustomGrid implement the DrawCell method to draw the contents of the cell. If the DefaultDrawing property is true, the background of the cell is painted before DrawCell is called, and the 3D effects of the fixed cells or the focus rectangle around the focused cell are drawn after DrawCell.
The ACol and ARow parameters give the column and row indexes of the cell that should be drawn. 
The ARect parameter gives the boundaries of the cell in the coordinates of the canvas. 
The AState parameter indicates whether the cell is selected, whether the cell has input focus, and whether the cell is in the fixed, non-scrolling portion of the grid.</docstr>
      </procedure>
      <procedure name="DrawCellBackground">
        <docstr>Draws the background of a cell in the grid.
DrawCellBackground draws the background of a cell. Descendants of TCustomGrid can override the DrawCellBackground method to supply custom drawing techniques. 
If the DefaultDrawing property is true, the background of the cell is painted before DrawCell is called, and the three-dimensional effects of the fixed cells or the focus rectangle around the focused cell is drawn after DrawCell. 
The ACol and ARow parameters give the column and row indexes of the cell that should be drawn. The ARect parameter gives the boundaries of the cell in the coordinates of the canvas. The AState parameter indicates whether the cell is selected, has input focus, or is in the fixed, nonscrolling portion of the grid.</docstr>
      </procedure>
      <procedure name="DrawCellHighlight">
        <docstr>Draws the background of a highlighted cell in the grid.
DrawCellHighlight draws the background of a highlighted cell. Descendants of TCustomGrid can override the DrawCellHighlight method to implement custom drawing techniques. 
If the DefaultDrawing property is true, the background of the highlighted cell is painted before DrawCell is called, and the three-dimensional effects of the fixed cells or the focus rectangle around the focused cell is drawn after DrawCellHighlight. 
The ACol and ARow parameters give the column and row indexes of the cell that should be drawn. The ARect parameter gives the boundaries of the cell in the coordinates of the canvas. The AState parameter indicates whether the cell is selected, has input focus or is in the fixed, nonscrolling portion of the grid.</docstr>
      </procedure>
      <procedure name="DefineProperties">
        <docstr>Adds the ColWidths and RowHeights properties to the values saved with the grid.
DefineProperties overrides the inherited method to save the ColWidths and RowHeights properties with the grid when they contain values other than the default widths and heights.</docstr>
      </procedure>
      <procedure name="MoveColRow">
        <docstr>Selects the cell indicated by the ACol and ARow parameters.
Grid controls call MoveColRow internally when changing the selected cell or cells. MoveColRow selects the indicated cell, but does not take care of removing any previous selection. 
The ACol and ARow parameters are the column index and the row index of the cell to be selected. The MoveAnchor parameter indicates whether the new cell becomes the upper left corner of the selected region. MoveAnchor is true unless MoveColRow is called when extending a multicell selected region. The Show parameter indicates whether MoveColRow should ensure that the newly selected cell is visible.</docstr>
      </procedure>
      <function name="SelectCell">
        <docstr>Determines whether a particular cell in the grid can be selected.
Grid controls call SelectCell internally before attempting to move selection to a the cell identified by the ACol and ARow parameters. ACol and ARow are the column and row indexes for the cell, where the first column has index 0, and the top row has index 0.
The SelectCell method for TCustomGrid always returns true, allowing the cell to be selected. Descendants of TCustomGrid override this method to check the properties of the information displayed in the cell or to generate an event, such as Vcl.Grids.TCustomDrawGrid.OnSelectCell.</docstr>
      </function>
      <procedure name="SizeChanged">
        <docstr>Responds to changes in the size of the grid.
SizeChanged provides the interface for a method that responds to changes in the number of rows or columns in the grid. The SizeChanged method of TCustomGrid does nothing. Descendants of TCustomGrid override this method to make internal adjustments or generate events.</docstr>
      </procedure>
      <function name="Sizing">
        <docstr>Indicates whether the indicated coordinates are on one of the resize hot zones of the graph.
Grid controls call Sizing internally with the coordinates of a mouse click to determine whether the user is about to resize a row or column.</docstr>
      </function>
      <procedure name="ScrollData">
        <docstr>Scrolls the visual image of the cells in the grid.
Grid controls call ScrollData internally when the nonfixed rows or columns scroll. ScrollData updates the image of the grid.</docstr>
      </procedure>
      <procedure name="SetStyleElements">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="InvalidateCell">
        <docstr>Invalidates the region occupied by a cell so that it will be repainted with the next Windows paint message.
Call InvalidateCell when the contents of a cell change so that the cell will need to be repainted. The ACol parameter is the column index of the cell, and the ARow parameter is the row index.</docstr>
      </procedure>
      <procedure name="InvalidateCol">
        <docstr>Invalidates the region occupied by a column so that it will be repainted with the next Windows paint message.
Call InvalidateCol when a column changes so that the area it occupies will need to be repainted. The ACol parameter is the column index.</docstr>
      </procedure>
      <procedure name="InvalidateRow">
        <docstr>Invalidates the region occupied by a row so that it will be repainted with the next Windows paint message.
Call InvalidateRow when a row changes so that the area it occupies will need to be repainted. The ARow parameter is the row index.</docstr>
      </procedure>
      <function name="IsTouchPropertyStored">
        <docstr>Checks whether the associated touch manager stored any of the given options.
Vcl.Grids.TCustomGrid.IsTouchPropertyStored inherits from Vcl.Controls.TControl.IsTouchPropertyStored. All content below this line refers to Vcl.Controls.TControl.IsTouchPropertyStored.
Checks whether the associated touch manager stored any of the given options.
IsTouchPropertyStored is used internally by the VCL framework to check whether the associated touch manager component has stored the given options. Do not call IsTouchPropertyStored directly. IsTouchPropertyStored is used primarily to ensure that controls that do not require gesturing are not storing useless data in the DFMs or executables.</docstr>
      </function>
      <procedure name="TopLeftChanged">
        <docstr>Updates the position of the inplace editor when the grid scrolls.
Grid controls call TopLeftChanged internally, whenever the LeftCol or TopRow property changes.
Descendants of TCustomGrid override this method to make additional adjustments or to generate an event, such as Vcl.Grids.TCustomDrawGrid.OnTopLeftChanged.</docstr>
      </procedure>
      <procedure name="TimedScroll">
        <docstr>Extends a move, resize, or selection out of the scrollable region when the user drags the mouse in a direction where the grid is scrolled.
TimedScroll is called periodically as the user continues to drag with the mouse outside of the scrollable cells in the grid. TimedScroll does nothing unless the user is moving a row or column, resizing a row or column, or selecting a multiple cell region using the mouse. TimedScroll scrolls the cells in the grid to allow the operation to continue into the portion of the grid that was hidden due to scrolling.</docstr>
      </procedure>
      <procedure name="Paint">
        <docstr>Draws the image of the grid control on the screen.
Paint is called when the grid receives a paint message. Paint draws the grid, calling the DrawCell method when it is time to paint the contents of each cell. If DefaultDrawing is false, Paint does not draw the background of the cells, provide the raised 3D effects on the fixed cells, or draw the focus rectangle around the selected cell when it has focus.</docstr>
      </procedure>
      <procedure name="ColWidthsChanged">
        <docstr>Responds when the column widths change.
ColWidthsChanged is called immediately after the column widths change. The change can result from setting the ColWidths property, from setting the DefaultColWidth property, from moving one of the columns, or from resizing the columns with the mouse.
ColWidthsChanged adjusts the scroll bar and the position of the inplace editor to take into account the new column size and positions of the columns.</docstr>
      </procedure>
      <procedure name="RowHeightsChanged">
        <docstr>Responds when the row heights change.
RowHeightsChanged is called immediately after the row heights change. The change can result from setting the RowHeights property, from setting the DefaultRowHeight property, from moving one of the rows, or from resizing the rows with the mouse.
RowHeightsChanged adjusts the scroll bar and the position of the inplace editor to take into account the new row size and positions of the rows.</docstr>
      </procedure>
      <procedure name="DeleteColumn">
        <docstr>Deletes a specified column from the grid.
Call DeleteColumn to remove a column from the middle of the grid. Provide the index of the column to remove as ACol. To remove the last column from the grid, set the ColCount property instead.</docstr>
      </procedure>
      <procedure name="DeleteRow">
        <docstr>Deletes a specified from the grid.
Call DeleteRow to remove a row from the middle of the grid. Provide the index of the row to remove as ARow. To remove the last row from the grid, set the RowCount property instead.</docstr>
      </procedure>
      <procedure name="UpdateDesigner">
        <docstr>Notifies the designer when rows and columns of the grid are moved or resized.
At design time, the designer automatically keeps track of property changes so that it can prompt the user to save any changes. Moving or resizing the rows and columns of the grid using the mouse bypasses this system. When such changes occur, UpdateDesigner notifies the designer that the properties of the grid have changed and that the changes should be saved.</docstr>
      </procedure>
      <function name="BeginColumnDrag">
        <docstr>Starts the dragging of a column in the grid.
BeginColumnDrag is called automatically when the user clicks on a column to start dragging. It enables the grid to control whether the column can be repositioned and if so, which column.
Origin is the index of the column to be moved. When BeginColumnDrag is called, this is the index of the column in which the mouse was clicked. TCustomGrid does not change this value. However, descendant classes can override this method to adjust which column can be moved.
Destination is the index of where the column should move. When BeginColumnDrag is called, this is the same as Origin. TCustomGrid does not change this value because the mouse has not yet moved. Descendant classes can override this method to adjust the default destination of the column.
MousePt is the coordinates of the mouse button when the user clicked.
BeginColumnDrag returns true if the drag operation is permitted, false if the drag should be disallowed.</docstr>
      </function>
      <function name="BeginRowDrag">
        <docstr>Starts the dragging of a row in the grid.
Call BeginRowDrag to start a drag operation. BeginRowDrag enables the grid to control where the row can be dropped. It is exposed as a protected method so that descendants of TCustomGrid can customize row dragging in a grid.</docstr>
      </function>
      <function name="CheckColumnDrag">
        <docstr>CheckColumnDrag validates whether the column currently selected for dragging can be dropped at the current location.
Use CheckColumnDrag to validate that the column currently selected for dragging can be dropped at the current location. CheckColumnDrag can change the Origin (the column being dragged) and/or the Destination (the drop target), as needed, to keep the grid&apos;s columns in order.</docstr>
      </function>
      <function name="CheckRowDrag">
        <docstr>CheckRowDrag validates whether the row currently selected for dragging can be dropped at the current location.
Use CheckRowDrag to validate that the row currently selected for dragging can be dropped at the current location. CheckRowDrag can change the Origin (the row being dragged) and/or the Destination (the drop target), as needed, to keep the grid&apos;s rows in order.</docstr>
      </function>
      <function name="EndColumnDrag">
        <docstr>Ends the dragging of a column in the grid.
Call EndColumnDrag to end a drag operation. EndColumnDrag enables the grid to control where the column can be dropped. It is exposed as a protected method so that descendants of TCustomGrid can customize column dragging in a grid.</docstr>
      </function>
      <function name="EndRowDrag">
        <docstr>Ends the dragging of a row in the grid.
Call EndRowDrag to end a drag operation. EndRowDrag enables the grid to control where the row can be dropped. It is exposed as a protected method so that descendants of TCustomGrid can customize row dragging in a grid.</docstr>
      </function>
      <property name="BorderStyle">
        <docstr>Determines whether a single line border is drawn around the grid.
Set BorderStyle to bsSingle to add a single line border around the grid&apos;s image. Set BorderStyle to bsNone to omit the border.</docstr>
      </property>
      <property name="Col">
        <docstr>Specifies the index of the column that contains the selected cell.
Use Col at runtime to determine the current column in the grid. Setting Col moves focus to the cell in the current row that is in the new column. The first column has an index of 0, the second column an index of 1, and so on.
The selected cell in the grid can be located by reading the Col property and the Row property to obtain the indexes of its column and row. When focus moves to the grid, the selected cell gets input focus.</docstr>
      </property>
      <property name="Color">
        <docstr>Specifies the background color of the control.
Use Color to read or change the background color of the control.
If a control&apos;s Vcl.Controls.TControl.ParentColor property is True, then changing the Color property of the control&apos;s parent automatically changes the Color property of the control. When the value of the Color property is changed, the control&apos;s ParentColor property is automatically set to False.
The Color of a TLabel is always the color of the background unless you set TLabel.Transparent to False.</docstr>
      </property>
      <property name="ColCount">
        <docstr>Specifies the number of columns in the grid.
Read ColCount to determine the number entries in the ColWidths array. Set ColCount to add or delete columns at the right side of the grid. The value of ColCount includes any fixed columns at the left of the grid as well as the scrollable columns in the body of the grid.</docstr>
      </property>
      <property name="DefaultColWidth">
        <docstr>Determines the width (in pixels) of all columns that have not been explicitly resized.
Set DefaultColWidth to change the size of all columns in the grid. When DefaultColWidth is set, columns that have been resized using the mouse or by setting the ColWidths property are given the DefaultColWidth as well. 
When new columns are added to the grid using the ColCount property, they are created with a width of DefaultColWidth.</docstr>
      </property>
      <property name="DefaultColAlignment">
        <docstr>DefaultColAlignment is the default text alignment for all columns where alignment is not explicitly specified using TCustomGrid.ColAlignments.</docstr>
      </property>
      <property name="DefaultDrawing">
        <docstr>Determines whether the Cells are painted when the grid is drawn.
Set DefaultDrawing to true to have the grid automatically paint the cells in the grid, including adding the background color, the 3-D effects on the fixed cells, and the focus rectangle around the selected cell. Set DefaultDrawing to false to skip the painting of the cells when the grid is drawn.
When DefaultDrawing is false, the cells should be painted using the DrawCell method. For TCustomGrid, DrawCell is an abstract method. Descendants of TCustomGrid use DrawCell to provide their own customized drawing code, or to generate an OnDrawCell event.</docstr>
      </property>
      <property name="DefaultRowHeight">
        <docstr>Specifies the height (in pixels) of all rows that have not been explicitly resized.
Set DefaultRowHeight to change the size of all rows in the grid. When DefaultRowHeight is set, rows that have been resized using the mouse or by setting the RowHeights property are given the DefaultRowHeight as well. 
When new rows are added to the grid using the RowCount property, they are created with a height of DefaultRowHeight.</docstr>
      </property>
      <property name="DrawingStyle">
        <docstr>Determines the style used when drawing the grid.
DrawingStyle determines the style used to draw the grid. The following table lists the possible values of DrawingStyle. 




Value

Meaning



gdsClassic



The grid control uses the standard, unthemed style.




gdsThemed



The grid control uses the current operating system theme.




gdsGradient



The grid control uses gradients for styling.




Notes about DrawingStyle for Vcl.Grids.TStringGrid:
Setting FixedColor has no effect unless you also set DrawingStyle to gdsClassic.
Setting GradientStartColor and GradientEndColor has no effect unless you set the value of DrawingStyle to gdsGradient.</docstr>
      </property>
      <property name="EditorMode">
        <docstr>Determines whether the current cell can be edited.
Set EditorMode to true, at runtime, to put the grid in edit mode. When EditorMode is true, the user can edit cells in the grid. When the user presses F2, EditorMode is set to true. When the user presses Enter, the value of EditorMode is toggled.

Note: EditorMode has no effect if the Options property does not include goEditing or if the Options property includes goAlwaysShowEditor.</docstr>
      </property>
      <property name="FixedColor">
        <docstr>Specifies the background color of the fixed rows and columns in the grid.
Set FixedColor to specify the color for the nonscrolling cells in the grid. The scrolling region of the grid is drawn using the Color property.</docstr>
      </property>
      <property name="FixedCols">
        <docstr>Specifies the number of columns on the left of the grid that cannot be scrolled.
Set FixedCols to create or get rid of nonscrolling columns. Nonscrolling columns appear at the left of the grid, and are always visible, even when the user scrolls the other columns in the grid. Use nonscrolling columns for displaying row titles or row numbers, or to implement a scroll lock that the user can set.
Nonscrolling columns are visually distinct from the scrollable columns in the grid. They are painted with a separate background color, and their cells have a raised, 3-D look.

Note:  Grids must include at least one scrolling column. Do not set FixedCols to a value greater than ColCount - 1.</docstr>
      </property>
      <property name="FixedRows">
        <docstr>Specifies the number of rows on the top of the grid that cannot be scrolled.
Set FixedRows to create or get rid of nonscrolling rows. Nonscrolling rows appear at the top of the grid, and are always visible, even when the user scrolls the other rows in the grid. Use nonscrolling rows for displaying column titles or column numbers.
Nonscrolling rows are visually distinct from the scrollable rows in the grid. They are painted with a separate background color, and their cells have a raised, 3-D look.

Note:  Grids must include at least one scrolling row. Do not set FixedRows to a value greater than RowCount - 1.</docstr>
      </property>
      <property name="GradientEndColor">
        <docstr>Determines the ending gradient color.
GradientEndColor determines the ending gradient color. GradientEndColor is used when the value of DrawingStyle is gdsGradient. GradientEndColor and GradientStartColor define the color range used when drawing individual cells within the grid control.</docstr>
      </property>
      <property name="GradientStartColor">
        <docstr>Determines the starting gradient color.
GradientStartColor determines the starting gradient color. GradientStartColor is used when the value of DrawingStyle is gdsGradient. GradientEndColor and GradientStartColor define a color range used when drawing individual cells within the grid control.</docstr>
      </property>
      <property name="GridHeight">
        <docstr>Specifies the height of the grid in pixels.
Read GridHeight to determine the size of the grid. If GridHeight is less than the value of ClientHeight, all of the rows of the grid appear in the control with an empty region below the grid. If the underlying grid is too tall to appear in the control, GridHeight is the same as ClientHeight, and the user must scroll to see the entire contents of the grid.</docstr>
      </property>
      <property name="GridLineWidth">
        <docstr>Specifies the width (in pixels) of the lines that separate the cells of the grid.
Set GridLineWidth to make the lines that separate the cells in the grid heavier or lighter. When GridLineWidth is zero, no separators are drawn between the cells of the grid.
GridLineWidth will have no effect if the Options property does not include goFixedHorzLine, goFixedVertLine, goHorzLine, or goVertLine.

Note: Values greater than 3 pixels are not recommended for applications that run on Windows 9x or Windows ME because of distortions that can appear.</docstr>
      </property>
      <property name="GridWidth">
        <docstr>Specifies the width of the grid in pixels.
Read GridWidth to determine the size of the grid. If GridWidth is less than the value of ClientWidth, all of the columns of the grid appear in the control with an empty region to the right of the grid. If the underlying grid is too wide to appear in the control, GridWidth is the same as ClientWidth, and the user must scroll to see the entire contents of the grid.</docstr>
      </property>
      <property name="HitTest">
        <docstr>Indicates the current position of the mouse cursor.
Read HitTest to determine the position of the mouse when it is over the grid or when the grid has captured the mouse. HitTest may represent a position that is not within the client area of the grid control if the user is moving or resizing the rows or columns, or if the user is selecting a range of cells using the mouse. HitTest is the position of the mouse cursor in the coordinate system where (0,0) is the upper left corner of the grid control&apos;s client area.</docstr>
      </property>
      <property name="InplaceEditor">
        <docstr>Designates the edit control the grid uses to allow users to edit the contents of the selected cell.
Read InplaceEditor to gain direct access to the edit control that sits on top of the selected cell when the grid is in edit mode. The inplace editor is created the first time the grid is put in edit mode. It is not destroyed until the grid is destroyed. The grid moves the editor when the selected cell changes. The grid hides the editor&apos;s window when the grid goes out of edit mode.</docstr>
      </property>
      <property name="LeftCol">
        <docstr>Specifies the index of the first visible scrollable column in the grid.
Read LeftCol to determine the index of the first column in the scrollable region that is visible. Set LeftCol to scroll the columns in the grid so that the column with index LeftCol is the first column after the fixed columns.</docstr>
      </property>
      <property name="Options">
        <docstr>Specifies various display and behavioral properties of the grid.
Set Options to include the desired properties for the grid. See the type Vcl.Grids.TGridOptions for definitions of these properties.</docstr>
      </property>
      <property name="ParentColor">
        <docstr>Specifies where a control looks for its color information.
To have a control use the same color as its parent control, set ParentColor to True. If ParentColor is False, the control uses its own Color property.
Set ParentColor to True for all controls to ensure that all the controls on a form have a uniform appearance. For example, if ParentColor is True for all controls in a form, changing the background color of the form to gray causes all the controls on the form to also have a gray background.
When the value of a control&apos;s Color property changes, ParentColor becomes False automatically.</docstr>
      </property>
      <property name="Row">
        <docstr>Specifies the index of the row that contains the selected cell.
Use Row at runtime to determine the current row in the grid. Setting Row moves focus to the cell in the current column that is in the new row. The first row has an index of 0, the second row an index of 1, and so on.
The selected cell in the grid can be located by reading the Row property and the Col property to obtain the indexes of its row and column. When focus moves to the grid, the selected cell gets input focus.</docstr>
      </property>
      <property name="RowCount">
        <docstr>Specifies the number of rows in the grid.
Read RowCount to determine the number of entries in the RowHeights array. Set RowCount to add or delete rows at the bottom of the grid. The value of RowCount includes any fixed rows at the top of the grid as well as the scrollable rows in the body of the grid.</docstr>
      </property>
      <property name="ScrollBars">
        <docstr>Specifies whether the grid includes horizontal and vertical scroll bars.
Use ScrollBars to give the grid horizontal or vertical scroll bars.

Note:  If all the cells in the grid fit in the ClientWidth, no horizontal scroll bar appears, even if ScrollBars is ssHorizontal or ssBoth. If all the cells fit in the ClientHeight, no vertical scroll bar appears, even if ScrollBars is ssVertical or ssBoth.</docstr>
      </property>
      <property name="Selection">
        <docstr>Indicates the boundaries of the current selection.
Set Selection to select a range of cells in the grid. Selection can either represent the first column, first row, last column and last row in the grid, or the row and column coordinates of the upper left and bottom right cells in the selected region.
Selection can only indicate more than one cell when Options includes goRangeSelect.</docstr>
      </property>
      <property name="TopRow">
        <docstr>Specifies the index of the first visible scrollable row in the grid.
Read TopRow to determine the index of the first row in the scrollable region that is visible. Set TopRow to scroll the rows in the grid so that the row with index TopRow is the first row after the fixed rows.</docstr>
      </property>
      <property name="VisibleColCount">
        <docstr>Indicates the number of scrollable columns visible in the grid.
Use VisibleColCount to determine the number of scrollable columns fully visible in the grid. VisibleColCount does not include the fixed columns counted by the FixedCols property. It does not include any partially visible columns on the right edge of the grid.</docstr>
      </property>
      <property name="VisibleRowCount">
        <docstr>Indicates the number of scrollable rows visible in the grid.
Use VisibleRowCount to determine the number of scrollable rows fully visible in the grid. VisibleRowCount does not include the fixed rows counted by the FixedRows property. It does not include any partially visible rows on the bottom of the grid.</docstr>
      </property>
      <event name="OnFixedCellClick">
        <docstr>Determines the event triggered when a user clicks in a fixed cell.
Write an event handler for OnFixedCellClick to supply custom logic to your application in response to a user clicking in a fixed cell. OnFixedCellClick is only triggered if the Options property includes either the goFixedColClick or goFixedRowClick option, or both options.
OnFixedCellClick can be useful when implementing sorting on columns. By clicking in a fixed cell, the applied sorting rule can be reversed.</docstr>
      </event>
      <constructor name="Create">
        <docstr>Creates an instance of TCustomGrid.
Call Create to create a grid control at runtime. Grid controls placed on a form at design time are created automatically.
Owner is a component that is responsible for freeing the grid and for initiating the streaming process when it is saved to a form file.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys an instance of TCustomGrid.
Do not call Destroy directly in an application. Instead, call Free. Free verifies that the grid reference is not nil, and only then calls Destroy.</docstr>
      </destructor>
      <function name="MouseCoord">
        <docstr>Returns the row and column indexes of the cell that contains a point specified in screen coordinates.
Call MouseCoord to locate the column and row of the cell which contains a given screen coordinate. Usually, MouseCoord is used to locate the cell that is under the mouse.</docstr>
      </function>
      <procedure name="BeginUpdate">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <procedure name="EndUpdate">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </procedure>
      <function name="TextWidthToColWidth">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </function>
      <property name="IsUpdating">
        <docstr>Embarcadero Technologies does not currently have any additional information.</docstr>
      </property>
    </members>
  </class>
  <class unit="Vcl.Grids" name="TCustomDrawGrid">
    <docstr>TCustomDrawGrid is the base class for grids that publish events for painting and manipulating the cells in the grid.
Use TCustomDrawGrid as a base class when defining grid components that publish events for painting or manipulating the cells in the grid. TCustomDrawGrid introduces a number of events and methods that take advantage of the tabular organization of the grid in responding to user actions.
Do not create instances of TCustomDrawGrid. Instead, put a grid control in a form by instantiating a descendant of TCustomDrawGrid. Use TDrawGrid to represent non-textual material in a tabular grid. For text, use a TStringGrid object. If the text represents field values from a dataset, use TDBGrid. If you are displaying Name/Value pairs, use TValueListEditor.</docstr>
    <members>
      <procedure name="ColumnMoved">
        <docstr>Generates an OnColumnMoved event.
ColumnMoved is called immediately after a column in the grid has moved. It overrides the inherited method to generate an OnColumnMoved event. Descendants of TCustomDrawGrid can override this method to make internal adjustments or to block the OnColumnMoved event.</docstr>
      </procedure>
      <procedure name="DrawCell">
        <docstr>Generates an OnDrawCell event.
DrawCell is called automatically whenever a cell in the grid is drawn. If the DefaultDrawing property is true, the background of the cell is painted before DrawCell is called, and the 3D effects of the fixed cells or the focus rectangle around the focused cell are drawn after DrawCell. Descendants of TCustomDrawGrid can override this method to draw the contents of the cell or to block the OnDrawCell event.</docstr>
      </procedure>
      <function name="GetEditMask">
        <docstr>Generates an OnGetEditMask event.
The inplace editor calls GetEditMask to obtain any input mask associated with the cell specified by the ACol and ARow parameters. 
GetEditMask returns the Value parameter set by the OnGetEditMask event handler. If there is no OnGetEditMask event handler, GetEditMask returns an empty string, indicating that there is no edit mask.</docstr>
      </function>
      <function name="GetEditText">
        <docstr>Generates an OnGetEditText event.
The inplace editor calls GetEditText to obtain the text for the indicated cell. GetEditText returns the Value parameter set by the OnGetEditText event handler. If there is no OnGetEditText event handler, GetEditText returns an empty string.</docstr>
      </function>
      <procedure name="RowMoved">
        <docstr>Generates an OnRowMoved event.
RowMoved is called immediately after a row in the grid changes position. It overrides the inherited method to generate an OnRowMoved event. Descendants of TCustomDrawGrid can override this method to make internal adjustments or to block the OnRowMoved event.</docstr>
      </procedure>
      <function name="SelectCell">
        <docstr>Determines whether a particular cell in the grid can be selected.
Grid controls call SelectCell internally before attempting to move selection to a the cell identified by the ACol and ARow parameters. ACol and ARow are the column and row indexes for the cell, where the first column has index 0, and the top row has index 0.
SelectCell generates an OnSelectCell event. This method then returns true, unless the OnSelectCell event handler indicates that the cell should not be selected. Descendants of TCustomDrawGrid can override this method to check the properties of the information displayed in the cell or block the OnSelectCell event.</docstr>
      </function>
      <procedure name="SetEditText">
        <docstr>Generates an OnSetEditText event.
SetEditText is called by the inplace editor so that the grid can store the new value for the current cell. SetEditText overrides the inherited parent class&apos;s method to generate an OnSetEditText event. Descendants of TCustomDrawGrid can override this method to update an internal representation of the cell&apos;s value, or to block the OnSetEditText event.</docstr>
      </procedure>
      <procedure name="TopLeftChanged">
        <docstr>Generates an OnTopLeftChanged event.
Grid controls call TopLeftChanged internally, whenever the LeftCol or TopRow property changes. After calling the inherited parent class&apos;s method to update the position of the InplaceEditor (inherited from TCustomGrid), TopLeftChanged generates an OnTopLeftChanged event.</docstr>
      </procedure>
      <event name="OnColumnMoved">
        <docstr>Occurs immediately after the position of a column changes.
Use OnColumnMoved to perform special processing when the position of a grid column changes. Columns can be moved programmatically or by user manipulation. OnColumnMoved does not occur unless the Options property includes goColMoving.</docstr>
      </event>
      <event name="OnDrawCell">
        <docstr>Occurs when a cell in the grid needs to be drawn.
Write an OnDrawCell event handler to draw the contents of all the cells in the grid. Draw on the cell using the methods of the Canvas property. The Rect parameter indicates the location of the cell on the canvas. The Col and Row parameters indicate the column and row indexes of the cell that should be drawn. The State parameter indicates whether the cell has input focus, whether the cell is selected, and whether the cell is a fixed (nonscrolling) cell.
If the OnDrawCell event handler is not assigned, all cells in the draw grid will appear empty. If the DefaultDrawing property is True, the draw grid paints the background color of the cell before the OnDrawCell event, and draws a focus rectangle around the selected cell after the OnDrawCell event handler finishes drawing the contents of the cell. If the DefaultDrawing property is False, the OnDrawCell event handler should paint the background of the cell and provide all visual indication of selection and focus.</docstr>
      </event>
      <event name="OnGetEditMask">
        <docstr>Occurs when the in-place editor requests an edit mask.
Write an OnGetEditMask event handler to provide the in-place editor with an edit mask that describes the valid input strings a user can type into a cell. Set the Value parameter to the string that describes the edit mask for the cell specified by the ACol and ARow parameters. If the cell does not have an edit mask, set the Value parameter to an empty string.
OnGetEditMask does not occur unless the Options property includes goEditing.</docstr>
      </event>
      <event name="OnGetEditText">
        <docstr>Occurs when the in-place editor requests the value of a cell.
Write an OnGetEditText event handler to provide the in-place editor with a string representing the contents of the cell. Set the Value parameter to the string for the cell specified by the ACol and ARow parameters. When the cell enters edit mode, the contents of the cell are drawn as the Value string returned by the OnGetEditText event handler. This image need not match the appearance of the cell when it is not in edit mode, which is drawn using the OnDrawCell event handler.
OnGetEditText does not occur unless the Options property includes goEditing.</docstr>
      </event>
      <event name="OnRowMoved">
        <docstr>Occurs immediately after the position of a row changes.
Write an OnRowMoved event handler to provide special processing whenever a row in the grid changes position. Rows can be moved programmatically or by user manipulation. OnRowMoved does not occur unless the Options property includes goRowMoving.</docstr>
      </event>
      <event name="OnSelectCell">
        <docstr>Occurs before a cell in the grid is selected.
Write an OnSelectCell event handler to specify whether any particular cell in the grid can be selected. The Col and Row parameters indicate the column and row indexes of the cell that is about to be selected. Set the CanSelect parameter to False to prevent the cell being selected.</docstr>
      </event>
      <event name="OnSetEditText">
        <docstr>Occurs when the user edits the value of a cell.
Write an OnSetEditText event handler to perform any special processing of the text edited by the user in an in-place editor. For example, use the OnSetEditText event to retrieve and store the value of a cell so that it can be displayed in an OnDrawCell event handler. OnSetEditText occurs every time the user changes the text.
The Value parameter is the new value for the cell specified by the ACol and ARow parameters.
OnSetEditText does not occur unless the Options property includes goEditing.</docstr>
      </event>
      <event name="OnTopLeftChanged">
        <docstr>Occurs immediately after the TopRow property or the LeftCol property changes.
Use OnTopLeftChanged to perform special processing when the non-fixed cells in the grid are scrolled.</docstr>
      </event>
      <function name="CellRect">
        <docstr>Returns the screen coordinates of a cell in the grid.
Call CellRect to obtain the boundaries, in pixels, of the cell in the column and row indicated by the ACol and ARow parameters. The top left cell is specified when ACol and ARow are set to zero.
If the indicated cell is not visible, CellRect returns an empty rectangle.</docstr>
      </function>
      <procedure name="MouseToCell">
        <docstr>Returns the column and row of the cell at the position with screen coordinates (X,Y).
Call MouseToCell to convert from grid-relative screen coordinates to row and column indexes. The X and Y parameters are the screen coordinates of the point to be converted. MouseToCell returns the ACol parameter as the number of the column over the point (X,Y), and the ARow parameter as the number of the row. 
Usually the MouseToCell method is used in a mouse event handler, which supplies the mouse coordinates as the X and Y parameters of the method call.</docstr>
      </procedure>
    </members>
  </class>
  <class unit="Vcl.Grids" name="TDrawGrid">
    <docstr>TDrawGrid represents a grid control that displays information in column and row format.
Add a TDrawGrid object to a form to present arbitrary information in a tabular format. TDrawGrid provides many properties to control the appearance of the grid, as well as events and methods that take advantage of the tabular organization of the grid in responding to user actions. 
TDrawGrid introduces several events and methods to allow applications to customize the appearance and behavior of the grid. 
If the cells of the grid contain text strings that represent objects, consider using a TStringGrid object instead. If the grid displays field values from the records in a dataset, use TDBGrid instead.</docstr>
  </class>
  <class unit="Vcl.Grids" name="TStringGrid">
    <docstr>TStringGrid represents a grid control designed to simplify the handling of strings and associated objects.
Add a TStringGrid object to a form to present textual data in a tabular format. TStringGrid provides many properties to control the appearance of the grid, as well as events and methods that take advantage of the tabular organization of the grid in responding to user actions. 
TStringGrid introduces the ability to associate an object with each string in the grid. These objects can encapsulate any information or behavior represented by the strings that are presented to the user.
For a TStringGrid, the DrawingStyle property controls whether the current settings have any effect for FixedColor, and for GradientStartColor and GradientEndColor:

Setting FixedColor has no effect unless you also set DrawingStyle  to gdsClassic.
Setting GradientStartColor and GradientEndColor has no effect unless you set the value of DrawingStyle to gdsGradient.
Note: If the strings to be presented in a grid represent field values from the records in a dataset, use TDBGrid instead.
Note: To display the string and the associated object or control, use TDrawGrid instead. .</docstr>
    <members>
      <procedure name="ColumnMoved">
        <docstr>Generates an OnColumnMoved event.
Vcl.Grids.TStringGrid.ColumnMoved inherits from Vcl.Grids.TCustomDrawGrid.ColumnMoved. All content below this line refers to Vcl.Grids.TCustomDrawGrid.ColumnMoved.
Generates an OnColumnMoved event.
ColumnMoved is called immediately after a column in the grid has moved. It overrides the inherited method to generate an OnColumnMoved event. Descendants of TCustomDrawGrid can override this method to make internal adjustments or to block the OnColumnMoved event.</docstr>
      </procedure>
      <procedure name="DrawCell">
        <docstr>Generates an OnDrawCell event.
Vcl.Grids.TStringGrid.DrawCell inherits from Vcl.Grids.TCustomDrawGrid.DrawCell. All content below this line refers to Vcl.Grids.TCustomDrawGrid.DrawCell.
Generates an OnDrawCell event.
DrawCell is called automatically whenever a cell in the grid is drawn. If the DefaultDrawing property is true, the background of the cell is painted before DrawCell is called, and the 3D effects of the fixed cells or the focus rectangle around the focused cell are drawn after DrawCell. Descendants of TCustomDrawGrid can override this method to draw the contents of the cell or to block the OnDrawCell event.</docstr>
      </procedure>
      <function name="GetEditText">
        <docstr>Generates an OnGetEditText event.
Vcl.Grids.TStringGrid.GetEditText inherits from Vcl.Grids.TCustomDrawGrid.GetEditText. All content below this line refers to Vcl.Grids.TCustomDrawGrid.GetEditText.
Generates an OnGetEditText event.
The inplace editor calls GetEditText to obtain the text for the indicated cell. GetEditText returns the Value parameter set by the OnGetEditText event handler. If there is no OnGetEditText event handler, GetEditText returns an empty string.</docstr>
      </function>
      <procedure name="SetEditText">
        <docstr>Generates an OnSetEditText event.
Vcl.Grids.TStringGrid.SetEditText inherits from Vcl.Grids.TCustomDrawGrid.SetEditText. All content below this line refers to Vcl.Grids.TCustomDrawGrid.SetEditText.
Generates an OnSetEditText event.
SetEditText is called by the inplace editor so that the grid can store the new value for the current cell. SetEditText overrides the inherited parent class&apos;s method to generate an OnSetEditText event. Descendants of TCustomDrawGrid can override this method to update an internal representation of the cell&apos;s value, or to block the OnSetEditText event.</docstr>
      </procedure>
      <procedure name="RowMoved">
        <docstr>Generates an OnRowMoved event.
Vcl.Grids.TStringGrid.RowMoved inherits from Vcl.Grids.TCustomDrawGrid.RowMoved. All content below this line refers to Vcl.Grids.TCustomDrawGrid.RowMoved.
Generates an OnRowMoved event.
RowMoved is called immediately after a row in the grid changes position. It overrides the inherited method to generate an OnRowMoved event. Descendants of TCustomDrawGrid can override this method to make internal adjustments or to block the OnRowMoved event.</docstr>
      </procedure>
      <constructor name="Create">
        <docstr>Creates an instance of TStringGrid.
Call Create to create an instance of TStringGrid at runtime. For string grids placed on forms at design time, Create is called automatically.
AOwner is another component, typically a form, that becomes the grid&apos;s Owner. The Owner is responsible for freeing the grid.</docstr>
      </constructor>
      <destructor name="Destroy">
        <docstr>Destroys an instance of TStringGrid.
Do not call Destroy directly in an application. Instead, call Free. Free verifies that the string grid is not nil, and only then calls Destroy.
Destroy frees the helper objects used to manage the array of strings and their associated objects.</docstr>
      </destructor>
    </members>
  </class>
</docs>
